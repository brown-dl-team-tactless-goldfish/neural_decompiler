,question,link,code
0,two-sum,https://leetcode.com/problems/two-sum/solutions/665659/c/,"public class Solution {
    public int[] TwoSum(int[] nums, int target) {
        if (nums == null || nums.Length == 0)
            return new int[] { };
        
        int[] result = new int[2];
        Dictionary<int, int> dict = new Dictionary<int, int>();        
        
        for (int i = 0; i < nums.Length; i++)
        {
            if (dict.ContainsKey(target - nums[i]))
            {
                result[0] = dict[target - nums[i]];
                result[1] = i;
                
                return result;
            }
            
            if (!dict.ContainsKey(nums[i]))
                dict.Add(nums[i], i);
        }
        
        return result;
    }
}"
1,two-sum,https://leetcode.com/problems/two-sum/solutions/343/c-9ms-solution/,"#include<stdio.h>
#include<stdlib.h>

#define PRIME 263
struct node{
	int index_in_nums;
	struct node *next;
};
void initialize_hashtable(struct node *);
int hash(int);
int *twoSum(int *, int, int);
void free_hashtable(struct node *);


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* twoSum(int* nums, int numsSize, int target) {
	int i,hash_value,hash_value_comp;
	int *result = (int *)malloc(sizeof(int)*2);
	if(result ==NULL)
	{
		printf(""Not enough memory\n"");
		return NULL;
	}
	struct node *hashtable = (struct node *)malloc(sizeof(struct node)*PRIME);  //declare an hashtable whose size is PRIME*1
	if(hashtable ==NULL)
	{
		printf(""Not enough memory\n"");
		return NULL;
	}
	
	initialize_hashtable(hashtable);   //initialize the values in hashtable
	
	
	for(i=0;i<numsSize;i++)            //Set hashtable according to the nums array in this for loop
	{
		hash_value = hash(nums[i]);
		if(hashtable[hash_value].index_in_nums == -1)   // if value in hashtable is not occupied
			hashtable[hash_value].index_in_nums = i;
		
		else        // if value in hashtable is occupied
		{
			struct node *tail = (struct node *)malloc(sizeof(struct node));
			if(tail==NULL)
			{
				printf(""Not enough memory\n"");
				free_hashtable(hashtable);
				return NULL;
			}
			else
			{
				tail->index_in_nums = i;
				tail->next = hashtable[hash_value].next;
				hashtable[hash_value].next = tail;
			}
		}
	}
	
	for(i=0;i<numsSize;i++)        //search ""target - nums"" in this for loop
	{
		hash_value_comp = hash(target-nums[i]);
		if(hashtable[hash_value_comp].index_in_nums==-1)   //not exist
			continue;
		if(nums[hashtable[hash_value_comp].index_in_nums] == target-nums[i] && hashtable[hash_value_comp].index_in_nums != i)
		{										
			result[0] = i;
			result[1] = hashtable[hash_value_comp].index_in_nums;
			free_hashtable(hashtable);
			return result;
		}
		
		else
		{
			struct node *temp = hashtable[hash_value_comp].next;
			while(temp !=NULL)
			{
				if(nums[temp->index_in_nums] == target-nums[i])
				{
					result[0] = i;
					result[1] = temp->index_in_nums;
					free_hashtable(hashtable);
					return result;
				}
				else
					temp = temp->next;
			}
		}
	}
	free_hashtable(hashtable);
	return NULL;
}


int hash(int key)
{
	return abs((key%PRIME));
}

void initialize_hashtable(struct node *hashtable)
{
	int i;
	for(i=0;i<PRIME;i++)
	{
		hashtable[i].index_in_nums = -1;
		hashtable[i].next = NULL;
	}
} 


void free_hashtable(struct node *hashtable)
{
	int i;
	for(i=0;i<PRIME;i++)
	{
		struct node* current = hashtable[i].next;
		while(current != NULL)
		{
			struct node* prev = current;
			current = current->next;
			free(prev);
			
		}
		free(current);
	}
}"
2,two-sum,https://leetcode.com/problems/two-sum/solutions/2633816/c-solution/,"/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

struct intPair {
    int x;
    int order;
};

int compare(const void *a, const void *b) {
    struct intPair *p = (struct intPair *) a;
    struct intPair *q = (struct intPair *) b;
    return p->x - q->x;
}

int* twoSum(int* nums, int numsSize, int target, int* returnSize){
    int i, j, *output;
    output = malloc(2 * sizeof(int));
    *returnSize = 2;
    struct intPair *arr = malloc(numsSize * sizeof(struct intPair));
    for (i = 0; i < numsSize; ++i) {
        arr[i].x = nums[i];
        arr[i].order = i;
    }
    qsort(arr, numsSize, sizeof(struct intPair), compare);
    i = 0;
    j = numsSize - 1;
    while (arr[i].x + arr[j].x != target) {
        while (arr[i].x + arr[j].x < target) {
            ++i;
        }
        while (arr[i].x + arr[j].x > target) {
            --j;
        }
    }
    output[0] = arr[i].order;
    output[1] = arr[j].order;
    free(arr);
    return output;
}"
3,two-sum,https://leetcode.com/problems/two-sum/solutions/1024482/solution-with-c/,"typedef struct {
	int num;
	int idx;
	// Makes structure hashable
	UT_hash_handle hh;
} num_t;

int* twoSum(int* nums, int numsSize, int target, int* returnSize){
	int* res = calloc((*returnSize = 2), sizeof(int));
	num_t *numsHash = NULL, *num = NULL, *tmp = NULL;

	for(int i = 0; i < numsSize; ++i){
		int toFind = target - nums[i];
		HASH_FIND_INT(numsHash, &toFind, num);

		if (num != NULL){
			res[0] = num->idx;
			res[1] = i;

			break;
		} else {
			num = malloc(sizeof(num_t));
			num->num = nums[i]; num->idx = i;

			HASH_ADD_INT(numsHash, num, num);
		}
	}

	HASH_ITER(hh, numsHash, num, tmp) {
		HASH_DEL(numsHash, num); free(num); 
	}

	return res;
}"
4,two-sum,https://leetcode.com/problems/two-sum/solutions/1833815/easy-solution-c-and-c/,"int* twoSum(int* nums, int numsSize, int target, int* returnSize){
*returnSize=2;
int *returna=(int*)malloc(2*(sizeof(int)));
for(int i=0;i<numsSize;i++)
   {
      for(int j=i+1;j<numsSize;j++)
         {
         if(nums[i]+nums[j]==target)
               {
                  returna[0]=i;
                 returna[1]=j;
              }
       }
  }
return returna;
}
"
5,two-sum,https://leetcode.com/problems/two-sum/solutions/1833815/easy-solution-c-and-c/,"class Solution {
public:
  vector<int> twoSum(vector<int>& nums, int target) {
  vector<int>vect;
 int n=nums.size();
 for(int i=0;i<n;i++)
       {
       for(int j=i+1;j<n;j++)
           {
          if(nums[i]+nums[j]==target)
              {
                  vect.push_back(i);
                  vect.push_back(j);
                 break;
            }
         }
      }
 return vect;
 }
};"
6,two-sum,https://leetcode.com/problems/two-sum/solutions/999423/c-brute-force/,"int *twoSum(int *nums, int numsSize, int target, int *returnSize){
    *returnSize = 2;
    int *returnValues = malloc((*returnSize) * sizeof(int));

    for (int i = 0; i < numsSize - 1; i++) {
        for (int j = i + 1; j < numsSize; j++) {
            if (nums[i] + nums[j] == target) {
                returnValues[0] = i;
                returnValues[1] = j;
                break;
            }
        }
    }
    
    return returnValues;
}"
7,two-sum,https://leetcode.com/problems/two-sum/solutions/1820711/easy-solution-c-and-c-easy-to-understand/," int* twoSum(int* nums, int numsSize, int target, int* returnSize){
 *returnSize=2;
 int *returna=(int*)malloc(2*(sizeof(int)));
 for(int i=0;i<numsSize;i++)
 {
 for(int j=i+1;j<numsSize;j++)
 {
 if(nums[i]+nums[j]==target)
 {
 returna[0]=i;
 returna[1]=j;
 }
 }
 }
 return returna;
 }
 
 "
8,two-sum,https://leetcode.com/problems/two-sum/solutions/1820711/easy-solution-c-and-c-easy-to-understand/,"class Solution {
public:
vector<int> twoSum(vector<int>& nums, int target) {
vector<int>vect;
int n=nums.size();
for(int i=0;i<n;i++)
{
for(int j=i+1;j<n;j++)
{
if(nums[i]+nums[j]==target)
{
vect.push_back(i);
vect.push_back(j);
break;
}
}
}
return vect;
}
};
"
9,two-sum,https://leetcode.com/problems/two-sum/solutions/665/c-uthash-solution/,"struct hash_map
{
  int key;                   /* key */
  int value;                 /* value */
  UT_hash_handle hh;         /* makes this structure hashable */
};
typedef struct hash_map map;
map* ht = NULL;                 /* a NULL struct for hash map initialization */

void htAdd(int key, int value)
{
  map* s;
  HASH_FIND_INT(ht, &key, s);  /* id already in the hash? */
  if (s==NULL)
  {
    s = (map*)malloc(sizeof(map));
    s->key = key;
    HASH_ADD_INT(ht, key, s);  /* id: name of key field */
  }
  s->value = value;
}

map* htFind(int key)
{
    map* s;
    HASH_FIND_INT(ht, &key, s);  /* s: output pointer */
    return s;
}

void htCleanup()
{
    map* cur, *tmp;
    HASH_ITER(hh, ht, cur, tmp)
    {
        HASH_DEL(ht, cur);  /* delete it (users advances to next) */
        free(cur);            /* free it */
    }
}

void htPrint() {
    map* s;
    for(s=ht; s != NULL; s=(map*)(s->hh.next))
        printf(""key %d:  value %d\n"", s->key, s->value);
}

int* twoSum(int* nums, int numsS, int target) {
  int i, *r;
  map* hRes; /* hash find result */
  ht = NULL; /* initialize the hash map  */
  r = (int*)malloc(2* sizeof(int));

  for(i = 0; i<numsS; i++)
    htAdd(nums[i], i);

  //htPrint();
  
  for(i = 0; i<numsS; i++)
  {
    hRes = htFind(target- nums[i]);
    if(hRes && hRes->value != i)
    {
      r[0] = i + 1;
      r[1] = hRes->value + 1;
      return r;
    }
  }

  htCleanup();
  return NULL;
}"
10,two-sum,https://leetcode.com/problems/two-sum/solutions/1826223/c/,"   }
  }
 }  "
11,two-sum,https://leetcode.com/problems/two-sum/solutions/2676586/c/,"class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
         unordered_map<int, int> m;
        for(int i = 0; i < nums.size(); i++)
        {
            if(m.find(target-nums[i]) != m.end())
            return {m[target-nums[i]], i};
            m[nums[i]] = i;
        }
      return{};
        
    }
    
};"
12,two-sum,https://leetcode.com/problems/two-sum/solutions/2042389/c/,"int* twoSum(int* nums, int numsSize, int target, int* returnSize){
    int* ans = (int*)malloc(2*sizeof(int));
    for(int i = 0; i< numsSize; i++) {
        for(int j =i+1 ; j<numsSize; j++) {
            if(nums[j] + nums[i] == target){
                ans[0]=i;
                ans[1]=j;
                *returnSize = 2;
                return ans;
            }
        }
    }
    *returnSize = 0;
    return ans;
}"
13,two-sum,https://leetcode.com/problems/two-sum/solutions/1658776/c/," int *k =(int*) calloc(2,sizeof(int));
for(int i=0; i<numsSize ; i+=2)

    if( nums[i] + nums[i+1] == target )
    {

        k[0] = i;
        k[1] = i+1;
        break;

    }

return k;"
14,two-sum,https://leetcode.com/problems/two-sum/solutions/341/c-solution-6ms-using-uthash/,"typedef struct {
    int key, index;
    UT_hash_handle hh;
} HashElement;

int* twoSum(int* nums, int numsSize, int target) {
    HashElement *hash = NULL, *elem, *tmp;
    // Allocate and zero out the result array
    int *result = malloc(sizeof(int) * 2); 
    memset(result, 0, sizeof(int) * 2);

    if (!numsSize || !nums) { return result; }
    for (int i = 0; i < numsSize; i++) {
        int lookupKey = target - nums[i];
        HASH_FIND_INT(hash, &lookupKey, elem);
        if (elem) {
            result[0] = elem->index;
            result[1] = i;
            return result;
        }
        elem = malloc(sizeof(HashElement));
        elem->key = nums[i];
        elem->index = i;
        HASH_ADD_INT(hash, key, elem);
    }
    
    // Free up every element in the hash table. 
    HASH_ITER(hh, hash, elem, tmp) { free(elem); }
    return result;
}"
15,two-sum,https://leetcode.com/problems/two-sum/solutions/341/c-solution-6ms-using-uthash/,"#define hash_new(h, max)        int h##Pos[max]; int h##Neg[max]; \
                                for (int i = 0; i < max; i++) { h##Pos[i] = -1; h##Neg[i] = -1; }
#define hash_get(h, key)        ((key) < 0? h##Neg[key]: h##Pos[key])
#define hash_set(h, key, val)   if ((key) < 0) h##Neg[key] = val; else h##Pos[key] = val
#define hash_exist(h, key)      (hash_get(h, key) != -1)

int* twoSum(int* nums, int numsSize, int target) {
    if (!nums || numsSize <= 0) return NULL;
    hash_new(map, 100000);
    
    for (int i = 0; i < numsSize; i++) {
        if (hash_exist(map, target - nums[i])) {
            int *result = malloc(sizeof(int) * 2);
            result[0] = hash_get(map, target - nums[i]);
            result[1] = i;
            return result;
        }
        hash_set(map, nums[i], i); 
    }
    return NULL;
}"
