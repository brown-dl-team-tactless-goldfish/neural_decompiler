public class Solution
{
    public int[] MinReverseOperations(int n, int p, int[] bannedVals, int K)
    {
        List<SortedSet<int>> remaining = new List<SortedSet<int>> { new SortedSet<int>(), new SortedSet<int>() };
        HashSet<int> banned = new HashSet<int>(bannedVals);
        for (int u = 0; u < n; u++)
        {
            if (u != p && !banned.Contains(u))
            {
                remaining[u & 1].Add(u);
            }
        }

        Queue<int> queue = new Queue<int>();
        queue.Enqueue(p);
        int[] dist = new int[n];
        Array.Fill(dist, -1);
        dist[p] = 0;

        while (queue.Count > 0)
        {
            int node = queue.Dequeue();
            int lo = Math.Max(node - K + 1, 0);
            lo = 2 * lo + K - 1 - node;
            int hi = Math.Min(node + K - 1, n - 1) - (K - 1);
            hi = 2 * hi + K - 1 - node;

            List<int> toRemove = new List<int>();
            foreach (int nei in remaining[lo % 2].GetViewBetween(lo, hi))
            {
                queue.Enqueue(nei);
                dist[nei] = dist[node] + 1;
                toRemove.Add(nei);
            }

            foreach (int nei in toRemove)
            {
                remaining[lo % 2].Remove(nei);
            }
        }

        return dist;
    }
}

public static class SortedSetExtensions
{
    public static IEnumerable<T> GetViewBetween<T>(this SortedSet<T> set, T lowerValue, T upperValue) where T : IComparable<T>
    {
        if (set == null)
            throw new ArgumentNullException(nameof(set));

        return set.GetViewBetween(new Range<T>(lowerValue, upperValue));
    }
    
    public static SortedSet<T> GetViewBetween<T>(this SortedSet<T> set, Range<T> range) where T : IComparable<T>
    {
        if (set == null)
            throw new ArgumentNullException(nameof(set));

        return set.GetViewBetween(range.LowerValue, range.UpperValue);
    }
}

public readonly struct Range<T> where T : IComparable<T>
{
    public T LowerValue { get; }
    public T UpperValue { get; }

    public Range(T lowerValue, T upperValue)
    {
        if (lowerValue.CompareTo(upperValue) > 0)
            throw new ArgumentException("Lower value must be less than or equal to the upper value.");

        LowerValue = lowerValue;
        UpperValue = upperValue;
    }
}