int findCriticalAndPseudoCriticalEdges_findParent(int idx, vector<int>& group) {

	if (group[idx] == idx) return idx;
	group[idx] = findCriticalAndPseudoCriticalEdges_findParent(group[idx], group);
	return group[idx];
}

int findCriticalAndPseudoCriticalEdges_(int n, vector<vector<int>>& edges, vector<int>& group, int pre) {

	for (int i = 0; i < n; ++i) group[i] = i;
	int res = 0;

	if (pre >= 0) {
		group[edges[pre][1]] = edges[pre][0];
		res += edges[pre][2];
	}

	for (int i = 0; i < edges.size(); ++i) {

		if (i == -pre - 1) continue;

		int p0 = findCriticalAndPseudoCriticalEdges_findParent(edges[i][0], group);
		int p1 = findCriticalAndPseudoCriticalEdges_findParent(edges[i][1], group);

		if (p0 != p1) group[p1] = p0, res += edges[i][2];

	}

	int p = findCriticalAndPseudoCriticalEdges_findParent(0, group);
	for (int i = 1; i < n; ++i) {
		if (p != findCriticalAndPseudoCriticalEdges_findParent(i, group)) return INT_MAX;
	}

	return res;
}

vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {
	vector<vector<int>> res(2);

	for (int i = 0; i < edges.size(); ++i) edges[i].push_back(i);
	sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {
		return a[2] < b[2];
	});

	vector<int> group(n);
	int mst = findCriticalAndPseudoCriticalEdges_(n, edges, group, INT_MIN + 1);

	for (int i = 0; i < edges.size(); ++i) {
		if (mst < findCriticalAndPseudoCriticalEdges_(n, edges, group, - i - 1)) {
			res[0].push_back(edges[i][3]);
		} else if (mst == findCriticalAndPseudoCriticalEdges_(n, edges, group, i)) {
			res[1].push_back(edges[i][3]);
		}
	}

	return res;
}