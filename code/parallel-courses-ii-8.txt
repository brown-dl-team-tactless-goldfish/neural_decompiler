class Solution {
public:
  int minNumberOfSemesters(int n, vector<vector<int>> &dependencies, int k) {
    init(n, dependencies);
    const int finalState = (1 << n) - 1;
    queue<pair<int, int>> q; //{state, step};
    q.push(pair(0, 0));
    unordered_set<int> visited = {0}; // visited state
    while (!q.empty()) {
      auto [state, step] = q.front();
      q.pop();
      for (auto nextState : getAllNextState(state, k)) {
        if (nextState == finalState) return step + 1;
        if (visited.count(nextState)) continue;
        visited.insert(nextState);
        q.push(pair(nextState, step + 1));
      }
    }
    return -1;
  }

  void init(int n1, const vector<vector<int>> &edges) {
    n = n1;
    vdep.resize(n);
    for (auto &e : edges) vdep[e[1] - 1] |= (1 << (e[0] - 1));
  }

  bool isAbleToTake(int i, int state) const {
    return (state & vdep[i]) == vdep[i];
  }

  bool haveNotTake(int i, int state) const { return ((1 << i) & state) == 0; }

  vector<int> getAllNextState(int state, const int k) const {
    vector<int> courses;
    for (int i = 0; i < n; i++) 
      if (haveNotTake(i, state) && isAbleToTake(i, state))
        courses.push_back(i);

    if (courses.size() <= k) {
      for (int course : courses) state |= (1 << course);
      return vector<int>{state};
    }

    vector<int> states;
    getCombination(states, courses, state, 0, k);
    return states;
  }

  void getCombination(vector<int> &states, const vector<int> &courses, int state, int i, int k) const {
    if (k == 0) {
      states.push_back(state);
      return;
    }
    for (int j = i; j + k <= courses.size(); j++) 
      getCombination(states, courses, state | (1 << courses[j]), j + 1, k - 1);
  }

  int n;
  vector<int> vdep; // store the bitmask of dependency, eg 0X00101 means depend on 1st and 3rd courses
};