char * numberToWords(int num) {

	register const unsigned int   BILLION  = 1000000000;
	register const unsigned int   MILLION  = 1000000;
	register const unsigned short THOUSAND = 1000;
	register const unsigned char  HUNDRED  = 100;

	char one[20][11] = {"", "One ", "Two ", "Three ", "Four ", "Five ", "Six ", "Seven ", "Eight ", "Nine ", "Ten ", "Eleven ", "Twelve ", "Thirteen ", "Fourteen ", "Fifteen ", "Sixteen ", "Seventeen ", "Eighteen ", "Nineteen "};
	char ten[10][9] = {"", "Ten ", "Twenty ", "Thirty ", "Forty ", "Fifty ", "Sixty ", "Seventy ", "Eighty ", "Ninety "};
	char ton[10][10] = {"", "Hundred ", "Thousand ", "Million ", "Billion "};

	if(num < 20) {
		if(num == 0) {
			strcpy(one[0], "Zero ");
		}
		char * rt_array = (char*)malloc(strlen(one[num]) * sizeof(char));
		one[num][strlen(one[num])-1] = '\0';
		strcpy(rt_array, one[num]);
		return rt_array;
	}

	char words[150] = "";

	// Case 10 digits: Billion(s)
	if(num >= BILLION) {
		strcat(words, one[num / BILLION]);
		strcat(words, ton[4]);
		num -= (num / BILLION) * BILLION;
	}

	// Case 7-9 digits: Millions(s):
	if(num >= MILLION) {
		if(num / MILLION >= 100) {
			strcat(words, one[(num / MILLION) / 100]);
			strcat(words, ton[1]);
		}
		if(((num / MILLION) - (num / MILLION / 100) * 100) >= 20) {
			strcat(words, ten[(((num / MILLION) / 10) % 10)]);
			if(((num / MILLION) % 10) != 0) {
				strcat(words, one[((num / MILLION) % 10)]);
			}
			strcat(words, ton[3]);
		} else {
			strcat(words, one[((num / MILLION) - (num / MILLION / 100) * 100)]);
			strcat(words, ton[3]);
		}
		num -= (num / MILLION) * MILLION;
	}
	
	// Case 4-6 digits: Thousand(s):
	if(num >= THOUSAND) {
		if(num / THOUSAND >= 100) {
			strcat(words, one[(num / THOUSAND) / 100]);
			strcat(words, ton[1]);
		}
		if(((num / THOUSAND) - (num / THOUSAND / 100) * 100) >= 20) {
			strcat(words, ten[(((num / THOUSAND) / 10) % 10)]);
			if(((num / THOUSAND) % 10) != 0) {
				strcat(words, one[((num / THOUSAND) % 10)]);
			}
			strcat(words, ton[2]);
		} else {
			strcat(words, one[((num / THOUSAND) - (num / THOUSAND / 100) * 100)]);
			strcat(words, ton[2]);
		}
		num -= (num / THOUSAND) * THOUSAND;
	}

	// Case 3 digits: Hundred(s):
	if(num >= HUNDRED) {
		strcat(words, one[(num / HUNDRED)]);
		strcat(words, ton[1]);
		num -= (num / HUNDRED) * HUNDRED;
	}

	// Case 1-2 digits: Teen(s):
	if(num >= 20) {
		strcat(words, ten[num / 10]);
		if(num % 10 != 0)
			strcat(words, one[num % 10]);
	} else if(num > 0) {
		strcat(words, one[num]);
	}

	// Remove any tailing space
	if(isspace(words[strlen(words)-1])) {
		words[strlen(words)-1] = '\0';
	}

	// Allocate the length of characters used in words[]
	int rt_size = strlen(words);
	char * rt_array = (char*)malloc(rt_size * sizeof(char) + 1);
	strcpy(rt_array, words);

	return rt_array;
}