class Solution {
public:
    vector<int> minSubsequence(vector<int>& a) {
        // if there is only one item return it
	    if (1 == a.size())
		    return a;
        
        // if there are 2 items we either leave them both if they are equal or leave the most
        if (2 == a.size())
        {
            if (a[0] != a[1])
                a.erase(std::min_element(a.begin(), a.end()));
            return a;
        }
        
        // we need to sort only a half plus one item of the array
        // since the sum of this will be always greater than the sum of remaining subrange
        auto past_the_middle = a.begin() + a.size() / 2 + 1;
        std::partial_sort(a.begin(), past_the_middle, a.end(), std::greater<>());

        // sum the items of the greatest and the lowerest parts 
        auto left_sum = std::accumulate(a.begin(), past_the_middle, 0);
        auto right_sum = std::accumulate(past_the_middle, a.end(), 0);

        // going to the left starting from the middle item we need to find the item where the left sum
        // becomes not greater than the right sum
        auto it = std::find_if(std::make_reverse_iterator(past_the_middle), a.rend(), [=](auto n) mutable {
            left_sum  -= n;
            right_sum += n;
            return left_sum <= right_sum;
        }).base();

        // remove the right part
        if (it < a.end())
            a.erase(it, a.end());

        return a;
    }
};