class Solution {
public:
    int minimumEffortPath(vector<vector<int>>& heights) {
        vector<vector<int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        const int n = heights.size();
        const int m = heights[0].size();
        vector<vector<int>> cost = vector<vector<int>>(n, vector<int>(m, INT_MAX));
        cost[0][0] = 0;
        typedef pair<int, pair<int,int>> pr;
        priority_queue<pr, vector<pr>, greater<pr>> pq;
        pq.push({0, {0, 0}});
        while (!pq.empty()) {
            const auto cur = pq.top();
            int r = cur.second.first;
            int c = cur.second.second;
            int e = cur.first;
            pq.pop();
            for (const auto &dir : dirs) {
                int r_n = r + dir[0];
                int c_n = c + dir[1];
                if (r_n >= 0 && r_n < n && c_n >= 0 && c_n < m) {
                    int e_n = max(abs(heights[r_n][c_n] - heights[r][c]), e);
                    if (e_n < cost[r_n][c_n]) {
                        cost[r_n][c_n] = e_n;
                        pq.push({e_n, {r_n, c_n}});
                    }
                }
            }
        }
        return cost[n - 1][m - 1];
    }
};