class Solution {
public:
    int videoStitching(vector<vector<int>>& clips, int T) {
        // Greedy & Linear scan: sort the clips first based on its starting and ending time.
        // Then go through each clip and check if current clip's starting time <= lower bound
        // and if ending time > highest ending time so far. 
        // If yes update the highest ending time.
        // If the staring time > highest ending time, we cannot stitch the videos.
        // If the starting time > lower bound, we pick the previous time slot, update the lower bound
        // and the highest ending time, keep search until the end.
        int res = 0, low = 0, high = 0;
        sort(clips.begin(), clips.end(),
            [](const auto& v1, const auto& v2) // sort
             {
                 return v1[0] < v2[0] || (v1[0] == v2[0] && v1[1] < v2[1]);
             });
        
        for (int i = 0; i < clips.size() && high < T; ++i)
        {
            if (clips[i][0] <= low && clips[i][1] > high) // find the maximum ending time within current lower bound
            {
                high = clips[i][1];
                res += high >= T ? 1 : 0; // find the last video
            }
            else if (clips[i][0] > high)
            {
                return -1; // no overlapping
            }
            else if (clips[i][0] > low)
            {
                ++res; // pick the previous video
                low = high;
                high = max(high, clips[i][1]); // update lower bound and highest ending time
                res += high >= T ? 1 : 0; // it is the last video
            }
        }
        
        return high < T ? -1 : res; // the maximum ending time < T or we find all the videos
    }
};