class Solution {
public:
	class node{
		public :
		char lprec;
		char lsufc;
		int lprefix;
		int lsuffix;
		int lsubstr;
		node(){
			lprefix = 0;
			lsuffix = 0;
			lsubstr = 0;
		}
	};

	void buildtree(vector<node> &segtree, int s, int e, int tidx, string &str){
		if(s == e){
			node newnode;
			newnode.lprec = newnode.lsufc = str[s];
			newnode.lprefix = newnode.lsuffix = newnode.lsubstr = 1;
			segtree[tidx] = newnode;
			return;
		}
		int mid = (s + e)/2;
		buildtree(segtree, s, mid, 2*tidx+1, str);
		buildtree(segtree, mid+1, e, 2*tidx + 2, str);
		node lans = segtree[2*tidx+1];
		node rans = segtree[2*tidx+2];
		node nn;
		if(lans.lsubstr > rans.lsubstr){
			nn.lsubstr = lans.lsubstr;
		}else{
			nn.lsubstr = rans.lsubstr;
		}

		if(lans.lsufc == rans.lprec){
			if(lans.lsuffix + rans.lprefix > nn.lsubstr){
				nn.lsubstr = lans.lsuffix + rans.lprefix;
			}
		}

		int len = mid - s +1;
		nn.lprec = lans.lprec;
		if(len == lans.lprefix){
			if(rans.lprec == lans.lprec){
				nn.lprefix = lans.lprefix + rans.lprefix;
			}else{
				nn.lprefix = lans.lprefix;
			}
		}else{
			nn.lprefix = lans.lprefix;
		}
		len = e - (mid + 1) + 1;

		nn.lsufc = rans.lsufc;
		if(len == rans.lsuffix){
			if(rans.lsufc == lans.lsufc){
				nn.lsuffix = rans.lsuffix + lans.lsuffix;
			}else{
				nn.lsuffix = rans.lsuffix;
			}
		}else{
			nn.lsuffix = rans.lsuffix;
		}

		segtree[tidx] = nn;
		return;
	}

	void update(vector<node> &segtree, int s, int e, int tidx, char value, int index){
		if(s>index || e < index) return;
		if(s == e){
			segtree[tidx].lprec = segtree[tidx].lsufc = value;
			return;
		}
		int mid = (s + e)/2;
		update(segtree, s, mid, 2*tidx+1, value , index);
		update(segtree, mid+1, e, 2*tidx + 2, value , index);

		node lans = segtree[2*tidx+1];
		node rans = segtree[2*tidx+2];
		node nn;
		if(lans.lsubstr > rans.lsubstr){
			nn.lsubstr = lans.lsubstr;
		}else{
			nn.lsubstr = rans.lsubstr;
		}

		if(lans.lsufc == rans.lprec){
			if(lans.lsuffix + rans.lprefix > nn.lsubstr){
				nn.lsubstr = lans.lsuffix + rans.lprefix;
			}
		}
		int len = mid - s +1;
		nn.lprec = lans.lprec;
		if(len == lans.lprefix){
			if(rans.lprec == lans.lprec){
				nn.lprefix = lans.lprefix + rans.lprefix;
			}
			else{
				nn.lprefix = lans.lprefix;
			}
		}else{
			nn.lprefix = lans.lprefix;
		}
		len = e - (mid + 1) + 1;

		nn.lsufc = rans.lsufc;
		if(len == rans.lsuffix){
			if(rans.lsufc == lans.lsufc){
				nn.lsuffix = rans.lsuffix + lans.lsuffix;
			}
			else{
				nn.lsuffix = rans.lsuffix;
			}
		}else{
			nn.lsuffix = rans.lsuffix;
		}
		segtree[tidx] = nn;
		return;
	}


	vector<int> longestRepeating(string s, string qc, vector<int>& qi) {
		int n = s.size();
		vector<node> segtree(4*n);
		buildtree(segtree, 0, n-1, 0, s);
		vector<int> ans;
		for(int i=0; i<qc.size(); i++){
			update(segtree, 0, n-1, 0, qc[i], qi[i]);

			ans.push_back(segtree[0].lsubstr);
		}
		return ans;
	}
};