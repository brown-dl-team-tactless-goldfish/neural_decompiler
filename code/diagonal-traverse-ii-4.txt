/*
Given a 2D integer array nums, return all elements of nums in diagonal order as shown in the below images.

Example 1:


Input: nums = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,4,2,7,5,3,8,6,9]
Example 2:


Input: nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]
Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]


Constraints:

1 <= nums.length <= 105
1 <= nums[i].length <= 105
1 <= sum(nums[i].length) <= 105
1 <= nums[i][j] <= 105


[[14,12,19,16,9],[13,14,15,8,11],[11,13,1]]

[14,12,19,16,9]
[13,14,15,8,11]
[11,13,1]
*/



/**
 * Note: The returned array must be malloced, assume caller calls free().
 */


int* findDiagonalOrder(int** nums, int numsSize, int* numsColSize, int* returnSize){
    int total_num = 0;
    for (int i = 0; i < numsSize; i++){
        total_num = total_num + numsColSize[i];
    }

    *returnSize = total_num;
    int *ans = calloc(*returnSize, sizeof(int));
    int ans_idx = 0;

    int *skip_to = calloc(numsSize, sizeof(int));
    for (int i = 0; i < numsSize; i++){
        skip_to[i] = i - 1;
    }

    for (int i = 0; i < numsSize ; i++){
        int d_i = i;
        int d_j = 0;
        int pre_d_i = -1;
        while(d_i >= 0){
            if (d_j < numsColSize[d_i]){
                ans[ans_idx] = nums[d_i][d_j];
                ans_idx++;
            } else {
                if (pre_d_i == -1){
                    // do nothing
                } else {
                    skip_to[pre_d_i] =  skip_to[d_i];
                }
            }
            pre_d_i = d_i;
            d_j = d_j + (d_i - skip_to[d_i]);
            d_i = skip_to[d_i];

        }
    }
    int lastcol_j = 1;
    while (ans_idx!=total_num){
        int d_i = numsSize - 1;
        int d_j = lastcol_j;
        int pre_d_i = -1;
        while(d_i >= 0){
            if (d_j < numsColSize[d_i]){
                ans[ans_idx] = nums[d_i][d_j];
                ans_idx++;
            } else {
                if (pre_d_i == -1){
                    // do nothing
                } else {
                    skip_to[pre_d_i] =  skip_to[d_i];
                }
            }
            pre_d_i = d_i;
            d_j = d_j + (d_i - skip_to[d_i]);
            d_i = skip_to[d_i];

        }
        lastcol_j++;
    }
    free(skip_to);
    return ans;
}