typedef struct Interval {
    int start;
    int end;
}Interval;

typedef struct SummaryRanges {
    Interval *intervals;
    int size;
    int capacity;
}SummaryRanges;


SummaryRanges* summaryRangesCreate() {
    SummaryRanges *obj = (SummaryRanges*)malloc(sizeof(SummaryRanges));
    obj->intervals = (Interval*)malloc(sizeof(Interval)*10);
    obj->size = 0;
    obj->capacity = 10;
    return obj;
}

void summaryRangesAddNum(SummaryRanges* obj, int val) {
    if(obj->size == 0){
        obj->intervals[0].start = val;
        obj->intervals[0].end = val;
        obj->size++;
        return;
    }
    int i;
    for(i = 0; i < obj->size; i++){
        if(val >= obj->intervals[i].start && val <= obj->intervals[i].end){
            return;
        }
        if(val < obj->intervals[i].start){
            if(i == 0){
                if(val == obj->intervals[i].start - 1){
                    obj->intervals[i].start = val;
                }else{
                    if(obj->size == obj->capacity){
                        obj->capacity *= 2;
                        obj->intervals = (Interval*)realloc(obj->intervals, sizeof(Interval)*obj->capacity);
                    }
                    int j;
                    for(j = obj->size; j > i; j--){
                        obj->intervals[j] = obj->intervals[j-1];
                    }
                    obj->intervals[i].start = val;
                    obj->intervals[i].end = val;
                    obj->size++;
                }
            }else{
                if(val == obj->intervals[i].start - 1){
                    if(val == obj->intervals[i-1].end + 1){
                        obj->intervals[i-1].end = obj->intervals[i].end;
                        int j;
                        for(j = i; j < obj->size - 1; j++){
                            obj->intervals[j] = obj->intervals[j+1];
                        }
                        obj->size--;
                    }else{
                        obj->intervals[i].start = val;
                    }
                }else{
                    if(val == obj->intervals[i-1].end + 1){
                        obj->intervals[i-1].end = val;
                    }else{
                        if(obj->size == obj->capacity){
                            obj->capacity *= 2;
                            obj->intervals = (Interval*)realloc(obj->intervals, sizeof(Interval)*obj->capacity);
                        }
                        int j;
                        for(j = obj->size; j > i; j--){
                            obj->intervals[j] = obj->intervals[j-1];
                        }
                        obj->intervals[i].start = val;
                        obj->intervals[i].end = val;
                        obj->size++;
                    }
                }
            }
            return;
        }
    }
    if(val == obj->intervals[i-1].end + 1){
        obj->intervals[i-1].end = val;
    }else{
        if(obj->size == obj->capacity){
            obj->capacity *= 2;
            obj->intervals = (Interval*)realloc(obj->intervals, sizeof(Interval)*obj->capacity);
        }
        obj->intervals[i].start = val;
        obj->intervals[i].end = val;
        obj->size++;
    }
}

int** summaryRangesGetIntervals(SummaryRanges* obj, int* returnSize, int** returnColumnSizes){
    int **ans = (int**)malloc(sizeof(int*)*obj->size);
    *returnColumnSizes = (int*)malloc(sizeof(int)*obj->size);
    *returnSize = obj->size;
    for(int i = 0; i < obj->size; i++){
        ans[i] = (int*)malloc(sizeof(int)*2);
        ans[i][0] = obj->intervals[i].start;
        ans[i][1] = obj->intervals[i].end;
        (*returnColumnSizes)[i] = 2;
    }
    return ans;
}

void summaryRangesFree(SummaryRanges* obj) {
    free(obj->intervals);
    free(obj);
}