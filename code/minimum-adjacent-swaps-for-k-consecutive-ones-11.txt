class Solution {
public:
  int minMoves(vector<int>& nums, int k) {
    // Print(nums);
    if (k <= 1) return 0;
    vector<int> min_moves_left = CalculateMinMoves(nums, k / 2);
    reverse(nums.begin(), nums.end());
    vector<int> min_moves_right = CalculateMinMoves(nums, k - (k / 2));
    reverse(min_moves_right.begin(), min_moves_right.end());
    // Print(min_moves_left); Print(min_moves_right);
    int64 best = INF;
    for (int i = 0; i < nums.size() - 1; i++) {
      int64 sum = (int64)min_moves_left[i] + min_moves_right[i + 1];
      best = min(best, sum);
    }
    return best;
  }

  vector<int> CalculateMinMoves(vector<int>& nums, int k) {
    vector<int> ans(nums.size(), INF);
    deque<int> ones_pos; // max k size
    int i = 0;
    while (ones_pos.size() < k && i < nums.size()) {
      if (nums[i] == 1) ones_pos.push_back(i);
      i++;
    }
    i--;
    if (i >= nums.size()) {
      return ans;
    }
    ans[i] = MinMovesForIdx(k, i, ones_pos);
    i++;
    for (; i < nums.size(); i++) {
      if (nums[i] == 0) {
        ans[i] = ans[i - 1] + k;
      } else {
        int to = i - 1 - (k - 1);
        int from = ones_pos.front();
        ans[i] = ans[i - 1] - (to - from);
        ones_pos.pop_front();
        ones_pos.push_back(i);
      }
    }
    return ans;   
  }
private:
  int MinMovesForIdx(int k, int idx, deque<int> ones_pos) {
    int ans = 0;
    if (ones_pos.size() < k) return INF;
    for (int i = 0; i < k; i++) {
      ans += (idx - ones_pos.back() - i);
      ones_pos.pop_back();
    }
    return ans;
  }
};