typedef struct 
{
    int top;
    int size;
    int * arr;
}Stack;

bool isStackFull(Stack * stack)
{
    return (stack->top == stack->size - 1) ? 1 : 0;
}

bool isStackEmpty(Stack * stack)
{
    return (stack->top == -1) ? 1 : 0;
}

void push(Stack * stack, int data)
{
    if(isStackFull(stack))
        return;
    
    stack->arr[++(stack->top)] = data;
}

int pop(Stack * stack)
{
    if(isStackEmpty(stack))
        return -1;
    
    return stack->arr[(stack->top)--];
}

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char ** buildArray(int* target, int targetSize, int n, int* returnSize)
{
    int count = 1;
    
    char ** ret_arr = (char **)malloc(sizeof(char *) * (2 * n));
    int ret_arr_index = 0;
    
    int target_index = 0;
    
    Stack stack;
    stack.top = -1;
    stack.size = n;
    stack.arr = (int *)malloc(sizeof(int) * stack.size);
    
    while(count != target[targetSize-1])
    {
        push(&stack, count);
        char * str_arr = (char *)malloc(sizeof(char) * 5);
        strncpy(str_arr, "Push", 5);
        ret_arr[ret_arr_index++] = str_arr;
        
        if(count == target[target_index])
        {   
            target_index++;
        }
        else
        {
            pop(&stack);
            char * pop_arr = (char *)malloc(sizeof(char) * 4);
            strncpy(pop_arr, "Pop", 4);
            ret_arr[ret_arr_index++] = pop_arr;
        }
        count++;
    } 
    
    push(&stack, count);
    char * str_arr = (char *)malloc(sizeof(char) * 5);
    strncpy(str_arr, "Push", 5);
    ret_arr[ret_arr_index++] = str_arr;
    *returnSize = ret_arr_index;
    return ret_arr;
}