/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 
 //this code does not pass all test cases, which I don't agree with the expected answer, for example
 //How could the answer is true for following test case?
 /*
 [1,2,3,4,5]
5
1
*/
class Solution {
public:
    map<TreeNode*, TreeNode*> nodeMap; //[child, parent]
    map<TreeNode*, bool> isLeftMap; //[node, if it is a left branch]
    TreeNode* findNode(TreeNode* node, int val)
    {
        if(node == NULL) return NULL;
        if(node->val == val) return node;
        if(node->left != NULL)
        {
            nodeMap[node->left] = node;
            isLeftMap[node->left] = true;
            TreeNode* l = findNode(node->left, val);
            if(l != NULL) return l;
        }
        if(node->right != NULL)
        {
            nodeMap[node->right] = node;
            isLeftMap[node->left] = false;
            TreeNode* r = findNode(node->right, val);
            if(r != NULL) return r;
        }
        return NULL;
    }
    
    int getDepth(TreeNode* node)
    {
        if(node == NULL) return 0;
        return 1 + std::max(getDepth(node->left), getDepth(node->right));
    }
    
    bool btreeGameWinningMove(TreeNode* root, int n, int x) {
        if(root == NULL) return false;
        nodeMap[root] == NULL;
        TreeNode* xStartNode = findNode(root, x);
        //cout<<xStartNode->val;
        //find max length on left branch
        int left = getDepth(xStartNode->left);
        //find max length on right branch
        int right = getDepth(xStartNode->right);
        //find max length on parent branch
        TreeNode* curr = xStartNode;
        TreeNode* parent = nodeMap[xStartNode];
        int len = 1;
        int max = 0;
        while(parent != NULL)
        {
            int tmp = len + (isLeftMap[curr] ? getDepth(parent->right) :  getDepth(parent->left));
            max = std::max(tmp, max);
            len++;
            curr = parent;
            parent = nodeMap[parent];
        }
        if((max > right+1 && max > left+1) || (left > right+1 && left > max+1) || (right > max+1 && right+1 > left+1))
            return true;
        return false;
    }
};