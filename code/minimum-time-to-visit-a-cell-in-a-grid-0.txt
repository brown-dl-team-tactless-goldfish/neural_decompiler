class Solution {
public:
  int minimumTime(vector<vector<int>>& grid) {
    int rows = grid.size(), cols = grid[0].size();
    
    // We must be able to go beyond point [0, 0] in order to visit the rest of the
    // matrix.
    if (grid[0][0] != 0) return -1;
    if (rows > 1 && cols > 1) {
      if (grid[1][0] > 1 && grid[0][1] > 1) return -1;
    } else if (rows > 1) {
      if (grid[1][0] > 1) return -1;
    } else if (cols > 1) {
      if (grid[0][1] > 1) return -1;
    }
    
    vector<vector<bool>> visited(rows, vector<bool>(cols, false));
    priority_queue<tuple<int, int, int>> pq;
    pq.push({-grid[0][0], 0, 0});
    
    // Use a Dijkstra like algorithm.
    while (!pq.empty()) {
      auto [t, r, c] = pq.top(); pq.pop();
      if (visited[r][c]) continue;
      t *= -1;
      visited[r][c] = true;
      if (r == (rows - 1) && (c == (cols - 1))) return t;
      
      vector<pair<int, int>> notImmediate;
      
      if (r > 0 && !visited[r - 1][c]) {
        if ((t + 1) >= grid[r - 1][c]) {
          pq.push({-(t + 1), r - 1, c});
        } else {
          notImmediate.push_back({r - 1, c});
        }
      }
      
      if (r < (rows - 1) && !visited[r + 1][c]) {
        if ((t + 1) >= grid[r + 1][c]) {
          pq.push({-(t + 1), r + 1, c});
        } else {
          notImmediate.push_back({r + 1, c});
        }
      }
      
      if (c > 0 && !visited[r][c - 1]) {
        if ((t + 1) >= grid[r][c - 1]) {
          pq.push({-(t + 1), r, c - 1});
        } else {
          notImmediate.push_back({r, c - 1});
        }
      }
      
      if (c < (cols - 1) && !visited[r][c + 1]) {
        if ((t + 1) >= grid[r][c + 1]) {
          pq.push({-(t + 1), r, c + 1});
        } else {
          notImmediate.push_back({r, c + 1});
        }
      }
      
      // For the ones that cannot be immediately visited, we can visit an immediately
      // visitable neighbor and go back and forth for some time.
      // We already check for [1, 0] and [0, 1] to be immediately visitable from
      // [0, 0] at the start and for every other point, we know it has at least one
      // immediately visitable neighbor which is the point we just came from.
      for (auto& pr : notImmediate) {
        int diff = grid[pr.first][pr.second] - (t + 1);
        if (diff % 2 == 0) {
          pq.push({-grid[pr.first][pr.second], pr.first, pr.second});
        } else {
          pq.push({-(grid[pr.first][pr.second] + 1), pr.first, pr.second});
        }
      }
    }
    return -1;
  }
};