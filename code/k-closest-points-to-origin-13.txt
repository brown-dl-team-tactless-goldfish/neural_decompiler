int** kClosest(int** points, int pointsSize, int* pointsColSize, int K, int* returnSize, int** returnColumnSizes){

    
int i,j,k,p,d1=0,d2=0,d[10000],t[1][2],temp=0,temp1=0,temp2=0;

for(i=0;i<pointsSize;i++)
{
d1=points[i][0]*points[i][0];
d2=points[i][1]*points[i][1];
d[i]=d1+d2;

}
    
quick_sort(points,d,0,pointsSize-1);     


    
    *returnSize = K;
    
    int **result =(int **)malloc(K*sizeof(int *));
    *returnColumnSizes =(int *)malloc(K * sizeof(int));
    
    for (i = 0; i < K; i++){
        (*returnColumnSizes)[i]=2;
        
        result[i] = (int *)malloc(2*sizeof(int));
        result[i][0]=points[i][0];
        result[i][1]=points[i][1];
    }
    
return result;
} 


void quick_sort(int** points,int nums[],int f, int l) {
  int i, j, t, p = 0,temp1=0,temp2=0;

    
  if (f < l) {
    p = f;
    i = f;
    j = l;

    while (i < j) {
      while (nums[i] <= nums[p] && i < l)
        i++;
      while (nums[j] > nums[p])
        j--;
      if (i < j) {
          
        t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
          
         temp1=points[j][0];
         temp2=points[j][1];


         points[j][0]=points[i][0];
         points[j][1]=points[i][1];

         points[i][0]=temp1;
         points[i][1]=temp2; 
      }
    }
      
      

    t = nums[p];
    nums[p] = nums[j];
    nums[j] = t;
          
         temp1=points[p][0];
         temp2=points[p][1];


         points[p][0]=points[j][0];
         points[p][1]=points[j][1];

         points[j][0]=temp1;
         points[j][1]=temp2;  
      
     
    quick_sort(points,nums,f, j - 1);
    quick_sort(points,nums,j + 1, l);
  }
}
