int isvalid(int x, int y, int** points, int pointsSize)//function to return the index of first valid point, and returns -1 if no valid points in all the given points
{
    for(int i = 0; i <pointsSize; i++)
    {
        if(x==points[i][0] || y==points[i][1])
            return i;
    }
    return -1;
}

bool isvalid1(int x, int y,int a, int b)//function to check if current point is valid
{
    if(x==a || y==b)
        return true;
    return false;
}

int dist(int x, int y, int a, int b)//function to find the manhattan distance as described in the problem
{
    return abs(x-a) + abs(y-b);
}

int nearestValidPoint(int x, int y, int** points, int pointsSize, int* pointsColSize){
    *pointsColSize =2;//x and y coordinates
    int k = isvalid(x, y, points, pointsSize);
    if (k == -1)//condition to terminate and return -1 if no valid points are given
        return -1;
    
    int index = k;// index of first valid point
    
    int min = dist(x,y,points[k,0],points[k][1]);// distance at first valid point
    for(int i = k; i<pointsSize; i++)//for loop to iterate through valid points
    {
        if(isvalid1(x,y,points[i][0],points[i][1]))//condition to check for valid point
        {
            int a = dist(x,y,points[i][0],points[i][1]);//a is a dummy variable to hold the value returned by dist function
            if( a< min)
            {
                min = a;
                index = i;  //variable index keeps getting updated to the least distance of valid point's index
            }
        }
    }
    return index;    
}````