int checkWays(vector<vector<int>> &pairs){
	/*1. Make a modified adjacency(ancestory) list. The number of entries for a given
	    node is equal to the number of pairs containing that node. */
	unordered_map<int, unordered_set<int>> adj;
	for(int i=0; i<pairs.size(); i++){
		adj[pairs[i][0]].insert(pairs[i][1]);
		adj[pairs[i][1]].insert(pairs[i][0]);
	}

	/*NOTE : Here, the adjacency list is defined differently. All the nodes that share an
	  ancestor relationship along with a given node (either-way) are present in the adjList
	  of that node. 
	  Thus, degree of a node 'v' is equal to the number of pairs (given as input) that 
	  contain 'v'. This is different from the conventional
	  definition of 'degree', but fits well in the context*/

	//2. push nodes into a max-heap (ordered by degree)
	priority_queue<pair<int,int>> pq;
	for(auto &[node,neighbours] : adj)
		pq.push(make_pair(neighbours.size(), node));

	int totalNodes = pq.size();
	int result = 1;

	unordered_set<int> visited;
	//3. process nodes in the order of non-increasing degree
	while(!pq.empty()){
		int currNode = pq.top().second;
		int degree = pq.top().first;
		pq.pop();

		/*3.1 find neighbouring node with least degree that is >= currNode's degree
		that has already been visited
		 (this should be the parent, provided the check 3.3 below holds)*/
		int parent = -1;
		int parentDegree = INT_MAX;
		for(auto &neighbour : adj[currNode]){
			if(visited.count(neighbour) && adj[neighbour].size() < parentDegree && adj[neighbour].size() >= degree){
				parent = neighbour;
				parentDegree = adj[neighbour].size();
			}
		}
		visited.insert(currNode);
		
		/*3.2 case when parent is not found => check if currNode itself is the root. 
		 if not, then tree can't be made*/
		if(parent == -1){
			if(degree != totalNodes-1) return 0;
			continue;
		}

		/*3.3 now check whether parent's adjList contains all the nodes present in currNode's adjList.
		 if not, then tree can't be made.*/
		for(auto &neighbour : adj[currNode]){
			if(neighbour == parent) continue;
			if(!adj[parent].count(neighbour)) return 0;
		}

		/*3.4 check the special case of multiple trees
		 this is possible when parent and currentNode have same degree
		 so they can be exchanged with each other to form 2 distinct trees*/
		if(degree == parentDegree)
			result = 2;
	}
	return result;
}