typedef struct
{
	char pattern;
	char string[3000];
} Obj;

int cmp1(const void* a, const void* b)
{
	return ((Obj*)a)->pattern - ((Obj*)b)->pattern;
}

int cmp2(const void* a, const void* b)
{
	return strcmp(((Obj*)a)->string, ((Obj*)b)->string);
}



bool wordPattern(char * pattern, char * s){
	Obj obj[3000];
	int index = 0;
	int len = strlen(pattern);
	char* temp;

	while(*s){
		temp = s;
		while(*temp != '\0' && *temp != ' '){
			temp++;
		}
		if(*temp == '\0'){
			strcpy(obj[index++].string, s);
			break;
		}
		else{
			*temp = '\0';
			strcpy(obj[index++].string, s);
			s = temp + 1;
		}
	}
	if(index != len)return 0;
	for(int i = 0; i < len; i++){
		obj[i].pattern = pattern[i];
	}
	qsort(obj, index, sizeof(Obj), cmp1);
	int last_same;
	for (int i = 0; i < index; i++){
		// printf("%c %s\n", obj[i].pattern, obj[i].string);
		last_same = i + 1;
		while(last_same < index && obj[i].pattern == obj[last_same].pattern){
			if(strcmp(obj[i].string, obj[last_same].string)){
				return 0;
			}
			last_same++;
		}
		i = last_same - 1;
	}
	qsort(obj, index, sizeof(Obj), cmp2);
	for (int i = 0; i < index; i++){
		// printf("%c %s\n", obj[i].pattern, obj[i].string);
		last_same = i + 1;
		while(last_same < index && strcmp(obj[i].string, obj[last_same].string) == 0){
			if(obj[i].pattern != obj[last_same].pattern){
				return 0;
			}
			last_same++;
		}
		i = last_same - 1;
	}
	return 1;
}