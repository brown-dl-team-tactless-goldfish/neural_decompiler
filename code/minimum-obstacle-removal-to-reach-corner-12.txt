using PII = pair<int, int> ; //{x, y}
class Solution {
    int m, n ;
    int dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}} ;
    vector<vector<int>> gothrough(vector<vector<int>>&grid, vector<vector<bool>>&visited, int x0, int y0){
        queue<PII>q ;
        q.push({x0, y0}) ;
        vector<vector<int>>ret ;
        while(!q.empty()){
            int sz = q.size() ;
            for(int len = 0; len < sz; len++)
            {
                auto [x, y] = q.front() ;
                q.pop() ;
                for(int k = 0; k < 4; k++){
                    int xx = x + dirs[k][0] ;
                    int yy = y + dirs[k][1] ;
                    if(xx < 0 || yy < 0 || xx >= m || yy >= n)
                        continue ;
                    if(visited[xx][yy])
                        continue ;
                    visited[xx][yy] = true ;
                    if(grid[xx][yy] == 1)
                        ret.push_back({xx,yy}) ;
                    else{
                        if(xx == m-1 && yy == n-1){
                            ret.push_back({xx, yy}) ;
                            return ret ;
                        }
                        q.push({xx,yy}) ;    
                    }
                }
            }
        }
        return ret ;
    }
public:
    int minimumObstacles(vector<vector<int>>& grid) {
        m = grid.size() ;
        n = grid[0].size() ;
        vector<vector<bool>>visited(m, vector<bool>(n)) ;
        queue<PII>q ;
        q.push({0,0}) ;
        visited[0][0] = true ;
        int step = 0 ;
        while(!q.empty())
        {
            int sz = q.size() ;
            for(int len = 0; len < sz; len++)
            {
                auto [x,y] = q.front() ;
                q.pop() ;
                for(int k = 0; k < 4; k++){
                    int xx = x + dirs[k][0] ;
                    int yy = y + dirs[k][1] ;
                    if(xx < 0 || yy < 0 || xx >= m || yy >= n)
                        continue ;
                    if(visited[xx][yy])
                        continue ;
                    visited[xx][yy] = true ;
                    if(grid[xx][yy] == 1)
                        q.push({xx, yy}) ;
                    else{
                        if(xx == m-1 && yy == n-1)
                            return step ;
                        auto next = gothrough(grid, visited, xx, yy) ;
                        for(int i = next.size()-1; i >=0; i--){
                            if(next[i][0] == m-1 && next[i][1] == n-1)
                                return step ;
                            q.push({next[i][0], next[i][1]}) ;
                        }
                    }
                }
            }
            step++ ;
        }
        return -1 ;
    }
};