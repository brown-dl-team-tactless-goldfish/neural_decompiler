char** rotateTheBox(char** box, int boxSize, int* boxColSize, int* returnSize, int** returnColumnSizes){
    int rLen = boxSize, cLen = *boxColSize;
    int stoneCnt = 0;
    
    /* prepare return ans parms */
    char** ans = (char**)calloc(cLen, sizeof(char*));
    int* col = (int*)calloc(cLen, sizeof(int));
    for(int i = 0; i < cLen; i++){
        ans[i] = (char*)calloc(rLen, sizeof(char));
        for(int j = 0; j < rLen; j++)
            ans[i][j] = '.';
        col[i] = rLen;
    }
    
    /* 1. find '*' and count # num */
    for(int i = 0; i < rLen; i++){
        stoneCnt = 0;
        for(int j = 0; j < cLen; j++){
            if(box[i][j]=='#') /* count stone */
                stoneCnt++;
            else if(box[i][j]=='*')/* A stationary obstacle, try to remove stone if need */
            {
                ans[j][rLen - 1 - i] = '*';/* put stationary obstacle */
                if(stoneCnt && stoneCnt <= j){/* stoneCnt==j, full */
                    for(int k = 0; k < stoneCnt; k++){
                        ans[j - 1 - k][rLen - 1 - i] = '#';/* stone falls */
                    }
                    stoneCnt = 0;/* reset for next stationary obstacle */
                }
            }
            if(stoneCnt && (j == (cLen - 1))){
                for(int k = 0; k < stoneCnt; k++){
                    ans[j - k][rLen - 1 - i] = '#';/* stone falls */
                }                
            }
        }
    }
    
    *returnSize = cLen;
    *returnColumnSizes = col;
    return ans;
}