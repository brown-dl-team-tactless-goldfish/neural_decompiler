
class Solution {
public:
    unordered_map<int, TreeNode*> rootMap; 
    
    bool findBST(TreeNode* root, long left, long right){
        if(root == NULL) return true; 
        int res = root->val > left && root->val < right; 
        res = res && findBST(root->left, left, root->val)  && findBST(root->right, root->val, right); 
        return res;
    }
    
    bool isValidBST(TreeNode* root) {
        return findBST(root, LONG_MIN, LONG_MAX);     
    }
    
    TreeNode* mergeAll(TreeNode* root){ 
        TreeNode* res =  rootMap.count(root->val)? rootMap[root->val]: root; 
        rootMap.erase(root->val); 
        if(res->left) root->left = mergeAll(res->left); 
        if(res->right) root->right = mergeAll(res->right);
        return res; 
    }
    TreeNode* canMerge(vector<TreeNode*>& trees) {
        unordered_set<int> st ;
        for(auto x:trees){
            rootMap[x->val] = x;
            if(x->left) st.insert(x->left->val);
            if(x->right) st.insert(x->right->val);
        }
        TreeNode* root; 
        for(auto x:trees){
            if(!st.count(x->val)){
                root = x;
                break ; 
            }
        }
        mergeAll(root); 
        return isValidBST(root) && (rootMap.size() == 0)? root: NULL; 
    }
};