/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution {
    public int MinimumOperations(TreeNode root) {
        
        Queue<TreeNode> Q = new();
        Q.Enqueue(root);
        int res = 0;
        while(Q.Count>0)
        {
            int l = Q.Count();
            List<int> L = new();
            
            for(int i=0;i<l;i++){
               TreeNode node =  Q.Dequeue();
                L.Add(node.val);
                if(node.left!=null)
                    Q.Enqueue(node.left);
                if(node.right!=null)
                    Q.Enqueue(node.right); 
            }
            
            res += CountSwap(L);
            
        }
        return res; 
    }
    public int CountSwap(List<int> L)
    {
        int[] A = L.ToArray();
        int[] C = (int[])A.Clone();
        Array.Sort(C);
        Dictionary<int,int> D = new();
        for(int i=0;i<A.Length;i++)
        {
            D[A[i]] = i;
        }
        int res = 0;
        for(int i=0;i<A.Length;i++)
        {
            if(D[C[i]]!=i)
            {
                int p = D[C[i]];
                (A[p],A[i]) = (A[i],A[p]);
                D[A[i]] = i;
                D[A[p]] = p;
                res ++;
            }
        }
        return res;
    }
}