public class Solution {
    public int MaximalPathQuality(int[] vals, int[][] edges, int mt) {
        Dictionary<int, Dictionary<int, int>> g = new Dictionary<int, Dictionary<int, int>>();
        for (int i = 0; i < vals.Length; ++i) g.Add(i, new Dictionary<int, int>());
        foreach (int[] edge in edges) {
            g[edge[0]].Add(edge[1], edge[2]);
            g[edge[1]].Add(edge[0], edge[2]);
        }
        
        int[] r = new int[1];
        int[] s = new int[vals.Length];
        s[0]++;
        
        MaxPath(g, 0, vals, mt, s, r, vals[0]);
        
        return r[0];
    }
    
    // DFS Traverse all the way to the breaking case and do res calc there
    public void MaxPath(Dictionary<int, Dictionary<int, int>> g, int src, int[] vals, int t, int[] s, int[] r, int sum) { 
        if (src == 0) 
            r[0] = Math.Max(r[0], sum);
        
        if (t < 0) 
            return;
        
        foreach (KeyValuePair<int, int> nx in g[src]) {
            if (t - nx.Value >= 0) {
                s[nx.Key]++;
                MaxPath(g, nx.Key, vals, t - nx.Value, s, r, sum + (s[nx.Key] == 1 ? vals[nx.Key] : 0));
                s[nx.Key]--;
            }
        }
    }
}