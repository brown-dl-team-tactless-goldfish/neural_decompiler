public class Solution
    {
        private const int MODULO = 1000000007;


        public class Heap<T>
        {
            private readonly IList<T> _data;
            private readonly IComparer<T> _comparer;

            public int Count => _data.Count;
            public T Peek => _data[0];

            public Heap(IList<T> inputs, IComparer<T> comparer = null)
            {
                _comparer = comparer ?? Comparer<T>.Default;
                _data = inputs;
                for (int i = Count / 2; i >= 0; i--)
                {
                    SiftDown(i);
                }
            }

            public Heap(IEnumerable<T> inputs, IComparer<T> comparer = null) : this(inputs.ToList(), comparer)
            {
            }

            private void Swap(int i, int j)
            {
                var tmp = _data[i];
                _data[i] = _data[j];
                _data[j] = tmp;
            }

            private void SiftDown(int i)
            {
                while (2 * i + 1 < _data.Count)
                {
                    int left = 2 * i + 1;
                    int right = 2 * i + 2;
                    int j = left;

                    if (right < _data.Count && _comparer.Compare(_data[right], _data[left]) < 0)
                    {
                        j = right;
                    }

                    if (_comparer.Compare(_data[i], _data[j]) <= 0)
                    {
                        break;
                    }

                    Swap(i, j);
                    i = j;
                }
            }

            private void SiftUp(int i)
            {
                while (_comparer.Compare(_data[i], _data[(i - 1) / 2]) < 0)
                {
                    Swap(i, (i - 1) / 2);
                    i = (i - 1) / 2;
                }
            }

            public T Pop()
            {
                T top = Peek;
                _data[0] = _data.Last();
                _data.RemoveAt(Count - 1);
                SiftDown(0);
                return top;
            }

            public void Push(T value)
            {
                _data.Add(value);
                SiftUp(Count - 1);
            }
        }

        private class SolCmp : IComparer<int>
        {
            public int Compare(int x, int y)
            {
                return y.CompareTo(x);
            }
        }

        public int MaxProfit(int[] inventory, int orders)
        {
            checked
            {
                int res = 0;

                Dictionary<int, int> map = new Dictionary<int, int>();
                for (int i = 0; i < inventory.Length; i++)
                {
                    var inv = inventory[i];
                    if (map.TryGetValue(inv, out var c))
                    {
                        map[inv] = c + 1;
                    }
                    else
                    {
                        map.Add(inv, 1);
                    }
                }

                Heap<int> heap = new Heap<int>(map.Keys.ToList(), new SolCmp());

                while (heap.Count > 0 && orders > 0)
                {
                    var top = heap.Pop();

                    var mapCount = map[top];
                    map.Remove(top);

                    int chunkCount = Math.Min(mapCount, orders);
                    int least = top;
                    if (map.Count > 0)
                    {
                        least = (top - heap.Peek);
                    }
                    var maxCount = Math.Min(orders, least);
                    var chunkSize = Math.Max(1, maxCount / chunkCount);

                    var min = top - chunkSize + 1;
                    var max = top;

                    long curr = (long)(min + max) * chunkSize / 2;
                    curr %= MODULO;

                    res += (int)((curr * chunkCount) % MODULO);
                    res %= MODULO;
                    orders -= (chunkSize * chunkCount);

                    int next = top - chunkSize;
                    if (next > 0)
                    {
                        if (map.TryGetValue(next, out var c))
                        {
                            map[next] = c + chunkCount;
                        }
                        else
                        {
                            map.Add(next, chunkCount);
                            heap.Push(next);
                        }

                    }
                }

                return res;
            }
        }
    }