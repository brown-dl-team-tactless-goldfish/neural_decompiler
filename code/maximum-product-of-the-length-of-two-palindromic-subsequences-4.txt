class Solution {
private:
    int ret = 0 ;
    bool isPalindrome(string& s){
        int n = s.length() ;
        for(int i = 0; i < n/2 ; i++){
            if(s[i] != s[n-1-i])
                return false ;
        }
        return true ;
    }
    
    void dfs(const string& s, int cur, string& s1, string& s2){
        if(cur == s.size()){
            if(isPalindrome(s1) && isPalindrome(s2)){
                ret = fmax(ret , s1.size() * s2.size()) ;
            }    
            return ;
        }
        
        s1.push_back(s[cur]) ;
        dfs(s, cur+1, s1, s2) ;
        s1.pop_back() ;
        
        s2.push_back(s[cur]) ;
        dfs(s, cur+1, s1, s2) ;
        s2.pop_back() ;
        
        dfs(s, cur+1, s1, s2) ;
    }
public:
    int maxProduct(string s) {
        string s1, s2 ;
        dfs(s, 0, s1, s2);
        return ret ;
    }
};