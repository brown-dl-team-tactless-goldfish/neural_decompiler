class Solution {
    vector<double> gradient(vector<vector<int>>& positions, double x0, double y0) {
        vector<double> ans = {0, 0, 0};
        for (auto& p: positions) {
            int x = p[0];
            int y = p[1];
            double dx = x0 - x, dy = y0 - y;
            double len = sqrt(dx*dx + dy*dy);
            ans[0] += dx/len; // grad_x
            ans[1] += dy/len; // grad_y
            ans[2] += len;    // f(x, y)
        }
        return ans;
    }
public:
    double getMinDistSum(vector<vector<int>>& positions) {
        if (positions.size() <= 1) {
            return 0;
        } else if (positions.size() == 2) {
            int dx = positions[0][0] - positions[1][0];
            int dy = positions[0][1] - positions[1][1];
            return sqrt(dx*dx + dy*dy);
        }
        double x0 = ((double) rand() / (RAND_MAX));
        double y0 = ((double) rand() / (RAND_MAX));
        double learningRate = 0.1;
        double lastTotalDist = INT_MAX;
        double lastGradX = 0, lastGradY = 0;
        while (true) {
            auto grad = gradient(positions, x0, y0);
            if (fabs(grad[0]) + fabs(grad[1]) < 1e-6 || 
                fabs(lastTotalDist - grad[2]) < 1e-8) {
                lastTotalDist = grad[2];
                break;
            }
            x0 -= grad[0] * learningRate;
            y0 -= grad[1] * learningRate;
            if ((lastGradX * grad[0]) < 0 || 
               lastGradY * grad[1] < 0) {
                learningRate *= (fabs(grad[0]) + fabs(grad[1])) / 
                    (fabs(grad[0]) + fabs(grad[1]) + fabs(lastGradX) + fabs(lastGradY));
            } 
            lastGradX = grad[0];
            lastGradY = grad[1];
            lastTotalDist = grad[2];
        }
        return lastTotalDist;
    }
};