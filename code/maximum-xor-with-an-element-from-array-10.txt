class Solution {
public:
    
    struct Node
    {
        Node * child[2];
    };
    
    Node * root;
    
    Node * createNode()
    {
        Node * node = new Node();
        node->child[0] = NULL;
        node->child[1] = NULL;
        return node;
    }
    
    // insert bits of num value in to Binary Trie from MSB to LSB
    void insert(int num)
    {
        Node * node = root;
        int digit;
        
        for(int i=31;i>=0;i--)
        {
            digit = (num>>i) & 1;
            
            if(node->child[digit]==NULL)
                node->child[digit] = createNode();
            
            node = node->child[digit];
        }
    }
    
    // search the largest possible reverse bit value of given value 
    int getMaxValue(int num)
    {
        Node * node = root;
        int digit;
        int val = 0;
        
        // loop through value bits MSB to LSB
        for(int i=31;i>=0;i--)
        {
            digit = (num>>i) & 1;
            
            // for current bit 1, move to 0 bit if possible
            if(digit && node->child[digit-1])
            {
                node = node->child[digit-1];   
                val += pow(2,i);    // XOR bit 1, so add value
            }
            else if(digit && node->child[digit])node = node->child[digit];
            
            // for current bit 0, move to 1 bit if possible
            else if(!digit && node->child[digit+1])
            {
                node = node->child[digit+1];
                val += pow(2,i);    // XOR bit 1, so add value
            }
            else if(!digit && node->child[digit])node = node->child[digit];
            
            else return -1; // no child 0 or 1 bit and so return -1
        }
        
        return val;        
    }
    
    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {
        
        root = createNode();
        
        int n = nums.size();
        
        // sort nums array
        sort(nums.begin(),nums.end());
        
        for(int i=0;i<queries.size();i++)
            queries[i].push_back(i);
        
        // sort query array based on threshold value M
        sort(queries.begin(),queries.end(),[](const vector<int>&a, const vector<int>&b){
            return a[1] < b[1];         
        });
        
        vector<int>res(queries.size());
        
        int curr = 0;
        
        // loop through queries and add values less than threshold in to Binary Trie
        for(int i=0;i<queries.size();i++)
        {
            while(curr<n && nums[curr] <= queries[i][1])
                insert(nums[curr++]);
            
            res[queries[i][2]] = getMaxValue(queries[i][0]);
        }
        
        return res;        
    }
};