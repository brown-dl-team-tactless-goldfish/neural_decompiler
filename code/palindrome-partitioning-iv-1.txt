class Solution {
    bool ispalindrome(string &s, int i, int j, vector<vector<int>> &palind)
    {
        int x = i, y = j;
        while(i <= j)
        {
            if(palind[i][j] != -1)
                return palind[x][y] = palind[i][j];
            if(s[i] == s[j])
            {
                i++;
                j--;
            }
            else
            {
                return palind[x][y] = 0;   
            }
        }
        return palind[x][y] = 1;
    }
    int dfs(int start, int end, vector<vector<int>> &dp, string &s, int n, vector<vector<int>> &palind, int partition)
    {
        if(start > end) return 0;
        if(partition == 1)
        {
            return dp[end][partition] = ispalindrome(s, start, end, palind);
        }
        if(start == end) return 0;
        if(dp[end][partition] != -1)
            return dp[end][partition];
        for(int i = start; i <= end; i++)
        {
            if(ispalindrome(s, i, end, palind))
            {
                if(dfs(start, i-1, dp, s, n, palind, partition-1))
                    return 1;
            }
        }
        return 0;
    }
public:
    bool checkPartitioning(string s) {
        int n = s.size();
        vector<vector<int>> dp(n+1, vector<int> (4, -1));
        vector<vector<int>> palind(n+1, vector<int> (n+1, -1));
        return dfs(0, n-1, dp, s, n, palind, 3);
    }
};