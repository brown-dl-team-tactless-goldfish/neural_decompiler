//BinarySearch + BFS 392ms/107MB:
class Solution {
public:    
    int latestDayToCross(int row, int col, vector<vector<int>>& cells) {
        vector<int> graph[row];
        for (int i = 0; i < row; i++){
            graph[i].resize(col,0);
        }
        
        for (int i = 0; i < cells.size(); i++){
            graph[cells[i][0]-1][cells[i][1]-1] = i+1;
        }
        
        int l = 1, r = row*col+1;
        
        while (l+1 < r){
            int m = (l+r)>>1;
            if (bfs(graph, m, row, col)){
                l = m;
            }else{
                r = m;
            }
        }
        
        return l;
    }
    
    bool bfs(vector<int> graph[], int td, int r, int c){
        
        bool vis[r*c];
        
        memset(vis, false, sizeof(vis);
        
        queue<int> q; 
        
        auto push = [&](int i, int j){
            if (i == -1 || j == -1 || i == r || j == c || vis[i*c+j] || graph[i][j] <= td) return false;
            
            if (i == r-1) return true;
            
            vis[i*c+j] = true;
            q.push({i*c+j});
            return false;
        };
        
        for (int j = 0; j < c; j++){
            if (graph[0][j] > td) q.push(j);
        }
        
        while(q.size()){
            int i = q.front()/c;
            int j = q.front()%c;
            q.pop();
            
            if (push(i+1, j)) return true;;
            if (push(i-1, j)) return true;;
            if (push(i, j+1)) return true;;
            if (push(i, j-1)) return true;;
        }
        
        return false;
    }    
};