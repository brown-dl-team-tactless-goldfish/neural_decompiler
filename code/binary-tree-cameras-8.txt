#define CAMERA_0_DEPTH  0   // camera on this node
#define CAMERA_1_DEPTH  1   // camera on children's node
#define CAMERA_2_DEPTH  2   // camera on 2 level children's node

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

int MinCameraCoverInner(struct TreeNode* pstRoot, short sDepth, short sRet)
{
    if(pstRoot == NULL) return sRet;

    // parser tree first
    if(pstRoot->left == NULL)
    {
        // leaf already
        if(pstRoot->right == NULL)
        {
            pstRoot->val = CAMERA_2_DEPTH;
            return sDepth == 1? 1: sRet;    // sDepth == 1, means root
        }
    }
    else
    {
        sRet = MinCameraCoverInner(pstRoot->left, sDepth+1, sRet);  // parse left leaf
    }
    if(pstRoot->right != NULL) sRet = MinCameraCoverInner(pstRoot->right, sDepth+1, sRet);  //parse right leaf

    // check children node and update val
    if(pstRoot->left != NULL)
    {
        if(pstRoot->right == NULL)
        {
            // only check left leaf since right leaf is null
            switch(pstRoot->left->val)
            {
                case CAMERA_2_DEPTH:
                    sRet++;
                    //pstRoot->val = CAMERA_0_DEPTH;
                    break;
                case CAMERA_1_DEPTH:
                    if(sDepth == 1) sRet++; // sDepth == 1, means root
                case CAMERA_0_DEPTH:
                    pstRoot->val = pstRoot->left->val + 1;
                    break;
            }
        }
        else
        {
            // if one of children leaf hits 2-depth, add camera
            if(pstRoot->left->val == CAMERA_2_DEPTH || pstRoot->right->val == CAMERA_2_DEPTH)
            {
                sRet++;
                //pstRoot->val = CAMERA_0_DEPTH;
            }
            else
            {
                switch(pstRoot->left->val + pstRoot->right->val)
                {
                    case CAMERA_2_DEPTH:
                        if(sDepth == 1) sRet++;     // sDepth == 1, means root
                    default:
                        pstRoot->val = (pstRoot->left->val == CAMERA_0_DEPTH || pstRoot->right->val == CAMERA_0_DEPTH)? CAMERA_1_DEPTH: CAMERA_2_DEPTH;
                        break;
                }
            }
        }
    }
    else if(pstRoot->right != NULL)
    {
        // only check right leaf since left leaf is null
        switch(pstRoot->right->val)
        {
            case CAMERA_2_DEPTH:
                sRet++;
                //pstRoot->val = CAMERA_0_DEPTH;
                break;
            case CAMERA_1_DEPTH:
                if(sDepth == 1) sRet++; // sDepth == 1, means root
            case CAMERA_0_DEPTH:
                pstRoot->val = pstRoot->right->val + 1;
                break;
        }
    }

    return sRet;
}

int minCameraCover(struct TreeNode* root){
    return MinCameraCoverInner(root, 1, 0);
}