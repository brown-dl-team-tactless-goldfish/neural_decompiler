

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

int update(int ** graph, int peopleNum, int * index, int cur, int ** visited, int ** smallQuiet, int **);

int* loudAndRich(int** richer, int richerSize, int* richerColSize, int* quiet, int quietSize, int* returnSize){
    *returnSize = quietSize;
    int * smallQuiet = malloc(sizeof(int) * quietSize);
    int * visited = malloc(sizeof(int) * quietSize);
    int ** graph = malloc(sizeof(int *) * quietSize);
    int * index = malloc(sizeof(int *) * quietSize);
    for (int i = 0; i < quietSize; i++){
        smallQuiet[i] = i;
        visited[i] = 0;
        index[i] = 0;
        graph[i] = malloc(sizeof(int) * quietSize);
    }
    for (int i = 0; i < richerSize; i++){
        int temp = richer[i][1];
        graph[temp][index[temp]] = richer[i][0];
        index[temp]++;
    }
    for (int i = 0; i < quietSize; i++){
        update(graph, quietSize, index, i, &visited, &smallQuiet, &quiet);
    }
    return smallQuiet;
}

int update(int ** graph, int peopleNum, int * index, int cur, int ** visited, int ** smallQuiet, int ** quiet){
    if ((*visited)[cur] == 1)
        return (*smallQuiet)[cur];
    (*visited)[cur] = 1;
    int small;
    for (int i = 0; i < index[cur]; i++){
        small = update(graph, peopleNum, index, graph[cur][i], visited, smallQuiet, quiet);
        if ((*quiet)[small] < (*quiet)[cur]){
            (*quiet)[cur] = (*quiet)[small];
            (*smallQuiet)[cur] = small;
        }
    }
    return (*smallQuiet)[cur];
}