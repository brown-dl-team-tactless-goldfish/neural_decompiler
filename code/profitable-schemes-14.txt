class Solution {
private:
    int mod=1e9+7;
    int add(int a,int b){
        return (a+b)%mod;
    }
    int mem[101][101][101];
    int solve(vector<int>&groups,vector<int>&profits,int n,int index,int profit){
	//if there are no more thiefs to participate or no more crimes to commit then return 1 if we have exceeded the min profit
        if(n==0 or index==profits.size()){
            return profit==0;
        } else if(mem[index][n][profit]!=-1){
            return mem[index][n][profit];
        } else {
		//we can choose to not commit this crime
            int ans1=solve(groups,profits,n,index+1,profit);
            int ans2=0;
            if(groups[index]<=n){
			//we can commit this crime and get some profit as a result
                ans2=solve(groups,profits,n-groups[index],index+1,max(profit-profits[index],0));
            }
            return mem[index][n][profit]=add(ans1,ans2);
        }
    }
public:
    int profitableSchemes(int n, int minProfit, vector<int>& group, vector<int>& profit) {
        memset(mem,-1,sizeof(mem));
        return solve(group,profit,n,0,minProfit);
    }
};