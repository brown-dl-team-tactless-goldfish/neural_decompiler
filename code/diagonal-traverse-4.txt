void traverseReverse(int* x, int* y, int matrixSize, int *matrixColSize, bool* direction)
{
	int i = *x, j = *y;
	bool dir = *direction;

	i++;//
	j--;
	if( i > (matrixSize-1) )
	{
		i--;
		j += 2;
		dir = !dir;
	}
	if( j < 0)
	{
		j++;
		dir = !dir;
	}
	*x = i;
	*y = j;
	*direction = dir;
}

void traverseStraight(int* x, int* y, int matrixSize, int *matrixColSize, bool* direction)
{
	int i = *x, j = *y;
	bool dir = *direction;

	i--;
	j++;
	if( i<0 && j > ( (*matrixColSize) - 1 ) )
	{
		i += 2;
		j--;
		dir = !dir;
	}
	if( i<0 )
	{
		i = 0;
		dir = !dir;  
	}
	if( j > ( (*matrixColSize) - 1 ) ) 
	{
		j--;
		i += 2;
		dir = !dir;   
	}
	*x = i;
	*y = j;
	*direction = dir;
}

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* findDiagonalOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize){
	if(matrixSize == 0)
	{
		*returnSize = 0;
		return NULL;
	}
	int* ptr = malloc(sizeof(int)*matrixSize*(*matrixColSize));
	int i = 0, j = 0, k = 0;
	bool direction = true;//straight

	while( k < ( (matrixSize* (*matrixColSize) ) -1 ) )
	{
		switch(direction)
		{
			case 1:  
				ptr[k] = matrix[i][j];
				traverseStraight(&i, &j, matrixSize, matrixColSize, &direction);
				break;

			case 0:
				ptr[k] = matrix[i][j];
				traverseReverse(&i, &j, matrixSize, matrixColSize, &direction);
				break; 
		}
		k++;
	}
	ptr[k] = matrix[i][j];
	*returnSize = (matrixSize* (*matrixColSize) ) ;    

	return ptr; 
}