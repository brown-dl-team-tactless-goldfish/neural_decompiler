class Solution {
    typedef pair<int, int> pii;
    
    int d[5][10][10], res = 0;
    bool visited[5][10][10], path[5][10][10];
    vector<pii> moves[5];
    pii trace[5][10][10];
    int chosen[5];
    
    void update(int id, int u, int v, int val, int uu, int vv) 
    {
        d[id][u][v] = val;
        moves[id].push_back({u, v});
        trace[id][u][v] = {uu, vv};
    }
    
    void bfs(string type, int id, vector<int>& pos)
    {
        int u = pos[0];
        int v = pos[1];
        moves[id].push_back({u, v});
        if (type == "rook" || type == "queen")
        {
            for (int i = 1; i < 8; ++i) if (u + i <= 8)
            {
                update(id, u + i, v, i, u + i - 1, v);
            }
            for (int i = 1; i < 8; ++i) if (u - i > 0)
            {
                update(id, u - i, v, i, u - i + 1, v);
            }
            for (int j = 1; j < 8; ++j) if (v + j <= 8)
            {
                update(id, u, v + j, j, u, v + j - 1);
            }
            for (int j = 1; j < 8; ++j) if (v - j > 0)            
            {
                update(id, u, v - j, j, u, v - j + 1);
            }
        }
        if (type == "bishop" || type == "queen")
        {
            for (int i = 1; i < 8; ++i) if (u + i <= 8 && v + i <= 8)
            {
                update(id, u + i, v + i, i, u + i - 1, v + i - 1);
            }
            for (int i = 1; i < 8; ++i) if (u - i > 0 && v - i > 0)
            {
                update(id, u - i, v - i, i, u - i + 1, v - i + 1);
            }
            for (int i = 1; i < 8; ++i) if (u + i <= 8 && v - i > 0)
            {
                update(id, u + i, v - i, i, u + i - 1, v - i + 1);
            }
            for (int i = 1; i < 8; ++i) if (u - i > 0 && v + i <= 8)
            {
                update(id, u - i, v + i, i, u - i + 1, v + i - 1);
            }
        }
    }
    
    void Try(int x, int n) 
    {
        if (x >= n)
        {
            for (int i = 0; i < n; ++i) for (int j = 1; j <= 8; ++j) for (int k = 1; k <= 8; ++k) path[i][j][k] = false;
            for (int i = 0; i < n; ++i) 
            {
                auto [u, v] = moves[i][chosen[i]];
                while (u != 0 && v != 0)
                {
                    path[i][u][v] = true;
                    for (int j = 0; j < i; ++j) if (path[j][u][v])
                    {
                        if (d[j][u][v] == d[i][u][v]) 
                        {
                            return;
                        }
                        if (d[j][u][v] < d[i][u][v] && moves[j][chosen[j]] == make_pair(u, v)) 
                        {
                            return;
                        }
                        if (d[j][u][v] > d[i][u][v] && moves[i][chosen[i]] == make_pair(u, v))
                        {
                            return;
                        }
                    }
                    auto [u1, v1] = trace[i][u][v];
                    u = u1;
                    v = v1;
                }
            }
            
            ++res;
            return;
        }
        for (int i = 0; i < moves[x].size(); ++i) 
        {
            chosen[x] = i;
            Try(x + 1, n);
        }
    }
    
public:
    int countCombinations(vector<string>& pieces, vector<vector<int>>& positions) {
        int n = pieces.size();
        for (int i = 0; i < n; ++i)
        {
            bfs(pieces[i], i, positions[i]);
        }
        Try(0, n);
        return res;
    }
};