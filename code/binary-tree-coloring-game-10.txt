class Solution {
public:
    
    // find neighbor nodes of node x
    void findNodes(TreeNode *root, int x, vector<TreeNode*>&neighbors)
    {
        if(!root) return;
        
        // found target node x
        if(root->val==x)
        {
            neighbors.push_back(root->left);
            neighbors.push_back(root->right);
            
            return;
        }
        
        findNodes(root->left,x,neighbors);
        findNodes(root->right,x,neighbors);        
    }
    
    // count nodes of the subtree
    int countNodes(TreeNode *root)
    {
        if(!root) return 0;
        
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
    
    bool btreeGameWinningMove(TreeNode* root, int n, int x) {
        
        // store neighbor node of node x
        vector<TreeNode*>neighbors;
        
        // find neighbor nodes
        findNodes(root,x,neighbors);
        
        // count left child neighbor subtree nodes
        int leftSubtreeCount = countNodes(neighbors[0]);
        
        // count right child neighbor subtree nodes        
        int rightSubtreeCount = countNodes(neighbors[1]);
        
        // count parent neighbor subtree nodes
        int parentSubtreeCount = n - 1 - leftSubtreeCount - rightSubtreeCount;
        
        // return true if max node count of player 2 is greater than n/2 which player 2 can choose to WIN
        // otherwise return false means player 2 lose
        return max({leftSubtreeCount,rightSubtreeCount,parentSubtreeCount}) > n/2;
    }
};