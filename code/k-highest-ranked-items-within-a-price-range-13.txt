
class Cell {
public:
	int distance , price, row, col;
	Cell(int distance, int price, int row, int col) {
		this->distance = distance;
		this->price = price;
		this->row = row;
		this->col = col;
	}


};
class Comp {
public:
	bool operator()(Cell &c1, Cell &c2) {
		if (c1.distance != c2.distance) return c1.distance > c2.distance;
		else if (c1.price != c2.price) return c1.price > c2.price;
		else if (c1.row != c2.row) return c1.row > c2.row;
		else if (c1.col != c2.col) return c1.col > c2.col;
		return true;
	}
};
class Solution {
public:
	vector<vector<int>> highestRankedKItems(vector<vector<int>>& g, vector<int>& pricing, vector<int>& start, int k) {
		int sr = start[0]; int sc = start[1]; int minPrice = pricing[0]; int maxPrice = pricing[1];
		int rows = g.size(); int cols = g[0].size();
		vector<vector<int>> ans;
		int dirs[4][2] = {{0 , 1}, {0, -1}, {1, 0}, { -1, 0}};

		priority_queue<Cell, vector<Cell>, Comp> pq;
		pq.push(Cell(0, g[sr][sc], sr, sc));

		vector<vector<bool>> vis(g.size(), vector<bool> (g[0].size(), false));

		while (!pq.empty()) {
			auto fr = pq.top(); pq.pop();
			if (vis[fr.row][fr.col]) continue;

			vis[fr.row][fr.col] = true;
			/* add it to the answer if this is a valid cell and k-- also*/
			if (fr.price >= minPrice && fr.price <= maxPrice && k > 0) {
				ans.push_back({fr.row, fr.col});
				if (k == 0) return ans;
				k--;
			}

			for (auto d : dirs) {
				int ni = fr.row + d[0];
				int nj = fr.col + d[1];

				if (ni >= 0 && nj >= 0 && ni < rows && nj < cols &&  g[ni][nj] > 0 && !vis[ni][nj]) {
					pq.push(Cell(fr.distance + 1, g[ni][nj], ni, nj));
				}
			}
		}

		return ans;

	}
};