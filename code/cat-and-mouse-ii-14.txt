class Solution {
    
    int[][] direction;
    int available;
    int m;
    int n;
    int[][][][][] dp;
    int catJump;
    int mouseJump;
    char[][] grid;

    public boolean canMouseWin(String[] gridString, int catJump, int mouseJump) {
        m = gridString.length;
        n = gridString[0].length();
        direction = new int[][] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        this.catJump = catJump;
        this.mouseJump = mouseJump;
        grid = new char[m][n];

        int mouseI = -1;
        int mouseJ = -1;
        int catI = -1;
        int catJ = -1;

        for (int i = 0; i < m; i++) {
            char[] row = gridString[i].toCharArray();
            for (int j = 0; j < n; j++) {
                if (row[j] == 'M') {
                    mouseI = i;
                    mouseJ = j;
                } else if (row[j] == 'C') {
                    catI = i;
                    catJ = j;
                }

                if (row[j] != '#') {
                    available++;
                }
            }
        }

        for (int i = 0; i < m; i++) {
            grid[i] = gridString[i].toCharArray();
        }

        // 1 <= rows, cols <= 8, just set a big turn size 200, which is never reached
        dp = new int[200][m][n][m][n];

        return dfs(0, mouseI, mouseJ, catI, catJ);
    }

    private boolean dfs(int turn, int mouseI, int mouseJ, int catI, int catJ) {
        if (turn > available * 2) {
            return false;
        }

        //dp[turn][mouseI][mouseJ][catI][catJ] == 1 means mouse wins
        //dp[turn][mouseI][mouseJ][catI][catJ] == 2 means cat wins
        if (dp[turn][mouseI][mouseJ][catI][catJ] != 0) {
            return dp[turn][mouseI][mouseJ][catI][catJ] == 1;
        }

        if (turn % 2 == 0) {

            for (int[] dir : direction) {

                for (int step = 0; step <= mouseJump; step++) {
                    int i = mouseI + dir[0] * step;
                    int j = mouseJ + dir[1] * step;

                    if (i >= 0 && i < m && j >= 0 && j < n && grid[i][j] != '#') {
                        if (grid[i][j] == 'F') {
                            dp[turn][mouseI][mouseJ][catI][catJ] = 1;
                            return true;
                        }

                        if (dfs(turn+1, i, j, catI, catJ)) {
                            dp[turn][mouseI][mouseJ][catI][catJ] = 1;
                            return true;
                        }
                    } else {
                        break;
                    }

                }

            }
            dp[turn][mouseI][mouseJ][catI][catJ] = 2;
            return false;

        } else {
            for (int[] dir : direction) {

                for (int step = 0; step <= catJump; step++) {
                    int i = catI + dir[0] * step;
                    int j = catJ + dir[1] * step;

                    if (i >= 0 && i < m && j >= 0 && j < n && grid[i][j] != '#') {
                        if (grid[i][j] == 'F') {
                            dp[turn][mouseI][mouseJ][catI][catJ] = 2;
                            return false;
                        }

                        if (i == mouseI && j == mouseJ) {
                            dp[turn][mouseI][mouseJ][catI][catJ] = 2;
                            return false;
                        }

                        if (!dfs(turn+1, mouseI, mouseJ, i, j)) {
                            dp[turn][mouseI][mouseJ][catI][catJ] = 2;
                            return false;
                        }
                    } else {
                        break;
                    }

                }

            }
            dp[turn][mouseI][mouseJ][catI][catJ] = 1;
            return true;
        }
    }
}
