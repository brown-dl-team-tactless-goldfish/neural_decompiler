class Solution {
public:
  inline int bfs(vector<vector<int>> &g, vector<int> &vis, int id){        //bfs with searching the longest path from one of two cells that are present itself cycle with length 2
    queue<int>q;
    
    int level = 0;
    q.push(id);
    while(!q.empty()){
      int n = q.size();
      level++;
      while(n--){
        int j = q.front(); q.pop();
        vis[j] = 1;
        for(auto k: g[j])
          if(vis[k] == 0) q.push(k);
      }
    }
    return level;
  }
  
  
  int maximumInvitations(vector<int>& fav) {
    int n = fav.size(), ans_cycle = 0, ans_linear = 0;
    
    vector<vector<int>> g(n);                                                                //graph with reversed edges for searching and deleting "tails"
    for(int i = 0; i != n; i++) g[fav[i]].push_back(i);
    
    vector<int>vis(n,0);                                                                     //for visiting cells
    for(int i = 0; i != n; i++)
      if(vis[i] == 0)                                                                        //if we not visited this cell we move from this cell and will calculate total length
        for(int next = i, len = 0; ;len++)
          if(vis[next] == 0){                                                                //while we move we mark our path (1 - visited) 
            vis[next] = 1;
            next = fav[next];
          }
          else{                                                                              //if we collide to visited cell => we have loop
            int stop = next;                                                                 //again move from begin of this path to cell where we have loop
            next = i;                                                                        //so we discard from loop cells that are presented itself "tail"
            while(next != stop) {vis[next] = 0; next = fav[next]; len--;}                    //and remark it as not visited
            
            if(len == 2) ans_linear += bfs(g, vis, stop) + bfs(g, vis, fav[stop]);           //if len == 2 search the longest tails for ans_linear
            else{
              ans_cycle = max(ans_cycle, len);                                               //if len > 2 discard all tails for this loop
              
              queue<int>q;
              do{q.push(next); next = fav[next];}while(next != stop);
              while(!q.empty()){
                int j = q.front(); q.pop();
                vis[j] = 1;
                for(auto k: g[j])
                  if(vis[k] == 0) q.push(k);
              }
            }
            break;
          }
    
    return max(ans_cycle, ans_linear);
  }
};