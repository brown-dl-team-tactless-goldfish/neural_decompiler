/*
Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i < j < k and arr[i] + arr[j] + arr[k] == target.

As the answer can be very large, return it modulo 109 + 7.

 

Example 1:

Input: arr = [1,1,2,2,3,3,4,4,5,5], target = 8
Output: 20
Explanation: 
Enumerating by the values (arr[i], arr[j], arr[k]):
(1, 2, 5) occurs 8 times;
(1, 3, 4) occurs 8 times;
(2, 2, 4) occurs 2 times;
(2, 3, 3) occurs 2 times.
Example 2:

Input: arr = [1,1,2,2,2,2], target = 5
Output: 12
Explanation: 
arr[i] = 1, arr[j] = arr[k] = 2 occurs 12 times:
We choose one 1 from [1,1] in 2 ways,
and two 2s from [2,2,2,2] in 6 ways.
 

Constraints:

3 <= arr.length <= 3000
0 <= arr[i] <= 100
0 <= target <= 300
*/

typedef struct {
    int val;
    int count;
}Data;

static Data **pHash;
static int hashsize;
void Insert(int value){
    int key = value % hashsize;
    while(1){
        if (pHash[key] == NULL){
            pHash[key] = calloc(1, sizeof(Data));
            pHash[key] -> val = value;
            pHash[key] -> count = 1;
            return;
        } else {
            if (pHash[key]-> val == value){
                (pHash[key] -> count)++;
                return;
            } else {
                key = key + 1;
                key = key % hashsize;
            }
        }
    }
}

int get_key(int value){
    int key = value % hashsize;
    while(1){
        if (pHash[key] == NULL){
            return -1;
        } else {
            if (pHash[key]-> val == value){
                return key;
            } else {
                key = key + 1;
                key = key % hashsize;
            }
        }
    }

}

long long C(int a, int b){
    if (b == 1) return a;
    if (a==b || b==0) return 1;
    if (b>a) return 0;
    long long ans = 1;
    for (int i = 0; i < b; i++){
        ans = ans * (a - i);
    }

    for (int i = b; i > 1; i--){
        ans = ans / i;
    }
    return ans;
}

int threeSumMulti(int* arr, int arrSize, int target){
    // Allocate Hash
    hashsize = arrSize + 1;
    pHash = (Data**)calloc(hashsize, sizeof(Data*));

    //Insert
    for (int i = 0 ; i < arrSize; i++){
        Insert(arr[i]);
    }

    long long ans = 0;
    //Search over hash
    for (int i = 0; i < hashsize; i++){
        if (pHash[i] == NULL) continue;
        for (int j = i ; j < hashsize; j++){
            if (pHash[j] == NULL) continue;
            int tar = target - pHash[i] -> val - pHash[j] -> val;
            if (tar < 0) continue;
            int k = get_key(tar);
            if (k == -1 || k < j){
                continue;
            }
            // i != j != k
            if (pHash[i] -> val != pHash[j] -> val &&  pHash[j] -> val != pHash[k] -> val && pHash[i] -> val != pHash[k] -> val ){
                ans = ans + pHash[i] -> count * pHash[j] -> count * pHash[k] -> count;
                continue;
            }
            // i == j != k
            if (pHash[i] -> val == pHash[j] -> val &&  pHash[j] -> val != pHash[k] -> val ){
                ans = ans + pHash[k] -> count * C(pHash[i] -> count, 2);
                continue;
            }

            // i != j == k
            if (pHash[i] -> val != pHash[j] -> val &&  pHash[j] -> val == pHash[k] -> val ){
                ans = ans + pHash[i] -> count * C(pHash[j] -> count, 2);
                continue;
            }

            // i == k != j
            if (pHash[i] -> val == pHash[k] -> val &&  pHash[j] -> val != pHash[k] -> val ){
                ans = ans + pHash[j] -> count * C(pHash[i] -> count, 2);
                continue;
            }

            // i == j == k
            if (pHash[i] -> val == pHash[k] -> val &&  pHash[j] -> val == pHash[k] -> val ){
                ans = ans +  C(pHash[i] -> count, 3);
                continue;
            }
        }
    }
    return (int)(ans % (1000000000+7));
}