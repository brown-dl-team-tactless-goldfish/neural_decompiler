struct T {
    int x;
    int y;
    int r;
    int l;
};

struct Q {
    struct T data[2*41*41*41*41];
    int i;
    int j;
    int size;
    int max_size;
};

void init(struct Q* r) {
    r->i = r->j = r->size = 0;
    r->max_size = 2*41*41*41*41;
}

void push(struct Q* r, struct T t) {
    r->data[r->i++] = t;
    r->size ++;
    r->i = r->i%r->max_size;
}

struct T pop(struct Q* r) {
    struct T t = r->data[r->j++];
    r->j = r->j%r->max_size;
    r->size --;
    return t;
}

int empty(struct Q* r) {
    return r->size == 0;
}

int shortestPath(int** grid, int gridSize, int* gridColSize, int k){
    struct Q q;
    struct T t = {0,0,k,0};
    int p;
    int ans = -1;
    char V[41*41*41*41];
    memset(V,0,sizeof(V));
    init(&q);
    push(&q, t);
    while (!empty(&q)) {
        t = pop(&q);
        p = (k+1)*(*gridColSize*t.x + t.y)+t.r;
        if (V[p]) {
            continue;
        }
        V[p] = 1;
        if (t.x == gridSize-1 && t.y == *gridColSize-1) {
            ans = t.l; break;
        }
        if (t.x > 0) {
            struct T t1 = {t.x-1,t.y,t.r,t.l+1};
            if (grid[t.x-1][t.y]) {
                t1.r --;
            }
            if (t1.r >= 0) {
                push(&q, t1);
            }
        }
        if (t.y > 0) {
            struct T t1 = {t.x,t.y-1,t.r,t.l+1};
            if (grid[t.x][t.y-1]) {
                t1.r --;
            }
            if (t1.r >= 0) {
                push(&q, t1);
            }
        }
        if (t.x < gridSize-1) {
            struct T t1 = {t.x+1,t.y,t.r,t.l+1};
            if (grid[t.x+1][t.y]) {
                t1.r --;
            }
            if (t1.r >= 0) {
                push(&q, t1);
            }
        }
        if (t.y < *gridColSize-1) {
            struct T t1 = {t.x,t.y+1,t.r,t.l+1};
            if (grid[t.x][t.y+1]) {
                t1.r --;
            }
            if (t1.r >= 0) {
                push(&q, t1);
            }
        }
    }
    return ans;
}