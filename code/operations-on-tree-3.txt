class LockingTree {
    vector<int> parent,lock_;
    vector<vector<int>> tree;
    int n;
    
    bool findparent(int i){  //check if any of the parent is locked
        if(i==-1) return 0;
        if(lock_[i]!=-1) return 1;
        return findparent(parent[i]);
    }
    
    bool findchild(int in){  //checks if any of the child node is locked
        if(lock_[in]!=-1) return 1;
        bool st = 0;
        for(int i = 0; i<tree[in].size();++i){
            st=st || findchild(tree[in][i]);
            if(st) break;
        } 
        return st;
    }
    
    void update(int in){  // unlock all the child nodes
        lock_[in] = -1;
        for(int i = 0; i<tree[in].size();++i)  update(tree[in][i]);
    }
public:
    LockingTree(vector<int>& nums) {
        parent  = nums;
        n=nums.size();
        tree = vector<vector<int>>(n);
        lock_ = vector<int>(n,-1);
        for(int i = 0; i<nums.size();++i) 
            if(nums[i]>=0) tree[nums[i]].push_back(i);
    }
    
    bool lock(int num, int user) {
        if(lock_[num]==-1) {lock_[num] = user; return 1;}
        return 0;
    }
    
    bool unlock(int num, int user) {
        if(lock_[num]==user){
            lock_[num]=-1; return 1;
        }
        return 0;
    }
    
    bool upgrade(int num, int user) {
        if(lock_[num]!=-1) return 0;  //check the lock on num
        if(findparent(parent[num])) return 0; //check any locked parent
        if(!findchild(num)) return 0; //check any locked desendent
        update(num);   //unlock all child nodes
        lock_[num]=user;  //lock num by user
        return 1;
    }
};