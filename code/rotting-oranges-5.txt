void calculate(int **m, int **co, int x, int y, int r, int c, int *num){
    int start_r = x, finish_r = x, start_c = y, finish_c = y, res = 0;
    if (x-1 >= 0)
        start_r = x-1;
    if (y-1 >= 0)
        start_c = y-1;
    if (x+1 < r)
        finish_r = x+1;
    if (y+1 < c)
        finish_c = y+1;
    
    if (co[start_r][y] == 1 && start_r != x){
        if (m[start_r][y] == 1)
            (*num)--;
        m[start_r][y] = 2;
    }
    if (co[finish_r][y] == 1 && finish_r != x){
        if (m[finish_r][y] == 1)
            (*num)--;
        m[finish_r][y] = 2;
    }
    if (co[x][start_c] == 1 && start_c != y){
        if (m[x][start_c] == 1)
            (*num)--;
        m[x][start_c] = 2;
    }
    if (co[x][finish_c] == 1 && finish_c != y){
        if (m[x][finish_c] == 1)
            (*num)--;
        m[x][finish_c] = 2;
    }
}

int space(int **m, int r, int c, int *num, int *rotten){
    int res = 0;
    
    for (int i=0; i<r; i++){
        for (int j=0; j<c; j++){
            res = 0;
            if (m[i][j] == 1){
                (*num)++;
                if (i-1 >= 0 && m[i-1][j] != 0)
                    res++;
                if (i+1 < r && m[i+1][j] != 0)
                    res++;
                if (j-1 >= 0 && m[i][j-1] != 0)
                    res++;
                if (j+1 < c && m[i][j+1] != 0)
                    res++;
                if (res == 0)
                    return -1;
            }
            else if (m[i][j] == 2)
                (*rotten)++;
            else
                continue;
        }
    }
    return 1;
}

void transfer(int **source, int **dest, int r, int c){
    for (int i=0; i<r; i++){
        for (int j=0; j<c; j++){
            dest[i][j] = source[i][j];
        }
    }
}

int orangesRotting(int** grid, int gridSize, int* gridColSize){

    //first we check if is possible that an orange is isolated
    int i = 0, j = 0, check, num_or = 0, cycles = 1, rotten = 0, prev = 0;

    check = space(grid, gridSize, gridColSize[0], &num_or, &rotten);
    if (check == -1)
        return -1;
    if (num_or == 0)
        return 0;
    if (rotten == 0)
        return -1;

    int **copy = (int**)malloc(sizeof(int*)*gridSize);
    if (copy == NULL)
        return -1;
    for (i=0; i<gridSize; i++){
        copy[i] = (int*)malloc(sizeof(int)*gridColSize[0]);
        if (copy[i] == NULL)
            return -1;
        for (j=0; j<gridColSize[0]; j++)
            copy[i][j] = 0;
    }
    
    transfer(grid, copy, gridSize, gridColSize[0]);

    while (num_or > 0){
        for (i=0; i<gridSize; i++){
            for (j=0; j<gridColSize[0]; j++){
                if (copy[i][j] == 2)
                    calculate(grid, copy, i, j, gridSize, gridColSize[0], &num_or);
                if (num_or == 0)
                    return cycles;
            }
        }
        if (prev == num_or) //isolated good oranges that wont be changed
            return -1;
        prev = num_or;
        transfer(grid, copy, gridSize, gridColSize[0]);
        cycles++;
    }
    return cycles;
}