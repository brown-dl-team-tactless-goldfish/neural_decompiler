struct slot
{
    int array[16];
    int cur = 0;
    int n = 0;
    int d = 0;
    
    inline bool valid(int v)
    {
        if (cur == 0)
        {
            return true;
        }
        return (array[cur - 1] < v) && (cur < n);
    }

    inline int push(int v)
    {
        int d1 = diff();
        array[cur] = v;
        cur++; 
        int d = diff();
        return d - d1;
    }

    inline int pop(int v)
    {
        int d1 = diff();
        cur--;
        int d = diff();
        return d - d1;
    }

    inline int diff()
    {
        if (cur == 0) return 0;
        return array[cur - 1] - array[0];
    }
    
    inline bool equal(slot& s)
    {
        if (cur != s.cur)
        {
            return false;   
        }
        if (cur == 0) return true;
        if (array[0] != s.array[0]) return false;
        if (array[cur - 1] != s.array[cur - 1]) return false;
        return true;
    }
    
};
class Solution {
public:
    int n;
    vector<slot> slots;
    int res = INT_MAX;
    void visit(vector<int>& nums, int p , int sum)
    {
        if (p == n)
        {        
            res = min(res, sum);
        }
        if (sum >= res)
        {
            return;
        }
        int v = nums[p];
        for (int i = 0; i < slots.size(); i++)
        {
            if (slots[i].valid(v) )
            {
                bool dup = false;
                for (int j = 0; j < i; j++)
                {
                    if (slots[i].equal(slots[j]))
                    {
                        dup = true;
                        break;
                    }
                }
                if (dup)
                {
                    continue;
                }
                sum += slots[i].push(v);
                visit(nums, p + 1, sum);
                sum += slots[i].pop(v);
            }
        }
    }
    int minimumIncompatibility(vector<int>& nums, int k) {
        n = nums.size();
        
        if (k == n) return 0;
        slots.resize(k);
        unordered_map<int, int> m;
        for (auto& v : nums)
        {
            m[v]++;
        }
        for (auto& p : m)
        {
            if (p.second > k)
            {
                return -1;
            }
        }
        
        for (auto& slot : slots)
        {
            slot.n = n / k;
        }
        sort(nums.begin(), nums.end());
        visit(nums, 0, 0);
        return res == INT_MAX ? -1 : res;
    }
};