double* averageOfLevels(struct TreeNode* root, int* returnSize){
    int array_size = 10;
    long long* sum_level_array = (long long*)malloc(array_size * sizeof(long));
    int* num_level_array = (int*)malloc(array_size * sizeof(int));
    int max_depth_visited = 0;
    int current_depth = 1;
    int node_stack_size = 10;
    struct TreeNode** node_stack = (struct TreeNode**)malloc(node_stack_size * sizeof(struct TreeNode*));
    int* node_level_stack = (int*)malloc(node_stack_size * sizeof(int));
    int node_stack_pointer = -1;
    struct TreeNode* current = root;
    while(current){
        // get the value of the current node and the level at which it is
        int current_node_val = current->val;

        // if the current depth-1 is greater than array_size-1, set array_size to 2x array_size and realloc
        // sum_level_array and num_level_array
        if(current_depth-1 > array_size-1){
            array_size *= 2;
            sum_level_array = (long long*)realloc(sum_level_array, array_size * sizeof(long long));
            num_level_array = (int*)realloc(num_level_array, array_size * sizeof(int));
        }

        // add current_node_val to sum_level_array[current_depth-1] and add 1 to num_level_array[current_depth-1] if
        // this level has been visited before, if this level hasn't been visited before, set
        // sum_level_array[current_depth-1] to current_node_val and set num_level_array[current_depth-1] to 1, and
        // also set max_depth_visited to current_depth
        if(current_depth > max_depth_visited){
            sum_level_array[current_depth-1] = current_node_val;
            num_level_array[current_depth-1] = 1;
            max_depth_visited = current_depth;
        }
        else{
            sum_level_array[current_depth-1] += current_node_val;
            num_level_array[current_depth-1] += 1;
        }

        // get the left and the right nodes of the current node
        struct TreeNode* left = current->left;
        struct TreeNode* right = current->right;

        // if a right node is present, add it and its level to the node and depth stacks respectively
        if(right){
            node_stack_pointer++;
            // if the node stack pointer is greater than node_stack_size - 1, set node_stack_size to 2x and realloc
            // bot the stacks
            if(node_stack_pointer > node_stack_size-1){
                node_stack_size *= 2;
                node_stack = (struct TreeNode**)realloc(node_stack, node_stack_size * sizeof(struct TreeNode*));
                node_level_stack = (int*)realloc(node_level_stack, node_stack_size * sizeof(int));
            }
            // add the node and its level to their respective stacks, the level is current_depth + 1
            node_stack[node_stack_pointer] = right;
            node_level_stack[node_stack_pointer] = current_depth+1;
        }
        // if a left node exists, go left and set current_depth to current_depth + 1
        if(left){
            current_depth += 1;
            current = left;
        }
        // if there is no left node, pop a node and its depth from their respective stacks and set current and
        // current_depth to each node and depth popped respectively
        else{
            // if there are no nodes left in the stack, all the elements have been traversed, set current to NULL so
            // that the loop terminates in the next iteration
            if(node_stack_pointer < 0) current = NULL;
            else{
                current = node_stack[node_stack_pointer];
                current_depth = node_level_stack[node_stack_pointer];
                node_stack_pointer--;
            }
        }
    }
    // create an array of doubles and set its size to max_depth as max_depth is the number of levels in the tree and
    // is the number of averages we are to calculate and return
    double* return_array = (double*)malloc(max_depth_visited * sizeof(double));

    // set the values in the return array
    for(int i=0; i<max_depth_visited; ++i){
        return_array[i] = (double)sum_level_array[i]/(double)num_level_array[i];
    }

    // set returnSize to max depth
    *returnSize = max_depth_visited;

    // free temporal data structures
    free(node_stack);
    free(node_level_stack);
    free(sum_level_array);
    free(num_level_array);

    // return return_array
    return return_array;
}