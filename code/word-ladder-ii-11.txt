class Solution {
public:
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
        unordered_set<string_view> st(begin(wordList), end(wordList));
        if (!st.count(endWord)) return ans;
        queue<string_view> q;
        q.push(beginWord);
        dist = {{beginWord, 0}};
        while (!q.empty()) {
            int n = q.size();
            while (n--) {
                auto v = q.front();
                q.pop();
                int x = dist[v] + 1;
                string u = string(v);
                for (int i = 0; i < size(u); i++) {
                    char t = u[i];
                    for (char c = 'a'; c <= 'z'; c++) {
                        u[i] = c;
                        if (dist.count(u)) continue;
                        auto it = st.find(u);
                        if (it != end(st)) {
                            q.push(*it);
                            dist[*it] = x;
                        }
                    }
                    u[i] = t;
                }
            }
        }
        if (dist.count(endWord)) dfs(beginWord, endWord);
        return ans;
    }
private:
    vector<vector<string>> ans;
    unordered_map<string_view, int> dist;
    vector<string_view> path;
    
    void dfs(string& beginWord, string_view s) {
        path.push_back(s);
        if (s == beginWord) {
            vector<string> tmp(size(path));
            transform(rbegin(path), rend(path), begin(tmp), [] (auto t) { return string(t); });
            ans.push_back(move(tmp));
            path.pop_back();
            return;
        }
        int x = dist[s];
        string u = string(s);
        for (int i = 0; i < size(s); i++){
            char t = u[i];
            for (char c = 'a'; c <= 'z'; c++) {
                u[i] = c;
                auto it = dist.find(u);
                if (it != end(dist) && it->second == x - 1)
                    dfs(beginWord, it->first);
            }
            u[i] = t;
        }
        path.pop_back();
    }
};