class DSU{
private:
    vector<int> rank,parent ;
public:
    DSU(int n){
        parent.resize(n) ;
        iota(begin(parent),end(parent),0) ;
        rank.resize(n,1) ;
    }
    
    int find_parent(int node){
        if(node == parent[node]) return node ;
        return parent[node] = find_parent(parent[node]) ;
    }
    
    void Union(int u , int v){
        int U = find_parent(u) , V = find_parent(v) ;
        if(U == V) return ;
        if(rank[U] < rank[V]) swap(U,V) ;
        rank[U] += rank[V] ;
        parent[V] = U ;
    }
    
};

class Solution {
public:
    vector<bool> ans ;
    vector<bool> areConnected(int n, int threshold, vector<vector<int>>& queries) {
        DSU dsu(n + 1) ;
        
		//join all pairs satisfying __gcd(x,y) > threshold
        for(int i = threshold + 1 ; i <= n ; ++i ){
            for(int j = i*2 ; j <= n ; j += i ){
                dsu.Union(i,j) ;
            }
        }
        
        for(auto &x : queries)
            if(dsu.find_parent(x[0]) == dsu.find_parent(x[1])) ans.push_back(true) ;
            else ans.push_back(false) ;
        
        
        return ans ;
    }
};