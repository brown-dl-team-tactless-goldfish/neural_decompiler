class Solution {
public:
    typedef pair<int,int> p;
    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstP) 
    {
        vector<int> ans;
        vector<bool> vis(n, false);  //1st time a person gets to know the secret, visited
        vector<vector<p>> adj(n);    //adjacency list, pairs having meeting and their meeting time
        priority_queue<p, vector<p>, greater<p>> q;    //min heap, sort according to time
        int time, person;
        
        q.push({0,0}), q.push({0, firstP});   //because the know at time 0
        
        for(auto i: meetings)  
        {
            adj[i[0]].push_back({i[2], i[1]}); //person - time of meeting, other person with whom meeting
            adj[i[1]].push_back({i[2], i[0]});
        }
        
        while(!q.empty())   //BFS
        {
            time = q.top().first;
            person = q.top().second;
            q.pop();
            
            if(vis[person])     //the person has already told the secret to his neighbours
                continue;
            
            vis[person] = true;     //else mark visited
            ans.push_back(person);  //visited persons know the secret, jo jo jante ja rhe they will come in answer
            for(auto neigh: adj[person])
                if(vis[neigh.second] == false and neigh.first >= time)  
                    q.push(neigh);
			//if neighbouring person is not visited and has meeting with the current already knowing person after or at the time the current person gets to know the secret then we push it into the queue
        }
        return ans;
    }
};