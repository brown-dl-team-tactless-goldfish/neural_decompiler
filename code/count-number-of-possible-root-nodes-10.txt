class Solution {
public:
    unordered_map<int,int>m;
    unordered_map<int,int>r;
    unordered_map<int,int>g;
    int ans=0;
    void dfs(vector<vector<int>>&adj,int node,int parent){
        
        m[node]=parent;
        
        for(auto x:adj[node]){
            if(x==parent)continue;
            dfs(adj,x,node);
        }
        
    }
    void dfs2(vector<vector<int>>&adj,int node,int parent,int count,int k){
        
      
        int temp=count;
       
            if(g.count(node)&& (g[node]==parent)){     // already counted correct parent-child
                temp--;
            }
            if(r.count(node) && (r[node]==parent)){ 
                 // check if a reverse was present in guesses
                //since when making this node a root
               //all the node on its path will have reverse parent-                                                    //child relation
                temp++;
            }
        
        if(temp>=k)ans++;
        
        for(auto x:adj[node]){
            if(x==parent)continue;
            dfs2(adj,x,node,temp,k);
        }
    }
    
    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guess, int k) {
        int n=edges.size();
        m.clear();
        r.clear();
        g.clear();
        vector<vector<int>>adj(n+1);
        for(auto x:edges){
            adj[x[0]].push_back(x[1]);
            adj[x[1]].push_back(x[0]);
        }
        dfs(adj,0,-1);
        
        int count=0;
        for(int i=0;i<guess.size();i++){
            int u=guess[i][0];
            int v=guess[i][1];
            if(m[v]==u){
                g[v]=u; //correct parent-child edge present in guess
                count++;
            }
            if(m[u]==v){    
                r[u]=v; //incase of reverse parent child we add it in the reverse map
            }
        }

        dfs2(adj,0,-1,count,k);
        return ans;
        
        
    }
};
