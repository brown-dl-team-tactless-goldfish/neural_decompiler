struct Point {
    double x;
    double y;
    Point(double x, double y): x(x), y(y) {}
};
class Solution {
public:
    double distanceSquare(Point* A, Point* B) {
        return (B->x - A->x) * (B->x - A->x) + (B->y - A->y) * (B->y - A->y);
    }
    // Return two intersection points of two circles.
    pair<Point*, Point*> getIntersectionPoints(Point* A, Point* B, double r) {
        double d = sqrt(distanceSquare(A, B));
        if (d <= 2 * r) {
          double ex = (B->x - A->x) / d;
          double ey = (B->y - A->y) / d;
          double x = d / 2;
          double y = sqrt(r * r - x * x);
          Point* P1 = new Point(A->x + x * ex - y * ey, A->y + x * ey + y * ex);
          Point* P2 = new Point(A->x + x * ex + y * ey, A->y + x * ey - y * ex);
          return make_pair(P1, P2);
        }
        // Return two null pointer if no exist
        return make_pair(nullptr, nullptr);
    }
    // Return the number of points that lie in circle with center t
    int countInsidePoints(Point* t, double r, vector<Point*> points) {
        int res = 0;
        for (Point* a: points)
            if (distanceSquare(t, a) <= r * r)
                res++;
        return res;
    }
    int numPoints(vector<vector<int>>& points, int r) {
        int res = 0;
        int n = points.size();
        vector<Point*> lst;
        for (vector<int> t: points) lst.push_back(new Point(t[0], t[1]));
        for (int i = 0; i < n; i++) {
            res = max(res, countInsidePoints(lst[i], r, lst));
            for (int j = i + 1; j < n; j++) {
                auto t = getIntersectionPoints(lst[i], lst[j], r);
                if (t.first != nullptr) {
                    res = max(res, countInsidePoints(t.first, r, lst));
                    res = max(res, countInsidePoints(t.second, r, lst));
                }
            }
        }
        return res;
    }
};