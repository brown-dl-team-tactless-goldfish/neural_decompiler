class Solution {
public:
    int n;
    int dfs(vector<vector<int>> &left,vector<vector<int>> &right,vector<vector<int>> &dp,int k,int in){
        if(in>=n){
            if(k==0) return 0;
            else return INT_MAX;
        }
        if(k==1){
            int t = (in+n-1)/2;
            return dp[in][k] = left[in][t]+right[t][n-1];
        }
        if(dp[in][k]!=-1) return dp[in][k];
        int re = INT_MAX;
        for(int i = in; i<=n-k;++i){ // try partitioning at every index from index in to possible end
            int t = (in+i)/2; // median of range [in,i]
            int p = dfs(left,right,dp,k-1,i+1);
            if(p!=INT_MIN) p+=left[in][t]+right[t][i]; // distances of this ranges is equal to the left sum and right sum from in to t and t to i respectively
            re = min(re,p);
        }
        return dp[in][k] = re;
    }
    int minDistance(vector<int>& nums, int k) {
        if(k==nums.size()) return 0;
        sort(nums.begin(),nums.end()); n = nums.size();
        vector<vector<int>> left(n,vector<int>(n,0)); // stores the sum of distances from every index in range [i,j] to median treating jth element as median 
        vector<vector<int>> right(n,vector<int>(n,0)); // stores the sum of distances from every index in range [i,j] to median treating ith element as median 
        vector<vector<int>> dp(n+1,vector<int>(k+1,-1));
        for(int gap=1;gap<nums.size();++gap){
            for(int i = 0,j=gap;j<nums.size();++i,++j){
                left[i][j] = left[i][j-1]+(j-i)*(nums[j]-nums[j-1]);
                right[i][j] = right[i+1][j] + (j-i)*(nums[i+1]-nums[i]);
            }
        }
        return dfs(left,right,dp, k, 0);
    }
};