class Solution {
public:
    int smallestChair(vector<vector<int>>& times, int targetFriend) {
        unordered_map<int, int> umap;
        unordered_map<int, vector<int>> used;
        int high = 0, n = times.size();
        for (int i = 0; i < n; i++) {
            umap[times[i][0]] = i;
            high = max(high, times[i][1]);
        }
        priority_queue<int, vector<int>, greater<int>> available;
        
        for (int i = 0; i <= high; i++) {
            available.push(i);
        }
        
        for (int t = 0; t <= high; t++) {
            if (used.count(t)) {
                for (int i :used[t]) {
                    available.push(i);
                }
            }
            
            if (umap.count(t) && umap[t] == targetFriend) {
                return available.top();
            }
            if (umap.count(t)) {
                int end = times[umap[t]][1];
                used[end].push_back(available.top());
                available.pop();
            }
        }
        return high;
    }
};