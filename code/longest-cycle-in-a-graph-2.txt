typedef struct _node_trace{
    int sequence_count;
    int total_cycles;
}node_trace;

int longestCycle(int* edges, int edgesSize){
//fist element of the structure array got intialized with memory
node_trace** node_trace_array = calloc(edgesSize,sizeof(node_trace));
bool* node_state_array = calloc(edgesSize,sizeof(bool));
int return_max_sequence = -1;
int num_cycles = 1;
for(int node_ptr =0;node_ptr < edgesSize;node_ptr++){
    //condition to check we have reached end of the linked nodes
    if(edges[node_ptr] == -1 || node_state_array[node_ptr]){continue;}
    int temp_node_ptr = node_ptr;
    int temp_seq_len = -1;
    //we will now trverse through entire sequnce of nodes
    while(temp_node_ptr != -1){
        temp_seq_len++;
        //consider the node has reached for the first time
        if(!node_state_array[temp_node_ptr]){
            node_trace_array[temp_node_ptr] = malloc(sizeof(node_trace_array));
            node_trace_array[temp_node_ptr]->sequence_count = temp_seq_len;
            node_trace_array[temp_node_ptr]->total_cycles = num_cycles;
            node_state_array[temp_node_ptr] =true;
        }
        //if the node pointer has already visted the respective node then
        else{
            //if the pointer reches to respective node in same cycle then note down the 
            //sequnce lenght if its more than the previous value 
            if(node_trace_array[temp_node_ptr]->total_cycles == num_cycles){
                return_max_sequence = fmax(return_max_sequence,temp_seq_len - node_trace_array[temp_node_ptr]->sequence_count);                
            }
            break;
        } 
        temp_node_ptr = edges[temp_node_ptr];
    }
    num_cycles++;
}
//we will free the heap here 
for(int node_ptr =0;node_ptr < edgesSize;node_ptr++){
  if(node_trace_array[node_ptr]){free(node_trace_array[node_ptr]);}
}
free(node_trace_array);
free(node_state_array);
return return_max_sequence;
}