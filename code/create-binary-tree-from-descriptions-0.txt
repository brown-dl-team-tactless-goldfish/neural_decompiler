typedef struct {
    int key;
    struct TreeNode* value;
    UT_hash_handle hh;
} HashMapTree;
typedef struct {
    int key;
    int value;
    UT_hash_handle hh;
} HashMapChild;
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
struct TreeNode* createBinaryTree(int** descriptions, int descriptionsSize, int* descriptionsColSize) {
    struct TreeNode* pRetVal = NULL;

    HashMapTree* pTreeHashTable = NULL;
    HashMapTree *pParent, *pChild;
    HashMapChild* pChildHashTable = NULL;
    HashMapChild* pChildDegree;
    int parent, child, isLeft;
    int i;
    for (i = 0; i < descriptionsSize; ++i) {
        parent = descriptions[i][0];
        child = descriptions[i][1];
        isLeft = descriptions[i][2];

        // parent node
        pParent = NULL;
        HASH_FIND_INT(pTreeHashTable, &parent, pParent);
        if (pParent == NULL) {
            pParent = (HashMapTree*)malloc(sizeof(HashMapTree));
            if (pParent == NULL) {
                perror("malloc");
                return pRetVal;
            }
            pParent->key = parent;
            pParent->value = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            if (pParent->value == NULL) {
                perror("malloc");
                return pRetVal;
            }
            pParent->value->val = parent;
            pParent->value->left = NULL;
            pParent->value->right = NULL;
            HASH_ADD_INT(pTreeHashTable, key, pParent);
        }
        // parent degree
        pChildDegree = NULL;
        HASH_FIND_INT(pChildHashTable, &parent, pChildDegree);
        if (pChildDegree == NULL) {
            pChildDegree = (HashMapChild*)malloc(sizeof(HashMapChild));
            if (pChildDegree == NULL) {
                perror("malloc");
                return pRetVal;
            }
            pChildDegree->key = parent;
            pChildDegree->value = 0;
            HASH_ADD_INT(pChildHashTable, key, pChildDegree);
        }

        // child node
        pChild = NULL;
        HASH_FIND_INT(pTreeHashTable, &child, pChild);
        if (pChild == NULL) {
            pChild = (HashMapTree*)malloc(sizeof(HashMapTree));
            if (pChild == NULL) {
                perror("malloc");
                return pRetVal;
            }
            pChild->key = child;
            pChild->value = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            if (pChild->value == NULL) {
                perror("malloc");
                return pRetVal;
            }
            pChild->value->val = child;
            pChild->value->left = NULL;
            pChild->value->right = NULL;
            HASH_ADD_INT(pTreeHashTable, key, pChild);
        }
        // child degree
        pChildDegree = NULL;
        HASH_FIND_INT(pChildHashTable, &child, pChildDegree);
        if (pChildDegree == NULL) {
            pChildDegree = (HashMapChild*)malloc(sizeof(HashMapChild));
            if (pChildDegree == NULL) {
                perror("malloc");
                return pRetVal;
            }
            pChildDegree->key = child;
            pChildDegree->value = 1;
            HASH_ADD_INT(pChildHashTable, key, pChildDegree);
        } else {
            pChildDegree->value += 1;
        }

        // isLeft
        if (isLeft == 1) {
            pParent->value->left = pChild->value;
        } else {
            pParent->value->right = pChild->value;
        }
    }

    // get root by degree
    parent = 0;
    HashMapChild* pCurrentChild;
    HashMapChild* pTempChild;
    HASH_ITER(hh, pChildHashTable, pCurrentChild, pTempChild) {
        if (pCurrentChild->value == 0) {
            parent = pCurrentChild->key;
        }
        HASH_DEL(pChildHashTable, pCurrentChild);
        free(pCurrentChild);
    }
    // get root node to return value
    HashMapTree* pCurrentParent;
    HashMapTree* pTempParent;
    HASH_ITER(hh, pTreeHashTable, pCurrentParent, pTempParent) {
        if (pCurrentParent->value->val == parent) {
            pRetVal = pCurrentParent->value;
        }
        HASH_DEL(pTreeHashTable, pCurrentParent);
        free(pCurrentParent);
    }

    return pRetVal;
}