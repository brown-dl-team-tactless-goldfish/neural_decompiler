class Node {
public:
    Node* ch[2];
    
    Node() {
        ch[0] = ch[1] = nullptr;
    }
};

Node* insert(Node* node, int value, int i) {
    if(node == nullptr) {
        node = new Node();
    } else {
        node = new Node(*node);
    }
    if(i == -1) return node;
    int nxt = !!(value & (1 << i));
    node->ch[nxt] = insert(node->ch[nxt], value, i - 1);
    return node;
}

int query(Node* node, int value, int i) {
    if(i == -1) return 0;
    int vv = !!(value & (1 << i));
    if(node->ch[!vv]) {
        return (1 << i) + query(node->ch[!vv], value, i - 1);
    } else {
        return query(node->ch[vv], value, i - 1);
    }
}

class Solution {
    int n_;
    vector<vector<int>> T;
    vector<Node*> tries;
    void dfs(int cur, Node* curTrie) {
        tries[cur] = insert(curTrie, cur, 18);
        for(auto y: T[cur]) {
            dfs(y, tries[cur]);
        }
    }
public:
    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {
        n_ = parents.size();
        T.resize(n_);
        tries.resize(n_);
        int root;
        for(int i = 0; i < n_; i++) {
            if(parents[i] == -1) {
                root = i;
            } else {
                T[parents[i]].push_back(i);
            }
        }
        dfs(root, nullptr);
        vector<int> ans;
        for(auto &v: queries) {
            ans.push_back(query(tries[v[0]], v[1], 18));
        }
        return ans;
    }
};