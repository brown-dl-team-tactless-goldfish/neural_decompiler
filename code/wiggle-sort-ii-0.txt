Here we have to make such an arrangement for the array element such that at even position value should be lower than its neighbours and value at odd position should be higher than its neighbours.
Time limit for this solution is time taken by sorting. Here in my case it is O(nlogn). First sort the array in revers order. Then use second half for the elements at even postion i.e. for values having lower value than its neighbour and use first half for the elements at even position.
For example: lets say our array is 4,5,5,6 
Step1: Sort in reverse order : 6, 5, 5, 4
Step2: Copy first half for using it in odd positions. i.e. 6,5
Step3: Select first from 2nd half array and then from copied first half.
             5,6,  5,4

Another example of odd number of elements: 1,5,1,1,6,4,5
After sorting in reverse order: 6,5,5,4,1,1,1
Copy first half array: 6,5,5                Second half array: 4,1,1,1
Take element from second half and then from copied first half array.
4,6,1,5,1,5,1

    void qSort(int *a, int s, int l)
    {
        int i, j, p, t;
        if(s>=l)return;
        p = s;
        i = s;
        j = l;
        while(i<j)
        {
            while(a[i]>=a[p] && i<l)i++;
            while(a[j]<a[p] && j>0)j--;
            if(i<j)
            {
                t = a[i];
                a[i] = a[j];
                a[j] = t;
            }
        }
        t = a[j];
        a[j] = a[p];
        a[p] = t;
        qSort(a, s, j-1);
        qSort(a, j+1, l);
    }
    void wiggleSort(int* a, int nS) {
        int i, j, k, *x, *p, *q;
        qSort(a, 0, nS-1);
    /*
        for(i=0; i<nS; i++)
            printf("%d\t", a[i]);
        printf("\n");
    */
        x = malloc(sizeof(int)*nS/2+10);
        for(i=0, k=nS/2; i<k; i++)
            x[i] = a[i];
        q = x;
        p = a+nS/2;
        for(i=0, j=0, k=nS/2; j<k; j++)
        {
            a[i++] = p[j];
            a[i++] = q[j];
        }
    }