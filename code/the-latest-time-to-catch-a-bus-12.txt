class Solution {
public:
    int latestTimeCatchTheBus(vector<int>& b, vector<int>& pass, int cap) {
        sort(pass.begin(),pass.end()); // sorting passengers 
        sort(b.begin(),b.end()); // sorting buses
        int bus_i = 0; // bus index
        int pass_i = 0; // passenger index
        bool cp = false; // to store last bus leaved with full capacity or not
        // Now we will fill buses till its capacity or till its time
        while(pass_i < pass.size() && bus_i < b.size()){
            // here we can increment bus in 2 case if we reached capacity or we reached its time
            // reached capaity
            int bus = b[bus_i]; // bus i
            int c = cap; // its capacity
            // loop to fill its capaity
            cp = false;
            while(c > 0 and pass_i < pass.size() and pass[pass_i] <= bus){
                c--;
                pass_i++;
            }
            if(c == 0) cp = 1;
            // now bus has to go as if its capaity is full or its passenger is not on time
            bus_i++;
        }
        // if we didn't got chance to fill last bus i.e bus_i < b.size()-1
        if(bus_i < b.size()) return b[b.size()-1];
        // if last bus has leaved without full capacity then
        // here also can be 2 cases that if last passenger was on bus time so we have to traverse basck passenger
        // last bus leaved but not with full capacity
        // pass_i == 0 means no people got chance to sit on bus then
        if(!cp && (pass_i == 0 || (pass[pass_i-1] != b[bus_i-1]))) return b[bus_i-1];
        // or if last bus leaved with full capacity then we have to traverse passengers in reverse order and check time
        // last passenger to sit will be pass_i - 1
        pass_i--;
        int late_time = pass[pass_i];
        while(pass_i >= 0 && late_time <= pass[pass_i]){
            pass_i--;
            late_time--;
        }
        if(pass_i == -1) return pass[0]-1;
        return late_time;
    }
};