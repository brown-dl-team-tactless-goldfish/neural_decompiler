class Solution {
public:
    int totalStrength(vector<int>& strength) {
        
        int size = strength.size();
        
        long long MOD = 1000000007L;
        
        // left to right prefix sum and prefix sum of prefix sum
        vector<long long>rightPrefixSum(size);
        vector<long long>rightPrefixSumPrefixSum(size);
        
        rightPrefixSum[0] = strength[0];
        rightPrefixSumPrefixSum[0] = strength[0];
        
        for(int i=1;i<size;i++)
        {
            rightPrefixSum[i] = rightPrefixSum[i-1] + strength[i];
            rightPrefixSumPrefixSum[i] = rightPrefixSumPrefixSum[i-1] + rightPrefixSum[i];
        }
        
        // right to left prefix sum and prefix sum of prefix sum
        vector<long long>leftPrefixSum(size);
        vector<long long>leftPrefixSumPrefixSum(size);

        leftPrefixSum[size-1] = strength[size-1];
        leftPrefixSumPrefixSum[size-1] = strength[size-1];
        
        for(int i=size-2;i>=0;i--)
        {
            leftPrefixSum[i] = leftPrefixSum[i+1] + strength[i];
            leftPrefixSumPrefixSum[i] = leftPrefixSumPrefixSum[i+1] + leftPrefixSum[i];
        }
        
        
        // monotonic stack to get the right index with value < current value
        stack<int>rstak;        
        
        // store right index for current index till value >= current index value
        vector<int>rightIndexes(size);
        
        for(int i=size-1;i>=0;i--)
        {
            // remove values >= current value
            while(!rstak.empty() && strength[rstak.top()]>=strength[i])rstak.pop();
            
            rightIndexes[i] = rstak.empty() ? size-1 : rstak.top() - 1;
            
            rstak.push(i);
        }
        


        // monotonic stack to get the left index with value < current value
        stack<int>lstak;
        
        // store previous index of current value
        unordered_map<int,int>leftIndexes;
        
        int leftIndex,rightIndex;
        long long rightSum, leftSum,totalSum,leftSize,rightSize;
        
        // sum of all subarray strengths
        long long totalStrength = 0L;
        
        for(int i=0;i<size;i++)
        {
            leftIndex = leftIndexes.find(strength[i])==leftIndexes.end() ? 0 : leftIndexes[strength[i]] + 1;
            
            // remove value >= current value
            while(!lstak.empty() && strength[lstak.top()]>=strength[i])lstak.pop();
            
            // left index => max (left index, previous index of current value)
            leftIndex = max(leftIndex, lstak.empty() ? 0 : lstak.top() + 1);
            rightIndex = rightIndexes[i];
            
            // get left and right subarray size from current index inclusive
            leftSize = i - leftIndex + 1;
            rightSize = rightIndex - i + 1;
            
            lstak.push(i);
            leftIndexes[strength[i]]=i;
            
            // rigth subarrays sum from prefix sum of prefix sum from left to right
            rightSum = rightPrefixSumPrefixSum[rightIndex] - (i>0 ? rightPrefixSumPrefixSum[i-1] + (rightPrefixSum[i-1] * rightSize) : 0L);
            
            // left subarrays sum from prefix sum of prefix sum from right to left
            leftSum = leftPrefixSumPrefixSum[leftIndex] - (i<size-1 ? leftPrefixSumPrefixSum[i+1] + (leftPrefixSum[i+1] * leftSize) : 0L);                
            
            // total subarray sums => left sum * right size + right sum * left size - current value * left size * right size            
            totalSum = ((rightSum%MOD * leftSize) + (leftSum%MOD * rightSize) - ((long long)strength[i] * (leftSize * rightSize)) + MOD)%MOD;
            
            totalStrength = (totalStrength + (totalSum * (long long)strength[i])%MOD ) %MOD;
        }
        
        return totalStrength;
    }
};