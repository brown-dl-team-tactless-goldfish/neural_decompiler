class Solution {
public:
    int tree[400004];
    void update(int node, int l, int r, int idx, int val) {
        if(l>r) return ;
        if(l==r) {
            tree[node]=val;
            return ;
        }
        int mid=(l+r)/2;
        if(idx<=mid) update(2*node, l, mid, idx,val);
        else update(2*node+1, mid+1, r, idx,val);
        tree[node]=max(tree[2*node], tree[2*node+1]);
    }
    int query(int node, int l, int r, int ql, int qr) {
        if(l>r || ql>r || qr<l) return 0;
        if(ql<=l && qr>=r) return tree[node];
        int mid= (l+r)/2;
        int q1 = query(2*node, l, mid, ql, qr);
        int q2= query(2*node+1 , mid+1, r, ql, qr);
        return max(q1,q2);
    }
    int minOperations(vector<int>& target, vector<int>& arr) {
        int n = target.size();
        memset(tree,0,sizeof(tree));
        map<int,int>mp;
        for(int i=0;i<target.size();i++) {
            mp[target[i]]=i;
        }
        int ans=0;
        for(int i=0;i<arr.size();i++) {
            if(mp.find(arr[i])!=mp.end()) {
                int pos = mp[arr[i]];
                int q = query(1, 0, n-1,0,pos-1);
                ans=max(ans,q+1);
                update(1,0,n-1,pos,q+1);
            }
        }
        return n-ans;
    }
};