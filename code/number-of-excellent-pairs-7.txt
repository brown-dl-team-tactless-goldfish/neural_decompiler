class Solution {
public:
    long long countExcellentPairs(vector<int>& nums, int k) {
        std::vector<int> occurrences = CountHammingWeigths(nums);
        std::vector<int> hamming_weights;
        std::vector<int> counts;
        for (int ii = 0; ii < occurrences.size(); ++ii) {
            int c = occurrences[ii];
            if (c != 0) {
                hamming_weights.emplace_back(ii);
                counts.emplace_back(c);
            }
        }   
        std::vector<int> prefix_sum(counts.size());
        std::inclusive_scan(counts.begin(), counts.end(), prefix_sum.begin());
        long long result = 0;
        int jj = 0;
        for (int ii = hamming_weights.size() - 1; ii >= 0; --ii) {
            jj = std::lower_bound(hamming_weights.begin() + jj, hamming_weights.end(),
                                  std::max(0, k - hamming_weights[ii])) - hamming_weights.begin();
            int c1 = counts[ii];
            int c2 = prefix_sum.back() - (jj == 0 ? 0 : prefix_sum[jj - 1]);
            result += c1 * c2;
        }
        return result;
    }
    
    std::vector<int> CountHammingWeigths(const vector<int>& nums) {
        constexpr size_t kMaxNumBit = 64;
        std::unordered_set<int> distinct_nums(nums.begin(), nums.end());
        std::vector<int> weights(distinct_nums.size());
        std::transform(distinct_nums.cbegin(), distinct_nums.cend(), weights.begin(),
                       [kMaxNumBit](uint num){ return std::bitset<kMaxNumBit>(num).count(); });
        std::vector<int> occurrences(kMaxNumBit);
        for (int w : weights) {
            ++occurrences[w];
        }
        return occurrences;
    }
};