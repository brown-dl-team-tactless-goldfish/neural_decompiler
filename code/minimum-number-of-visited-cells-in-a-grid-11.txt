typedef pair<int,int> pp;

class Solution {
public:
    int minimumVisitedCells(vector<vector<int>>& grid){

        // unweighted graph all edges have equal weight so i can use BFS
        int m=grid.size();
        int n=grid[0].size();
        
        vector<set<int>> cnv(m); // column not visited
        vector<set<int>> rnv(n); // rows not visited
        
        for(int i=0;i<m;++i){
            for(int j=0;j<n;++j){
               cnv[i].insert(j);
               rnv[j].insert(i);
            }
        }
        
        vector<vector<bool>> visited(m,vector<bool> (n,false));
        
        pp t;
        int r,c,jump;
        queue<pp> q;
        q.push({0,0});
        visited[0][0]=true;
        int steps=1;
        
        while(!q.empty()){
        
            int s=q.size();
            
            for(int i=0;i<s;++i){

               r=q.front().first;
               c=q.front().second;
               q.pop(); 
               jump=grid[r][c];
             
               if(r==m-1 && c==n-1) return steps;
                 
               vector<int> erased;
                
                for(auto itr=rnv[c].lower_bound(r+1);      // pushing downward
                         itr!=rnv[c].end() && *itr<=min(r+jump,m-1);
                         itr++){
        
                      erased.push_back(*itr);
                      q.push({*itr,c});
                }
                
                for(auto e:erased){
                    rnv[c].erase(e);
                    cnv[e].erase(c);
                }
             
               // for(int k=r+1;k<=min(r+jump,m-1);++k){ // pushing downward
               //     if(!visited[k][c]){
               //         visited[k][c]=true;
               //         q.push({k,c});
               //     }
               // }  
            
               erased.clear();
               for(auto itr=cnv[r].lower_bound(c+1);    // pushing rightward 
                         itr!=cnv[r].end() && *itr<=min(c+jump,n-1);
                         itr++){
        
                      erased.push_back(*itr);
                      q.push({r,*itr});
                }  
            
            for(auto e:erased){
                    cnv[r].erase(e);
                    rnv[e].erase(r);
                }
                 // for(int k=c+1;k<=min(c+jump,n-1);++k){ // pushing rightward
                 //       if(!visited[r][k]){
                 //           visited[r][k]=true;
                 //           q.push({r,k});
                 //       }
                 //   }   
                }
            steps++;
        }
        return -1;    
    }
};