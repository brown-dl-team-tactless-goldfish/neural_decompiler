public class Solution
{
    public int[][] SpiralMatrixIII(int rows, int cols, int rStart, int cStart)
    {
        var rowT = new bool[rows];
        var colT = new bool[cols];

        var output = new int[rows * cols][];

        output[0] = new int[2] { rStart, cStart };
        rowT[rStart] = true;
        colT[cStart] = true;
        var j = 1;

        while (j != rows * cols)
        {

            //move Right
            MoveRight(ref j, ref rows, ref cols, ref rStart, ref cStart, ref colT, ref output, rStart < 0);


            // move down       
            MoveDown(ref j, ref rows, ref cols, ref rStart, ref cStart, ref rowT, ref output, cStart >= cols);


            //move left       
            MoveLeft(ref j, ref rows, ref cols, ref rStart, ref cStart, ref colT, ref output, rStart >= rows);



            //move up
            MoveUp(ref j, ref rows, ref cols, ref rStart, ref cStart, ref rowT, ref output, cStart < 0);


        }


        return output;
    }

    public void MoveRight(ref int j, ref int rows, ref int cols, ref int rStart, ref int cStart,
                          ref bool[] colT, ref int[][] output, bool doNotInsert = false)
    {
        cStart++;
        rStart = doNotInsert ? ++rStart : rStart;
        while (cStart < cols && colT[cStart])
        {
            if (!doNotInsert)
            {
                output[j++] = new int[2] { rStart, cStart };
            }
            cStart++;
        }

        if (cStart < cols)
        {
            output[j++] = new int[2] { rStart, cStart };
            colT[cStart] = true;
        }

    }

    public void MoveLeft(ref int j, ref int rows, ref int cols, ref int rStart, ref int cStart,
                        ref bool[] colT, ref int[][] output, bool doNotInsert = false)
    {
        cStart--;
        rStart = doNotInsert ? --rStart : rStart;
        while (cStart >= 0 && colT[cStart])
        {
            if (!doNotInsert)
            {
                output[j++] = new int[2] { rStart, cStart };
            }
            cStart--;
        }

        if (cStart >= 0)
        {
            output[j++] = new int[2] { rStart, cStart };
            colT[cStart] = true;
        }

    }

    public void MoveDown(ref int j, ref int rows, ref int cols, ref int rStart, ref int cStart,
                         ref bool[] rowT, ref int[][] output, bool doNotInsert = false)
    {
        rStart++;
        cStart = doNotInsert ? --cStart : cStart;
        while (rStart < rows && rowT[rStart])
        {
            if (!doNotInsert)
            {
                output[j++] = new int[2] { rStart, cStart };
            }
            rStart++;
        }
        if (rStart < rows)
        {
            output[j++] = new int[2] { rStart, cStart };
            rowT[rStart] = true;
        }

    }

    public void MoveUp(ref int j, ref int rows, ref int cols, ref int rStart, ref int cStart,
                         ref bool[] rowT, ref int[][] output, bool doNotInsert = false)
    {
        rStart--;
        cStart = doNotInsert ? ++cStart : cStart;
        while (rStart >= 0 && rowT[rStart])
        {
            if (!doNotInsert)
            {
                output[j++] = new int[2] { rStart, cStart };
            }
            rStart--;
        }
        if (rStart >= 0)
        {
            output[j++] = new int[2] { rStart, cStart };
            rowT[rStart] = true;
        }

    }


}