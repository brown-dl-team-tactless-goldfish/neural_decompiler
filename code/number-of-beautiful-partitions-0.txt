class Solution {
public:
  int beautifulPartitions(string s, int k, int minLength) {
    if(!prime(s[0]) || prime(s.back())) return 0;
    init(s, k, minLength);
    int res =  (dp(n, k) + mod - dp(n-1, k)) % mod;
    return res;
  }

  int dp(int i, int k) {
    if (i < 0 || k < 0) return 0;
    auto& res = vdp[i][k];
    if (res > -1) return res;
    res = dp(i - 1, k);
    if (isGood(i)) res += dp(i - minLen, k - 1);
    return res % mod;
  }

  void init(const string &s, int k, int minLength) {
    n = s.size();
    minLen = minLength;
    vdp = vector(n + 1, vector(k + 1, -1LL));
    vdp[0][0] = 1;
    for (auto c : s) isPrime.push_back(prime(c));
  }

  bool prime(char c){
      static const string primes = "2357";
      return primes.find(c) != string::npos;
  }

  bool isGood(int i) { return (i == n || isPrime[i]) && (i==0 || !isPrime[i-1]); }

  const long long mod = 1e9 + 7;
  int n;
  int minLen;
  vector<bool> isPrime;
  vector<vector<long long>> vdp;
};