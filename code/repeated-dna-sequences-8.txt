

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

struct Pair {
    int hash;
    int index;
};

int cmp(const void* a, const void* b) {
    const struct Pair* a1 = a;
    const struct Pair* b1 = b;
    return a1->hash - b1->hash;
}

char ** findRepeatedDnaSequences(char * s, int* returnSize){
    struct Pair A[100005];
    int C[256];
    int l = strlen(s);
    int base=4;
    int base10=262144;
    int i,j,k;
    char** r;
    memset(A, 0, sizeof(l*sizeof(struct Pair)));
    C['A']=0;
    C['C']=1;
    C['G']=2;
    C['T']=3;
    if (l < 10) {
        *returnSize = 0;
        return NULL;
    }
    A[0].index = 0;
    for (i = 0; i < 10; i++) {
        A[0].hash = A[0].hash*base+C[s[i]];
    }
    j = 1;
    for (; i < l; i++) {
        A[j].hash = A[j-1].hash-base10*C[s[i-10]];
        A[j].hash = A[j].hash*base+C[s[i]];
        A[j].index = j;
        j++;
    }
    qsort(A, j, sizeof(struct Pair), cmp);
    int prev = A[0].hash;
    int count = 1;
    r = malloc(l*sizeof(char*));
    k = 0;
    for (i = 1; i < j; i++) {
        if (A[i].hash == A[i-1].hash) {
            count ++;
        } else {
            if (count > 1) {
                r[k] = malloc(11);
                memcpy(r[k], &s[A[i-1].index], 10);
                r[k][10] = 0; k++;
            }
            count = 1;
        }
    }
    if (count > 1) {
        r[k] = malloc(11);
        memcpy(r[k], &s[A[j-1].index], 10);
        r[k][10] = 0; k++;
    }
    
    *returnSize = k;
    return r;
}