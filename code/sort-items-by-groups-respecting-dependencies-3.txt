class Solution {
public:
    vector<int> toposort(vector<int> &indeg, vector<vector<int>> &adj){
        vector<int> res;
        queue<int> q;
        for(int i=0;i<indeg.size();i++) if(indeg[i]==0) q.push(i);
        while(!q.empty()){
            int p = q.front(); q.pop();
            res.push_back(p);
            for(auto c : adj[p]){
                indeg[c]--;
                if(indeg[c]==0) q.push(c);
            }
        }
        return res;
    }
    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems)      {
        int k = group.size();
        int id = m;
        unordered_map<int,vector<int>> mp; //mapping of group id and elements.
        for(int i=0;i<k;i++){
            //Assigning dummy group ids to those with group[i] = -1;
            if(group[i]==-1) group[i]=id++;
            mp[group[i]].push_back(i);
        }
        m = id;
        vector<vector<int>>grp_adj(m);
        vector<vector<int>> adj(n);
        vector<int> grp_indeg(m,0);
        vector<int> indeg(n,0);
        for(int i =0;i<k;i++){
            auto temp = beforeItems[i];
            if(temp.size()==0) continue;
            for(auto x : temp) {
                adj[x].push_back(i);
                indeg[i]++;
                if(group[x]!=group[i])
                {
                    //edge between groups is made when they are not same. 
                    grp_adj[group[x]].push_back(group[i]);
                    grp_indeg[group[i]]++;
                }
            }
        }
        auto topo_grp = toposort(grp_indeg, grp_adj); //toposort on groups
        if(topo_grp.size()!=m) return {};
        vector<int> res; //stores final ordering asper question 
        for(int i =0;i<m;i++){
            //toposort on elements inside group with id topo_grp[i].
            id = topo_grp[i];
            vector<int>temp;
            queue<int> q;
            for(auto u : mp[id]){
                if(indeg[u]==0) q.push(u);
            }
            while(!q.empty()){
                auto p =q.front();
                q.pop();
                temp.push_back(p);
                for(auto c: adj[p]){
                    if(group[c]!=id) {
                        //Reducing the indegree of those vertices which belongs to different groups.
                        indeg[c]--;
                        continue;
                    }
                    indeg[c]--;
                    if(indeg[c]==0) q.push(c);
                }
            }
            if(temp.size()!=mp[id].size()) return {};
            res.insert(res.end(),temp.begin(),temp.end()); //final results.
        }
        return res;
    }
};