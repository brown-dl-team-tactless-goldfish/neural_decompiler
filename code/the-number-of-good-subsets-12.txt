class Solution {
public:
    int cal_mask(int x){
        int ret = 0;
        if(!(x%2)) ret = ret|(1<<9);
        if(!(x%3)) ret = ret|(1<<8);
        if(!(x%5)) ret = ret|(1<<7);
        if(!(x%7)) ret = ret|(1<<6);
        if(!(x%11)) ret = ret|(1<<5);
        if(!(x%13)) ret = ret|(1<<4);
        if(!(x%17)) ret = ret|(1<<3);
        if(!(x%19)) ret = ret|(1<<2);
        if(!(x%23)) ret = ret|(1<<1);
        if(!(x%29)) ret = ret|(1<<0);
        return ret;
    }
    
    int numberOfGoodSubsets(vector<int>& nums) {
        int M = 1000000007;
        vector<long> count(31,0);
        int n = nums.size();
        vector<bool> mask(31,true);
        mask[4] = false;
        mask[8] = false;
        mask[9] = false;
        mask[12] = false;
        mask[16] = false;
        mask[18] = false;
        mask[20] = false;
        mask[24] = false;
        mask[25] = false;
        mask[27] = false;
        mask[28] = false;
        for(int i=0; i<n; i++) count[nums[i]]+= 1;
        vector<int> uniq;
        for(int i=2; i<=30; i++) if(mask[i] && count[i]) uniq.push_back(i);
        // we will consider 1 later
        n = uniq.size();
        unordered_map<int,long> dp;
        dp[0] = 1;
        int m = 1<<11;
        unordered_map<int,long>::iterator it;
        vector<long> ans(n,0);
        for(int i=0; i<n; i++){
            int cur_mask = cal_mask(uniq[i]);
            for(int j=0; j<m; j++){
                it = dp.find(j);
                if(it==dp.end()) continue;
                int new_mask = cur_mask&(j);
                if(new_mask) continue;
                new_mask = cur_mask|(j);
                dp[new_mask]+= dp[j]*count[uniq[i]];
                dp[new_mask]%= M;
                ans[i]+= dp[j]*count[uniq[i]];
                ans[i]%= M;
            }
        }
        long ret = 0;
        for(int i=0; i<n; i++){
            ret+= ans[i];
            ret%= M;
        }
        // now let's consider duplication of 1
        for(int i=0; i<count[1]; i++){
            ret = ret<<1;
            ret%= M;
        }
        return ret;
    }
};