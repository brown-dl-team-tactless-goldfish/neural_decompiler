class Solution {
    #define ll long long int
    const ll mod = 1e9 + 7;
    
    ll dp[1004][1004][2];
    
    // to check prime digit
    bool isPrime(char c) {
        return (c == '2' || c == '3' || c == '5' || c == '7');
    }
    
    ll solve(string &s, int i, int flag, int k, int minLength) {
        // if i is last index and k == 0 then the condition is fullfilled so return 1.
        if(i == s.size()) {
            return (k == 0);
        }
        
        // if i is out of index or no partion to left to do then the condition will not be fullfill return 0.
        if(i >= s.size() || k <= 0) return 0;
        
        // to chech dp array.
        ll &ans = dp[i][k][flag];
        if(ans != -1) return ans;
        
        
        ans = 0;
        
        // if the minlength condition is fullfilled then,
        if(flag) {
            // if current index if non prime then it can be last index of any valid substring, so here we can partion the string and flag become 0, because the condition of minlength (0 at this time) become false.
            if(!isPrime(s[i])) ans += solve(s, i + 1, 0, k - 1, minLength) % mod;
            
            // we also have another option to proceed further without partioning.
            ans += solve(s, i + 1, flag, k, minLength) % mod;
        } 
        
        // if the flag is false means we are at first char of one substring.
        else {
            // if first char is non prime we will not proceed further.
            if(!isPrime(s[i])) return 0;
            
            // if it is prime we can go directly to the size of minlength by (i + m - 1) and flag become active.
            ans += solve(s, i + minLength - 1, 1, k, minLength) % mod;
        }
        
        // to prevent the overflow.
        ans %= mod;
        return ans;
    }
public:
    int beautifulPartitions(string s, int k, int minLength) {
        memset(dp, -1, sizeof(dp));
        return solve(s, 0, 0, k, minLength);
    }
};