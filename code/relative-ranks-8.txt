

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
#define MAX_STR_SIZE 15

int cmpfunc(const void *a, const void *b)
{
    const int *p = *(const int **)a;
    const int *q = *(const int **)b;
    
    return q[1] - p[1];
}

void free_hash(int **arr, int sz)
{
    for (int i = 0; i < sz; i++)
        free(arr[i]);
    
    free(arr);
}

void getstr(char *str, int idx)
{
    switch (idx) {
    case 0:
        strcpy(str, "Gold Medal");
        break;
    case 1:
        strcpy(str, "Silver Medal");
        break;
    case 2:
        strcpy(str, "Bronze Medal");
        break;
    default:
        sprintf(str, "%d", idx + 1);
        break;
    }
}

char ** findRelativeRanks(int* score, int scoreSize, int* returnSize)
{
    int **hash = (int **)calloc(scoreSize, sizeof(int *)); //2-d array to store the scores and the corresponding index
    char **result = (char **)calloc(scoreSize, sizeof(char *));
    *returnSize = scoreSize;
    
    for (int i = 0; i < scoreSize; i++) {
        int *buff = (int *)calloc(2, sizeof(int));
        buff[0] = i; // 1st element idx
        buff[1] = score[i]; // 2nd element score
        
        hash[i] = buff;
        
        char *str = (char *)calloc(MAX_STR_SIZE, sizeof(char));
        result[i] = str;
    }
    
    qsort(hash, scoreSize, sizeof(hash[0]), cmpfunc); // sort the 2d array based on the score in decreasing order
    
    for (int i = 0; i < scoreSize; i++)
        getstr(result[hash[i][0]], i); //put the result to the respective index based on the sorted score array
    
    free_hash(hash, scoreSize);
    
    return result;
}