class Solution {
      constexpr static int SIZE = 8;
    
   struct hasher {
        size_t operator() (const pair<int,int>& coords)const {
            return coords.first*8 + coords.second;
        }
    };
public:
       vector<vector<int>> queensAttacktheKing( vector<vector<int>>& queens, const vector<int>& king) const{
      unordered_set<pair<int,int>, hasher> queenZ;
        for ( auto&& coords: queens) {
            queenZ.insert( {coords[0], coords[1]});
        }
 
         vector<vector<int>> res;
        constexpr array<int,8> col = {-1,1,0,0, 1,-1,1,-1};
       constexpr  array<int,8> row = {0, 0,-1,1,1,-1,-1,1};
        
        for (auto idx = 0; idx < col.size(); ++idx) {
            
            auto x =  check(col[idx], row[idx], queenZ, king);
            if (!x.empty())
                res.push_back(move(x));
        }
        
        return res;
    }
  
     vector<int> check(const int cd,const  int rd, const unordered_set<pair<int,int>, hasher>  &queenZ , const vector<int>& king) const{
         auto r = king[0];
         auto c = king[1];
         
         while (0 <= r && r < SIZE &&  0 <= c && c < SIZE) {
             if (queenZ.count({r, c}))
                 return {r,c};
             r += rd;
             c += cd;
                 
                 
         }
         
        return {};
    }
};