class Solution {
public:
    int minimumSize(vector<int>& nums, int maxOperations) {
        /*
        the maximal possible result is max(nums) -> no operatios
        the minimal possible result is 1 -> endless split
        binary search condition:
            if N can be achieved, any number > N can be achieved
            if N-1 can not be achieved, any number < N-1 cannot be achieved? -> proved
        -> search the right N that N can be, while N-1 cannot be achieved.
        */
        int min = 1, max = getMax(nums);
        int cur;
        while (min < max) {
            cur = min + (max - min) / 2;
            if (canAchieve(nums, cur, maxOperations)) {
                max = cur;
            }
            else {
                min = cur+1;
            }
        }
        return max;
    }
    
private:
    int getMax(const vector<int>& nums) {
        int max = nums[0];
        for (int i = 1; i < nums.size(); i++) {
            max = std::max(max, nums[i]);
        }
        return max;
    }
    
    bool canAchieve(const vector<int>& nums, int cur, int maxOp) {
        int ops = 0;
        for (auto n : nums) {
            if (n <= cur) continue;
            ops += (n-1) / cur;
            if (ops > maxOp) return false;
        }
        return true;
    }
};