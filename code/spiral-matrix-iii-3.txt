/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *columnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** spiralMatrixIII(int R, int C, int r0, int c0, int** columnSizes, int* returnSize) {
    *returnSize=R*C;
    int **ret=(int**)malloc((*returnSize)*sizeof(int*));
    int count=0;
    columnSizes[0]=(int*)malloc((*returnSize)*sizeof(int));
    for(int i=0;i<*returnSize;i++){
        columnSizes[0][i]=2;
        ret[i]=(int*)calloc(2,sizeof(int));
    }
    int **map=(int**)malloc(R*sizeof(int*));
    for(int i=0;i<R;i++){
        map[i]=(int*)calloc(C,sizeof(int));
    }
    int direction[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
    int dir_count=0;
    
    ret[count][0]=r0;
    ret[count][1]=c0;
    count++;
    map[r0][c0]=1;
    while(count<*returnSize){
        if(r0+direction[dir_count][0]>=0
           &&r0+direction[dir_count][0]<R
           &&c0+direction[dir_count][1]>=0
           &&c0+direction[dir_count][1]<C){
            if(map[r0+direction[dir_count][0]][c0+direction[dir_count][1]]!=1){
                r0=r0+direction[dir_count][0];
                c0=c0+direction[dir_count][1];
                ret[count][0]=r0;
                ret[count][1]=c0;
                count++;
                map[r0][c0]=1;
                dir_count=(dir_count+1)%4;
            }else{
                dir_count--;
                if(dir_count<0){
                    dir_count=3;
                }
            }
        }else{
            r0=r0+direction[dir_count][0];
            c0=c0+direction[dir_count][1];
            dir_count=(dir_count+1)%4;
        }
    }
    return ret;
}