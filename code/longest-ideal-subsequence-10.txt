class SegmentTree {
private:
    vector<int> st;

public:
    SegmentTree(int size) {
        st.resize(4 * size, 0);
    }
    
    int query(int idx, int s, int e, int qs, int qe) {
        if(qs <= s && e <= qe) return st[idx];
        if(qs > e || qe < s) return 0;
        
        int mid = (s + e) >> 1;
        return max(query(idx * 2, s, mid, qs, qe), query(idx * 2 + 1, mid + 1, e, qs, qe));
    }
    
    int update(int idx, int s, int e, int at, int val) {
        if(s == at && e == at) return st[idx] = val;
        
        int mid = (s + e) >> 1;
        
        if(at <= mid) return st[idx] = max(st[idx], update(idx * 2, s, mid, at, val));
        return st[idx] = max(st[idx], update(idx * 2 + 1, mid + 1, e, at, val));
    }
};

class Solution {
public:
    int longestIdealString(string s, int k) {
        int res = 0;
        SegmentTree st(27);
        
        for(char c: s) {
            int val = st.query(1, 1, 26, c - 96 - k, c - 96 + k);
            st.update(1, 1, 26, c - 96, val + 1);
            res = max(res, val + 1);
        }
        
        return res;
    }
};