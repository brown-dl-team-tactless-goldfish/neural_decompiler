/**
 * Method: if the in-order and pre-order traversals of subtree t forms a substring of	 
 * in-order and pre-order traversals of tree s, then, s will be a subtree of tree t
 * We need to store both traversals in the auxiliary arrays to check if s forms 	 
 * substring	 
 */

#define ROOT_RANGE  4000
#define SUBTREE_RANGE   3000

void inOrder(struct TreeNode *t, int *s, int *idx) {
    if (!t) { 
        s[(*idx)++] = 100000;           // required for external nodes
        return;                         // else test [1,2,3] [1,2] will fail
    }
    
    inOrder(t->left, s, idx);
    s[(*idx)++] = t->val;
    inOrder(t->right, s, idx);
}

void preOrder(struct TreeNode *t, int *s, int *idx) {
    if (!t) {
        s[(*idx)++] = 100000;    
        return;
    }

    s[(*idx)++] = t->val;
    preOrder(t->left, s, idx);
    preOrder(t->right, s, idx);
}

// this is a simple O(n^2) function to check the substring
// we can use KMP algorithm to get O(m+n) time 
bool ispresent(int *s, int sCnt, int *t, int tCnt) {
    int i, j, k;
    
    for(i = 0; i < sCnt; i++) {
        for(j = i, k = 0; k < tCnt && s[j] == t[k]; j++, k++)
            if(k >= 0 && k == tCnt - 1)
                return true;
    }
        
    return false; 
}

bool isSubtree(struct TreeNode* s, struct TreeNode* t){			// s is the tree and t is the subtree
    if (!t) return true;
    if (!s) return false;
    
    // auxiliary array used to store the pre-order and in-order traversals
    // storing integer values as chars. Will be easy to use strstr lib function
    int rootOrder[SUBTREE_RANGE] = {0};
    int subrootOrder[ROOT_RANGE] = {0};
    int sIdx = 0, tIdx = 0;
    
    // in-order traversals of both trees
    inOrder(s, rootOrder, &sIdx);
    inOrder(t, subrootOrder, &tIdx);
    
    if (!ispresent(rootOrder, sIdx, subrootOrder, tIdx)) 
        return false;
    
    // pre-order traversals of both trees
    sIdx = 0; tIdx = 0;
    preOrder(s, rootOrder, &sIdx);
    preOrder(t, subrootOrder, &tIdx);
       
    return ispresent(rootOrder, sIdx, subrootOrder, tIdx);
}