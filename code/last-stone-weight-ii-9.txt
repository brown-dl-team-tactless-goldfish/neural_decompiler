class Solution {
public:
    
    // Initialize the S_Differnce with INT_MAX
    int S_Difference = INT_MAX;
    
    unordered_map<long long, int> m;
    
    int lastStoneWeightII(vector<int>& stones) {
        /* Consider two no.s a and b
            With 2 numbers, we can have only the following combinations -- (2 factorial = 2)
            1. (a) - (b)
            2. (b) - (a)
            
            With 3 numbers [a, b, c], we can have the following combinations --
            1. a - (b - c) = (a + c) - (b)
            2. a - (c - b) = (a + b) - (c)
            3. b - (a - c) = (b + c) - (a)
            4. b - (c - a) = (b + a) - (c)
            5. c - (a - b) = (c + b) - (a)
            6. c - (b - a) = (c + a) - (b)
            
            => 3! = 6 combinations above 
            
            Further down the line, whenever we'll have one more character, we'll have 
            4! combinations = 24 since we can change the positions of numbers in above negative
            signed expressions.
            
            The gist of this is that whenever we'll add more numbers, we'll have two sets and
            the answer will be equivalent to subtraction of sums of those two sets
            
            S1 - S2 = S_Difference
            
            Hence, the original problem reduces to minimizing S_Difference
            
            But,                S1 + S2 = Sum_Array
                        =>      S_Difference = Sum_Array - 2 * S2
                                S_Difference = 2 * S1 - Sum_Array
                                
            So, we need to find a subset sum which minimizes S_Difference and return that as the 
            answer.
            
            Now, in each subset sum, we have two choices, either include the ith element or 
            we don't.
        */
        int Sum_Array = accumulate(stones.begin(), stones.end(), 0);
        
        return helper(0, 0, Sum_Array, stones);
    }
    
    int helper(int i, int currSum, int Sum_Array, vector<int> &stones) {
        int n = stones.size();
        if (i == n) {
            return S_Difference = min(S_Difference, abs(Sum_Array - 2 * currSum));
        }
        
        long long enc = getEncoded(i, currSum);
        if (m.find(enc) != m.end())
            return m[enc];
        
        // Pick the current one
        int pick = helper(i + 1, currSum + stones[i], Sum_Array, stones);
        
        // Don't pick the current stone
        int dontPick = helper(i + 1, currSum, Sum_Array, stones);
        
        return m[enc] = min(pick, dontPick);
    }
    
    long long getEncoded(int x, int y) {
        return (static_cast<long long>(x) << 32) ^ y;
    }
};