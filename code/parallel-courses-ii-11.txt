public int MinNumberOfSemesters(int n, int[][] dependencies, int k)
{
	// Dependent course for i, set bit are courses that depends on i
	int[] dependency = new int[n];
	foreach (var course in dependencies)
	{
		dependency[course[1] - 1] |= 1 << (course[0] - 1);
	}

	// PreRequisite course for i, set bit are courses that i depends on
	int allMask = (1 << n) - 1;
	int[] preRequisite = new int[allMask + 1];

	for (int i = 0; i <= allMask; i++)
	{
		for (int j = 0; j < n; j++)
		{
			if ((i & (1 << j)) != 0)
			{
				preRequisite[i] |= dependency[j];
			}
		}
	}

	int[] d = new int[allMask + 1];
	for (int i = 1; i <= allMask; i++)
	{
		d[i] = n + 10; // some max value
	}

	// 0 courses are required to non-existent zero course
	d[0] = 0;
	for (int i = 1; i <= allMask; i++)
	{
		// Iterate over all submask of i
		// https://cp-algorithms.com/algebra/all-submasks.html

		for (int lastSemester = i; lastSemester != 0; lastSemester = (lastSemester - 1) & i)
		{
			int count = countSetBit(lastSemester);
			if (count > k)
			{                        
				continue;
			}

			// Courses taken other than i
			int alreadyTaken = i ^ allMask;

			// Courses taken satisfy preRequisite of lastSemester
			if ((alreadyTaken & preRequisite[lastSemester]) == preRequisite[lastSemester])
			{			    
				d[i] = Math.Min(d[i], d[i ^ lastSemester] + 1);
			}                    
		}
	}

	return d[allMask];
}

private int countSetBit(int value)
{
	int count = 0;
	while (value != 0)
	{
		count++;
		value &= value - 1;
	}
	return count;
}
