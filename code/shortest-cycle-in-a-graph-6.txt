class Solution {
public:
    vector<int>* adj;
    int findShortestCycle(int n, vector<vector<int>>& edges) {
        //BFS
        //calculate for each vertex
        //O(N2)

        adj=new vector<int>[n];
        for(auto it: edges) {
            adj[it[0]].push_back(it[1]);
            adj[it[1]].push_back(it[0]);
        }

        int cycle=1e9;

        for(int i=0;i<n;i++) {
            queue<pair<int,int>> q; //current and parent
            vector<int> distance(n,-1);
            q.push(make_pair(i,-1));
            distance[i]=0;

            while(!q.empty()) {
                pair<int,int> pi=q.front(); q.pop();
                for(auto it: adj[pi.first]) {
                    if(distance[it]==-1) { //not visited yet
                        distance[it]=distance[pi.first]+1;
                        q.push(make_pair(it,pi.first));
                    }
                    else if(pi.second != it) cycle=min(cycle, distance[pi.first]+distance[it]+1);
                }
            }
        }

        return cycle==1e9 ? -1 : cycle;
    }
};