#define WHITE (0)
#define GRAY  (1)
#define BLACK (2)

class Solution {
public:
    int maximumDetonation(vector<vector<int>> &bombs) {
        int numBombs = bombs.size();
        vector<vector<int>> graph(numBombs); // adj. list
        for (int i = 0; i < numBombs; ++i) {
            for (int j = 0; j < numBombs; ++j) {
                if (i == j) {
                    // i and j indicate the same bomb.
                    continue;
                }

                unsigned long x1 = bombs[i][0], y1 = bombs[i][1], r1 = bombs[i][2];
                unsigned long x2 = bombs[j][0], y2 = bombs[j][1], r2 = bombs[j][2];
                unsigned long dist = getDistance(x1, y1, x2, y2);
                if (r1 * r1 >= dist) {
                    graph[i].push_back(j);
                }
                if (r2 * r2 >= dist) {
                    graph[j].push_back(i);
                }
            }
        }

        // Use DFS to find the component with most nodes.
        int maxBombs = 0;
        for (int i = 0; i < numBombs; ++i) {
            vector<int> state(numBombs, WHITE);
            maxBombs = max(maxBombs, dfs(graph, state, i));
        }

        return maxBombs;
    }

private:
    unsigned long getDistance(unsigned long x1, unsigned long y1, unsigned long x2, unsigned long y2) {
        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
    }

    // dfs returns the number of nodes in a component.
    int dfs(vector<vector<int>> &graph, vector<int> &state, int currBomb) {
        state[currBomb] = GRAY;

        int numBombs = 1;
        for (auto &nextBomb : graph[currBomb]) {
            if (state[nextBomb] != WHITE) {
                continue;
            }
            numBombs += dfs(graph, state, nextBomb);
        }
        state[currBomb] = BLACK;

        return numBombs;
    }
};