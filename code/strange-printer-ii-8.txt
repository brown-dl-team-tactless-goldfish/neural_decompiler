class Solution {
public:
	struct Color {
		int xmin, ymin, xmax, ymax, visited;
		Color () {
			xmin = 100; ymin = 100; xmax = -1; ymax = -1;
			visited = false;
		}
		void push(int i, int j) {
			xmin = min(i, xmin);
			ymin = min(j, ymin);
			xmax = max(i, xmax);
			ymax = max(j, ymax);
		}
		void change(vector<vector<int>>& grid) {
			for(int i = xmin; i <= xmax; i++) 
				for(int j = ymin; j <= ymax; j++) 
					grid[i][j] = 100;
			visited = true;
		}
	};
	bool isPrintable(vector<vector<int>>& targetGrid) {
		int m = targetGrid.size(), n = targetGrid[0].size();
		vector<Color> color(70);
		unordered_set<int> colorInGrid;
		for(int i = 0; i < m; i++) 
			for(int j = 0; j < n; j++) 
			   color[targetGrid[i][j]].push(i, j), colorInGrid.insert(targetGrid[i][j]);       

		bool ok = true;
		while(ok) {
			ok = false;
			for(auto& c : colorInGrid) {
				if(color[c].visited) continue;
				bool findRec = true;
				for(int i = color[c].xmin; i <= color[c].xmax && !findRec ; i++) 
					for(int j = color[c].ymin; j <= color[c].ymax && !findRec ; j++) 
						if(targetGrid[i][j] != 100 && targetGrid[i][j] != c) findRec  = true;
				if(findRec == true) {
					ok = true;
					color[c].change(targetGrid);
				}    
			}
		}
		for(int i = 0; i < m; i++) 
			for(int j = 0; j < n; j++) 
				if(targetGrid[i][j] != 100) return false;
		return true;
	}
};