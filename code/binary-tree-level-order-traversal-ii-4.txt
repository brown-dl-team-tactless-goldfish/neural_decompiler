/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
 
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */

int arr[1000][1000];
int mx;
int col[1000];
int max(int a, int b)
{
    if(a < b) return b;
    return a;
}
void go(struct TreeNode* root, int level)
{
    if(root == NULL) return;
    
    arr[level][col[level]++] = root->val;
    go(root->left, level + 1);
    go(root->right, level + 1);
    mx = max(mx, level + 1);
}
int** levelOrderBottom(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
    for(int i = 0; i < 1000; i++) col[i] = 0;
    mx = 0;
    go(root, 0);
    int cnt = 0;
    /*
        Ans for storing the answer of the level by level traversal
    */
    int **ans = (int **) malloc(sizeof(int *) * mx);
    /*
        returnColumnSizes is an 1d array and the function is bringing the address of the 1d array 
        by double pointer (**).
        so allocate memory of the array using malloc.
        mx is the maximum depth of a tree.
    */
    *returnColumnSizes = (int *) malloc(sizeof(int) * mx);
    for(int i = mx - 1; i >= 0; i--)
    {
        if(col[i] == 0) continue;
        else
        {
            ans[cnt] = (int *)malloc(sizeof(int) * col[i]);
            /*
                so dereferencing the returnColumnSizes array using *returnColumnSizes
                so i get the first address of the array.
                now i have to put the 0th, 1th, 2nd ... value in the array.
                basically it is the size of answer array column 
                **Node: It is crucial to do (*returnColumnSizes) this.
                    first we have to dereference the first pointer then move the array position.
            */
            (*returnColumnSizes)[cnt] = col[i];
            for(int j = 0; j < col[i]; j++)
            {
                ans[cnt][j] = arr[i][j];
            }
            cnt++;
        }
    }
    *returnSize = cnt;
    return ans;
}