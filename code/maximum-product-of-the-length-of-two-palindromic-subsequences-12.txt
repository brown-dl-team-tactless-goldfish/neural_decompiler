class Solution {
public:
    bool isPalindrome(string &a) {
        int i = 0, j = a.length()-1;
        while(i <= j) {
            if(a[i++] != a[j--]) return false;
        }
        return true;
    }
    
    void solve(string &s, int i, int n, string &a, string &b, int &res) {
        if(isPalindrome(a) && isPalindrome(b)) { // both subsequences are palindrome
            res = max(res, (int)a.length()*(int)b.length()); // take maximum of product of their length
        }
        if(i >= n) return ; // base case
        
        // case I: if we don't choose to add the current char to any of the subsequences
        solve(s, i+1, n, a, b, res);
        
        // case II: if we choose to add the current char to a
        a += s[i];
        solve(s, i+1, n, a, b, res);
        a.pop_back(); // backtrack
        
        // case III: if we choose to add the current char to b
        b += s[i];
        solve(s, i+1, n, a, b, res); 
        b.pop_back(); // backtrack
    }
    
    int maxProduct(string s) {
        int n = s.length();
        string a = "", b = "";
        int res = 1;
        solve(s, 0, n, a, b, res);
        return res;
    }
};