class Solution {
public:
    unordered_map<int,int> color,vis;
    vector<int> topogroup,res;
    unordered_map<int,int> item_to_group;
    unordered_map<int,unordered_set<int>> mp;
    unordered_map<int,unordered_map<int,unordered_set<int>>> items;
    void dfs(int u, int parent){
        vis[u]=1;
        for(auto v:mp[u]){
            if(!vis.count(v) && v!=parent){
                dfs(v,u);
            }
        }
        topogroup.push_back(u);
    }
    void dfs1(int u, int gr, int parent){
        vis[u]=1;
        for(auto v:items[gr][u]){
            if(!vis.count(v) && v!=parent){
                dfs1(v,gr, u);
            }
        }
        res.push_back(u);
    }
    bool acyclic1(int u, int gr, int parent){
        color[u]=1;
        vis[u]=1;
        for(auto v:items[gr][u]){
            if(color[v]==1){
                return true;
            }
            if(!vis.count(v) && v!=parent){
                if(acyclic1(v,gr, u)) return true;
            }
        }
        color[u]=2;
        return false;
    }
    bool acyclic(int u,int parent){
        color[u]=1;
        vis[u]=1;
        for(auto v:mp[u]){
            if(color[v]==1){
                return true;
            }
            if(!vis.count(v) && v!=parent && acyclic(v,u)){
                return true;
            }
        }
        color[u]=2;
        return false;
    }
    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {
        //1. Topological sort on groups
        //2. Topological sort within groups
        vector<int> fl(m+1,0);
        for(int i=0;i<n;i++){
            item_to_group[i]=group[i];
            items[group[i]][i]={};
            mp[group[i]]={};
            if(group[i]==-1) fl[m]=1;
            else fl[group[i]]=1;
        }
        for(int i=0;i<n;i++){
            if(beforeItems[i].size()!=0){
                for(int j=0;j<beforeItems[i].size();j++){
                    int group1=item_to_group[i];
                    int group2=item_to_group[beforeItems[i][j]];
                    if(group1!=group2){
                        mp[group2].insert(group1);
                    }
                    else{
                        items[group1][beforeItems[i][j]].insert(i);
                        
                    }
                }
            }
        }
        //also check in each that it's not making a cycle
        if(acyclic(-1,-100)){
                return {};
        }
        for(int i=0;i<m;i++){
            if(!vis.count(i) && acyclic(i,-100)){
                return {};
            }
        }
        vis.clear();
        if(fl[m]==1 && mp[-1].size()>0)
            dfs(-1,-100);
        for(int i=0;i<m;i++){
            if(!vis.count(i) && fl[i] && mp[i].size()>0){
                dfs(i,-100);
            }
            else if(!vis.count(i) && fl[i] && mp[i].size()==0){
                vis[i]=1;
                topogroup.push_back(i);
            }
        }
        reverse(topogroup.begin(),topogroup.end());
        if(!vis.count(-1) && fl[m]){
                topogroup.push_back(-1);
        }
        vis.clear();
        vector<int>result;
        color.clear();
        for(auto gr:topogroup){
            for(auto j:items[gr]){
                if(!vis.count(j.first) && acyclic1(j.first,gr,-100)){
                    return result;
                }
            }
        }
        vis.clear();
        for(auto gr:topogroup){
            res.clear();
            for(auto i:items[gr]){
                if(!vis.count(i.first) && items[gr].count(i.first)){
                    dfs1(i.first,gr,-100);
                }
            }
             (reverse(res.begin(),res.end()));
             for(auto k:res) result.push_back(k);
        }
        return result;
    }
};