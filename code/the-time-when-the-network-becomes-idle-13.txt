public:
    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {
        int n = patience.size();
        vector<int> dist(n, 0);
        vector<int> edgeList[n];
        vector<int> visited(n, false);
        for (auto edge: edges) {
            edgeList[edge[0]].push_back(edge[1]);
            edgeList[edge[1]].push_back(edge[0]);
        }
        queue<int> q;
        q.push(0);
        q.push(-1);
        int curDist = 0;
        while (!q.empty()) {
            int cur = q.front();
            q.pop();
            if (cur == -1) {
                if (!q.empty()) {
                    curDist++;
                    q.push(-1);
                    continue;
                }
                break;
            }
            if (visited[cur]) continue;
            visited[cur] = true;
            dist[cur] = curDist;
            for (int neighbour : edgeList[cur]) {
                    q.push(neighbour);
            }
        }
        int max = INT_MIN;
        for (int i = 1; i < n; i++) {
            int tat = 2 * dist[i];
            int pat = patience[i];
            int totalTime =0;
            if (tat < pat) totalTime = tat;
            else {
                totalTime = (tat % pat == 0) ? (tat/pat - 1)*pat + tat : (tat/pat)*pat + tat;
            }
            max = (totalTime > max ) ? totalTime : max;
        }
        return max + 1;
    }
};