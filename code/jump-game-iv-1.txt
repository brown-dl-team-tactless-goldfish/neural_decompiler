struct values_hash {
  int key;
  int* indexes;
  int size;
  UT_hash_handle hh;
};

struct queue {
  int* data;
  int read;
  int write;
  int cap;
};

static
void add_index(struct values_hash** table, int value, int idx) {
  struct values_hash* entry;
  HASH_FIND_INT(*table, &value, entry);
  if (!entry) {
    /* First hashtable entry for this value */
    entry = calloc(1, sizeof(*entry));
    entry->key = value;
    HASH_ADD_INT(*table, key, entry);
  }

  /* Rather than keep a capacity value, assume we need to grow is size is a power of 2 */
  if (!(entry->size & (entry->size - 1))) {
    int cap = (entry->size) ? entry->size * 2 : 1;
    entry->indexes = realloc(entry->indexes, cap * sizeof(entry->indexes));
  }

  entry->indexes[entry->size++] = idx;
}

static
void queue_init(struct queue* obj) {
  memset(obj, 0, sizeof(*obj));
}

static
int queue_size(const struct queue* obj) {
  return obj->write - obj->read;
}

static
void queue_push(struct queue* obj, int value) {
  if (queue_size(obj) == obj->cap) { /* Queue at capacity */
    int old_cap = obj->cap;
    int offset = (obj->cap) ? (obj->read % obj->cap) : 0;
    obj->cap = (obj->cap) ? obj->cap * 2 : 8;
    obj->data = realloc(obj->data, obj->cap * sizeof(*obj->data));
    /* 
    Using a ring buffer means that some values could have been written to the
    front of the buffer than need to be appending to the buffer now as it will
    not wrap at the previous capacity.
    */
    memcpy(&obj->data[old_cap], &obj->data[0], offset * sizeof(*obj->data));
    obj->read = offset;
    obj->write = offset + old_cap;
  }

  obj->data[obj->write++ % obj->cap] = value;
}

static
int queue_pop(struct queue* obj) {
  return obj->data[obj->read++ % obj->cap];
}

static
void queue_uninit(struct queue* obj) {
  free(obj->data);
}

int minJumps(int* arr, int arrSize) {
  int* const dp = malloc(arrSize * sizeof(*dp));
  for (int i = 1; i < arrSize; ++i) {
    dp[i] = -1;
  }
  struct values_hash* index_by_value = NULL;

  add_index(&index_by_value, arr[0], 0);
  for (int i = 1; i < arrSize; ++i) {
    /* There is no point recording the index if the index is in the middle of duplicate entries */
    if (i + 1 == arrSize || arr[i - 1] != arr[i] || arr[i + 1] != arr[i]) {
      add_index(&index_by_value, arr[i], i);
    }
  }

  /* Queue the starting index */
  struct queue q;
  queue_init(&q);
  queue_push(&q, 0);
  dp[0] = 0;

  for (;;) {
    int curr = queue_pop(&q);
    if (curr == arrSize - 1) {
      break;
    }

    int depth = dp[curr];
    int value = arr[curr];

    /* Queue up any index that can be reached by having the same value */
    struct values_hash* entry;
    HASH_FIND_INT(index_by_value, &value, entry);
    for (int i = 0; i < entry->size; ++i) {
      int idx = entry->indexes[i];
      if (0 > dp[idx]) {
        dp[entry->indexes[i]] = depth + 1;
        queue_push(&q, entry->indexes[i]);
      }
    }
    entry->size = 0;  /* No point queue up by the same value twice */

    /* Queue up previous value */
    if (curr && 0 > dp[curr - 1]) {
      dp[curr - 1] = depth + 1;
      queue_push(&q, curr - 1);
    }
    /* Queue up following value */
    if (0 > dp[curr + 1]) {
      dp[curr + 1] = depth + 1;
      queue_push(&q, curr + 1);
    }
  }

  /* Save result and return the memory to the system */
  int ret = dp[arrSize - 1];
  free(dp);
  struct values_hash* tmp;
  struct values_hash* to_del;
  HASH_ITER(hh, index_by_value, to_del, tmp) {
    HASH_DEL(index_by_value, to_del);
    free(to_del->indexes);
    free(to_del);
  }
  queue_uninit(&q);

  return ret;
}