class Solution {
public:
    int findMinimumTime(vector<vector<int>>& tasks) {
        
        //Step 1: Sort it in inc. end time order, if matches, then inc. start time
        sort(tasks.begin(),tasks.end(),[](vector<int>a,vector<int>b)
        { return (a[1]!=b[1]) ? a[1]<b[1] : a[0]<b[0];});

        unordered_set<int> st; // will store the seconds on which the computer was on

        //Step 2: For Each task do the Greedy Approach
        for(auto task :tasks){
            int alreadyDone = 0;
            // check how much already done while overlapping with previous
            for(int i=task[0];i<=task[1];i++) if(st.find(i)!=st.end()) alreadyDone++;

            // now lets do the left work as late as possible so as to maximize overlapping
            for(int i=task[1];alreadyDone<task[2];i--){
                if(st.find(i)==st.end()){
                    st.insert(i);
                    alreadyDone++;
                }
            } 
        }

        return st.size();
    }
};