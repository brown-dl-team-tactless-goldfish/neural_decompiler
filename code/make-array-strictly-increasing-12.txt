class Solution {
public:
   // for memoization we use map with previous element ,current index
    map<pair<int,int>,int> mp;
    int rec(int i,int prev,vector<int>& arr1,vector<int>& arr2){
        // base condition 
        if(i>=arr1.size()) return 0;
        if(mp[{prev,i}]!=0) return mp[{prev,i}];
        // condition 1:-
        /*
            if previous element is greater than current element of arr1 ,the we check if there exist any element in arr2 greater than prev element  using binary search*/
        if(prev>=arr1[i]){
            auto c=lower_bound(arr2.begin(),arr2.end(),prev+1);
            // if not exist then return some big value let say 10000000;
            if(c==arr2.end()) return 1e7;
            int k=*c;
            return mp[{prev,i}]=1+rec(i+1,k,arr1,arr2);
        }
       // condition 2:-
        /*Now we have two choices 
         first- prev=arr1[i] (consider current element as prev element and i->i+1*/ 
        int ans=rec(i+1,arr1[i],arr1,arr2);
       /*second- find element just bigger then prev in arr2*/
        auto c=lower_bound(arr2.begin(),arr2.end(),prev+1);
        if(c!=arr2.end()){
            int k=*c;
            ans=min(ans,1+rec(i+1,k,arr1,arr2));
        }
        return mp[{prev,i}]=ans;
    }
    int makeArrayIncreasing(vector<int>& arr1, vector<int>& arr2) {

        sort(arr2.begin(),arr2.end());
        int c=rec(0,-1,arr1,arr2);
       return c>=1e7?-1:c;   
    } 
};