class Solution {
public:

	// Memoize results since the same query is asked repeatedly
	vector<vector<int>> mem;  	
	
	// Check to see if u and v already speak a common language
    bool check(vector<vector<int>>& a, int u, int v) {
        if(mem[u][v] != 0) return mem[u][v] == 1;
        for(int i=0; i<a[v].size(); i++) {
            if(find(a[u].begin(), a[u].end(), a[v][i]) != a[u].end()) {
                mem[v][u] = mem[u][v] = 1;
                return true;
            }
        }
        mem[u][v] = mem[v][u] = -1;
        return false;
    }
	
    int minimumTeachings(int n, vector<vector<int>>& languages, vector<vector<int>>& friendships) {
        int m = languages.size(), ret = m, i;
        mem.assign(m + 1, vector<int>(m + 1, 0));
		
        for(i=0; i<m; i++)
            sort(languages[i].begin(), languages[i].end()); 		// May not be necessary, just a precaution
			
        for(int lang=1; lang<=n; lang++) {
            int count = 0;
            vector<bool> teach(m, false);
            for(i=0; i<friendships.size(); i++) {
                int u = friendships[i][0] - 1;
                int v = friendships[i][1] - 1;
                if(check(languages, u, v)) 
                    continue;
                if(find(languages[u].begin(), languages[u].end(), lang) == languages[u].end()) {
                    if(!teach[u])
                        count++;
                    teach[u] = true;
                }
                if(find(languages[v].begin(), languages[v].end(), lang) == languages[v].end()) {
                    if(!teach[v])
                        count++;
                    teach[v] = true;
                }
            }
            ret = min(ret, count);
        }
        return ret;
    }
};