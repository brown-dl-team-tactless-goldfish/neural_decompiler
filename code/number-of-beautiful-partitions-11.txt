class Solution 
{
public:
    int beautifulPartitions(string s, int k, int m) 
    {
        int primes[10] = {0,0,1,1,0,1,0,1,0,0};                   // fast detection of primes
        int n = s.size(), mod = 1000000007;
        
        int dp[1001][1001];                                       // 2D cache for recursive DP 
        fill_n(&dp[0][0], 1001*1001, -1);                         // filled with -1 for 'not seen'
        
        function<int(int,int)> dfs;                               // this recursive function computes
        dfs = [&](int i, int k) -> int                            // the number of beautiful partitions 
        {                                                         // of 's' starting from position 'i'
            if (dp[i][k] != -1) return dp[i][k];                  // using memoization/cache dp[i][k]
            
            if (k == 1)                                           // [1] for last partition, return 1 if there
                return dp[i][k] = n >= m + i;                     //     is at least m terminal digits, else 0
            
            if (i + m * k > n)                                    // [2] the number of remaining digits is not
                return dp[i][k] = 0;                              //     enough to cover k partitions of size m
            
            int res = 0;                                          // [3] scan valid initial positions 'j' of the next
            for (int j = i+m; j <= n-m*(k-1); ++j)                //     partition and recursively update state;
                if (!primes[s[j-1]-'0'] and primes[s[j]-'0'])     //     there is no point to consider the full range
                    res = (res + dfs(j, k-1)) % mod;              //     for j (same as in [2], but 1 partition less)
            
            return dp[i][k] = res;
        };
        
        if (!primes[s[0]-'0'] or primes[s[n-1]-'0'])             // consider trivial cases when either
            return 0;                                            // initial or terminal digit is invalid
        
        return dfs(0,k);
    }
};