// Let dp[i][j] be the number of playlists of length i that have exactly j unique songs. We want dp[L][N], and it seems likely we can develop a recurrence for dp.

// Algorithm

// Consider dp[i][j]. Last song, we either played a song for the first time or we didn't. If we did, then we had dp[i-1][j-1] * (N-j) ways to choose it. If we didn't, then we repeated a previous song in dp[i-1][j] * max(j-K, 0) ways (j of them, except the last K ones played are banned.)

class Solution {
public:
    long long int dp[101][101];// ith song using j unique songs 
    long long int mod = 1000000007;
    
    int numMusicPlaylists(int N, int L, int K) {
        
        dp[0][0] =1;
        for(int i=1;i<=L;i++) {
            for(int j=1;j<=N;j++) {
                dp[i][j] = dp[i-1][j-1] * (N-j+1); // we are using a new song hense till i-1 , j-1 songs used and there are N-j+1 ways to                                                    // chose jth song
                
                dp[i][j] += dp[i-1][j] * max(j-K,0); // if we have used J songs , only those songs used k songs back can be used , ie j-k                                                      //songs
                dp[i][j] %= mod;
            }
        }
        return dp[L][N];
    }
};