
// Frequency count LUTs
int lut1[26];
int lut2[26];

// Variables to hold sum of characters of strings
int sum1;
int sum2;

// Compare frequency count
bool compare (void)
{
    for (char i = 0; i < 26; i++)
    {
        if (lut1[i] != lut2[i])
        {
            return 0;
        }
    }
    return 1;
}

bool checkInclusion(char * s1, char * s2)
{
    /*

    Algo:

    1. Generate a lut (lut1[]) for s1 which contains the count of each character.
       Additionally also maintain a sum total of numerical value of 
       all characters (say sum1).
    2. Repeat the same for s2 string over a window length equal to length
       of s1 : lut2[] and sum2.
    3. If sum1 == sum2 then compare 26 values in lut1 and lut2. If they match,
       return TRUE.
    4. Slide the window of length len1, right by one character on s2.
    5. Go to step 2 if sliding window has not reached end of s2.
    6. Return FALSE.
    */

    int len1 = strlen(s1);
    int len2 = strlen(s2);
    char c = 0;

    if (len2 < len1)
        return 0;

    sum1 = sum2 = 0;
    memset (lut1, 0, sizeof(int) * 26);
    memset (lut2, 0, sizeof(int) * 26);

    // Window size is len1
    for (int i = 0; i < len1; i++)
    {
        c = s1[i] - 'a';
        sum1 += c;
        lut1[c]++;
    }

    // Window size is STILL len1
    for (int i = 0; i < len1; i++)
    {
        c = s2[i] - 'a';
        sum2 += c;
        lut2[c]++;
    }

    for (int i = 0; i < (len2 - len1 + 1); i++)
    {
        // Compare frequency count ONLY if sums are equal.
        if (sum1 == sum2)
        {
            if (compare ())
                return 1;
        }

        // Last minute panic break :-D
        if (i + len1 >= len2)
            break;

        // Sliding window logic:
        // Leave the earliest character behind.
        c = s2[i] - 'a';
        sum2 -= c;
        lut2[c]--;

        // Add the next character.
        c = s2[i+len1] - 'a';
        sum2 += c;
        lut2[c]++;
    }

    // Alas, no match!
    return 0;
}