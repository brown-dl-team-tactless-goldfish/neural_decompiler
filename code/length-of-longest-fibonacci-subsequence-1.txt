#define SIZE 1000    
struct HashArray
{
    int key;
    int count;
    struct HashArray* next;
}Hash[SIZE];       
void addHash(int num)     
{
    int temp=abs(num%SIZE);     
    if(Hash[temp].key==0)
    {
        Hash[temp].key=num;
        Hash[temp].count++;
    }else if(Hash[temp].key==num)
    {
        Hash[temp].count++;     
    }else
    {
        struct HashArray *p=&Hash[temp]; 
        while(p->key!=num&&p->next!=NULL)    
        {p=p->next;}
        if(p->key==num)
        {p->count++;}
        else
        {
            p->next=(struct HashArray*)malloc(sizeof(struct HashArray));
            p=p->next;
            p->key=num;
            p->count=1;
            p->next=NULL;
        }
    }   
}
int findHash(int num){
    int temp=abs(num%SIZE);     
    if(Hash[temp].key==0||Hash[temp].count==0)
    {
        return 0;
    }else if(Hash[temp].key==num)
    {
        return 1;
    }else
    {
        struct HashArray *p=&Hash[temp]; 
        while(p->key!=num&&p->next!=NULL)    
        {p=p->next;}
        if(p->key==num)
        {return 1;}
        else
        {return 0;}
    } 
}
int lenLongestFibSubseq(int* A, int ASize) {
    for(int i=0;i<SIZE;i++){
        Hash[i].key=0;
        Hash[i].count=0;
        Hash[i].next=NULL;
    }
    int ret=0;
    for(int i=0;i<ASize;i++){
        addHash(A[i]);
    }
    for(int i=0;i<ASize-2;i++){
       for(int j=i+1;j<ASize-1;j++){
           int temp1=A[i];
           int temp2=A[j];
           int count=2;
           while(findHash(temp1+temp2)){
               int temp=temp1+temp2;
               temp1=temp2;
               temp2=temp;
               count++;
           }
           if(count>ret){
               ret=count;
           }
       } 
    }
    return ret>2?ret:0;
}