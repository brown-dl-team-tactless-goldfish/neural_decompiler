	void bfs(string& beginWord, string& endWord, unordered_set<string>& d, unordered_map<string, vector<string>>& neighbors, unordered_map<string, int>& dist){
        queue<string> q;
        q.push(beginWord);
        dist[beginWord] = 0;
        int lvl = 1;
        while(!q.empty()){
            int q_size = q.size();
            unordered_set<string> visited;
            for(int i = 0; i < q_size; i++){
                auto curr = q.front();
                q.pop();
                string nxt = curr;
                for(int j = 0; j < nxt.size(); j++){
                    auto tmp = nxt[j];
                    for(char c = 'a'; c <= 'z'; c++){
                        nxt[j] = c;
                        if(d.count(nxt) != 0){
                            neighbors[curr].push_back(nxt);
                            visited.insert(nxt);
                            if(dist.count(nxt) == 0){
                                dist[nxt] = lvl;
                                q.push(nxt);
                            }
                        }
                    }
                    nxt[j] = tmp;
                }
            }
            lvl++;
            for(string w: visited) d.erase(w);
        }
    }
    
    void dfs(string& curr, string& endWord, unordered_map<string, vector<string>>& neighbors, unordered_map<string, int>& dist, vector<string>& path, vector<vector<string>>& res){
        path.push_back(curr);
        if(curr == endWord){
            res.push_back(path);
            return;
        }
        for(auto nxt: neighbors[curr]){
            if(dist[nxt] == dist[curr] + 1){
                dfs(nxt, endWord, neighbors, dist, path, res);
                path.pop_back();
            }
        }
    }
    
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
        vector<vector<string>> res;
        unordered_set<string> d(wordList.begin(), wordList.end());
        if(d.count(endWord) == 0) return res;
        unordered_map<string, vector<string>> neighbors;
        unordered_map<string, int> dist;
        bfs(beginWord, endWord, d, neighbors, dist);
        vector<string> path;
        dfs(beginWord, endWord, neighbors, dist, path, res);
        return res;
    }