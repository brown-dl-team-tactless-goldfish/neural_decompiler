int cmpfunc(const void* a, const void* b){
    return *(int*)a - *(int*)b;
}

long long minimalKSum(int* nums, int numsSize, int k){
    qsort(nums, numsSize, sizeof(int), cmpfunc);
    
    int cn = k;
    long long ans = 0;
    if((nums[0] -1) <= k){
        ans += (long long)(1 + nums[0] - 1) *(nums[0] - 1)/ 2;
        cn -= (nums[0] - 1) ;
    }
    else{
        ans += (long long)(1 + k) *( k )/ 2;
        return ans;
    }
    printf("ans = %d ", ans);
    for(int i = 1; i < numsSize; i++){
        int item = nums[i] - nums[i-1] - 1 ;
        if(item <= 0)
            continue;
        if(item <= cn){
            cn -= item;
            int up = nums[i-1] + 1;
            int down = nums[i] - 1;
            ans += (long long)(up + down)*(down - up + 1) / 2;
        }
        else{            
            int up = nums[i-1] + 1;
            int down = up + cn -1;
            ans += (long long)(up + down)*(down - up + 1) / 2;
            cn = 0;    
        }
        if(cn == 0)
            return ans;
    }
    int up = nums[numsSize-1] + 1;
    int down = up + cn -1;
    ans += (long long)(up + down)*(down - up + 1) / 2;
    return ans;
}