typedef struct AdjList{
    int* node;//children of current node
    int* nodeDir;//the direction each child faces
    int nodeSize;//keep track of size for dynamic enlargement
    int nodeCount;//need node count to check if nodeSize needs to be boosted
}AdjList;

AdjList* initAdjList(int size){
    AdjList* adjList = malloc(size * sizeof(AdjList));
    for(int i = 0; i < size; i++){
        adjList[i].node = malloc(2 * sizeof(int));
        adjList[i].nodeDir = malloc(2 * sizeof(int));
        adjList[i].nodeSize = 2;
        adjList[i].nodeCount = 0;
    }
    return adjList;
}

void upSize(AdjList* adjList, int index){
    int newSize = adjList[index].nodeSize * 2;
    adjList[index].node = realloc(adjList[index].node, newSize * sizeof(int));
    adjList[index].nodeDir = realloc(adjList[index].nodeDir, newSize * sizeof(int));
    adjList[index].nodeSize = newSize;    
}

void addEdge(AdjList* adjList, int source, int destination, int direction){
    adjList[source].node[adjList[source].nodeCount] = destination;
    adjList[source].nodeDir[adjList[source].nodeCount++] = direction;
}

void freeAdjList(AdjList* adjList, int size){
    for(int i = 0; i < size; i++){
        free(adjList[i].nodeDir);
        free(adjList[i].node);
    }
    free(adjList);
}

void dfs(AdjList* adjList, int parent, int curr, int* redirects){
    //check all of current node's children
    for(int i = 0; i < adjList[curr].nodeCount; i++){
        int child = adjList[curr].node[i];
        int direction = adjList[curr].nodeDir[i];
        if(parent != child){//make sure we're not going back towards root (0)
            *redirects += direction;//add direction (either 0 or 1)
            dfs(adjList, curr, child, redirects);
        }
    }
}

int minReorder(int n, int** connections, int connectionsSize, int* connectionsColSize){
    int redirects = 0;
    AdjList* adjList = initAdjList(n);
    //populate adjacency list
    for(int i = 0; i < connectionsSize; i++){
        int city1 = connections[i][0];
        int city2 = connections[i][1];
        //make the children array for city1 larger if needed
        if(adjList[city1].nodeCount == adjList[city1].nodeSize)
            upSize(adjList, city1);
        addEdge(adjList, city1, city2, 1);//set edge, mark direction as 1
        //make the children array for city2 larger if needed
        if(adjList[city2].nodeCount == adjList[city2].nodeSize)
            upSize(adjList, city2);          
        addEdge(adjList, city2, city1, 0);//set edge, mark direction as 0
    }
    dfs(adjList, -1, 0, &redirects);
    freeAdjList(adjList, n);
    return redirects;
}