#include <stdlib.h>
#include <string.h>
#include <assert.h>
//#include "DisjointSetUnion.h"
#ifndef DisjointSetUnion_H
#define DisjointSetUnion_H

#include <stdbool.h>

struct DisjointSetUnion;
typedef struct DisjointSetUnion DisjointSetUnion;

DisjointSetUnion * DisjointSetUnion_create(const int nodeAmount);
void DisjointSetUnion_destroy(DisjointSetUnion * const pThis);

bool DisjointSetUnion_union(DisjointSetUnion * const pThis, const int node1, const int node2);
bool DisjointSetUnion_find(const DisjointSetUnion * const pThis, const int node1, const int node2);

#endif /*DisjointSetUnion_H*/

struct DisjointSetUnion{
	int * parents;
	int parentsLen;
};

static inline bool DisjointSetUnion_isNodeValid(DisjointSetUnion * const pThis, const int node);
static int DisjointSetUnion_findRoot(DisjointSetUnion * const pThis, const int node);

DisjointSetUnion * DisjointSetUnion_create(const int nodeAmount){
	DisjointSetUnion * pDisjointSetUnion = (DisjointSetUnion *)malloc( sizeof (DisjointSetUnion) );
	if (NULL == pDisjointSetUnion){
		goto EXCEPTION;
	}

	pDisjointSetUnion->parentsLen = nodeAmount;
	pDisjointSetUnion->parents = (int *)malloc(sizeof (int) * pDisjointSetUnion->parentsLen);
	if (NULL == pDisjointSetUnion->parents){
		goto EXCEPTION_OBJ_MALLOCED;
	}
	memset(pDisjointSetUnion->parents, 0xFF, sizeof (int) * pDisjointSetUnion->parentsLen);

	return pDisjointSetUnion;

	assert(0);
EXCEPTION_OBJ_MALLOCED:
	free(pDisjointSetUnion);
	pDisjointSetUnion = NULL;
EXCEPTION:
	return NULL;
}

void DisjointSetUnion_destroy(DisjointSetUnion * const pThis){
	free(pThis->parents);
	pThis->parents = NULL;
	free(pThis);
}

bool DisjointSetUnion_union(DisjointSetUnion * const pThis, const int node1, const int node2){
	const int node1Root = DisjointSetUnion_findRoot(pThis, node1),
		node2Root = DisjointSetUnion_findRoot(pThis, node2);

	if (-1 == node1Root || -1 == node2Root){
		return false;
	}

	if (node1Root != node2Root){
		(pThis->parents)[node2Root] = node1Root;
	}

	return true;
}

bool DisjointSetUnion_find(const DisjointSetUnion * const pThis, const int node1, const int node2){
	const int node1Root = DisjointSetUnion_findRoot(pThis, node1),
		node2Root = DisjointSetUnion_findRoot(pThis, node2);

	if (-1 == node1Root || -1 == node2Root){
		return false;
	}

	return (node1Root == node2Root);
}

static inline bool DisjointSetUnion_isNodeValid(DisjointSetUnion * const pThis, const int node){
	if (!( node >= 0 && node < pThis->parentsLen )){
		return false;
	}

	return true;
}

static int DisjointSetUnion_findRoot(DisjointSetUnion * const pThis, const int node){
	if ( !DisjointSetUnion_isNodeValid(pThis, node) ){
		return -1;
	}

	int root = node;
	while ( (pThis->parents)[root] != -1 ){
		root = (pThis->parents)[root];
	}

	return root;
}

//--------------------------------

bool validPath(int n, int** edges, int edgesSize, int* edgesColSize, int source, int destination){
	DisjointSetUnion * pDisjointSetUnion = DisjointSetUnion_create(n);
	if (NULL == pDisjointSetUnion){
		abort();
	}

	for (int i = 0; i < edgesSize; i += 1){
		const bool unionSuccessful = 
			DisjointSetUnion_union(pDisjointSetUnion, edges[i][0], edges[i][1]);
		assert(unionSuccessful);
	}

	const bool findResult = DisjointSetUnion_find(pDisjointSetUnion, source, destination);

	DisjointSetUnion_destroy(pDisjointSetUnion);
	pDisjointSetUnion = NULL;

	return findResult;
}