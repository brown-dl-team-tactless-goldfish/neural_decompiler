class Solution {
public:
	//root by path compression
    int root(int x, int* parent){
        if(x == parent[x]) return x;
        parent[x] = root(parent[x], parent);
        return parent[x];
    }
    //normal union , you can use rank union
    void unionn(int i, int j, int* parent){
        parent[root(i, parent)] = root(j, parent);
    }
    
    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {
        int parent[n];
        //check if any root dosn't come back or any loop
        for(int i = 0; i < n; i++)
            parent[i] = i;
        for(int i = 0; i < n; i++){
            if(leftChild[i] != -1){
                if(root(i, parent) != root(leftChild[i], parent))
                    unionn(i, leftChild[i], parent);
                else return false;
            }
            if(rightChild[i] != -1){
                if(root(i, parent) != root(rightChild[i], parent))
                    unionn(i, rightChild[i], parent);
                else return false;
            }
        }
        //if there are 2 or more root, i.e check if only 1 root exist
        int count = 0;
        for(int i = 0; i < n; i++){
            if(i == parent[i])
                count++;
        }
        return count == 1;
    }
};