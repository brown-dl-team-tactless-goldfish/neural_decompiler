class Solution {
    struct tree{
        int *t;
        int c;
        int n;
        tree(int ni) 
        {
            c = 1;
            while(c<ni)
                c<<=1;
            c<<=1;
            t = new int[c];
            memset(t, 0, sizeof(int) * c);
            n = ni;
        }
        
        void update(int ti, int ni, int til, int tih)
        {
            if (tih == til)
                t[ni]++;
            else
            {
                int tim = (til+tih)>>1;
                if (ti <= tim)
                    update(ti, ni*2+1, til, tim);
                else
                    update(ti, ni*2+2, tim+1, tih);
                t[ni] = t[ni*2+1] + t[ni*2+2];
            }
        }
        
        int query(int ti, int ni, int til, int tih)
        {
            if (tih == ti)
                return t[ni];
            int tim = (til+tih)>>1;
            int ans = query(min(ti, tim), ni*2+1, til, tim);
            if (ti >= tim + 1)
                ans += query(ti, ni*2+2, tim+1, tih);
            return ans;
        }
        
        int query(int ti)
        {
            return query(ti, 0, 0, n-1);
        }
        
        void update(int ti)
        {
            update(ti,  0,  0,  n-1);
        }
   };
public:
    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size();
        vector<int> indexnum2(n,0);
        for(int i=0; i<n; i++)
            indexnum2[nums2[i]] = i;
        tree t(n);
        t.update(indexnum2[nums1[0]]);
        long long ans = 0;
        for(int i=1; i<n-1; i++)
        {
            long long leftc = t.query(indexnum2[nums1[i]]);
			//don't run another segment tree
            int rightc =  n -1 - (indexnum2[nums1[i]]) - (i - leftc);
            ans += leftc * rightc;
            t.update(indexnum2[nums1[i]]);
        }
        return ans;
    }
};