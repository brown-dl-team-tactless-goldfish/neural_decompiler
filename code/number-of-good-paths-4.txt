vector <int> f;
int find(int x) {
    if (f[x] != x)
        f[x] = find(f[x]);
    return f[x];
}
void unify(int x, int y) {
    x = find(x);
    y = find(y);
    f[x] = y;
}
int numberOfGoodPaths(vector<int>& a, vector<vector<int>>& ee) {
    int n = a.size();
    f.resize(n);
    iota(f.begin(), f.end(), 0);
    vector <vector <int>> edges(n);
    for (auto &z : ee) {
        int x = z[0], y = z[1];
        if (a[x] >= a[y]) // only useful if we can go from x -> y
            edges[x].push_back(y);
        if (a[y] >= a[x]) // or y -> x
            edges[y].push_back(x);
    }
    map <int, vector <int>> m;
    for (int i = 0; i < n; i++)
        m[a[i]].push_back(i);
    int ret = 0;
    unordered_map <int, int> cnt;
    for (auto &[key, arr] : m) {
        for (int &i : arr) 
            for (int &j : edges[i]) 
                unify(i, j);
        for (int &i : arr) 
            cnt[find(i)]++;
        for (auto &[key, nn] : cnt) 
            ret += nn * (nn + 1) / 2;
        cnt.clear();
    }
    return ret;
}