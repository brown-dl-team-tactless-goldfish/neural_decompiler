class Solution {
public:
    int minStickers(vector<string>& stickers, string target) {
        for (auto c : target)
        {
            d_target[c]++;
        }
        
        for (const auto & sticker : stickers)
        {
            for (auto c : sticker)
            {
                d_total[c]++;
                d_hashes[sticker][c]++;
            }
        }
        
        for (const auto & elem : d_target)
        {
            if (d_total.find(elem.first) == d_total.cend())
            {
                return -1;
            }
        }
        
        d_result = numeric_limits<int>::max(); 
        int path  = 0;
        explore(path);
        return d_result;
    }
    
    
private:
    void explore(int path)
    {
        if (path >= d_result)
        {
            return;
        }
        
        if (d_target.empty())
        {
            d_result = min(d_result, path);
            return;
        }
        
        auto it = *d_target.begin();
        for (const auto & hash :d_hashes)
        {
            if (hash.second.find(it.first) == hash.second.cend())
            {
                continue;
            }
            
            auto temp = d_target;
            for (const auto & p : hash.second)
            {
                
                if (d_target.find(p.first) == d_target.cend())
                {
                    continue;
                }
                
                if (d_target[p.first] <= p.second)
                {
                    d_target.erase(p.first);
                }
                else
                {
                    d_target[p.first] = d_target[p.first] - p.second;
                }
            }
            
            explore(path+1);
            
            
            d_target = move(temp);
        }
        
    }
    
    
    unordered_map<int,int> d_target;
    unordered_map<int,int> d_total;
    unordered_map<string, unordered_map<int,int>> d_hashes;
    int d_result;
};
