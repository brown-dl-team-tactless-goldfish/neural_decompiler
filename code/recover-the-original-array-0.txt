typedef struct node {
    int value;
    int idx;
    struct node* next;
} Node;

typedef struct hash {
    int size;
    Node *nodes;
} Hash;

static void hashAdd(Hash *h, int value, int vIdx)
{
    const int idx = value % h->size;
    Node *cur = &h->nodes[idx];
    
    while (cur->next != NULL) {
        cur = cur->next;
    }  

    cur->next = calloc(1, sizeof(Node));
    cur = cur->next;
    cur->value = value;
    cur->idx = vIdx;
}

static int hashFind(Hash *h, bool* used, int value)
{
    const int idx = value % h->size;
    Node *cur = h->nodes[idx].next;
    
    for(; cur != NULL && (cur->value != value || used[cur->idx]); cur = cur->next);
    
    if (cur == NULL) {
        return -1;
    } else {
        return cur->idx;
    }
}

static bool checkValid(Hash *h, bool* used, int* ret, int rIdx, int* nums, int nIdx, int nSize, int k)
{
    for(; nIdx < nSize && used[nIdx]; nIdx++);

    if (nIdx < nSize) {
        const int idx = hashFind(h, used, nums[nIdx] + 2*k);

        if (idx != -1) {                
            ret[rIdx] = nums[nIdx] + k;

            used[nIdx] = true;
            used[idx] = true;
            if (checkValid(h, used, ret, rIdx + 1, nums, nIdx + 1, nSize, k)) {
                return true;
            }
            used[idx] = false;
            used[nIdx] = false;
        } 
    
        return false;
    } else {
        return true;
    }
}

static int compare(const void* v, const void*z)
{
    const int a = *(const int*)v;
    const int b = *(const int*)z;
    
    if (a < b) return -1;
    else if (a > b) return 1;
    else return 0;
}

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* recoverArray(int* nums, int numsSize, int* returnSize){
    int *ret = calloc(numsSize/2, sizeof(int));
    Hash h = { 0, NULL };
    
    h.size = numsSize;
    h.nodes = calloc(numsSize, sizeof(Node));
    *returnSize = numsSize/2;
    
    qsort(nums, numsSize, sizeof(int), compare);
    
    for (int i = 0; i < numsSize; i++) {
        hashAdd(&h, nums[i], i);
    }
    
    for (int i = 1; i <= numsSize/2; i++) {
        if (nums[i] == nums[i - 1]) continue;
        const int diff = abs(nums[i] - nums[0]);
        if (diff == 0 || (diff % 2) == 1) continue;

        bool used[numsSize];      
        memset(used, 0, sizeof(used));
        
        if (checkValid(&h, used, ret, 0, nums, 0, numsSize, diff/2)) {
            break;
        }
    }
   
    return ret;
}