// Optimal Approach:
   // Topic Included: 
        // 1. Sorting
        // 2. Minimum Size Sliding Window
struct comp
{
    bool operator()(pair<int,int>&p1,pair<int,int>&p2)
    {
        return p1.first<p2.first;
    }
};
class Solution {
public:
    vector<int> smallestRange(vector<vector<int>>& nums) {
        // Create a new array
        vector<pair<int,int>>v;
        
        int k=nums.size();
        
        // Now Store all element with their list number in new Array
           // Including value of element and its corresponding list's list number
        for(int i=0;i<k;i++)
            for(auto num:nums[i])
                v.push_back({num,i});
        
        // Now sort the new Array
        sort(v.begin(),v.end(),comp());
        
        // Initialize some neccessary variables
        int i=0;
        int j=0;
        unordered_map<int,int>mp;
        int a=INT_MIN,b=INT_MIN;
        int n=v.size();
        int size=INT_MAX;
        int count=0;
        
        // Variable Size Sliding Window Problem
        while(j<n)
        {
         // Do pre-calculation 
            int val=v[j].first;
            int list_no=v[j].second;
            mp[list_no]++;
            if(mp[list_no]==1)
                count++;
        
        // Play with Condition
            if(count<k)
                j++;
            else
            { 
             // Squeeze Window until the window has a element goes out of range
                while(count==k)
                {
                    //  Store Result
                    if(v[j].first-v[i].first<size)
                    {
                        size=v[j].first-v[i].first;
                        a=v[i].first;
                        b=v[j].first;
                        
    // Added this condition just for speed-up (  not neccessary :)  )
                        if(size==0)
                            return {a,b};
                    }
                    
                    // Remove Calculation for i
                    mp[v[i].second]--;
                    if(mp[v[i].second]==0)
                        count--;
                    i++;
                }
             // Expand Window to bring statisfy condition of range
                j++;
            }
                
            
        }
        
        // Return Range
       return {a,b};     
    }
};

Time Complexity: O(n)+O(nlogn)+O(n)
Space Complexity: O(n)