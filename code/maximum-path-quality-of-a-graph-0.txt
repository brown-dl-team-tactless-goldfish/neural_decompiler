// OJ: https://leetcode.com/problems/maximum-path-quality-of-a-graph/
// Author: github.com/lzl124631x
// Time: O(ElogE + 4^10)
// Space: O(V + E)
class Solution {
    typedef array<int, 2> T;
public:
    int maximalPathQuality(vector<int>& V, vector<vector<int>>& E, int maxTime) {
        int N = V.size();
        vector<vector<array<int, 2>>> G(N); // build graph
        for (auto &e : E) {
            int u = e[0], v = e[1], c = e[2];
            G[u].push_back({v, c});
            G[v].push_back({u, c});
        }
        priority_queue<T, vector<T>, greater<T>> pq; // use Dijkstra to find the shortest distance from node 0 to all other nodes.
        vector<int> dist(N, INT_MAX);
        dist[0] = 0;
        pq.push({0, 0});
        while (pq.size()) {
            auto [d, u] = pq.top();
            pq.pop();
            if (d > dist[u]) continue;
            for (auto &[v, c] : G[u]) {
                if (dist[v] > dist[u] + c) {
                    dist[v] = dist[u] + c;
                    pq.push({dist[v], v});
                }
            }
        }
        vector<int> cnt(N); // `cnt[u]` is the number of times we've visted node `u` in the current path
        int ans = 0;
        function<void(int, int, int)> dfs = [&](int u, int val, int time) {
            if (cnt[u] == 0) val += V[u];
            cnt[u]++;
            if (u == 0) ans = max(ans, val); // Only update answer if the current node is `0`.
            for (auto &[v, c] : G[u]) {
                if (time + c + dist[v] > maxTime) continue; // if the current time + the edge time + dist[u] is greater than maxTime, skip
                dfs(v, val, time + c);
            }
            cnt[u]--;
        };
        dfs(0, 0, 0);
        return ans;
    }
};