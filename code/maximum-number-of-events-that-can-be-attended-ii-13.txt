class Solution {
public:
    
    map<string, int> dp ;
    struct cmp{
        bool operator()(const vector<int> &v1 , const vector<int> &v2){
            return v1[0] < v2[0] ;
        }
    };
    
    int solve(int pos , vector<vector<int>>&events , int k ){
        if(pos >= events.size() || !k) return 0 ;
        
		//Encode states
        string temp = to_string(pos) + " " + to_string(k) ;
		
        if(dp.find(temp) != end(dp) ) return dp[temp] ;
        
        //Two choices
        // 1) pick the current event and then go to next event possible to pick 
		//Next event possible would be when the start time of that event will be greater than the end time of current event!
		
        // 2) Dont pick the current event and move to (current + 1) th event
        
        int idx = upper_bound(begin(events) + pos ,end(events),vector<int>{events[pos][1],INT_MIN},cmp()) - begin(events) ;
        
        int op1 = events[pos][2] + solve(idx,events,k-1) ;
        int op2 = solve(pos+1,events,k) ;
        return dp[temp] = max(op1,op2) ;
        
    }
    int maxValue(vector<vector<int>>& events, int k) {
        sort(begin(events),end(events)) ;
        
        // for(auto &x : events) cout << x[0] << " " << x[1] << " || " ; cout << endl ; 
        
        return solve(0,events,k) ;
    }
};