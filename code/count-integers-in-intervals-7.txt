class CountIntervals {
public:
    CountIntervals() {
        k = 0;
    }
    
    void add(int left, int right) {
        auto rit = lidx.upper_bound(right);
        if (rit == lidx.begin())
        {
            lidx.insert(left);
            ridx[left] = right;
            k += (right - left + 1);
        }
        else
        {
            auto prit = prev(rit);
            if (*prit < left)
            {
                if (ridx[*prit] < left)
                {
                    lidx.insert(left);
                    ridx[left] = right;
                    k += (right - left + 1);
                }
                else
                {
                    k += max(0, right - ridx[*prit]);
                    ridx[*prit] = max(ridx[*prit], right);
                }
            }
            else
            {
                right = max(right, ridx[*prit]);
                while (ridx[*prit] >= left)
                {
                    int pl = *prit;
                    left = min(pl, left);
                    if (prit == lidx.begin())
                    {
                        k -= (ridx[pl] - pl + 1);
                        ridx.erase(pl);
                        lidx.erase(pl);
                        break;
                    }
                    prit = prev(prit);
                    k -= (ridx[pl] - pl + 1);
                    ridx.erase(pl);
                    lidx.erase(pl);
                }
                lidx.insert(left);
                ridx[left] = right;
                k += (right - left + 1);
            }
        }
    }
    
    int count() {
        return k;
    }
    
private: 
    set<int> lidx;
    unordered_map<int, int> ridx;
    int k;
};

/**
 * Your CountIntervals object will be instantiated and called as such:
 * CountIntervals* obj = new CountIntervals();
 * obj->add(left,right);
 * int param_2 = obj->count();
 */