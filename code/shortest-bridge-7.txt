class Solution {
public:
    // flood fill algorithm
    void dfs(vector<vector<int>> &grid, int i, int j, vector<vector<bool>> &vis, vector<vector<int>> &vertices)
    {
        vis[i][j] = true;
        if (grid[i][j] == 0)
            return;
        vertices.push_back({i,j});
        if (i and !vis[i - 1][j])
            dfs(grid, i - 1, j, vis, vertices);

        if (i < grid.size() - 1 and !vis[i + 1][j])
            dfs(grid, i + 1, j, vis, vertices);

        if (j and !vis[i][j - 1])
            dfs(grid, i, j - 1, vis, vertices);

        if (j < grid[0].size() - 1 and !vis[i][j + 1])
            dfs(grid, i, j + 1, vis, vertices);
    }
    
	void numIslands(vector<vector<int>>& grid, vector<vector<int>>& vertices, vector<vector<bool>> &vis) {
		if (!grid.size())
			return ;
		int ans = 0, r = grid.size(), c = grid[0].size();
        
        for (int i = 0; i < r; i++){
			for (int j = 0; j < c; j++) {
				if (grid[i][j] == 1 and !vis[i][j]) {
					dfs(grid, i, j, vis, vertices);
                    return;
				}
			}
		}
	}
    
    int shortestBridge(vector<vector<int>>& A) {
        ios_base::sync_with_stdio(false);  cin.tie(NULL);cout.tie(0);
        vector<vector<bool>> vis(A.size(),vector<bool>(A[0].size(),false));
        vector<vector<int>> vertices1;
        vector<vector<int>> vertices2;
        numIslands(A, vertices1, vis);
        numIslands(A, vertices2, vis);
        int minimum = INT_MAX;
        for(int i = 0; i < vertices1.size(); i++){
            for(int j = 0; j < vertices2.size(); j++){
                minimum = min(minimum, abs(vertices1[i][0] - vertices2[j][0]) + abs(vertices1[i][1] - vertices2[j][1]) - 1);
            }
        }
        return minimum;
    }
};