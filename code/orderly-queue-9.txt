/* Compare two strings inside the same ring buffer, but starting at different indexes */
int str_cmp(const char* s, int len, int idx1, int idx2) {
  for (int i = 0; i < len; ++i) {
    if (s[(idx1 + i) % len] != s[(idx2 + i) % len]) {
      return s[(idx1 + i) % len] - s[(idx2 + i) % len];
    }
  }
  return 0;
}

char * orderlyQueue(char * s, int k){
  if (1 == k) { /* We can't sort and can only rotate the string */
    /* Find index of the minimum element */
    int min = 0;
    int len = 1;
    for (int i = 1; s[i]; ++i, ++len) {
      if (s[min] > s[i]) {
        min = i;
      }
    }
    
    /* We know the minimal value we want to begin with, but there might be more than one, find the
     * one that will produce the best */
    for (int i = min + 1; i < len; ++i) {
      if (s[i] == s[min]) {
        int cmp = str_cmp(s, len, min, i);
        if (0 < cmp) {
          min = i;
        }
      }
    }
    
    /* Rotate so that our minimum element is first */
    int front = 0;
    int middle = min;
    int next = middle;
    while (front != next) {
      char tmp = s[front];
      s[front++] = s[next];
      s[next++] = tmp;
      if (next == len) {
        next = middle; 
      } else if (front == middle) {
        middle = next;
      }
    }
  } else { /* We can reorder all elements with enough time, just sort and return */
    /* Counting sort is a good fit since we have a small range */
    int count[26] = {0};
    int len = 0;
    for (char* c = s; *c; ++c, ++len) {
      ++count[*c - 'a'];
    }
    char* pos = s;
    for (int i = 0; i < 26; ++i) {
      memset(pos, i + 'a', count[i]);
      pos += count[i];
    }
  }
  return s;
}