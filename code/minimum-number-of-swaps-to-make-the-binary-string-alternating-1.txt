int minSwaps(char * s){
    const int slen = strlen(s);
    // Count number of 0s and 1s that need to change if the sequence will be 01010...
    int start0bad[2] = {0};
    // Count number of 0s and 1s that need to change if the sequence will be 10101...
    int start1bad[2] = {0};
    
    for (int i = 0; i < slen; i++) {
        if ((i % 2) == 0) { // i = 0,2,4,...
            if (s[i] == '0') { // start1 expects s[i] to be 1
                start1bad[0]++;
            } else {           // start0 expects s[i] to be 0
                start0bad[1]++;
            }
        } else { // i = 1,3,5,...
            if (s[i] == '0') { // start0 expects s[i] to be 1
                start0bad[0]++;
            } else {           // start1 expects s[i] to be 0
                start1bad[1]++;
            }
        }
    }
    
    // If more 1s than 0s are misplaced (or vice versa), then there are
    // no possible swaps we can do to fix the string.
    if (start0bad[0] != start0bad[1] && start1bad[0] != start1bad[1]) {
        return -1;
    // If only 1 pattern is possible, return the swaps needed to generate it
    } else if (start0bad[0] != start0bad[1]){
        return start1bad[0];
    } else if (start1bad[0] != start1bad[1]) {
        return start0bad[0];
    // Otherwise choose the smallest number of swaps
    } else if (start0bad[0] < start1bad[0]) {
        return start0bad[0];
    } else {
        return start1bad[0];
    }
}