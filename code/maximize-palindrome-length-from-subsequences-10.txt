using cache_t = vector<vector<int>>;
int longestPalindrome(string word1, string word2) {
	const auto lsize = word1.size();
	const auto rsize = word2.size();
	const auto word = word1 + word2;
	const auto sz = word.size();
	// cache when `empty == false`
	cache_t zero_table(sz + 1, vector<int>(sz + 1, 0));
	// cache when `empty == true`
	cache_t one_table(sz + 1, vector<int>(sz + 1, 0));

	for (size_t i = 0; i != sz; ++i) {
		zero_table[i][i + 1] = 1;
	}

	// `zero_table[i][j]` is the longest palindromic subsequence of `word[i:j]`.
	for (size_t i = sz - 1; i-- > 0;) {
		for (size_t j = i + 2; j <= sz; ++j) {
			if (word[i] == word[j - 1]) {
				zero_table[i][j] = zero_table[i + 1][j - 1] + 2;
			} else {
				zero_table[i][j] =
					max(zero_table[i][j - 1], zero_table[i + 1][j]);
			}
		}
	}

	for (size_t i = lsize; i-- > 0;) {
		for (size_t j = lsize + 1; j <= sz; ++j) {
			if (word[i] == word[j - 1]) {
				one_table[i][j] = zero_table[i + 1][j - 1] + 2;
			} else {
				one_table[i][j] =
					max(one_table[i][j - 1], one_table[i + 1][j]);
			}
		}
	}
	return one_table[0][sz];
}