int cmp(const void *a, const void *b){
    char *A=*(char **)a;
    char *B=*(char **)b;
    
    char *a_ident, *b_ident, *a_word, *b_word;
    a_ident=malloc(strlen(*(char **)a)*sizeof(char));
    b_ident=malloc(strlen(*(char **)b)*sizeof(char));
    int a_type, b_type;
    
    for(int i=0;i<strlen(A);i++){
        if(A[i]!=' '){
            a_ident[i]=A[i];
        }else{
            a_ident[i]='\0';
            break;
        }
    }
    
    for(int i=0;i<strlen(B);i++){
        if(B[i]!=' '){
            b_ident[i]=B[i];
        }else{
            b_ident[i]='\0';
            break;
        }
    }
    
    a_word=strchr(*(char **)a, ' ');
    b_word=strchr(*(char **)b, ' '); 
    
    a_type=0; b_type=0; /* word */
    for(int i=0; i<strlen(a_word); i++){
        if(a_word[i]>='0' && a_word[i]<='9'){
            a_type=1; /* digit */
            break;
        }
    }
    for(int i=0; i<strlen(b_word); i++){
        if(b_word[i]>='0' && b_word[i]<='9'){
            b_type=1;
            break;
        }
    }

    if(a_type==0 && b_type==1)
        return -1;
    else if(a_type==1 && b_type==0)
        return 1;
    else if(a_type==1 && b_type==1)
        return 0;
    else if(a_type==0 && b_type==0){
        if(strcmp(a_word, b_word)!=0)
            return strcmp(a_word, b_word);
        else
            return strcmp(a_ident, b_ident);
    }
    
    return 0;
}


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char ** reorderLogFiles(char ** logs, int logsSize, int* returnSize){
    qsort(logs, logsSize, sizeof(char *), cmp);
    
    *returnSize=logsSize;
    return logs;
}