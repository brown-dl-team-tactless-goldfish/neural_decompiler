struct target_hash {
	int key;
	/* Used to handle the case where muliple entries have the same key */
	struct target_hash* next;
	UT_hash_handle hh;
};

static
void write_response(struct target_hash* entry, int idx, struct target_hash* entries_start, int** response_out) {
	int start_idx = idx;
	int end_idx = idx;
	int target = entry->key;
	while (target >>= 1) {
		--start_idx;
	}

	do {
		int ret_idx = entry - entries_start;
		response_out[ret_idx][0] = start_idx;
		response_out[ret_idx][1] = end_idx;
	} while (entry = entry->next);
}

int** substringXorQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes){
	int** ret = malloc(queriesSize * sizeof(*ret));
	*returnColumnSizes = malloc(queriesSize * sizeof(**returnColumnSizes));
	for (int i = 0; i < queriesSize; ++i) {
		ret[i] = malloc(2 * sizeof(**ret));
		(*returnColumnSizes)[i] = 2;
	}
	*returnSize = queriesSize;

	struct target_hash* table = NULL;
	struct target_hash* const entries = malloc(queriesSize * sizeof(*entries));
	struct target_hash* entry;

	/* 
	Hash all the queries. To support duplicate keys, the entries with a
	duplicate key are inserted into a single link list starting at the
	first entry with the key
	*/
	for (int i = 0; i < queriesSize; ++i) {
		int target = queries[i][0] ^ queries[i][1];
		HASH_FIND_INT(table, &target, entry);
		if (!entry) {
			/* New key */
			entries[i].key = target;
			entries[i].next = NULL;
			HASH_ADD_INT(table, key, &entries[i]);
		} else {
			/* Key is not unique */
			entries[i].next = entry->next;
			entry->next = &entries[i];
		}
	}

	int fingerprint[31];
	int num_fingers = 0;
	for (int i = 0; s[i]; ++i) {
		/* 
		Build the next fingerprint by left shifting the previous fingerprints
		and adding the new character.
		*/
		num_fingers = (30 == num_fingers) ? 30 : (num_fingers + 1);
		for (int j = num_fingers - 1; j; --j) {
			fingerprint[j] = (fingerprint[j - 1] << 1) + ('1' == s[i]);
			HASH_FIND_INT(table, &fingerprint[j], entry);
			if (entry) {
				write_response(entry, i, entries, ret);
				HASH_DEL(table, entry);
			}
		}
		/* New fingerprint of from the single character */
		fingerprint[0] = ('1' == s[i]);
		HASH_FIND_INT(table, &fingerprint[0], entry);
		if (entry) {
			write_response(entry, i, entries, ret);
			HASH_DEL(table, entry);
		}
	}

	/* Any remaining queries have no response */
	struct target_hash* tmp;
	HASH_ITER(hh, table, entry, tmp) {
		do {
			ret[entry - entries][0] = -1;
			ret[entry - entries][1] = -1;
		} while ((entry = entry->next));
	}
	HASH_CLEAR(hh, table);

	free(entries);
	return ret;
}