class Solution {
    vector<int> list;
    
    // inorder traversal
    void fillList(TreeNode* root){
        if(root){
            fillList(root->left);
            list.emplace_back(root->val);
            fillList(root->right);
        }
    }
public:
    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {
        // fill the root values into list, in sorted order.
        fillList(root);
        vector<vector<int>> result;
        int cond1,cond2;

        for(int &query : queries){
            // lower bound gives the iterator containing value
            // which is not less than the query. It gives either greater or equal(if present).
            auto lb = lower_bound(list.begin(), list.end(), query);
            
            // if its the end, nothing in tree is greater than the query value.
            // else self explanatory
            if(lb == list.end()) cond2 = -1;
            else cond2 = *lb;
            
            // if its the beginning and the value is greater than query, then no appropriate element is present.
            // else self explanatory
            if(lb == list.begin() and *lb > query) cond1 = -1;
            else {
                if(lb == list.end() or *lb > query) advance(lb, -1);
                cond1 = *lb;
            }
            
            // store the result
            result.push_back({cond1,cond2});
        }
        
        // return the result
        return result;
    }
};