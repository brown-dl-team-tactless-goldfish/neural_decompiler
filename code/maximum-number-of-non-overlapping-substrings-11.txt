class Solution {

public:
    vector<string> maxNumOfSubstrings(string s) {
        int n = s.size();
        
        // Find the first and last appearances of each character.
        vector<int> begin(26, n), end(26, -1);
        for(int i=0; i<n; i++) {
            int r = s[i] - 'a';
            begin[r] = min(begin[r], i);
            end[r] = max(end[r], i);
        }
        
        // Find all the valid substrings.
        vector<pair<int, int>> sub;
        for(int c=0; c<26; c++) {
            // Pick each character from 'a' to 'z'.
            if(begin[c] == n) continue;
            
            int b = begin[c], e = end[c];
            
            // Check if the substring from index b to index e is valid, but looking into each character between b and e.
            // if the first and last appearances are within [b, e], continue, otherwise, we need to expand the range.
            bool valid = false;
            while(!valid) {
                valid = true;
                for(int i=b+1; i<e; ++i) {
                    int nc = s[i] - 'a';
                    if(begin[nc] >= b && end[nc] <= e) continue;
                    
                    valid = false;
                    b = min(b, begin[nc]);
                    e = max(e, end[nc]);
                    break;
                }
            }
            
            // Add the valid substring.
            sub.push_back({b, e});
        }
        
        // Sort by substring length.
        sort(sub.begin(), sub.end(), [](pair<int, int>& p1, pair<int, int>& p2) { return p1.second - p1.first < p2.second - p2.first; } );
        
        // Greedy solution, insert the shortest substring if no overlap.
        vector<pair<int, int>> v;
        for(auto p : sub) {
            bool intersect = false;
            for(auto p2 : v) {
                if(p.second < p2.first || p.first > p2.second) continue;
                else {
                    intersect = true;
                    break;
                }
            }
            if(!intersect) v.push_back(p);
        }
        
        vector<string> ans;
        for(auto p : v) ans.push_back(s.substr(p.first, p.second - p.first + 1));
        return ans;
    }
};