class Solution {
public:
    bool countFrequecy(int node, int dest,vector<int> adj[],vector<int>&freq, int par)
    {
        if(node==dest)  // reached the destination
            return 1;
        bool ans =0;
        for(auto x:adj[node])
        {
            if(x!=par)
            {
                if(countFrequecy(x,dest,adj,freq,node)) // If destination is in current path
                {
                    freq[x]++; //incrementing the freq of nodes in the path
                    ans=1;
                }
            }
        }
        return ans;
    }
    int minCost(int node, int par, int lastPicked,vector<int>& price,vector<int> adj[],vector<int>&freq,vector<vector<vector<int>>>&dp)
    {
        int ans = 1e9,res=0;
        if(dp[node][par][lastPicked]!=-1)
            return dp[node][par][lastPicked];
        if(lastPicked) // if we picked the last i.e, node then price = price/2
            res = freq[node]*(price[node]/2);
        else
            res = freq[node]*(price[node]);
        
        for(auto x:adj[node])
        {
            if(x!=par) 
            {
                ans=minCost(x,node,0,price,adj,freq,dp);
                if(lastPicked==0)  
                    ans = min(ans,minCost(x,node,1,price,adj,freq,dp));
                res+=ans;
            }
        }
        return dp[node][par][lastPicked] = res;
    }
    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {
        vector<int> freq(n,0);
        vector<int> adj[n+1];
        for(int i=0;i<n-1;i++)
        {
            adj[edges[i][0]].push_back(edges[i][1]);
            adj[edges[i][1]].push_back(edges[i][0]);
        }
        for(auto x:trips)
        {   countFrequecy(x[0],x[1],adj,freq,-1);
            freq[x[0]]++;
        }
       
        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(n+1,vector<int>(2,-1)));
        return min(minCost(0,n,0,price,adj,freq,dp),minCost(0,n,1,price,adj,freq,dp));
        
        return 0;
    }
};