// val < 2e15
struct node
{
    node* arr[2];
    int cnt[2];
    node()
    {
        arr[0] = nullptr;
        arr[1] = nullptr;
        cnt[0] = 0;
        cnt[1] = 0;
    }
    void add(int v, int level)
    {
        if (level < 0) return;
        int bit = 1 << level;
        int index = 0;
        if ((v & bit) == bit)
        {
            index = 1;
        } else {
            index = 0;
        }
        if (arr[index] == nullptr)
        {
            arr[index] = new node();   
            
        }
        cnt[index]++;
        arr[index]->add(v, level - 1);
    }
    
    void remove(int v, int level)
    {
        if (level < 0) return;
        int bit = 1 << level;
        int index = 0;
        if ((v & bit) == bit)
        {
            index = 1;
        } else {
            index = 0;
        }
        node* c = nullptr;
        if (arr[index] != nullptr)
        {
            c = arr[index];          
            c->remove(v, level - 1);
            cnt[index]--;
            if (cnt[index] == 0)
            {
                arr[index] = nullptr;
            }
        }
    }
    
    void search(int& v, const int x, int level)
    {
        if (level < 0) return;
        int bit = 1 << level;
        int x1 = x & bit;
        int index = 1;
        if (x1 != 0) index = 0;
        if (arr[index] == nullptr)
        {
            index = 1 - index;
        }
        v = ((index << level) | v);
        arr[index]->search(v, x, level - 1);
    }
};
class Solution {
public:
    const static int ml = 16;
    int n;
    vector<node*> dp;
    vector<vector<int>> qs;
    vector<vector<int>> child;
    vector<int> ans;
    void dfs(int c, node* r, vector<vector<int>>& queries)
    {
        //cout << "in:" << c << ","<<  r->cnt[0] << "," << r->cnt[1] << endl;
        r->add(c, ml);
        
        
        if (!qs[c].empty())
        {
            for (auto& q : qs[c])
            {
                
                int v = 0;
                r->search(v, queries[q][1], ml);
                cout << q << "," << v << "," << queries[q][1] << endl;
                ans[q] = v ^ queries[q][1];
            }
        }
        for (auto& cl : child[c])
        {
            dfs(cl, r, queries);
        }
        r->remove(c, ml);
        //cout << "out:" << c << "," << r->cnt[0] << "," << r->cnt[1] << endl;
        
        return;
    }
    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {
        n = parents.size();
        
        qs.resize(n);
        for (int i = 0; i < queries.size(); i++)
        {
            qs[queries[i][0]].push_back(i);
        }
        ans.resize(queries.size());
        child.resize(n);
        int root = -1;
        for (int i = 0; i < n; i++)
        {
            if (parents[i] == -1)
            {
                root = i;
            }
            else
            {
                child[parents[i]].push_back(i);
            }
        }
        
        
        node* r = new node();
        dfs(root,  r, queries);
        
        return ans;
    }
};