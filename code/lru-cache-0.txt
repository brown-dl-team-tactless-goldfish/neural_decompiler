#define HASH_SIZE 10001 // Based on key

typedef struct qnode {
    struct qnode *prev;
    struct qnode *next;
    int key;
    int data;
} Qnode;


typedef struct queue {
    Qnode *head;
    Qnode *tail;
    int count;
} Queue;



typedef struct {
    
    int capacity;
    Queue *queue;
    Qnode **hash;
} LRUCache;


Qnode *createnewnode(int key, int data)
{
      Qnode *temp = (Qnode *)malloc(sizeof(Qnode));
      temp->prev = NULL;
      temp->next = NULL;
      temp->key = key;
      temp->data = data;
      return temp;
}


Queue* createqueue(int numberofframes)
{
    Queue *queue = (Queue *)malloc(sizeof(Queue));
    // head and tail are dummy nodes
    queue->head = createnewnode(-1,0); 
    queue->tail = createnewnode(-1,0);
    queue->head->next = queue->tail;
    queue->tail->prev = queue->head;
    queue->count = 0;
    
    return queue;
}

Qnode ** createhash(int size)
{
    Qnode **hash = (Qnode **)malloc(size * sizeof(Qnode *));
    
    memset(hash, 0, size *sizeof(Qnode *)); // Initialize to NULL
    
    return hash;
}


void removeNode(LRUCache *cache, Qnode *node)
{
    Qnode *prev = node->prev;
    Qnode *next = node->next;
    
    prev->next = next;
    next->prev = prev;
}
// Add new node
void addNode(LRUCache *cache, Qnode *node)
{
    node->prev = cache->queue->head;
    node->next = cache->queue->head->next;
    
    cache->queue->head->next->prev = node;
    cache->queue->head->next = node;  
}

void movetohead(LRUCache *cache, Qnode *node)
{
    removeNode(cache,node);
    addNode(cache,node);
    
}

Qnode* popTail(LRUCache *cache)
{
    Qnode *node = cache->queue->tail->prev;
    removeNode(cache,node);
    return node;
}



LRUCache* lRUCacheCreate(int capacity) {
    
    LRUCache *lru = (LRUCache *)malloc(sizeof(LRUCache));
    lru->hash = createhash(HASH_SIZE);
    lru->queue = createqueue(capacity);
    lru->capacity = capacity;
    
    return lru;
}

int lRUCacheGet(LRUCache* obj, int key) {
  
    if(obj->hash[key] != NULL)
    {
        Qnode *node = obj->hash[key];
        int data = node->data;
        movetohead(obj,node);
        return data;
    }
    
    return -1;
}

void lRUCachePut(LRUCache* obj, int key, int value) {
  
   Qnode *node = obj->hash[key];
    
   if(!node)
   {
       node = createnewnode(key,value);
       obj->hash[key] = node;
       addNode(obj,node);
       obj->queue->count++;
       
       if(obj->queue->count > obj->capacity)
       {
           Qnode *tail = popTail(obj);
           obj->hash[tail->key] = NULL;
           obj->queue->count--;
       }
       
   }
   else{
        
       node->data = value; // update node value
       movetohead(obj,node);
    }
    
    
}

void lRUCacheFree(LRUCache* obj) {
    
    while(obj->queue->head)
    {
        Qnode * temp = obj->queue->head;
        obj->queue->head = obj->queue->head->next;
        free(temp);
    }
    
    free(obj->queue);
    free(obj->hash);
    free(obj);
    
}