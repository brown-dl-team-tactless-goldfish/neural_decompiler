int diff(char * x, char * y) {
  int diff = -1;
  
  if (x && y) {
    diff = 0;
    while (*x) {
      if (*x != *y) {
        ++diff;
      }
      x++;
      y++;
    }
  }
  return diff;
}

int find(char * x, char ** bank, int bankSize) {
  int position = -1;
  for (int i = 0; (i < bankSize); ++i) {
    if (diff(x, bank[i]) == 0) {
      position = i;
      break;
    }
  }
  
  return position;
}

int helper(int start_index, int end_index, char ** bank, int bankSize, bool * map, int step, int * steps) {
  int min_moves = INT_MAX;
  
  if (start_index == end_index) {
    min_moves = step;
  } else {
    // navigate each string the start string maps too
    for (int i = 0; i < bankSize; ++i) {
      if (map[start_index*bankSize + i] && (steps[i] > step)) {
        steps[i] = step;
        int moves = helper(i, end_index, bank, bankSize, map, step + 1, steps);
        min_moves = fmin(min_moves, moves);
      }
    }
  }
  
  return min_moves;
}

int minMutation(char * start, char * end, char ** bank, int bankSize){
  int min_moves = INT_MAX;
  int end_index = find(end, bank, bankSize);
  if (end_index >= 0) {
    bool * map = calloc(bankSize * bankSize, sizeof(bool));
    int steps[bankSize];

    for (int i = 0; i < bankSize; ++i) {
      steps[i] = INT_MAX;
      for (int j = i + 1; j < bankSize; ++j) {
        map[i*bankSize+j] = map[j*bankSize+i] = (diff(bank[i], bank[j]) == 1);
      }
    }
    
    int start_index = find(start, bank, bankSize);
    if (start_index >= 0) {
      int moves = helper(start_index, end_index, bank, bankSize, map, 0, steps);
      min_moves = fmin(min_moves, moves);
    } else {
      // find each string the start string can move to, use that as starting string
      for (int i = 0; i < bankSize; ++i) {
        if (diff(start, bank[i]) == 1) {
          int moves = helper(i, end_index, bank, bankSize, map, 1, steps);
          min_moves = fmin(min_moves, moves);
        }
      }
    }
  }
  
  if (min_moves == INT_MAX) {
    min_moves = -1;
  }
  return min_moves;
}