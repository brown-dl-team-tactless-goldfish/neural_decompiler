class Solution {
public:
    int ans;
    void dfs(int r,int c, vector<vector<int>>& g, vector<vector<bool>> &vis){
        if(r >= g.size() || c >= g[0].size() || g[r][c] == 0 || vis[r][c]) return;
        if(r == g.size()-1 && c == g[0].size()-1){ ans++; return;}
        vis[r][c] = 1;
        // go right
        dfs(r,c+1,g,vis);
        if(ans > 0) return; // if we have found answer with this path then return
        // go down
        dfs(r+1,c,g,vis);
    }
    
    bool isPossibleToCutPath(vector<vector<int>>& grid) {
        // if we have more than 2 unique ways then we cannot do that
        // so we will do dfs from right and down of top point and if we can find 2 unique ways then we return false else return 1;
        // we can only move right and down
        // so first we check
        ans = 0; 
        int m = grid.size();
        int n = grid[0].size();
        // some basic conditions in which answer will be constant
        if((m == 1 && n == 1) || (m == 1 && n == 2) || (m == 2 && n == 1)) return 0;
        if((m == 1 && n > 2) || (m > 2 && n == 1)) return 1;
        if(m > 2 && n > 2 && (!(grid[0][1] && grid[1][0]))) return 1;
        vector<vector<bool>> vis(m,vector<bool>(n,0));
        dfs(0,1,grid,vis); // dfs from right
        int ans2 = ans > 0 ? 1 : 0; // if ans
        ans = 0;
        dfs(1,0,grid,vis);
        ans = ans > 0 ? 1 : 0;
        return !(ans&ans2)  ;
    }
};