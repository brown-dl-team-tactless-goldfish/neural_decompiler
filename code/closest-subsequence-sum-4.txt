class Solution {
public:
	// Generate sums of all possible subsets of a given array
    vector<int> gen_subsets(vector<int> &a) {
        int n = a.size(), i, j;
        vector<int> ret;
        for(i = 0; i < (1<<n); i++) {
            int sum = 0;
            for(j=0; j<n; j++)
                if(i & (1 << j))
                    sum += a[j];
            ret.emplace_back(sum);
        }
        sort(ret.begin(), ret.end());
        return ret;
    }
    int minAbsDifference(vector<int>& nums, int goal) {
        int n = nums.size(), i, j;
		
		// Split array in half and generate sum subarrays for each of them		
		vector<int> half1, half2;   
        for(i=0; i<n/2; i++) 
            half1.emplace_back(nums[i]);
        for(; i<n; i++) 
            half2.emplace_back(nums[i]);
        vector<int> a = gen_subsets(half1);
        vector<int> b = gen_subsets(half2);
        int ret = 2e9;
		
		// For each element in a, find the closest elements in b (just over or just under) such that their sum is as close to target as possible
		// Earlier iterations were prone to time limit exceeded. A minor change fixed it. Problem setter needs to be less *nal, ideally.
        for(i=0; i<a.size(); i++) {   
            j = lower_bound(b.begin(), b.end(), goal - a[i]) - b.begin();
            if(j > 0)
                ret = min(ret, abs(goal - b[j - 1] - a[i]));
            if(j < b.size())
                ret = min(ret, abs(goal - b[j] - a[i]));
        }
        return ret;
    }
};