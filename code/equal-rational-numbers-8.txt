class Solution {
public:
    bool isRationalEqual(string S, string T) {
        vector<int> fs = getFractionFormat(S), ft = getFractionFormat(T);
        return fs == ft;
    }
private:
    // Get canonical form of a rational number
    vector<int> getFractionFormat(const string& S) {
        int a = getInteger(S);
        vector<int> f = getFractionPart(S);
        int b = f[0], lb = f[1], c = f[2], lc = f[3];
        // Handle special cases
        // When the fraction part is equal to 1
        if (b == 0 && lb == 0 && c == 9 && lc == 1)
            return {a+1, 0, 0, 0, 0};
        // When there is actually no repeating part
        if (c == 9 && lc == 1) {
            return {a, b+1, lb, 0, 0};
        }
        if (b == 0 && c == 0)
            return {a, 0, 0, 0, 0};
        if (c == 0)
            return {a, b, lb, 0, 0};
        return {a, b, lb, c, lc};
    }
    
    int getInteger(const string& S) {
        if (S[0] == '.')
            return 0;
        int pos = S.find('.');
        if (pos == string::npos)
            return stoi(S);
        return stoi(S.substr(0, pos));
    }
    
    vector<int> getFractionPart(const string& S) {
        // Get fraction part
        int pos = S.find('.');
        if (pos == string::npos) {
            return {0, 0, 0, 0};
        }

        string F = S.substr(pos+1);
        if (F == "")
            return {0, 0, 0, 0};
        
        // Get the border of literal repeating and non-repeating part
        pos = F.find('(');
        if (pos == string::npos) {
            int nonRepLen = F.size();
            int nonRep = 0;
            for (int i = 0; i < nonRepLen; ++i) {
                nonRep = 10*nonRep + (F[i] - '0');
            }
            return {nonRep, nonRepLen, 0, 0};
        }
        
        string nonRepStr = F.substr(0, pos);
        string repStr = F.substr(pos+1);
        repStr.pop_back();
        
        // Get the minimum repeating unit of the literal repeating part
        int secondStart = (repStr + repStr).find(repStr, 1);
        if (secondStart < repStr.size())
            repStr = repStr.substr(0, secondStart);
        
        int nonZeroPos = 0;
        for (int i = 0; i < nonRepStr.size() && nonRepStr[i] == '0'; ++i) {
            ++nonZeroPos;
        }
        
        // Check if the non-repeating part and repeating parts need to be updated
        if (nonZeroPos < nonRepStr.size()) {
            string a = nonRepStr.substr(nonZeroPos);
            string b = a + repStr + repStr;
            for (int i = 0; i < a.size(); ++i) {
                string subStr = b.substr(i, repStr.size());
                if (b.find(subStr, i+1) != string::npos) {
                    nonRepStr = nonRepStr.substr(0, nonZeroPos) + a.substr(0, i);
                    repStr = subStr;
                    break;
                }
            }
        }
        
        int nonRepLen = nonRepStr.size();
        int nonRep = 0;
        for (int i = 0; i < nonRepLen; ++i) {
            nonRep = 10*nonRep + nonRepStr[i] - '0';
        }
        
        int repLen = repStr.size();
        int rep = 0;
        for (int i = 0; i < repLen; ++i) {
            rep = 10*rep + repStr[i] - '0';
        }
        
        return {nonRep, nonRepLen, rep, repLen};
    }
};