class Solution {
public:
    string smallestSubsequence(string s) {
        vector<int> lastIndices(26);
        unordered_set<char> visited;
        stack<char> chars;
        
        for (int i = 0; i < s.size(); ++i)
        {
            lastIndices[s[i] - 'a'] = i; // store the last index of each unique character
        }
        
        for (int i = 0; i < s.size(); ++i)
        {
            char c = s[i];
            if (visited.find(c) == visited.end()) // if the character already appears in the stack, ignore it
            {
                while (!chars.empty() && c < chars.top() && lastIndices[chars.top() - 'a'] > i) // if current character < top character (say t) on stack, and we have more t in the later of the string, then we have smaller substring
                {
                    visited.erase(chars.top());
                    chars.pop();
                }
                
                visited.insert(c);
                chars.push(c); // update stack and hash table
            }
        }
        
        string res;
        while (!chars.empty())
        {
            res = chars.top() + res;
            chars.pop(); // accumulate the character to form the result
        }
        
        return res;
    }
};