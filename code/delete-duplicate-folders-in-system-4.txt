class Solution {
public:
    struct node {
        string name;
        map<string,node*>next;
        bool f;
        node(string n) {
            name=n;f=true;
        }
    };
    node* root;
    unordered_map<string,node*>mp;
    string dfs(node* r) {
        string temp="";
        if(r) {
            for(auto &[k,v]:r->next) {
                temp+="("+dfs(v)+")";
            }
            if(temp!="" && mp.count(temp)!=0){ 
                r->f=false;
                mp[temp]->f=false;
            }
            mp[temp]=r;
            temp=r->name+temp;
        }
        return temp;
    }
    void dfs2(node* r,vector<vector<string>>&res,vector<string>&temp){ 
        if(r) {
            if(r->f) {
                temp.push_back(r->name);
                res.push_back(temp);
                for(auto &[k,v]:r->next){
                    dfs2(v,res,temp);
                }
                temp.pop_back();
            }
        }
    }
    vector<vector<string>> deleteDuplicateFolder(vector<vector<string>>& paths) {
    root=new node("");
    for(vector<string> t:paths) {
        node* p=root;
        for(string &s:t) {
            if(p->next.count(s)==0) {
                p->next[s]=new node(s);
            }
            p=p->next[s];
        }
    }
    dfs(root);
    vector<vector<string>> res;
    vector<string> temp;
    for(auto &[k,v]:root->next)
    dfs2(v,res,temp);
    return res;
    }
};