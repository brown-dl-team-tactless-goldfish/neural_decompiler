class Solution {
public:
    int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {
        vector<vector<int>> dirs = {{0,1},{-1,0},{0,-1},{1,0}};
        int dir = 0;
        pair<int,int> curr = make_pair(0,0);
        int maxres = 0;
        unordered_set<string> obstacles_set;
        for(vector<int> obstacle: obstacles){
            string ob_str = to_string(obstacle[0]) + "@" + to_string(obstacle[1]);
            obstacles_set.insert(ob_str);
        }            
        for(int cmd : commands){
            if(cmd==-2)
                dir = (dir+1)%4;
            else if(cmd==-1)
                dir = (dir-1)<0? dir-1+4:dir-1;
            else{
                curr = makeOneMove(curr.first,curr.second,dirs[dir][0],dirs[dir][1],cmd,obstacles_set);
                maxres = max(maxres,curr.first*curr.first+curr.second*curr.second);
            }
        }
        return maxres;
    } 
    
    pair<int,int> makeOneMove(int curr_x,int curr_y,int go_x,int go_y,int moves,unordered_set<string>& obstacles){
        int x = curr_x, y = curr_y;
        int move = 0;
        while(move<moves){
            int next_x = curr_x + go_x;
            int next_y = curr_y + go_y;
            //Judge whether next position is OK
            string xy = to_string(next_x) + "@" + to_string(next_y);
            if(obstacles.find(xy)!=obstacles.end())
                break;
            curr_x = next_x;
            curr_y = next_y;
            move++;
        }
        return make_pair(curr_x,curr_y);
    }
    
};