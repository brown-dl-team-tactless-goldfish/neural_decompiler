//////////// QUEUE implementation
#define QCAPACITY   350
typedef struct Queue {
    int front, rear, size;
    int capacity;
    char **array;
} Queue;

Queue* createQueue(int capacity){
    Queue* queue = (Queue*) malloc(sizeof(Queue));
    queue->capacity = capacity;
    queue->front = queue->size = 0;
    queue->rear = capacity - 1;
    queue->array = calloc(queue->capacity, sizeof(char *));
    return queue;
}

int isFull(Queue* queue)  {   return (queue->size == queue->capacity); }
int isEmpty(Queue* queue) {   return (queue->size == 0);               }
int  size(Queue* queue)   {   return queue->size;                      }

void enqueue(Queue* queue, char *item) {
    if (isFull(queue))
        return;
    queue->rear = (queue->rear + 1) % queue->capacity;
    queue->array[queue->rear] = item;
    queue->size = queue->size + 1;
}

char * dequeue(Queue* queue) {
    if (isEmpty(queue))
        return NULL;
    
    char * item = queue->array[queue->front];
    queue->front = (queue->front + 1) % queue->capacity;
    queue->size = queue->size - 1;
    return item;
}

// hash map element structure: to store the patters to words 
#define NUM_WORDS  50
typedef struct {
    char *pat;
    char *wds[NUM_WORDS];			// array based adjacency list
    int  cnt;
    UT_hash_handle hh;
} hElem;

// visited set
typedef struct {
    char *word;
    UT_hash_handle hh;
} vElem;

int ladderLength(char * beginWord, char * endWord, char ** wordList, int wordListSize){
    bool endWordFound = false;
    for(int i = 0; i < wordListSize; i++) {
        if(strcmp(wordList[i], endWord) == 0) {
            endWordFound = true;
            break;
        }
    }
    
    if(strcmp(beginWord, endWord) == 0 || !endWordFound) return 0;
    
    hElem *map = NULL, *s;
    vElem *set = NULL, *v;

    int len = strlen(beginWord);
    char *pat = NULL;
    
    // add all patterns of each word in wordList to map
    for(int i = 0; i < wordListSize; i++) {
        for(int j = 0; j < len; j++) {
            pat = calloc(sizeof(char), len + 1);
            strcpy(pat, wordList[i]);
            pat[j] = '*';
            HASH_FIND_STR(map, pat, s);
            if(!s) {
                s = calloc(sizeof(hElem), 1);
                s->pat = pat; s->wds[s->cnt++] = wordList[i];
                HASH_ADD_STR(map, pat, s);
            } else {
                s->wds[s->cnt++] = wordList[i];
            }
        }
    } 
    
    // add begin word to set
    v = calloc(sizeof(vElem), 1);
    v->word = beginWord;
    HASH_ADD_STR(set, word, v);
    
    Queue *queue = createQueue(QCAPACITY);
    enqueue(queue, beginWord);
    int res = 1;
    
    while(!isEmpty(queue)) {
        int qSize = size(queue);
    
        for(int i = 0; i < qSize; i++) {
            char *curWd = dequeue(queue);
            if(strcmp(curWd, endWord) == 0) return res;
            
            for(int j = 0; j < len; j++) {
                pat = calloc(sizeof(char), len + 1);
                strcpy(pat, curWd);
                pat[j] = '*';
                HASH_FIND_STR(map, pat, s);
                if(s) {
                    for(int c = 0; c < s->cnt; c++) {
                        HASH_FIND_STR(set, s->wds[c], v);
                        if(!v) {
                            v = calloc(sizeof(vElem), 1);
                            v->word = s->wds[c];
                            HASH_ADD_STR(set, word, v);
                            enqueue(queue, s->wds[c]);
                        }
                    }
                }
            }
        }
        res ++;
    }
    return 0;
}