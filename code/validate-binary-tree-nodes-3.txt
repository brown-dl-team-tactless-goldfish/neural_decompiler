

bool valide_tree(int number, int* leftChild, int* rightChild, bool *visited)
{
    if(visited[number] == true)
        return false;
    
    visited[number] = true;
    if(leftChild[number] != -1)
        if(!valide_tree(leftChild[number], leftChild, rightChild, visited))
            return false;

    if(rightChild[number] != -1)
        if(!valide_tree(rightChild[number], leftChild, rightChild, visited))
            return false;

    return true;
}

bool validateBinaryTreeNodes(int n, int* leftChild, int leftChildSize, int* rightChild, int rightChildSize){

    int i;
    bool *visited;

    visited = (bool *)malloc(sizeof(bool)*n);
    memset(visited, false, sizeof(bool)*n);
    
    //check the cycle and locate the root
    for (int i=0; i<n;i++) {
        if (leftChild[i] >= 0 && !visited[leftChild[i]]) 
            visited[leftChild[i]] = true;
        else if (leftChild[i] >= 0 && visited[leftChild[i]])
            return false;

        if (rightChild[i] >= 0 && !visited[rightChild[i]]) 
            visited[rightChild[i]] = true;
        else if (rightChild[i] >= 0 && visited[rightChild[i]])
            return false;        
    }
    
    // not used node is root
    for (i=0; i<n;i++) {
        if (!visited[i])
            break;
    }
    
    // possible cycle, Edges > Nodes
    if (i == leftChildSize)
        return false;
    
    memset(visited, false, sizeof(bool)*n);
        
    if(!valide_tree(i, leftChild, rightChild, visited))
        return false;

    // all nodes are vsited ?
    for(i=0; i<n; i++)
        if(!visited[i])
            return false;

    return true;
}