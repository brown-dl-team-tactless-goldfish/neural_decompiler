/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */


typedef struct {
    int up;
    int bot;
    int left;
    int right;
    int len;
}C_info;

int** rotateGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){
    int m = gridSize;
    int n = *gridColSize;
    int **ret = malloc(m * sizeof(int*));
    for (int i = 0; i < m; i++){
        ret[i] = malloc(n * sizeof(int));
    }

    *returnSize = m;
    *returnColumnSizes = malloc(m * sizeof(int));
    for (int i = 0; i < m; i++){
        (*returnColumnSizes)[i] = n;
    }


    int cycle_count;
    if (m > n){
        cycle_count = n / 2;
    } else {
        cycle_count = m / 2;
    }

    C_info *cinfo = malloc(sizeof(C_info) * cycle_count);
    if (m > n){
        int left = n/2-1;
        int right = n/2;
        int up = left;
        int bot = (m-1) - up;
        int len;
        for (int i = 0; i < cycle_count; i++){
            cinfo[i].left = left;
            cinfo[i].right = right;
            cinfo[i].up = up;
            cinfo[i].bot = bot;
            len = 2 *(right - left + 1) + 2 *(bot - up + 1) - 4;
            cinfo[i].len = len;
            left--;
            right++;
            up--;
            bot++;
        }
    } else {
        int up = m/2 - 1;
        int bot = m/2;
        int left = up;
        int right = (n-1) - up;
        int len;
        for (int i = 0; i < cycle_count; i++){
            cinfo[i].left = left;
            cinfo[i].right = right;
            cinfo[i].up = up;
            cinfo[i].bot = bot;
            len = 2 *(right - left + 1) + 2 *(bot - up + 1) - 4;
            cinfo[i].len = len;
            left--;
            right++;
            up--;
            bot++;
        }
    }

    for (int i = 0; i < m; i++){
        for (int j = 0; j < n; j++){
            for (int cy = 0; cy < cycle_count; cy++){
                if (cinfo[cy].up <= i && i <= cinfo[cy].bot && cinfo[cy].left <= j && j <= cinfo[cy].right){
                    int steps = k % cinfo[cy].len;
                    int tar_i = i;
                    int tar_j = j;
                    while(steps>0){
                        if(tar_i == cinfo[cy].up){
                            if (tar_j == cinfo[cy].left){
                                tar_i++;
                            } else {
                                tar_j--;
                            }
                        } else if (tar_i == cinfo[cy].bot){
                            if (tar_j == cinfo[cy].right){
                                tar_i--;
                            } else {
                                tar_j++;
                            }
                        } else {
                            if (tar_j == cinfo[cy].left){
                                tar_i++;
                            } else {
                                tar_i--;
                            }
                        }
                        steps--;
                    }
                    ret[tar_i][tar_j] = grid[i][j];
                    break;
                }
            }
        }
    }
    return ret;
}

