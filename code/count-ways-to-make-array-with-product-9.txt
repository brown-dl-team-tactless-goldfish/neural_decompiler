    int mod=1e9+7;
    int modinv_val[10001];
    Solution(){
        for(int i=1;i<10001;i++)
            modinv_val[i]=modinv(i,mod-2,mod);
    }
    vector<int> waysToFillArray(vector<vector<int>>& queries) {
        vector<int> ans;
        for(auto q:queries){
            unordered_map<int,int> mp;
            ans.push_back(numWays(q[1],2,mp,q[0])+(q[1]==1?1:q[0]));
        }
        return ans;
    }
    //using backtrack to generate all the factor combinations
    int numWays(int n,int start,unordered_map<int,int>& mp,int size){
        if(n<start){ //now we get one answer
            return ways(mp,size)%mod;
        }
        long ans=0;
        for(int i=start;i*i<=n;i++){
            if(n%i==0){
                mp[i]++,mp[n/i]++;
                ans+=ways(mp,size)%mod;ans%=mod;
                mp[n/i]--;
                ans+=numWays(n/i,i,mp,size)%mod;ans%=mod;
                mp[i]--;
            }
        }
        return ans;
    }
    int ways(unordered_map<int,int>& mp,int sz){
        //for(auto t: mp) cout<<"["<<t.first<<" "<<t.second<<"] ";cout<<endl;
        int sum=0;
        for(auto t: mp) sum+=t.second;
        if(sum>sz || sum==0) return 0;
        //C(n,m) 
        long ans=1;
        for(auto t: mp){
            ans*=comb(sz,t.second);
            sz-=t.second;
            ans%=mod;
        }
        return ans;
    }
    int comb(int n,int m){
        long ans=1;
        for(int i=1;i<=m;i++){
            ans=ans*(n-i+1)%mod*modinv_val[i];//modinv(i,mod-2,mod);
            ans%=mod;
        }
        return ans;
    }
    long modinv(int a,int n,int p){ //calculate a^-1%p -->a^(p-2)%p
        if(n==0) return 1;
        if(n%2) return a*modinv((long)a*a%p,n/2,p)%p;
        return modinv((long)a*a%p,n/2,p)%p;
    }        