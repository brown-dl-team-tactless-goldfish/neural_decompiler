//////////////////// Graph implementation ////////////////////
typedef struct node {
    int v;
    struct node* next;
} Node;
 
typedef struct adjList {        // Adjacency list
    Node *head;
} AdjList;
 
typedef struct graph {          // Graph structure
    int numV;                   // number of vertices
    AdjList* list;              // adjacency list
} Graph;
 
Node* newAdjListNode(int v) {
    Node* newNode = calloc(sizeof(Node), 1);
    newNode->v = v;
    return newNode;
}
 
Graph* createGraph(int v) {
    Graph* graph = calloc(sizeof(Graph), 1);
    graph->list = calloc(sizeof(AdjList), v);
    graph->numV = v;
    return graph;
}
 
void addEdge(Graph* graph, int src, int dest) {
    Node* newNode = newAdjListNode(dest);
    newNode->next = graph->list[src].head;
    graph->list[src].head = newNode;
}
//////////////////// End Graph /////////////////////////

void dfs(Graph *graph, int node, int *nodesVisited, bool *visited) {
    Node *child = graph->list[node].head;
    while(child) {
        if(!visited[child->v]) {
            visited[child->v] = true;
            (*nodesVisited)++;
            dfs(graph, child->v, nodesVisited, visited);           
        }
        
        child = child->next;
    }
}

int maximumDetonation(int** bombs, int bombsSize, int* bombsColSize){
    Graph *graph = createGraph(bombsSize);
    int res = INT_MIN, nodesVisited = 0;
    
    for(int i = 0; i < bombsSize; i++) {
        for(int j = 0; j < bombsSize; j++) {
            if(i != j) {
                if( bombs[i][2] >= sqrt(pow(bombs[i][0] - bombs[j][0], 2) + pow(bombs[i][1] - bombs[j][1], 2)) ) 
                    addEdge(graph, i, j);
            }
        }
    }
    
    for(int i = 0; i < bombsSize; i++) {
        bool visited[100] = {false};
        nodesVisited = 0;
        visited[i] = true;
        nodesVisited++;
        dfs(graph, i, &nodesVisited, visited);
        res = fmax(res, nodesVisited);        
    }
    return res;
}