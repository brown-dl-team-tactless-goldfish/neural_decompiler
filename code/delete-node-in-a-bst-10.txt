/*
    Algo:

    1. Traverse the tree until key is found.
    2. If key has left children:
        a. find the largest node in the left subtree.
        b. Assign key node with this node value.
        c. call deleteNode on the left subtree.

    else if key has right children
        a. find the smallest node in the right subtree.
        b. Assign key node with this node value.
        c. call deleteNode on the right subtree.

    else delete key node.

*/

int find_largest_node (struct TreeNode* node)
{
    if (node->right)
        return find_largest_node (node->right);
    return (node->val);
}

int find_smallest_node (struct TreeNode* node)
{
    if (node->left)
        return find_smallest_node (node->left);
    return (node->val);
}

/* This function deletes a node and recursively finds another
   node in the left or right subtrees to replace it. To do so
   it must again delete that replacement node in the subtree
   and so on... */
// Returns 1 -> caller should delete this node 
// Returns 0 -> No-op
bool traverse_and_delete (struct TreeNode* node, int key)
{
    if (!node)
        return 0;

    if (key > node->val)
    {
        if (traverse_and_delete (node->right, key) == 1)
        {
            node->right = NULL;
        }
        return 0;
    }
    else if (key < node->val)
    {
        if (traverse_and_delete (node->left, key))
        {
            node->left = NULL;
        }
        return 0;
    }
    else
    {
        if (node->left)
        {
            node->val = find_largest_node (node->left);
            if (traverse_and_delete (node->left, node->val) == 1)
                node->left = NULL;
            return 0;
        }
        else if (node->right)
        {
            node->val = find_smallest_node (node->right);
            if (traverse_and_delete (node->right, node->val))
                node->right = NULL;
            return 0;
        }
        else
        {
            return 1;
        }
    }

}

struct TreeNode* deleteNode(struct TreeNode* root, int key)
{
    if (traverse_and_delete (root, key))
        root = NULL;
    return root;
}