class Solution {
public:
    int minReorder(int n, vector<vector<int>>& connections) {
        
        //Set up the count and make forward (destinations indexed by origin) and backward (origins indexed by destination) adjacency matrices
        int changes = 0;
        vector<vector<int>> dest(n);
        vector<vector<int>> orig(n);
        for (auto& c : connections){
            dest[c[0]].push_back(c[1]);
            orig[c[1]].push_back(c[0]);
        }
        
        //Use bi-directional BFS traversal of network from zero to count all paths that need to be reversed and then return changes
        vector<int> reachesZero(n,0);
        queue<int> stops;
        stops.push(0);
        while (!stops.empty()){
            int cur = stops.front();
            reachesZero[cur] = 1;
            stops.pop();
            for (auto& d : dest[cur])        //If paths from source go toward the outer node, note a change is needed
                if (reachesZero[d] == 0){  
                    changes++;           
                    stops.push(d);
                }
            for (auto& o : orig[cur])        //If path comes toward zero, no change needed, mark for traversal
                if (reachesZero[o] == 0)
                    stops.push(o);
        }   
        
        return changes;
    }
};