class Solution {
public:
    vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) { 
        int n = nums.size();
		// 1. we need prefix sum to compute sum on the subarray [left,right]
        vector<int> prefSum(n+1, 0);
        for (int i = 1; i < n + 1; ++i)
            prefSum[i] = prefSum[i-1] + nums[i-1];
        // 2. we have to store index of the picked subarray to restore the result
        vector<vector<int>> parent(3, vector<int>(n+1, -1));
        // 3. simple dp
        vector<int> dp_prev(n+1,0), dp_cur(n+1,0);
        for (int c = 1; c <= 3; ++c) {
            for (int len = 1; len <= n; ++len) {
                dp_cur[len] = dp_cur[len-1];
                parent[c-1][len] = parent[c-1][len-1];
                if (len >= k) {
                    int v = dp_prev[len - k] + prefSum[len] - prefSum[len-k];
                    if (v > dp_cur[len]) {
                        dp_cur[len] = v;
                        parent[c-1][len] = len-k+1;
                    }
                }
            }
            swap(dp_prev, dp_cur);
        }
        
		// 4. to restore the path
		// we go from the right bottom point in matrix to the up left
		// so the parent[2][n] - store the index of the start of the last taken subarray +1
		// hence if we took it, at the previous level we need to take the one which is before this start
		// because they are not intersecting
        vector<int> res(3, -1);
        int p = n;
        for (int i = 2; i >= 0; --i) {
            res[i] = parent[i][p] - 1;
            p = res[i];
        }
        
        return res;
    }
};