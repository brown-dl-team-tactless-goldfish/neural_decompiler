class Solution {
public:
    vector<int> v; // number of descendents of each node
    map<int, vector<int>> m;
    
    int dfs(int n, int p) { 
        const auto &alv = m[n];
        int tot =1; 
        
        for(auto c : alv) {
            if (c == p) continue;
            tot +=dfs(c, n);
        }
        v[n] = tot;
        return tot;
    }
    
    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {
        const size_t n = roads.size();
        v.resize(n+1);
        m.clear();
        for (auto &x : roads) { // build the graph adjacency matrix
            int u = x[0], v = x[1];
            m[u].push_back(v);
            m[v].push_back(u);
        }
        
        dfs(0, -1); // perform dfs
        
        long long ans = 0;
        vector<bool> vis(n+1);
        queue<int> q;
        q.push(0);
        vis[0] = true;
        while (!q.empty()) {
            auto x = q.front();
            q.pop();
            for (auto y : m[x]) {
                if (!vis[y]) {
                    ans += (v[y] + seats - 1) / seats;
                    q.push(y);
                    vis[y] = true;
                }
            }
        }
        return ans;
    }
};