class Solution {
private:
    int rSize, cSize;
    int oneCnt;
    int flipCnt;
    int res;
    
    int dir[5] = {0, 1, 0, -1, 0};
    
    void flip(int r, int c, vector<vector<int>> &mat) {
        if (r < 0 || c < 0 || r >= rSize || c >= cSize) return;
        oneCnt += mat[r][c] ? -1 : 1;
        mat[r][c] = !mat[r][c];
    }
    
    void flipSelfAdj(int r, int c, vector<vector<int>> &mat) {
        flip(r, c, mat);
        for (int i = 0; i < 4; i++) {
            flip(r + dir[i], c + dir[i + 1], mat);
        }
    }
    
    void flipSlot(int r, int c, vector<vector<int>> &mat) {
        flipSelfAdj(r, c, mat);
        flipCnt++;
    }
    
    void reverseFlipSlot(int r, int c, vector<vector<int>> &mat) {
        flipSelfAdj(r, c, mat);
        flipCnt--;
    }
    
	// Idea: for each slot, either flip it or not flip it
	// time complexity 2 ^ (mn), m * n slots, each slot we create 2 paths (take / not take)
    void dfs(int currR, int currC, vector<vector<int>> &mat) {
        
        int nextC = (currC + 1) % cSize;
        int nextR = currR + (nextC <= currC ? 1 : 0);
        
        // case 1: flip current slot
        flipSlot(currR, currC, mat);
        if (oneCnt == 0) {
            res = min(res, flipCnt);
            reverseFlipSlot(currR, currC, mat);
            return;
        }
        for (int r = nextR; r < rSize; r++) {
            for (int c = nextC; c < cSize; c++) {
                dfs(r, c, mat);
            }
        }
        reverseFlipSlot(currR, currC, mat);
        
        // case 2: don't flip current slot
        for (int r = nextR; r < rSize; r++) {
            for (int c = nextC; c < cSize; c++) {
                dfs(r, c, mat);
            }
        }
    }
public:
    int minFlips(vector<vector<int>>& mat) {
        
        res = INT_MAX;
        
        oneCnt = 0;
        flipCnt = 0;
        
        rSize = mat.size();
        cSize = mat[0].size();
         
        // get initial 1 count
        for (int r = 0; r < rSize; r++) {
            for (int c = 0; c < cSize; c++) {
                if (mat[r][c] == 1) oneCnt++;
            }
        }
        
		// there is nothing to flip
        if (oneCnt == 0) return 0;
        
        dfs(0, 0, mat);
        
        return res == INT_MAX ? -1 : res;
    }
};