
struct node {
        int x;
        int y;
};

void enque_around(char **grid, int h, int w, int x, int y, struct node *queue, int *rear)
{
        if (y + 1 < w && grid[x][y + 1] == '1') {
                ++(*rear);
                queue[*rear].x = x;
                queue[*rear].y = y + 1;
                grid[x][y + 1] = '0';
        }
        if (y > 0 && grid[x][y - 1] == '1') {
                ++(*rear);
                queue[*rear].x = x;
                queue[*rear].y = y - 1;
                grid[x][y - 1] = '0';
        }
        if (x > 0 && grid[x - 1][y] == '1') {
                ++(*rear);
                queue[*rear].x = x - 1;
                queue[*rear].y = y;
                grid[x - 1][y] = '0';
        }
        if (x + 1 < h && grid[x + 1][y] == '1') {
                ++(*rear);
                queue[*rear].x = x + 1;
                queue[*rear].y = y;
                grid[x + 1][y] = '0';
        }
}

int numIslands(char** grid, int gridSize, int* gridColSize){
        int h = gridSize;
        int w = gridColSize[0];

        struct node *queue = malloc(h * w * sizeof(struct node));
        int front = -1;
        int rear = -1;

        int i, j;
        int count = 0;
        for (i = 0; i < h; i++) {
                for (j = 0; j < w; j++) {
                        if (grid[i][j] != '1')
                                continue;

                        grid[i][j] = '0';
                        enque_around(grid, h, w, i, j, queue, &rear);

                        while (front < rear) {
                                ++front;
                                enque_around(grid, h, w, queue[front].x, queue[front].y, queue, &rear);
                        }

                        count++;
                }
        }

        return count;
}