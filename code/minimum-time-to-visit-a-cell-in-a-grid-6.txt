class Solution {
public:
    int minimumTime(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        if (grid[0][1] > 1 && grid[1][0] > 1) {
            return -1;
        }
        priority_queue<
            pair<int, pair<int,int>>,
            vector<pair<int, pair<int,int>>>,
            greater<pair<int, pair<int,int>>>
            > pq;
        vector<vector<int>> vis(m, vector<int>(n,0));
        pq.push({0,{0,0}});
        int row[] = {-1, 0, 1, 0};
        int col[] = {0, -1, 0, 1};
        while(!pq.empty()) {
            pair<int, pair<int,int>> p = pq.top();
            pq.pop();
            int time = p.first;
            int r = p.second.first;
            int c = p.second.second;
            if(r == m-1 && c == n-1)
                return time;
            if(vis[r][c]) continue;
            vis[r][c] = 1;
            for(int k = 0;k<4;k++) {
                int i = r + row[k];
                int j = c + col[k];
                if(i < 0 || i >= m || j < 0 || j >= n || vis[i][j])
                    continue;
                int timeToVistNeighbor = (grid[i][j] - time)%2 == 0;
                pq.push({max(time+1, grid[i][j] + timeToVistNeighbor), {i, j}});
            }
        }

        return -1;
    }
};