struct position {
    int r;
    int c;
    position(int r, int c) : r(r), c(c) {}
};

#define EMPTY ('.')
#define WALL  ('+')

class Solution {
public:
    int nearestExit(vector<vector<char>> &maze, vector<int> &entrance) {
        int rows = maze.size(), cols = maze[0].size();
        queue<position> q;
        vector<vector<bool>> visited(rows, vector<bool>(cols, false));
        vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        int steps = 0;

        q.push(position(entrance[0], entrance[1]));
        while (!q.empty()) {
            int qLen = q.size();
            for (int i = 0; i < qLen; ++i) {
                position curr = q.front();
                q.pop();

                if (isBorder(curr.r, curr.c, rows, cols) && 
                    !isAtEntrance(curr.r, curr.c, entrance) && 
                    maze[curr.r][curr.c] == EMPTY) {
                    return steps;
                }

                for (const auto &dir : dirs) {
                    int nextR = curr.r + dir[0], nextC = curr.c + dir[1];
                    if (nextR < 0 || rows <= nextR || nextC < 0 || cols <= nextC || 
                        maze[nextR][nextC] == WALL || visited[nextR][nextC]) {
                        continue;
                    }
                    visited[nextR][nextC] = true;
                    q.push(position(nextR, nextC));
                }

            }
            ++steps;
        }

        return -1;
    }

private:
    bool isBorder(int r, int c, int rows, int cols) {
        return r == 0 || r == rows - 1 || c == 0 || c == cols - 1;
    }

    bool isAtEntrance(int r, int c, vector<int> &entrance) {
        return r == entrance[0] && c == entrance[1];
    }
};