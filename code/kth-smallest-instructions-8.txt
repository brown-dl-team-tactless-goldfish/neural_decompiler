class Solution {
public:
    void dfs(vector<vector<int>>& cnt, int m, int n, int r, string& res)
    {
        if(n == 0 || m == 0)
        {
            int s = m + n;
            char c = m > 0 ? 'H' : 'V';
            res += string(s, c);
            return;
        }
        
        int a = cnt[m - 1][n];
        int b = cnt[m][n - 1];
        
        if(r <= a) {
            res.push_back('H');
            dfs(cnt, m-1, n, r, res);
        } else {
            res.push_back('V');
            dfs(cnt, m, n - 1, r - a, res);
        }
        
    }
    
    string kthSmallestPath(vector<int>& destination, int k) 
    {
        int n = destination.front(), m = destination.back();
        vector<vector<int>> cnt(m + 1, vector<int>(n + 1, 1));
        for (int i = 1; i <= m; i ++)
            for (int j = 1; j <= n; j++)
                cnt[i][j] = cnt[i - 1][j] + cnt[i][j - 1];

        string res;
        dfs(cnt, m, n, k, res);
        return res;
    }
};