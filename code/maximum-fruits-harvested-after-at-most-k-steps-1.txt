class Solution {
public:
    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {
        
        // Find Relative Position Of Farmer Using Binary Search : O(logn)
       int index= searchIndex(fruits,startPos);
        
        // Now Calculate Prefix sum for Left Part
       int prefix_sum_left=0;
      map<int,int>mp_left;
        for(int i=index-1;i>=0;i--)
        {  prefix_sum_left+=fruits[i][1];
           mp_left[startPos-fruits[i][0]]=prefix_sum_left;
        }
        
        // Now Calculate Prefix sum for right Part
    int prefix_sum_right=0;
     map<int,int>mp_right;
       for(int i=index;i<fruits.size();i++)
       {
           prefix_sum_right+=fruits[i][1];
           mp_right[fruits[i][0]-startPos]=prefix_sum_right;
       }
        
    // For Optimal Approach:
         // There is only two way to collect fruits
            // 1. Go right -> turn left  -> Go left
            // 2. Go left  -> turn right  -> Go right
        
 
        // go to left -> then turn right -> go to right
        int ans=0;
        int sum=0;
        for(int i=index-1;i>=0;i--)
        {     
             int left_step=startPos-fruits[i][0];
            if(k-left_step<0)
                break;
            sum+=fruits[i][1];
            
        // If he now turn from here to right then how much max fruit he can collect
            auto it=mp_right.upper_bound(k-2*left_step);
            int right_val=0;
            if(it!=mp_right.begin())
            {
                it--;
                right_val+=(it->second);
            }
           ans=max(ans,sum+right_val);     
        }
        
        
     
        // go to right -> then turn left -> go to left
        sum=0;
        for(int i=index;i<fruits.size();i++)
        {
            int right_step=fruits[i][0]-startPos;
            if(k-right_step<0)
                break;
            sum+=fruits[i][1];
            
            
            // If he now turn left then how much max fruit he can collect
            auto it=mp_left.upper_bound(k-2*right_step);
            int left_val=0;
            if(it!=mp_left.begin())
            {
                it--;
                left_val+=it->second;
            }
            ans=max(ans,sum+left_val);
        }
        return ans;
        
    }
    
   
    int searchIndex(vector<vector<int>>&fruits,int startPos)
    {
        int i=0;
        int j=fruits.size()-1;
        while(i<=j)
        {
            int mid=i+(j-i)/2;
            if(fruits[mid][0]==startPos)
                return mid;
            else
            {
                if(fruits[mid][0]<startPos)
                    i=mid+1;
                else
                    j=mid-1;
            }
        }
        return i;
    }
};

Time Complexity: O(n+logn+n*log(n/2))
Space Complexity: O(n)