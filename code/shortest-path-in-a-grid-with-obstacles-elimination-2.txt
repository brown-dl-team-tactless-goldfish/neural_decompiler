struct node{
	int x;
    int y;
    int obs_cnt;
	struct node *next;
};

struct queue {
	struct node *front;
	struct node *rear;
    int size;
};

struct queue *createQueue(struct queue *queue)
{
	struct queue *queue1=(struct queue*)malloc(sizeof(struct queue));
	queue1->front=queue1->rear= NULL;
    queue1->size =0;
	return queue1;
}

struct node *createNode(int x, int y, int obs_cnt)
{
	struct node *node1 = (struct node*)malloc(sizeof(struct node));
	node1->x=x;
    node1->y=y;
    node1->obs_cnt=obs_cnt;
	node1->next = NULL;
	return node1;
}

bool isEmpty(struct queue *queue)
{
    if (queue->front == NULL)
        return true;
    return false;
}

void enqueue(struct queue *queue1, int x, int y, int obs_cnt)
{

	struct node *node = createNode(x, y, obs_cnt);
	struct queue *queue = queue1;
           
	if(queue->rear == NULL)
	{
		queue->rear = node;
		queue->front = node;
        queue->size++;
		return;
	}
	queue->rear->next = node;
	queue->rear = node;
    queue->size++;
	
}

struct node *dequeue(struct queue *queue)
{
	if (queue->front == NULL)
		return NULL;

	struct node *temp = queue->front;
	queue->front = queue->front->next;
	
	if(queue->front == NULL)
		queue->rear = NULL;
	queue->size--;
    return temp;
}




int shortestPath(int** grid, int gridSize, int* gridColSize, int k)
{
    int m = gridSize;
    int n = gridColSize[0];
    
    if(m ==0 || n ==0) return 0;
    
    int **obstacle = (int **)calloc(sizeof(int *), m);
    int **visited = (int **)calloc(sizeof(int *), m);
    int directions[4][2] = {{0,1}, {0,-1}, {-1,0}, {1,0}};
    
    for(int i =0; i<m; i++)
    {
        obstacle[i] = (int *)calloc(sizeof(int), n);
        visited[i] = (int *)calloc(sizeof(int), n);   
    }
    
    struct queue *queue = createQueue(queue);
    
    //Push node 0 - starting point
    enqueue(queue, 0,0,grid[0][0]);
    obstacle[0][0] = grid[0][0];
    visited[0][0] = 1;
    
    int level = 1;
    while(!isEmpty(queue))
    {
        int size = queue->size;
        //Step1: pop all the nodes in the same level - this is required to find various path.
        while(size-- > 0)
        {
            struct node *node = dequeue(queue);
            int fx = node->x;
            int fy = node->y;
            int curr_obscnt = node->obs_cnt;
            if(fx == m-1 && fy == n-1)
                return level-1;
        
            //Step2: 4 directions up, down, left right
            for(int i=0; i<4; i++)
            {
                int x = fx + directions[i][0];
                int y = fy + directions[i][1];
            
                if(x<0 || x>=m || y<0 || y>=n)
                    continue;
            
                //Step3: Fetch old & new obstacle
                int old_obs = obstacle[x][y];
                int new_obs = curr_obscnt + grid[x][y];
                
                //Step4: Node is not visited and the obstacle count is within the limit
                if(!visited[x][y] && new_obs <= k)
                {
                    enqueue(queue, x, y, new_obs);
                    obstacle[x][y] = new_obs;
                    visited[x][y] = 1;
                }
            
                //Step:5 Node is already visited but new path has less obstacles
                if(new_obs < old_obs && new_obs <=k)
                {
                    enqueue(queue, x, y, new_obs);
                    obstacle[x][y] = new_obs;
                    visited[x][y] = 1;
                }
            
            }
        }
        level++;
    }
    
    return -1;
}