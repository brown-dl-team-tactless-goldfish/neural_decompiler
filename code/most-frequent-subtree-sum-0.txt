/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
//
//計算樹的每個節點的值
//
int process(struct TreeNode* root){
    
    if(root == NULL)
        return 0;
    int cn = 0; 
    cn = process(root->left) + process(root->right) + 1;
    if(root->left != NULL){
        root->val += root->left->val;
    }
    if(root->right != NULL){
        root->val += root->right->val;
    }
    return cn;

}
//
// 將處理好的tree, 將node 存到陣列arr
//
void result(struct TreeNode* root, int* arr, int* id){
    if(root == NULL)
        return;
     result(root->left, arr, id);
     result(root->right, arr, id);
     arr[*id] = root->val;
     *id = *id + 1; 
}
//
//qsort function
//
int cmpfunc(const void* a, const void* b){
    return *(int*)a - *(int*)b;
}

//1. process() --->計算樹的每個節點的值
//2. result()  --->將處理好的tree, 將node 存到陣列arr
//3. 計算重複數字的個數
int* findFrequentTreeSum(struct TreeNode* root, int* returnSize){
    int count  = process(root);
    * returnSize = count;
    int* id = (int*)calloc(1 ,sizeof(int));
    int* data = (int*)malloc(count * sizeof(int));
    result(root, data, id);

    qsort(data, *id, sizeof(int), cmpfunc);
    //sum[i] 代表val , cn[i] 相同sum 的個數
    int* sum = (int*)malloc((*id) * sizeof(int));
    int* cn = (int*)calloc((*id), sizeof(int));
    sum[0] = data[0];
    cn[0] = 1;
    int index= 0;
    int maxCn = 1;  //maxCn 是
    int total = 1;
    //下面計算重複數字的個數.  maxCn 是最大重複個個數， total 代表有幾個maxCn
    //index+1 是代表有幾個group
    //>>>>
    for(int i = 1; i < (*id); i++){
        if(data[i] == data[i-1]){
            cn[index]++;
            if(i == (*id -1)){
                if(cn[index] > maxCn){
                    maxCn = cn[index];
                    total = 1;
                }
                else if(cn[index] == maxCn){
                    total++;
                }                
            }
        }
        else{
            index++;
            sum[index] = data[i];
            cn[index] = 1;
            if(cn[index-1] > maxCn){
                maxCn = cn[index-1];
                total = 1;
            }
            else if(cn[index-1] == maxCn){
                total++;
            }
        }
    }
    //<<<<<
    
    int* ans = (int*)malloc(total * sizeof(int));
    int t =0;
    for(int i =0; i <= index; i++){
        if(cn[i] == maxCn){
            ans[t] = sum[i];
            t++;
        }
    }
    free(id);
    free(data);
    free(cn);
    free(sum);
    * returnSize = total;
    return ans;
    
}