int BSF(int* nums, int n, int val){
    int left = 0, right = n-1;
    int mid;
    while(left < right){
        mid = left + (right - left) /2;
        if(nums[mid] >= val)
            left = mid + 1;
        else
            right = mid;
    }
    return left;
}

int constrainedSubsetSum(int* nums, int numsSize, int k){
    int n = numsSize;
    int max = INT_MIN;
    int* queue = malloc((n+1) * sizeof(int) );
    int* dp = malloc((n+1) * sizeof(int));
    dp[0] = 0;
    int head = 0;
    int tail = 1;
    queue[head] = 0;

    for(int i = 1; i <= k; i++){
        dp[i] = nums[i-1];
        if(queue[head] > 0)
            dp[i] += queue[head];   
        
        max = fmax(max, dp[i]);
        if(dp[i] < 0){
            continue;
        }
        else if(dp[i] > queue[head]){
             queue[head] = dp[i];
             tail = head + 1;   
        }
        else if(dp[i] <= queue[tail-1] ){
            queue[tail] = dp[i];
            tail++;
        }
        else{
            int z = BSF(&queue[head], tail - head , dp[i]);
            queue[head + z] = dp[i];
            tail = head + z+1;
        }
    }

    for(int i = k+1; i <= n; i++){
        dp[i] = nums[i-1];
        if(queue[head] > 0)
            dp[i] += queue[head];
        max = fmax(max, dp[i]);
        if((queue[head] == dp[i-k]) && (dp[i-k] > 0)){
            head++;
            if(head == tail){
                queue[head] = 0;
                tail = head + 1;
            }
        }
        if(dp[i] < 0){
            continue;
        }         
        else if(dp[i] > queue[head]){
             queue[head] = dp[i];
             tail = head + 1;   
        }
        else if(dp[i] <= queue[tail-1]){
            queue[tail] = dp[i];
            tail++;
        }
        else{
            int z = BSF(&queue[head], tail - head , dp[i]);
            queue[head + z] = dp[i];
            tail = head + z+1;
        }        
    }
    return max;
}