class Solution {
public:
    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {
        this->target = target;
        this->t = t;
        vector<vector<int>> g(n+1);
        for(auto& e:edges) {
            g[e[0]].push_back(e[1]);
            g[e[1]].push_back(e[0]);
        }
        g[1].push_back(-1); //fake parent
        dfs(g, 1, 0, -1, 1.0);
        return p;
    }
    
    void dfs(const vector<vector<int>>& g, int i, int depth, int parent, double prob){
        int numChild = g[i].size() - 1;
        if(i == target){
            if(depth == t || (depth < t && numChild == 0)) p = prob;
        }  
        for(auto child : g[i]){
            if(child == parent) continue;
            dfs(g, child, depth+1, i, prob/numChild);
        }
    }
    
    double p=0;
    int t = 0;
    int target = 0;
};