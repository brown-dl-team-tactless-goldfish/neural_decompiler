#define MAX_SIZE 2000

typedef struct Node {
    struct Node *children[26];
    bool isWord;
} Node;

typedef struct {
    Node *root;
    char *str;
    int count;
} StreamChecker;

Node *createNode() {
    Node *node = malloc(sizeof(Node));
    node->isWord = false;
    for (int i = 0; i < 26; i++) {
        node->children[i] = NULL;
    }
    return node;
}

void addWord(Node *root, char *word) {
    Node *node = root;
    for (char *ptr = word; *ptr != '\0'; ptr++) {
        char c = *ptr;
        if (!node->children[c - 'a']) {
            node->children[c - 'a'] = createNode();
        }
        node = node->children[c - 'a'];
    }
    node->isWord = true;
}

bool findWord(Node *root, const char *word, int start) {
    Node *node = root;
    while (start >= 0) {
        char c = word[start];
        if (!node->children[c - 'a']) {
            return false;
        }
        node = node->children[c - 'a'];
        if (node->isWord) {
            return true;
        }
        start--;
    }
    return false;
}

void reverse(char *word) {
    int left = 0, right = strlen(word) - 1;
    while (left < right) {
        char tmp = word[left];
        word[left] = word[right];
        word[right] = tmp;
        left++;
        right--;
    }
}

char *createString() {
    char *str = malloc(sizeof(char) * (MAX_SIZE + 2));
    memset(str, 0, MAX_SIZE + 2);
    return str;
}

StreamChecker *streamCheckerCreate(char **words, int wordsSize) {
    StreamChecker *checker = malloc(sizeof(StreamChecker));
    checker->root = createNode();
    checker->str = createString();
    checker->count = 0;
    for (int i = 0; i < wordsSize; i++) {
        reverse(words[i]);
        addWord(checker->root, words[i]);
    }
    return checker;

}

bool streamCheckerQuery(StreamChecker *obj, char letter) {
    if (obj->count >= MAX_SIZE) {
        free(obj->str);
        obj->count = 0;
        obj->str = createString();
    }
    obj->str[obj->count++] = letter;
    int count = obj->count;
    return findWord(obj->root, obj->str, count - 1);
}

void freeTrie(Node *root) {
    if (root == NULL) {
        return;
    }
    for (int i = 0; i < 26; i++) {
        if (root->children[i]) {
            freeTrie(root->children[i]);
        }
    }
    free(root);
}

void streamCheckerFree(StreamChecker *obj) {
    freeTrie(obj->root);
    free(obj->str);
    free(obj);
}