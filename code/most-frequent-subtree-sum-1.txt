/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Return an array of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */
#define SIZE 500
struct HashArray
{
    int key;
    int count;
    struct HashArray* next;
}Hash[SIZE];       //主函数中需要初始化
int addHash(int num)     //在Hash table中添加数据
{
    int temp=abs(num%SIZE);     //添加的数据可包括负数
    if(Hash[temp].key==0)
    {
        Hash[temp].key=num;
        Hash[temp].count++;
        return Hash[temp].count;
    }else if(Hash[temp].key==num)
    {
        Hash[temp].count++;   
        return Hash[temp].count;
    }else
    {
        struct HashArray *p=&Hash[temp]; 
        while(p->key!=num&&p->next!=NULL)    
        {p=p->next;}
        if(p->key==num)
        {
            p->count++;
            return p->count;
        }
        else
        {
            p->next=(struct HashArray*)malloc(sizeof(struct HashArray));
            p=p->next;
            p->key=num;
            p->count=1;   
            p->next=NULL;
            return p->count;
        }
    }   
    return 0;
}
int order(struct TreeNode* root,int *sum,int *max, int* returnSize){
    if(root==NULL){return 0;}
    int temp_sum=root->val+order(root->left,sum,max,returnSize)+order(root->right,sum,max,returnSize);
    int temp_count=addHash(temp_sum);
    if(temp_count>*max){
        *max=temp_count;
        *returnSize=0;
        sum[(*returnSize)++]=temp_sum;
    }else if(temp_count==*max){
        sum[(*returnSize)++]=temp_sum;
    }
    return temp_sum;
}
int* findFrequentTreeSum(struct TreeNode* root, int* returnSize) {
    int *sum=(int*)malloc(sizeof(int)*2500);
    memset(sum,0,sizeof(int)*2500);
    int max=0;
    *returnSize=0;
    for(int i=0;i<SIZE;i++){
        Hash[i].key=0;
        Hash[i].count=0;
        Hash[i].next=NULL;
    }
    order(root,sum,&max,returnSize);
    return sum;
}