class Solution {
public:
    vector<int> countSubgraphsForEachDiameter(int n, vector<vector<int>>& edges) {
        vector<int> res(n - 1);
        vector<vector<int>> dist(n + 1, vector<int>(n + 1, n));
        int size = (int)edges.size();
        floydwarshall(edges, dist);
        for (int i = 1; i < 1 << size; i++) {
            unordered_set<int> nodes;
            if (!isSubTree(i, edges, nodes)) {
                continue;
            }
            int d = maxDist(dist, nodes, n);
            res[d - 1]++;
        }
        return res;
    }

private:
    int maxDist(vector<vector<int>> dist, unordered_set<int>& nodes, int n) {
        int d = 0;
        for (int i : nodes) {
            for (int j : nodes) {
                if (i != j) {
                    d = max(d, dist[i][j]);
                }
            }
        }
        return d;
    }
    
    void floydwarshall(vector<vector<int>>& edges, vector<vector<int>>& dist) {
        int n = (int)dist.size();
        for (auto& edge : edges) {
            dist[edge[0]][edge[1]] = dist[edge[1]][edge[0]] = 1;
        }
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
    }
    
    bool isSubTree(int mask, vector<vector<int>>& edges, unordered_set<int>& nodes) {
        int n = (int)edges.size();
        int numOfEdges = 0;
        for (int i = 0; i < n; i++) {
            if ((1 << i) & mask) {
                nodes.insert(edges[i][0]);
                nodes.insert(edges[i][1]);
                numOfEdges++;
            }
        }
        return (int)nodes.size() - 1 == (int)numOfEdges;
    }
};