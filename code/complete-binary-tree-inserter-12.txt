class CBTInserter {
public:
    CBTInserter(TreeNode* root) : root_(root) {
        int level_sz = 1;
		q_[0].push_back(root);
        while (level_sz == (1 << level_)) {
            q_[~level_ & 1].resize(1 << (level_ + 1));
            idx_ = 0;
            level_sz = 0;
            for (auto const& n : q_[level_ & 1]) {
                if (!n) break;
                bool is_full = true;
                for (auto* const c : {n->left, n->right}) {
                    if (c) {
                        q_[~level_ & 1][idx_++] = c;
                        ++level_sz;
                    } else {
                        is_full = false;
                        break;
                    }
                }
                if (!is_full) break;
            }
            ++level_;
        }
    }
    
    int insert(int v) {
        auto* n = new TreeNode(v);
        if (idx_ == (1 << level_)) {
            ++level_;
            q_[level_ & 1].resize(1 << level_ + 1);
            idx_ = 0;
        }
        auto* const p = q_[~level_ & 1][idx_ / 2];
        if (idx_ & 1) p->right = n; else p->left = n;
        q_[level_ & 1][idx_] = n;
        ++idx_;
        return p->val;
    }
    
    TreeNode* get_root() {
        return root_;
    }
private:
    int level_{0};
    int idx_{0};
    array<vector<TreeNode*>, 2> q_;
    TreeNode* const root_;
};