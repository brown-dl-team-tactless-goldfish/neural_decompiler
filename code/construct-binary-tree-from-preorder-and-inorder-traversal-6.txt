typedef struct TreeNode tn;
struct hash_map{
  int key;                   /* key */
  int val; 
  UT_hash_handle hh;         /* makes this structure hashable */
};
typedef struct hash_map map;
map* ht;

void htAdd(int key, int value) {
    map* s;
    HASH_FIND_INT(ht, &key, s);  /* id already in the hash? */
    if (s==NULL) {
      s = (map*)malloc(sizeof(map));
      s->key = key;
      HASH_ADD_INT(ht, key, s);  /* id: name of key field */
    }
    s->val = value;
}
map* htFind(int key) {
    map* s;
    HASH_FIND_INT(ht, &key, s);  /* s: output pointer */
    return s;
}
void htCleanup(){
    map *cur, *tmp;
    HASH_ITER(hh, ht, cur, tmp)
    {
        HASH_DEL(ht, cur);  /* delete it (users advances to next) */
        free(cur);            /* free it */
    }
}
/*
void htPrint() {
    map* s;
    for(s=ht; s != NULL; s=(map*)(s->hh.next))
        printf("key %d:  value %d\n", s->key, s->val);
}
*/

tn* helper(int* preO, int* inO, int inS, int start, int end, int *posPreO)
{
  (*posPreO)++;
  if(end < start || *posPreO == inS)
  {
    (*posPreO)--;
    return NULL;  
  }

  map* htRet = htFind(preO[*posPreO]);
  if(htRet == NULL)
  {
    perror("something is wrong; the two lists do not match!");
    return NULL; 
  }

  int posInO = htRet->val;    /* found the node's position in in-order list */
  
  tn* node = (tn*)malloc(sizeof(tn));
  node->val = preO[*posPreO];
  node->left = helper(preO, inO, inS, start, posInO-1, posPreO);
  node->right = helper(preO, inO, inS, posInO+1, end, posPreO);
  return node;
}

tn* buildTree(int* preO, int preS, int* inO, int inS)
{
  int posPreO = -1;             /* starting from -1 since ++ at the beginning of helper */
  ht = NULL;                    /* initialize hastmap */
  for(int i = 0; i<inS; i++)
    htAdd(inO[i], i);           /* build hashmap according to the inorder list */

  tn* res =  helper(preO, inO, inS, 0, inS-1, &posPreO);

  htCleanup();
  return res;
}