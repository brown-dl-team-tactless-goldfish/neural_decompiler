int currCount = 0, maxCount = 0;
int modeCount = 0, currVal = 0;
int *modes = NULL;

void handleValue(int val){
    if(val != currVal){
        currVal = val;
        currCount = 0;
    }
    currCount++;
    if(currCount > maxCount){ // Calculating maxCount(max freqency)
        maxCount = currCount;
        modeCount = 1; // atleast 1 mode is there in case all nodes are different
    }
    else if(maxCount == currCount) { // entering data(s) of max freqency into modes array
        if(modes){
            modes[modeCount] = currVal;
        }
        modeCount++;
    }
}

void inOrder(struct TreeNode* root){ // Morris Traversal
    if(!root) return;
    struct TreeNode* pre = NULL, *curr = root;
    while(curr){
        if(curr->left == NULL){
            handleValue(curr->val);
            curr = curr->right;
        }
        else{
            pre = curr->left;
            while(pre->right && pre->right != curr){
                pre = pre->right;
            }
            if(!pre->right){
                pre->right = curr;
                curr = curr->left;
            }
            else{
                pre->right = NULL;
                handleValue(curr->val);
                curr = curr->right;
            }
        }
    }
}


int* findMode(struct TreeNode* root, int* returnSize){
    if(!root) return NULL;
	// Freeing the memory allocated for previous test case
    if(modes){
        modes = (int *) realloc(modes, 0);
    }

    currCount = 0;
    maxCount = 0;
    inOrder(root);
    
    modes = (int *) realloc(modes, modeCount * sizeof(int));
    *returnSize = modeCount;

    modeCount = 0;
    currCount = 0;
    inOrder(root);
    return modes;
}