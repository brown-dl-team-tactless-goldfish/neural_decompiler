/* 
a後面只能跟著e  
所以當有 n 個字母時  此時的可能性就是當 n-1 個字母時e的可能性  
list[n][0] = list[n-1][1]

e後面只能跟著a或i 
所以當有 n 個字母時  此時的可能性就是當 n-1 個字母時a的可能性 + i的可能性  
list[n][1] = list[n-1][0] + list[n-1][2]

i不能重複出現
所以當有 n 個字母時  此時的可能性就是當 n-1 個字母時a的可能性 + e的可能性 + o的可能性 + u的可能性  
list[n][2] = (list[n-1][0] + list[n-1][1] + list[n-1][3] + list[n-1][4])

o後面只能跟著i或u
所以當有 n 個字母時  此時的可能性就是當 n-1 個字母時i的可能性 + u的可能性
list[n][3] = (list[n-1][2] + list[n-1][4])

u後面只能跟著a
所以當有 n 個字母時  此時的可能性就是當 n-1 個字母時a的可能性
list[n][4] = list[n-1][0]
*/


#define mod 1000000007

int countVowelPermutation(int n){
    long long list[2][5];            //節省空間 因為只會用到上一次的數字 所以用兩個空間就夠了
    for (int i = 0 ; i < 5 ; i++){   //當只有一個字母時 每個字母開頭的可能都只有1種 [a] [e] [i] [o] [u]
        list[0][i] = 1;
    }
    
    int last = 0;
    int now;
    for (int i = 1 ; i < n ; i++){
        now = i&1;   //now = i%2;
        list[now][0] = list[last][1] % mod; 
        list[now][1] = (list[last][0] + list[last][2]) % mod;
        list[now][2] = (list[last][0] + list[last][1] + list[last][3] + list[last][4]) % mod;
        list[now][3] = (list[last][2] + list[last][4]) % mod;
        list[now][4] = list[last][0] % mod;
        last = now;
    }
    int ans = (list[last][0] + list[last][1] + list[last][2] + list[last][3] + list[last][4]) % mod;
    return ans;
}