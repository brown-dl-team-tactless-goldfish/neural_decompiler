class Solution {
public:
    double minAreaFreeRect(vector<vector<int>>& points) {
        auto pack = [](const vector<int> &p) {
            return (uint64_t(p[0])<<32) | p[1];
        };

        unordered_set<int64_t> s;
        for (const auto &p : points) {
            s.insert(pack(p));
        }

        double best = -1;
        for (int a_index=0; a_index<points.size(); ++a_index) {
            const auto &a = points[a_index];
            for (int b_index=a_index+1; b_index<points.size(); ++b_index) {
                const auto &b = points[b_index];
                for (int c_index=b_index+1; c_index<points.size(); ++c_index) {
                    const auto &c = points[c_index];
                    const int ab_x = b[0]-a[0];
                    const int ab_y = b[1]-a[1];

                    const int ac_x = c[0]-a[0];
                    const int ac_y = c[1]-a[1];

                    if (ab_x*ac_x+ab_y*ac_y != 0) continue;

                    const int d_x  = a[0] + ab_x + ac_x;
                    const int d_y  = a[1] + ab_y + ac_y;

                    if (s.find(pack({d_x, d_y})) == s.end()) {
                        continue;
                    }

                    const double area = sqrt((double(ab_x)*ab_x+ab_y*ab_y)*(ac_x*ac_x+ac_y*ac_y));
                    if (area>0.000000001) {
                        if (best<0 || area<best) {
                            best = area;
                        }
                    }
                }
            }
        }

        return best < 0 ? 0 : best;
    }
};