using A = array<int, 6>;

void nxt(int& x) {
    int c = x & -x, r = x + c;
    x = (((x ^ r) >> 2) / c) | r;
}

int sq(int x) {
    int y = int(sqrt(x));
    return y * y == x;
}

class Solution {
  public:
    int numSquarefulPerms(vector<int>& nums) {
        int n = size(nums);
        if (n == 1) return 1;
        sort(begin(nums), end(nums));
        int ans = 0;
        A l, r;
        set<A> lh, rh;
        for (int s = (1 << n / 2) - 1; s < 1 << n; nxt(s)) {
            l = r = {};
            for (int i = 0, li = 0, ri = 0; i < n; i++)
                (s >> i & 1 ? l[li++] : r[ri++]) = nums[i];
            if (auto lit = lh.find(l), rit = rh.find(r);
                lit == end(lh) && rit == end(rh))
                lh.insert(lit, l), rh.insert(rit, r);
            else
                continue;
            map<int, int> lc, rc;
            do {
                int ok = 1;
                for (int i = 1; ok && i < n / 2; i++) ok &= sq(l[i - 1] + l[i]);
                if (ok) lc[l[n / 2 - 1]]++;
            } while (next_permutation(begin(l), begin(l) + n / 2));
            do {
                int ok = 1;
                for (int i = 1; ok && i < n - n / 2; i++)
                    ok &= sq(r[i - 1] + r[i]);
                if (ok) rc[r[0]]++;
            } while (next_permutation(begin(r), begin(r) + (n - n / 2)));
            for (auto [x, c] : lc)
                for (auto [y, d] : rc)
                    if (sq(x + y)) ans += c * d;
        }
        return ans;
    }
};