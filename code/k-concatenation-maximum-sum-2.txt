int max(int a, int b)
{
    if(a > b)
        return a;
    else
        return b;
}

int kConcatenationMaxSum(int* arr, int arrSize, int k){
    
    if(arrSize == 0)
        return 0;

    int i, sum, pos_count = 0, neg_count = 0, find_time = 0;
    long cur_max, max_so_far, max_globe, minus;

    // Do some check. If array are all positive, return sum of array and
    // Multiply the k times. If array are all negative, return 0.

    for(i=0; i<arrSize; i++)
    {
        if(arr[i] < 0)
            neg_count++;
        if(arr[i] > 0)
            pos_count++;
        if(pos_count > 0 && neg_count > 0)
            break;
    }

    if(neg_count == arrSize)
        return 0;
    else if(neg_count == 0)
    {
        sum = 0;
        for(i=0; i<arrSize; i++)
            sum += arr[i];
        return sum*k;
    }

    
    // This can be divided into two case.
    // 1. Each Repeating has the same ascending,
    //    just multiply the same value.
    // 2. Each Repeating hasn't any ascending,
    //    just return the first answer.
    
    cur_max = 0;
    max_so_far = 0;
    max_globe = 0;
    while(k)
    {
        for(i=0; i<arrSize; i++)
        {
            cur_max = max(arr[i%arrSize], cur_max + arr[i%arrSize]);
            max_so_far = max(max_so_far, cur_max);
        }

        if(max_globe < max_so_far)
        {
            find_time++;
            if(find_time >= 3)
            {
                minus = max_so_far - max_globe;
                max_globe = max_so_far;
                k--;
                break;
            }
            else
                max_globe = max_so_far;
        }
        else
            return max_globe;

        k--;
    }

    max_so_far += minus*k;

    return max_so_far%(1000000007);
}