
struct Heap {
    int data[10005*2];
    int n;
};

void swap(int* a, int* b) {
    int t, i;
    for (i = 0; i < 2; i++) {
        t = a[i]; a[i] = b[i]; b[i] = t;
    }
}

int norm(int *a) {
    return a[0]*a[0]+a[1]*a[1];
}

void heapifyUp(struct Heap* h, int j) {
    int i; // parent
    if (j == 0) {
        return;
    }
    if (j % 2 == 0) {
        i = j/2-1;
    } else {
        i = (j-1)/2;
    }
    if (norm(&h->data[2*i]) < norm(&h->data[2*j])) {
        swap(&h->data[2*i], &h->data[2*j]);
        heapifyUp(h, i);
    }
}

void heapifyDown(struct Heap* h, int i) {
    int l, r, largest;
    if (i >= h->n) {
        return;
    }
    l = 2*i+1;
    r = 2*i+2;
    largest = i;
    if (l < h->n && norm(&h->data[2*largest]) < norm(&h->data[2*l])) {
        largest = l;
    }
    if (r < h->n && norm(&h->data[2*largest]) < norm(&h->data[2*r])) {
        largest = r;
    }
    if (largest != i) {
        swap(&h->data[2*i], &h->data[2*largest]);
        heapifyDown(h, largest);
    }
}

void add(struct Heap* h, int* val) {
    h->data[2*h->n] = val[0];
    h->data[2*h->n+1] = val[1];
    h->n++;
    heapifyUp(h, h->n-1);
}

void replace(struct Heap* h, int* val) {
    h->data[0] = val[0];
    h->data[1] = val[1];
    heapifyDown(h, 0);
}

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** kClosest(int** points, int pointsSize, int* pointsColSize, int k, int* returnSize, int** returnColumnSizes){
    struct Heap h;
    int i;
    int** r;
    h.n = 0;
    for (i = 0; i < pointsSize; i++) {
        if (h.n < k) {
            add(&h, points[i]);
        } else {
            int* first = h.data;
            if (norm(first) > norm(points[i])) {
                replace(&h, points[i]);
            }
        }
    }
    *returnSize = h.n;
    *returnColumnSizes = malloc(h.n * sizeof(int));
    r = malloc(h.n*sizeof(int*));
    for (i = 0; i < h.n; i++) {
        (*returnColumnSizes)[i] = 2;
        r[i] = malloc(2*sizeof(int));
        r[i][0] = h.data[2*i];
        r[i][1] = h.data[2*i+1];
    }
    return r;
}