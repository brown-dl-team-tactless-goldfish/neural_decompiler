/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
#define null 0
typedef struct
{
    char *ser;
    int len;
    int count;
} Serialize;

void sinit(Serialize* s)
{
    s->len = 180;
    s->count = 0;
    s->ser=malloc(sizeof(int)*s->len);    
}

void dinit(Serialize* s, char* ser)
{
    s->len   = strlen(ser);
    s->count = 0;
    s->ser=ser;
}

void spush(Serialize* s,int val,bool nul)
{
    if ((s->count+80)>=s->len)
    {
        char *ser = s->ser;
        s->ser=malloc(sizeof(int)*s->len*2);
        memcpy(s->ser,ser,sizeof(int)*s->len);
        s->len *=2;
        free(ser);
    }
    if (nul)
        s->count +=sprintf(s->ser+s->count,",");
    else
        s->count +=sprintf(s->ser+s->count,"%d,",val);
}

struct TreeNode* spop(Serialize* ser)
{
    if (!ser->ser[0]) return null;
    if(ser->ser[0] == ',')
    {
        ser->count++;
        ser->ser++;
        return null;
    }
    char s_val[40];
    char *s = s_val;

    struct TreeNode* node = malloc(sizeof(struct TreeNode));
    /*
    char c = 0;
    while ((*s++ = *ser->ser++) != ',');

    *s = 0;
    node->val = atoi(s_val);
    */
    node->val = (int) strtol(ser->ser,&ser->ser,0);
    ser->ser++; // remove',''
    
    node->left = spop(ser);
    node->right = spop(ser);
    return node;
}

void push_node(Serialize* s,struct TreeNode *node)
{
    if (!node)
    {
        spush(s,0,1); // push empty space
        return;
    }
    spush(s,node->val,0);
    push_node(s,node->left);
    push_node(s,node->right);
}

/** Encodes a tree to a single string. */
char* serialize(struct TreeNode* root) 
{
   Serialize s;
   sinit(&s);
   push_node(&s,root);
   return(s.ser);    
}

/** Decodes your encoded data to tree. */
struct TreeNode* deserialize(char* data) 
{
   Serialize s;
   dinit(&s,data);
   return spop(&s);
}

// Your functions will be called as such:
// char* data = serialize(root);
// deserialize(data);