class Solution {
    int delta[4][2] = { -1, 0, 1, 0, 0, -1, 0, 1 };
public:
    int cutOffTree(vector<vector<int>>& f) {
        int m = f.size(), n = f[0].size();
        auto cmp = [](vector<int>& a, vector<int>& b) { return a[2] > b[2]; };
        priority_queue<vector<int>, vector<vector<int>>, decltype(cmp)> trees(cmp);
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                if (f[i][j] > 1) trees.push({ i, j, f[i][j] });
        auto dist = [&](int i0, int j0, int i1, int j1) {
            if (i0 == i1 && j0 == j1) return 0;
            queue<pair<int, int>> q; q.push({ i0, j0 });
            unordered_map<int, unordered_map<int, int>> visited{ { i0,{ { j0, 1 } } } };
            for (int steps = 1; !q.empty(); steps++)
                for (int k = q.size(); k > 0; k--) {
                    pair<int, int> p = q.front(); q.pop();
                    for (int d = 0; d < 4; d++) {
                        int i = p.first + delta[d][0], j = p.second + delta[d][1];
                        if (i == i1 && j == j1) return steps;
                        if (i < 0 || m <= i || j < 0 || n <= j || !f[i][j] || visited[i][j]++) continue;
                        q.push({ i, j });
                    }
                }
            return -1;
        };
        int total = 0, d = 0; // d: dist
        vector<int> t; // t: tree
        for (int i = 0, j = 0; !trees.empty(); i = t[0], j = t[1], total += d) {
            t = trees.top(); trees.pop();
            if ((d = dist(i, j, t[0], t[1])) == -1) return -1;
        }
        return total;
    }
};