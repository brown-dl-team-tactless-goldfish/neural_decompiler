public class Solution 
{
    public IList<string> MaxNumOfSubstrings(string s) 
    {
        //Prepare a dict with start and end index for each character
        Dictionary<char,int[]> dict = new Dictionary<char,int[]>();
        
        for(int i=0;i<s.Length;i++)
        {
            if(!dict.ContainsKey(s[i]))
            {
                dict.Add(s[i],new int[]{i,-1});
            }
            dict[s[i]][1]=i;
        }
        
        //Prepare a list of all the valid substring range
        List<(int st,int en)> li = new List<(int st,int en)>();
        
        for(int i=0;i<s.Length;i++)
        {
            int[] ind = dict[s[i]];
            int st = ind[0];
            
            if(st!=i)
                continue;
            
            int en = ind[1];
            bool found = true;
            
            for(int j=st+1;j<en;j++)
            {
                ind = dict[s[j]];
                
                if(ind[0] < st)
                {
                    found = false;
                    break;
                }
                
                if(ind[1]>en)
                    en=ind[1];
            }
            
            if(found)
                li.Add((st,en));
        }
        
        //Sort the list on substring lengths in ascending order
        li.Sort((x,y)=>(x.en-x.st).CompareTo(y.en-y.st));
        
        //ans list for smallest substrings without conflicts
        List<string> ans = new List<string>();
        ans.Add(s.Substring(li[0].st,li[0].en-li[0].st+1));
        
        for(int i=1;i<li.Count;i++)
        {
            bool conflict = false;
            for(int j=0;j<i;j++)
            {
                //check for conflicts
                if(!((li[j].st<li[i].st && li[j].en<li[i].st) || (li[j].st>li[i].en && li[j].en>li[i].en)))
                    conflict = true;
            }
            
            if(!conflict)
                ans.Add(s.Substring(li[i].st,li[i].en-li[i].st+1));
        }
        
        return ans;
    }
}