class BookMyShow {
public:
    // 0 max 1 sum,
    vector<array<long long, 2>> tree;
    vector<int> index;
    int m;
    int n;
    inline int lc(int o) { return (o << 1) ; }
    inline int rc(int o) { return (o << 1) + 1; }
    
    void build(int o, int l, int r) {
        if (l == r) {
            tree[o][1] = m;
            tree[o][0] = m;
            return;
        } 
        int mid = (l + r) >> 1;
        build(lc(o), l, mid);
        build(rc(o), mid + 1, r);
        update(o, l, r);
    }
    inline void update(int o, int l, int r) {
        int lo = lc(o);
        int ro = rc(o);
        tree[o][1] = tree[lo][1] + tree[ro][1];
        tree[o][0] = max(tree[lo][0], tree[ro][0]);
    }
    
    void querymax(int o, int l, int r, long long& k, int maxr, vector<int>& ans) {
        if (l > maxr || k == 0) return;
        if (tree[o][0] < k) {
            return;
        }
        if (l == r) {
            ans = {l, (int)(index[l])};
            k = 0;
            return;
        } 
        int mid = (l + r) >> 1;
        querymax(lc(o), l, mid, k, maxr, ans);
        querymax(rc(o), mid + 1, r, k, maxr, ans);
    }
    
    void updatemax(int o, int l, int r, long long& k, int maxr) {
        if (l > maxr || k <= 0) return;
        if (tree[o][0] < k) return;
        if (l == r) {
                index[l] += k;
                tree[o][1] -= k;
                tree[o][0] -= k;
                k = 0;
            return;
        }
        int mid = (l + r) >> 1;
        updatemax(lc(o), l, mid, k, maxr);
        updatemax(rc(o), mid + 1, r, k, maxr);
        update(o, l, r);
    }
    
    void querysum(int o, int l, int r, long long& k, int& maxr) {
        if (l > maxr || k == 0) return;
        if (r <= maxr) {
            long long mn = min(tree[o][1], k);
            k -= mn;
            return;
        }
        int mid = (l + r) >> 1;
        querysum(lc(o), l, mid, k, maxr);
        querysum(rc(o), mid + 1, r, k, maxr);
    }
    
    void updatesum(int o, int l, int r, long long& k, int& maxr) {
        if (l > maxr || k <= 0) return;
        if (l == r) {
            int mn = min((tree[o][1]), k);
            k -= mn;
            index[l] += mn;
            tree[o][1] -= mn;
            tree[o][0] -= mn;
            return;
        }
        int mid = (l + r) >> 1;
        updatesum(lc(o), l, mid, k, maxr);
        updatesum(rc(o), mid + 1, r, k, maxr);
        update(o, l, r);
    }
    static const int base = 1;
    BookMyShow(int n1, int m1) {
        n = n1;
        m = m1;
        index = vector<int>(n, 0);
        tree.resize(n * 4 + 1);
        build(base, 0, n -1);
    }
    
    vector<int> gather(int k, int maxRow) {
        long long k1 = k;
        vector<int> ans;
        querymax(base, 0, n - 1, k1, maxRow, ans);
        if (k1 == 0) {
            long long k2 = k;
            updatemax(base, 0, n - 1, k2, maxRow);
        }
        return ans;
    }
    
    bool scatter(int k, int maxRow) {
        long long k1 = k;
        querysum(base, 0, n - 1, k1, maxRow);
        if (k1 > 0) return false;
        long long k2 = k;
        updatesum(base, 0, n - 1, k2, maxRow);
        return true;
    }
};