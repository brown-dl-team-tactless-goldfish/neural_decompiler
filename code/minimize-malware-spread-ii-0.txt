
void dfs(int **graph, int n, int i, int *affected, int * affectedby, int c, int *infected, int *visited)
{
    if (i != c) {
        affected[i] += 1;
        if (affected[i] == 1)
            affectedby[i] = c;
    }
    for (int j = 0; j < n; j++ ) {
        if (graph[i][j] == 1 && i != j && infected[j] == 0 && visited[j] != 1) {
           visited[j] = 1;
           dfs(graph, n, j, affected, affectedby, c, infected, visited);
        }
    }
}

int minMalwareSpread(int** graph, int graphSize, int* graphColSize, int* initial, int initialSize){
    
    int *colors, n = graphSize, c = 1, *size, i, *count, ans = -1, *infected, *affected, *affectedby, *visited;
    
    if (!graph || !graphSize || !initial || !initialSize)
        return -1;
    
    infected = calloc(1, sizeof(int) * n);
    for (i = 0; i < initialSize; i++)
        infected[initial[i]] = 1;
    
    affected = calloc(1, n * sizeof(int)); // To track count of affect at each node
    affectedby = calloc(1, n * sizeof(int));// To track who affected a non initial node first
    size = calloc(1, sizeof(int) * n); // To track how many unique nodes an initial node affects
    
  
    // Do dfs for nodes in initial only, calculate affected counts of each node not in initial, also track who first affected it.
    visited = calloc(1, n * sizeof(int));
    for (i = 0; i < initialSize; i++) {
        dfs(graph, n, initial[i], affected, affectedby, initial[i], infected, visited);
        memset(visited, 0, n * sizeof(int));
    }
    
    // If any node is affected is only once, increment the count for the affecting node
    for (i = 0; i < n; i++)
        if (affected[i] == 1)
            size[affectedby[i]]++;

        
    /* find the node with max count */
    for (i = 0; i < n; i++) {
        if (size[i] > 0) {
            if (ans == -1 || size[i] > size[ans])
                ans = i;
        }
    }
    
    if (ans == -1)
        for (i = 0; i < initialSize; i++) {
            if (ans == -1 || initial[i] < ans)
                ans = initial[i];
        }
                
    
    return ans;   

}