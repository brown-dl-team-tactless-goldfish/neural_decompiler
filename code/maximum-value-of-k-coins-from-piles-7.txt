class Solution {
public:
    int maxValueOfCoins(vector<vector<int>>& piles, const int k) {
        computePrefixSumInPlace(piles);

        const int n = piles.size();
        // Let f[i][j] be the max value from gathering j coins from piles[0..i].
        vector<vector<int>> f(n); // we'll create f[i] dynamically according to piles[i]'s size.
        // bottom-up DP
        { // initialize
            const auto& currPile = piles[0];
            f[0].assign(k + 1, 0);
            for (int c = 1; c <= min(k, (int)currPile.size()); ++c) {
                // c is the count of coins we gather.
                // f[0][c] is simply the same as the prefix sum of piles[0][c-1].
                // f[0][1] is the value of gathering the first coin which is piles[0][0].
                f[0][c] = piles[0][c - 1];
            }
        }
        //  f[i][j] = max of (psum[i][c] + f[i-1][j-c]) if we gather c coins from piles[i],
        //      then gather j-c coins from piles[0..i-1].
        for (int i = 1; i < n; ++i) {
            const auto& currPile = piles[i];
            f[i].assign(k + 1, 0);
            for (int j = 1; j <= k; ++j) { // j coins in total
                for (int c = 0; c <= min(j, (int)currPile.size()); ++c) {
                    // c is the number of coins we gather from current pile.
                    // then j-c coins will be gathered from previous piles.
                    f[i][j] = max( //
                            f[i][j],
                            (c - 1 >= 0 ? currPile[c - 1] : 0) // coins from curr pile
                                    + f[i - 1][j - c]); // coins from previous piles.
                }
            }
        }

        return f[n - 1][k];
    }

private:
    static void computePrefixSumInPlace(vector<vector<int>>& piles) {
        for (auto& p : piles) {
            for (int i = 1; i < p.size(); ++i) {
                p[i] += p[i - 1];
            }
        }
    }
};