public class Solution {
    public int[] ShortestAlternatingPaths(int n, int[][] red_edges, int[][] blue_edges) {
        int[] result = new int[n];
        Dictionary<int, List<Tuple<int, char>>> graph = new Dictionary<int, List<Tuple<int, char>>>();
        Queue<Tuple<Tuple<int, char>, int>> queue = new Queue<Tuple<Tuple<int, char>, int>>();
        bool[] redVisited = new bool[n],
               blueVisited = new bool[n];
        
        for (int i = 1; i < n; i++)
            result[i] = -1;
        
        for (int i = 0; i < n; i++)
            graph.Add(i, new List<Tuple<int, char>>());
        
        foreach (var item in red_edges)
            graph[item[0]].Add(new Tuple<int, char>(item[1], 'R'));
        
        foreach (var item in blue_edges)
            graph[item[0]].Add(new Tuple<int, char>(item[1], 'B'));
        
        queue.Enqueue(new Tuple<Tuple<int, char>, int>(new Tuple<int, char>(0, 'X'), 0));
        redVisited[0] = true;
        blueVisited[0] = false;
        
        while (queue.Count > 0)
        {
            var cur= queue.Dequeue();
            
            if (result[cur.Item1.Item1] == -1)
                result[cur.Item1.Item1] = cur.Item2;
            
            foreach (var item in graph[cur.Item1.Item1])
                if ((item.Item2 != cur.Item1.Item2 && (item.Item2 == 'R' && !redVisited[item.Item1] || item.Item2 == 'B' && !blueVisited[item.Item1])) || cur.Item1.Item2 == 'X')
                {
                    queue.Enqueue(new Tuple<Tuple<int, char>, int>(item, cur.Item2 + 1));
                    
                    if (item.Item2 == 'R')
                        redVisited[item.Item1] = true;
                    else
                        blueVisited[item.Item1] = true;
                }
        }
        
        return result;
    }
}