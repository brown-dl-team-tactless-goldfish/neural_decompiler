class Solution {
public:
    int leftmostbit(int x){
        return __builtin_ffs(x)-1;
    }
    int rightmostbit(int x){
        return 31 - __builtin_clz(x);
    }
    
    int minCompat(int mask, vector<int>& nums){
        int rsb = rightmostbit(mask);
        int lsb = leftmostbit(mask);
        int prev = lsb;
        for(int i=lsb+1; i<=rsb; i++){
            if(mask&(1<<i)){
                if(nums[prev] == nums[i])
                    return INT_MAX;
                prev = i;
            }
        }
        return  nums[rsb] - nums[lsb];
    }
    
    const int N = 16+1;
    int minimumIncompatibility(vector<int>& nums, int k) {

        int n = nums.size();
        
        if(n%k!=0)
            return -1;
        int np = n/k;
        vector<int>freq(N);
        for(auto& x:nums){
            freq[x]++;
            if(freq[x]>k)
                return -1;
        }
        
        int fmask = (1<<n)-1;
        
        sort(nums.begin(), nums.end());
      
        vector<long>dp(fmask+1,INT_MAX);
        dp[0] = 0;
        for(int mask=1; mask<fmask+1; mask++){
            if(__builtin_popcount(mask)%np != 0)
                continue;
            for(int submask = mask; submask>0; submask = (submask-1)&mask){
                if(__builtin_popcount(submask) != np)
                    continue;
                dp[mask] = min(dp[mask], dp[mask-submask] + minCompat(submask, nums));
            }
        }
        
        return dp[fmask];
    }
};