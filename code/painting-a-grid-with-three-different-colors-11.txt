class Solution {
public:
    const int mod = 1e9+7;
    int dp[1005][243];
    
    vector<int> g[243]; // graph
    bool vis[243]; // valid mask that left right is not the same, vis[mask] = 1 is valid
    
    int n, m;
    int up; // 3^m
    
    bool check(vector<int> &mm){ // left, right
        for(int i = 1; i < m; ++i){
            if(mm[i] == mm[i-1]) return false;
        }
        return true;
    }
    bool check(vector<int> &a, vector<int> &b){ // up, down
        for(int i = 0; i < m; ++i){
            if(a[i] == b[i]) return false;
        }
        return true;
    }
    
    vector<int> cov(int mask){ // convert mask to vector
        vector<int> mm;
        for(int i = 0; i < m; ++i){
            mm.push_back(mask % 3);
            mask /= 3;
        }
        return mm;
    }
    
    
    int dfs(int i, int mask){
        if(i == n-1) return 1;
        if(dp[i][mask] != -1) return dp[i][mask];
        
        long res = 0;
        for(int v: g[mask]){
            res += dfs(i+1, v);
            res %= mod;
        }
        return dp[i][mask] = res;
    }
    
    int colorTheGrid(int m, int n) {
        memset(dp, -1, sizeof dp);
        this->n = n;
        this->m = m;
        up = pow(3, m);
        
		// 3^m mask which left, right not the same
        for(int i = 0; i < up; ++i){
            vector<int> cm = cov(i);
            if(!check(cm)) continue;
            vis[i] = 1;
        }
        
		// 3^5 * 3^5 build the graph
        for(int i = 0; i < up; ++i){
            if(!vis[i]) continue;
            vector<int> cm = cov(i);
            for(int j = 0; j < up; ++j){
                if(!vis[j]) continue;
                vector<int> cj = cov(j);
                if(check(cm, cj)){
                    g[i].push_back(j);
                }
            }
        }
        
		// try all mask
        long res = 0;
        for(int i = 0; i < up; ++i){
            if(!vis[i]) continue;
            res += dfs(0, i);
            res %= mod;
        }
        return res;
    }
};