/*
    1 find elements recurring in every path , towns can repeat so take set of path and then cnt
    2 find set of recurring elements in each path
    3 find substring in smallest path with common towns calculated in step 1
    3 use KMP algorithm to find the largest common substring length with
      text=paths[i] pattern=commmon substring calculated in step 3
      
    4 find min values of common length calculated in step 3

*/


vector<int> generate_lps(vector<int> p)
{
    int n=p.size();
    vector<int> lps(n,0);
    
    lps[0]=0;
    
    int i=1,len=0;
    
    while(i<n)
    {
        if(p[i]==p[len])
        {
            lps[i]=len+1;
            len++; i++;
        }
        else
        {
            if(len!=0)
            {
                len=lps[len-1];
            }
            else
            {
                lps[i]=0;
                i++;
            }
        }
    }
    
    return lps;
}

int max_common_length(vector<int> t,vector<int> p)
{
    vector<int> lps=generate_lps(p);
    
    int i,j;
    i=j=0;
    
    int n=t.size();
    
    int max_len=0;
    
    while(i<n)
    {
        if( t[i]==p[j] )
        {
            i++; j++;
            max_len=max(max_len,j);
            
        }
        
        if(j==p.size())
        {
            break;
        }
        else if(i<n && t[i]!=p[j])
        {
            if(j!=0)
                j=lps[j-1];
            else 
                i++;
        }
    }
    
    return max_len;
}

vector<int> find_substr(vector<int> &path,unordered_set<int> &common)
{
    int s,e;
    int as,ae;
    
    int n=path.size();
    int max_path_len=0;
    
    as=ae=-1;
    s=e=0;
    
    while(s<n)
    {
        if(common.count(path[s])>0)
        {
            e=s;
            while(e<n && common.count(path[e])>0)
                e++;
            
            if(e-s>max_path_len)
            {
                max_path_len=e-s;
                as=s; ae=e;
            }
            s=e;
        }
        
        else
            s++;
    }
    
    vector<int> ans(path.begin()+as,path.begin()+ae);
    return ans;
}


int longestCommonSubpath(int n, vector<vector<int>>& paths) {
    
    unordered_map<int,int> city_cnt;
    
    for(auto p:paths)
    {
        // cout<<p.size()<<endl;
        unordered_set<int> curr(p.begin(),p.end());
        for(auto city:curr)
            city_cnt[city]++;
    }
    
    unordered_set<int> present_in_all_paths;
    for(int i=0;i<n;i++)
    {
        // cout<<city_cnt[i]<<' ';
        if(city_cnt[i]==paths.size())
        {
            present_in_all_paths.insert(i);
        }
    }
    // cout<<endl;
    
    if(present_in_all_paths.size()==0)
        return 0;
    
    int min_size_path_index=0;
    int min_path_len=paths[0].size();
    for(int i=1;i<paths.size();i++)
    {
        if(min_path_len<paths[i].size())
        {
            min_path_len=paths[i].size();
            min_size_path_index=i;
        }
    }
    
    cout<<present_in_all_paths.size()<<endl;
    
    vector<int> substr=find_substr(paths[min_size_path_index],present_in_all_paths);

    // for(auto a:substr)
    //     cout<<a<<' ';
    // cout<<endl;
    
    int ans= substr.size();
    for(auto path: paths)
    {
        int curr_len=max_common_length(path,substr);
        // cout<<curr_len<<endl;
        ans=min(ans,curr_len);
        if(ans==0)
            return 0;
    }
    
    return ans;
    
}