class Solution {
public:
    
    // traverse tree in post order manner and get scores of the nodes of the tree
    long long postorder(int node, vector<vector<int>>&tree, unordered_map<long long,int>&scores, int &nodeCount, long long &maxScore)
    {
        // return 0 node count for NULL node
        if(node==-1)return 0;
        
        // get left and right subtree node count and update maxScore and scores
        int left = postorder(tree[node][0],tree,scores,nodeCount,maxScore);
        int right = postorder(tree[node][1],tree,scores,nodeCount,maxScore);
        
        // calculate current node's score using nL * nR * (total nodes - 1 -nL -nR) formula
        long long score = (long long)(left>0 ? left : 1) * (long long)(right>0 ? right : 1) * (long long)(node>0 ? nodeCount - 1 - left - right : 1);
        
        // update maxScore with current score
        maxScore = max(maxScore,score);
        
        // update current score count
        scores[score]++;
        
        // return node count of current subtree rooted at current node 
        return left + right + 1;
    }
    
    int countHighestScoreNodes(vector<int>& parents) {
        
        // total node count
        int nodeCount = parents.size();
        
        // 2D array of tree nodes containing left and right child node
        vector<vector<int>>tree(nodeCount,{-1,-1});
        
        // store node scores' count in map
        unordered_map<long long,int>scores;
        
        // current node
        int node = -1;
        
        // loop through parent node list and update the tree structure
        for(int &parent : parents)
        {
            node++;
            if(parent==-1) continue;
            
            if(tree[parent][0]==-1)tree[parent][0]=node;
            else tree[parent][1]=node;
        }
        
        long long maxScore = LLONG_MIN;
        postorder(0,tree,scores,nodeCount,maxScore);
        return scores[maxScore];
    }
};