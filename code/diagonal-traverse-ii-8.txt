    public class Solution
    {
        private class SolComparer : IComparer<int>
        {
            public int Compare(int x, int y)
            {
                return y.CompareTo(x);
            }
        }

        public int[] FindDiagonalOrder(IList<IList<int>> nums)
        {
            int n = nums.Count;
            if (n == 0)
            {
                return new int[] { };
            }

            SortedSet<int> availableRows = new SortedSet<int>(new SolComparer());

            int[] diagonalIndices = new int[n];
            List<int> res = new List<int>();
            ISet<(int, int)> visited = new HashSet<(int, int)>();
            IList<int> tmp = new List<int>();

            for (int i = 0; i < n; i++)
            {
                int col = 0;
                availableRows.Add(i);

                tmp.Clear();
                foreach (var ar in availableRows)
                {
                    int c = col + (i - ar);
                    res.Add(nums[ar][c]);
                    visited.Add((ar, c));
                    diagonalIndices[ar] = c + 1;

                    if (diagonalIndices[ar] >= nums[ar].Count)
                    {
                        tmp.Add(ar);
                    }
                }

                foreach (var t in tmp)
                {
                    availableRows.Remove(t);
                }
            }

            for (int r = n - 1; r >= 0; r--)
            {
                int start = diagonalIndices[r];
                for (int col = start; col < nums[r].Count; col++)
                {
                    if (visited.Add((r, col)))
                    {
                        tmp.Clear();
                        foreach (var ar in availableRows)
                        {
                            int c = col + (r - ar);
                            res.Add(nums[ar][c]);
                            visited.Add((ar, c));
                            diagonalIndices[ar] = c + 1;

                            if (diagonalIndices[ar] >= nums[ar].Count)
                            {
                                tmp.Add(ar);
                            }
                        }

                        foreach (var t in tmp)
                        {
                            availableRows.Remove(t);
                        }
                    }
                }

                availableRows.Remove(r);
            }


            return res.ToArray();
        }
    }