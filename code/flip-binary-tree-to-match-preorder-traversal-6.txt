public class Solution 
{
    public IList<int> FlipMatchVoyage(TreeNode root, int[] voyage) 
    {
        var result = new List<int>();
        var v = voyage.ToList();
        if(root == null) return result;
        if(root.val != voyage[0])
        {
            result.Add(-1);
            return result;
        }
        var rest = voyage.Skip(1).ToList();
        if(StartsWith(root.left, rest))
        {
            result.AddRange(FlipMatchVoyage(root.left, rest.Take(Count(root.left)).ToArray()));
            result.AddRange(FlipMatchVoyage(root.right, rest.Skip(Count(root.left)).ToArray()));
        }
        else if(StartsWith(root.right, rest))
        {
            result.Add(root.val);
            result.AddRange(FlipMatchVoyage(root.right, rest.Take(Count(root.right)).ToArray()));
            result.AddRange(FlipMatchVoyage(root.left, rest.Skip(Count(root.right)).ToArray()));
        }
        else
        {
            result.Add(-1);
            return result; 
        }
        
        return result.Contains(-1) ? new List<int>(){-1} : result;
    }
    
    private bool StartsWith(TreeNode root, List<int> list)
    {
        var vals = Traverse(root);
        foreach(var val in vals)
        {
            var index = list.IndexOf(val);
            if(index < 0 || index >= vals.Count) return false;
        }
        
        return true;
    }
    
    private List<int> Traverse(TreeNode root)
    {
        var list = new List<int>();
        Traverse(root, list);
        return list;
    }
    
    private void Traverse(TreeNode root, List<int> list)
    {
        if(root == null) return;
        list.Add(root.val);
        Traverse(root.left, list);
        Traverse(root.right, list);
    }
    
    private int Count(TreeNode root)
    {
        if(root == null) return 0;
        return Count(root.left) + Count(root.right) + 1;
    }
}