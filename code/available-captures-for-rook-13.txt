class Solution {
public:
    int numRookCaptures(vector<vector<char>>& board) {
        decltype(board.begin()) Rit;
        decltype(board[0].begin()) Rjt; 
        // find the 'R' on the board
        for (auto it = board.begin(); it != board.end(); ++it)
        {
            auto jt = std::find(it->begin(), it->end(), 'R');
            if (jt != it->end())
            {
                Rit = it;
                Rjt = jt;
                break;
            }
        }

        // counter applied to the column that the rook belongs to 
        auto counter_col = [](auto first, auto last) {
            auto figure_checker = [](auto c){ return c == 'B' || c =='p'; };
            auto pawn_checker = [](auto xt, auto et){ return xt != et && *xt == 'p'; };
            return pawn_checker(std::find_if(first, last, figure_checker), last);
        };

        // counter applied to the row that the rook belongs to
        auto counter_row = [](auto first, auto last, int col) {
            auto figure_checker = [col](auto const &row){ return row[col] == 'B' || row[col] =='p'; };
            auto pawn_checker = [col](auto xt, auto et){ return xt != et && (*xt)[col] == 'p'; };
            return pawn_checker(std::find_if(first, last, figure_checker), last);
        };
        
        // check rightward
        return counter_col(std::next(Rjt), Rit->end())
        // check leftward
            + counter_col(std::make_reverse_iterator(Rjt), Rit->rend())
        // check upword
            + counter_row(std::next(Rit), board.end(), std::distance(Rit->begin(), Rjt))
        // check downward
            + counter_row(std::make_reverse_iterator(Rit), board.rend(), std::distance(Rit->begin(), Rjt));
    }
};