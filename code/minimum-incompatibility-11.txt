int minimumIncompatibility(vector<int>& arr, int k) {
    
    
    int n = arr.size();
    
    vector<int> masks;
    unordered_map<int, int> cost;
    k = n / k;
    
    for(int i = 0; i < (1 << n); i++)
    {
        int x = __builtin_popcount(i);
        
        
        if(x == k)
        {
            int mask = 0;
            bool flag = 1;
            
            for(int j = 0; j < n; j++)
            if(i & (1 << j))
            {
                  if(mask & (1 << arr[j]))
                    {
                        flag = 0;
                        break;
                    }
                else mask = mask | (1 << arr[j]);
            }
                 
            if(flag)
            {
                 masks.push_back(i);
                
                 int x = 0;
                
                 for(int k = 16; k >= 0; k--)
                     if(mask & (1 << k))
                     {
                         x = k;
                         break;
                     }
                
                for(int k = 0; k <= 16; k++)
                    if(mask & (1 << k))
                    {
                        x = x - k;
                        break;
                    }
                         
                 cost[i] = x;

            }
             
        }
        
    }
    
   

   priority_queue< pair<int, int> , vector< pair<int, int> >, greater< pair<int, int> > > pq;
    
    int x = (1 << n) - 1;
    int m = masks.size();
    
    vector<int> dis(1 << n, 1e9);
    
    pq.push({0, x});
    
    dis[x] = 0;
    
    
    while(pq.size())
    {
        auto pr = pq.top();
        pq.pop();
        
        int mask = pr.second;
        int d = pr.first;
        
        if(d > dis[mask])
            continue;

        if(mask == 0)
            return dis[0];
        
        for(int i = 0; i < m; i++)
            if((masks[i] & (mask)) == masks[i])
            {
                 if(dis[masks[i] ^ mask] > (d + cost[masks[i]]))
                 {
                     dis[masks[i] ^ mask] = d + cost[masks[i]];
                     pq.push({dis[masks[i] ^ mask], mask ^ masks[i]});
                 }
            }
        
    
    }
    
    return -1;
}