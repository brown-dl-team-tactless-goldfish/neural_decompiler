struct Tree
{
    struct Tree* left;
    struct Tree* right;
};

int result;
struct Tree* root;

struct Tree* new_node (void)
{
    struct Tree* obj = (struct Tree*) malloc (sizeof(struct Tree));
    obj->left = NULL;
    obj->right = NULL;
    return obj;
}

void create_trie (struct Tree* r, int n, int W) // W = bitwidth
{
    if (W <= 0 || r == NULL)
        return NULL;

    if (n & (1 << (W-1)))
    {
        if (r->right == NULL)
            r->right = new_node();
        create_trie(r->right, n, W-1);
    }
    else
    {
       if (r->left == NULL)
            r->left = new_node();
        create_trie (r->left, n, W-1);
    }
    return;
}

void max_xor (struct Tree* high, struct Tree* low, int xor, int bit_pos)
{
    bool skip_zero_branch = 0;
    if (low == NULL)
    {
        result = result < xor ? xor : result;
        return;
    }
    if (high->right && low->left)
    {
        xor |= 1 << (bit_pos-1);
        max_xor (high->right, low->left, xor, bit_pos-1);
        xor &= ~(1 << (bit_pos-1));
        skip_zero_branch = 1;
    }
    if (high->left && low->right)
    {
        xor |= 1 << (bit_pos-1);
        max_xor (high->left, low->right, xor, bit_pos-1);
        xor &= ~(1 << (bit_pos-1));
        skip_zero_branch = 1;
    }
    if (skip_zero_branch == 0)
    {
        max_xor (high->left, low->left, xor, bit_pos-1);
        max_xor (high->right, low->right, xor, bit_pos-1);
    }
}

int findMaximumXOR(int* nums, int numsSize)
{
    struct Tree* node = root;
    int num, maxx = -1, bit_pos = 0, xor = 0;

    for (int i = 0; i < numsSize; i++)
        maxx = maxx < nums[i] ? nums[i] : maxx;
    while (maxx)
    {
        bit_pos++;
        maxx >>= 1;
    }

    root = new_node ();
    for (int i = 0; i < numsSize; i++)
        create_trie (root, nums[i], bit_pos);

    struct Tree* high, *low;
    high = low = root;
    result = 0;
    max_xor (root, root, 0, bit_pos);

    return result;

    /*
    Algo:
        1. Find max number. 
        2. Create a binary trie with MSB at top.
        2.5 maintain two nodes: high and low.
        2.7 Set xor = 0, bit_pos = depth of tree;
        3. recursive call:
            If left & right are both NULL
                return;
            if (high->right && low->left)
            {
                xor |= 1 << bit_pos;
                high = high->right;
                low = low->left
            }
            else if (high->left && low->right)
            {
                ...
            }
            else
            {
                no chagen to xor. 
            }
            bit_pos--;
    */

}