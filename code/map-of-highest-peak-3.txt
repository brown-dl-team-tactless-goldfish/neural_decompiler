public class Solution {
    
    private static int Min(int[][] field, int r, int c) {
        int result = int.MaxValue;
        
        for (int d = 0; d < 4; ++d) {
            int nr = r + (d - 1) % 2;
            int nc = c + (d - 2) % 2;
            
            if (nc < 0 || nr < 0 || nr >= field.Length || nc >= field[nr].Length || field[nr][nc] < 0)
                continue;
                        
            result = Math.Min(result, field[nr][nc]);
        }
        
        return result;
    } 
    
    public int[][] HighestPeak(int[][] isWater) {
        int[][] result = Enumerable
            .Range(0, isWater.Length)
            .Select(r => Enumerable
                .Range(0, isWater[r].Length)
                .Select(c => isWater[r][c] == 0 ? -1 : 0)
                .ToArray())
            .ToArray();
        
        Queue<(int r, int c)> frontier = new();
        
        for (int r = 0; r < isWater.Length; ++r)
            for (int c = 0; c < isWater[r].Length; ++c)
                if (isWater[r][c] == 1)
                    frontier.Enqueue((r, c));
        
        while (frontier.Count > 0) {
            for (int i = frontier.Count - 1; i >= 0; --i) {
                var at = frontier.Dequeue();
                
                for (int d = 0; d < 4; ++d) {
                    int r = at.r + (d - 1) % 2;
                    int c = at.c + (d - 2) % 2;
                    
                    if (c < 0 || r < 0 || r >= isWater.Length || c >= isWater[r].Length || result[r][c] >= 0)
                        continue;
                    
                    frontier.Enqueue((r, c));
                    
                    result[r][c] = Min(result, r, c) + 1;
                }
            }
        }
        
        return result;
    }
    
}