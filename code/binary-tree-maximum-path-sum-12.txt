/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
#define MIN -9999
int max(int a , int b, int c , int d)
{
    if(a >b & a>c & a>d)
        return a;
    if(b>a & b>c & b>d)
        return b;
    if(c>a & c>b & c>d)
        return c;
    return d;
}

int res = MIN;
int recursion(struct TreeNode *root)
{
    if(root == NULL)
        return MIN;
    
    int left =0 , right =0, sum = root->val;

    //tree with both left & right nodes
    if(root->left && root->right)
    {
        left = recursion(root->left);
        right = recursion(root->right);
        sum = max(MIN, sum+left+right, sum+left, sum+right);
    }
    //tree with only left nodes, set right to MIN
    else if(root->left && !root->right)
    {
        left = recursion(root->left);
        sum = sum +left;
        right = MIN;
    }  
    //tree with only right nodes , set left to MIN
    else if(!root->left && root->right)
    {
        right = recursion(root->right);
        sum = sum + right;
        left = MIN;
    }
    //tree with no leaf nodes, set left & right to min
    else
    {
        left = right = MIN;
    }
    
    //Subtree without the root can also be max
    int temp_res = max(left, right, root->val, sum);
    
    //check if subtree is greater than the previouslt identified maxtree
    if(temp_res > res)
        res = temp_res;
    
    return max(MIN, left+root->val , right+root->val, root->val);
    
}

int maxPathSum(struct TreeNode* root)
{
    int res1 = recursion(root);
    //Pathsum with the final root isn't manipulated yet so checking it below.
    int pathMax = res1>res ? res1 : res;
    
    res= MIN;
    return pathMax;

}