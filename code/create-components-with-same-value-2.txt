class Solution {
    private:
    int ans=0;
public:
    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {
        vector<int>consider(edges.size(),1);
         fun(nums,edges,0,consider);
         return ans;
    }
    void fun(vector<int>&nums, vector<vector<int>>&edges,int index,vector<int>&consider)
    {
        // cout<<"index:"<<index<<"    ans:"<<ans<<endl;
        ans=max(makeComp(nums,edges,consider),ans);
        //  cout<<endl;
        if(index==edges.size())
           return;

        // let delete this
         // pre-calculation
         consider[index]=0;
         fun(nums,edges,index+1,consider);
         // post-calculation
         consider[index]=1;
        
        // not delete this
        fun(nums,edges,index+1,consider);
         
    }
    int find(vector<int>&dsuf,int v)
    {
        if(dsuf[v]<0)
         return v;
        return dsuf[v]=find(dsuf,dsuf[v]);
    }
    void Union(vector<int>&dsuf,int from ,int to)
    {
        from=find(dsuf,from);
        to=find(dsuf,to);
        if(from!=to)
        {
            if(dsuf[from]<dsuf[to])
            {
                dsuf[from]+=dsuf[to];
                dsuf[to]=from;
            }
            else
            {
                dsuf[to]+=dsuf[from];
                dsuf[from]=to;
            }
        }
    }
  int makeComp(vector<int>&nums, vector<vector<int>>&edges,vector<int>&consider)
    {  vector<int>dsuf(nums.size(),-1);
    int cnt=0;
        for(int i=0;i<consider.size();i++)
         {
             if(consider[i])
            {
                Union(dsuf,edges[i][0],edges[i][1]);
            }
            else
              cnt++;
         }
        //  for(int i=0;i<dsuf.size();i++)
        //   cout<<"node:"<<i<<"   parent:"<<dsuf[i]<<endl;

         unordered_map<int,int>mp;
         for(int i=0;i<dsuf.size();i++)
         {
             if(dsuf[i]<0)
             {
                mp[i]+=nums[i];
             }
             else
             mp[dsuf[i]]+=nums[i];
         }
        unordered_set<int>st;
        for(auto p:mp)
        
             st.insert(p.second);
         
        if(st.size()==1)
        return cnt;
        return 0 ;
    }
};



class Solution {
    private:
    int ans=0;
public:
    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {
        vector<int>consider(edges.size(),1);
         fun(nums,edges,0,consider);
         return ans;
    }
    void fun(vector<int>&nums, vector<vector<int>>&edges,int index,vector<int>&consider)
    {
        // cout<<"index:"<<index<<"    ans:"<<ans<<endl;
        ans=max(makeComp(nums,edges,consider),ans);
        //  cout<<endl;
        if(index==edges.size())
           return;

        // let delete this
         // pre-calculation
         consider[index]=0;
         fun(nums,edges,index+1,consider);
         // post-calculation
         consider[index]=1;
        
        // not delete this
        fun(nums,edges,index+1,consider);
         
    }
    int find(vector<int>&dsuf,int v)
    {
        if(dsuf[v]<0)
         return v;
        return dsuf[v]=find(dsuf,dsuf[v]);
    }
    void Union(vector<int>&dsuf,int from ,int to)
    {
        from=find(dsuf,from);
        to=find(dsuf,to);
        if(from!=to)
        {
            if(dsuf[from]<dsuf[to])
            {
                dsuf[from]+=dsuf[to];
                dsuf[to]=from;
            }
            else
            {
                dsuf[to]+=dsuf[from];
                dsuf[from]=to;
            }
        }
    }
  int makeComp(vector<int>&nums, vector<vector<int>>&edges,vector<int>&consider)
    {  vector<int>dsuf(nums.size(),-1);
    int cnt=0;
        for(int i=0;i<consider.size();i++)
         {
             if(consider[i])
            {
                Union(dsuf,edges[i][0],edges[i][1]);
            }
            else
              cnt++;
         }
        //  for(int i=0;i<dsuf.size();i++)
        //   cout<<"node:"<<i<<"   parent:"<<dsuf[i]<<endl;

         unordered_map<int,int>mp;
         for(int i=0;i<dsuf.size();i++)
         {
             if(dsuf[i]<0)
             {
                mp[i]+=nums[i];
             }
             else
             mp[dsuf[i]]+=nums[i];
         }
        unordered_set<int>st;
        for(auto p:mp)
        
             st.insert(p.second);
         
        if(st.size()==1)
        return cnt;
        return 0 ;
    }
};