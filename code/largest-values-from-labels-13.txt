struct ValueLabel {
    int val;
    int label;
};

class Solution {
public:
    int largestValsFromLabels(
        vector<int>& values,
        vector<int>& labels,
        int numWanted,
        int useLimit) {

        std::vector<ValueLabel> Vals;       
        for (int i=0;i<values.size();++i) {
            Vals.push_back({values[i], labels[i]});
        }
        
        auto cmp = [](const ValueLabel& a, const ValueLabel& b) {
            return a.val > b.val;
        };        
        std::sort(Vals.begin(), Vals.end(), cmp); 
      
        std::unordered_map<int, int> LabelLimit;
        for (const auto& l:labels) {
            LabelLimit[l] = useLimit;
        }
        
        int ans = 0;
        int i = 0;
        while (i<Vals.size() && numWanted) {
            int val = Vals[i].val; 
            int label = Vals[i].label; 
            auto it = LabelLimit.find(label);
            if (it != LabelLimit.end() && it->second > 0) {
                ans += val;
                int count = it->second;
                --count;
                if (count == 0) {
                    LabelLimit.erase(it);
                } else {
                    LabelLimit[label] = count;
                }
                --numWanted;
            } 
            ++i;
        }
        
        return ans;
    }
};