public class Solution 
{
    int res = 1;
    public int LongestStrChain(string[] words) 
    {
        if (words == null || words.Length == 0) return 0;
        
        Dictionary<string, List<string>> g = new Dictionary<string, List<string>>();
        
        for (int i = 0; i < words.Length - 1; ++i)
        {
            for (int j = i + 1; j < words.Length; ++j)
            {
                if (IsOneStepAway(words[i], words[j]))
                {
                    if (words[i].Length > words[j].Length)
                    {
                        if (!g.ContainsKey(words[j]))
                        {
                            g.Add(words[j], new List<string>());
                            g[words[j]].Add(words[i]);
                        }
                        else
                        {
                            g[words[j]].Add(words[i]);
                        }
                    }
                    else
                    {
                        if (!g.ContainsKey(words[i]))
                        {
                            g.Add(words[i], new List<string>());
                            g[words[i]].Add(words[j]);
                        }
                        else
                        {
                            g[words[i]].Add(words[j]);
                        }
                    }
                }
            }
        }
        
        foreach (KeyValuePair<string, List<string>> e in g)
        {
            foreach (string n in e.Value)
            {
                DFS(g, n, 1);
            }
        }
        
        return res;
    }
    
    public bool IsOneStepAway(string w1, string w2)
    {
        if (Math.Abs(w1.Length - w2.Length) != 1) return false;
        
        Dictionary<char, int> chars = new Dictionary<char, int>();
        
        if (w1.Length > w2.Length)
        {
            foreach (char c in w1)
            {
                if (!chars.ContainsKey(c))
                {
                    chars.Add(c, 1);
                }
                else
                {
                    chars[c]++;
                }
            }
            
            int diffs = 0;
            foreach (char c in w2)
            {
                if (!chars.ContainsKey(c))
                {
                    diffs++;
                }
                else
                {
                    chars[c]--;
                    if (chars[c] == 0) chars.Remove(c);
                }
            }
            
            foreach (KeyValuePair<char, int> e in chars)
            {
                diffs += e.Value;
            }
            
            if (diffs != 1) return false;
        }
        else
        {
            foreach (char c in w2)
            {
                if (!chars.ContainsKey(c))
                {
                    chars.Add(c, 1);
                }
                else
                {
                    chars[c]++;
                }
            }
            
            int diffs = 0;
            foreach (char c in w1)
            {
                if (!chars.ContainsKey(c))
                {
                    diffs++;
                }
                else
                {
                    chars[c]--;
                    if (chars[c] == 0) chars.Remove(c);
                }
            }
            
            foreach (KeyValuePair<char, int> e in chars)
            {
                diffs += e.Value;
            }
            
            if (diffs != 1) return false;
        }
        
        return true;
    }
    
    public void DFS(Dictionary<string, List<string>> g, string key, int chainLen)
    {
        if (!g.ContainsKey(key))
        {
            res = Math.Max(res, chainLen + 1);
            return;
        }
        
        foreach (string n in g[key])
        {
            DFS(g, n, chainLen + 1);
        }
    }
}