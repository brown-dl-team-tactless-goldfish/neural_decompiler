typedef struct
{
    int data;
    int index;
}StackNode;

typedef struct
{
    int top;
    int size;
    StackNode * arr;
}Stack;

bool isStackFull(Stack * stack)
{
    return (stack->top == stack->size - 1) ? 1 : 0;
}

bool isStackEmpty(Stack * stack)
{
    return (stack->top == -1) ? 1 : 0;
}

void push(Stack * stack, int data, int index)
{
    if(isStackFull(stack))
        return;
    
    stack->arr[++(stack->top)].data = data;
    stack->arr[stack->top].index = index;
    return;
}

int pop(Stack * stack, int * index)
{
    if(isStackEmpty(stack))
        return INT_MIN;
    *index = stack->arr[stack->top].index;
    return stack->arr[(stack->top)--].data;
}

int peek_top(Stack * stack)
{
    if(isStackEmpty(stack))
        return INT_MIN;
    return stack->arr[stack->top].data;
}

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* nextGreaterElements(int* nums, int numsSize, int* returnSize)
{
    Stack stack;
    stack.top = -1;
    stack.size = (2 * numsSize);    //We need to traverse the array twice as its an circular array
    stack.arr = (StackNode *)malloc(sizeof(StackNode) * stack.size);
    
    *returnSize = numsSize;
    int * ret_arr = (int *)malloc(sizeof(int) * (*returnSize));
    
    int i=0;
    for(i=0; i<numsSize; i++)
    {
        if(isStackEmpty(&stack))
        {
            push(&stack, nums[i], i);
        }
        else
        {
            if(nums[i] <= peek_top(&stack))
            {
                push(&stack, nums[i], i);
            }
            else
            {
                while(!isStackEmpty(&stack) && (nums[i] > peek_top(&stack)))
                {
                    int pop_index;
                    int pop_element = pop(&stack, &pop_index);
                    ret_arr[pop_index] = nums[i];
                }
                push(&stack, nums[i], i);
            }
        }
    }
    
    i=0;
    for(i=0; i<numsSize; i++)
    {
        if(isStackEmpty(&stack))
        {
            break;
        }
        else
        {
            if(nums[i] <= peek_top(&stack))
            {
               // push(&stack, nums[i], i);
            }
            else
            {
                while(!isStackEmpty(&stack) && (nums[i] > peek_top(&stack)))
                {
                    int pop_index;
                    int pop_element = pop(&stack, &pop_index);
                    ret_arr[pop_index] = nums[i];
                }
               // push(&stack, nums[i], i);
            }
        }
    }
    
    while(!isStackEmpty(&stack))
    {
        int pop_index;
        int pop_element = pop(&stack, &pop_index);
        ret_arr[pop_index] = -1;
    }
    
    return ret_arr;
}