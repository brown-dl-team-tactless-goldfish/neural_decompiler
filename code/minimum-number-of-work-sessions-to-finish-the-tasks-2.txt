class Solution {
public:
    int n;
    vector<int> tasks;
    int sessionTime;

    int bitMask;  //the standard BitMask
    
    vector<vector<int>> f; // the memoization matrix 

    int memo(int taskNo, int timeRemain){
        /*
        - taskNo: of all the remaining tasks, which task must be done as the 'taskNo'th task
            Eg. TaskNo: 0, 1, 2, 3, 4, 5, 6....
            Tasks(i=) : 7, 10,5, 4, 13, 3,1...
            
            Note: taskNo is actually a function of bitMask
            
            ==> Note: taskNo = Number of 1's in the bitMask
            
        - timeRemain: time time remaining/available in the current session
        */
        
        if(f[bitMask][timeRemain] != -1) return f[bitMask][timeRemain];
        
        
        if(taskNo == n)
            return  f[bitMask][timeRemain]=  0; // all tasks done!
        
        int mini = INT_MAX;

        
        //Which task should I do as the 'taskNo'th task?
        
        for(int i=0;i<n;i++){
            
            //Is task[i] yet to be done?
            
            if( (bitMask & (1 << i)) == 0){ //Yes!, i'th task has yet to be done 
                
                
                //Can I do task[i] in the current session ?
                
                if(tasks[i] <= timeRemain){  //Yes, you can!
                    
                    bitMask = (bitMask | (1 << i)); //since we're doing task[i], set the i'th LSB
                    
                    //Option1. Do task[i] as the 'taskNo'th task in current session
                    int a = memo(taskNo+1, timeRemain-tasks[i]);
                    
                    //Option2. End this session, and do task[i] as the 'taskNo'th task in the next session
                    int b = 1 + memo(taskNo+1, sessionTime - tasks[i]);
                    
                    bitMask = (bitMask & (~(1 << i))); //BackTracking!, unset the i'th LSB
           
                    //the minimum sessions needed b/w option1 & option2
                    mini = min(mini, min(a, b));
                }
                else{ //No, I cannot do task[i] in the current session
                    
                    bitMask = (bitMask | (1 << i)); //since we're doing task[i], set the i'th LSB
                    
                    //Hence, end this session here, and do it in the next session
                    int c = 1 + memo(taskNo+1, sessionTime - tasks[i]);
                    
                    bitMask = (bitMask & (~(1 << i))); //BackTracking!, unset the i'th LSB
                    
                    mini = min(mini, c);             
                }
            }
        }
        
        
        return  f[bitMask][timeRemain]=  mini;
    }


    int minSessions(vector<int>& tasks, int sessionTime) {
        this->tasks = tasks;
        this->n = tasks.size();
        this->sessionTime = sessionTime;

        this->bitMask = 0;
        this->f.resize((1<<n), vector<int>(sessionTime + 1, -1));
        
        return 1 + memo(0,sessionTime);
    }
};