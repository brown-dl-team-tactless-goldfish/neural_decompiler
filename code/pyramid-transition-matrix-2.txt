class Solution {
 private:
  bool dfs(const string& row, const string& nextRow, int i,
         unordered_map<string, vector<char>>& Map) 
  {
    if (row.length() == 1)
      return true;
  
    if (nextRow.length() == row.length() - 1)
      return dfs(nextRow, "", 0, Map);

    const string& prefix = row.substr(i, 2);

    if (Map.find(prefix) != Map.end()){
      for (auto c : Map[prefix])
        if (dfs(row, nextRow + c, i + 1, Map))
          return true;
    }

    return false;
  }
 public:
  bool pyramidTransition(string bottom, vector<string>& allowed) {
    unordered_map<string, vector<char>> Map;

    for (auto& a : allowed)
      Map[a.substr(0, 2)].push_back(a[2]);

    return dfs(bottom, "", 0, Map);
  }


};