int cmpfunc(const void* a, const void* b){
    return *(int*)a - *(int*)b;
} 

void process(int** ans, int*idx, int* ansCol , int* data ,int pos, int* nums, int numsSzie, int* numsCn, int n){

    if(pos == n){
        ans[*idx] = malloc( pos * sizeof(int));
        memcpy(ans[*idx], data, pos* sizeof(int));
        ansCol[*idx] = pos ;
        *idx = *idx + 1;
        return;       
    }
    
    for(int i = 0; i < numsSzie; i++){
        if(numsCn[i] > 0){
            data[pos] = nums[i];
            pos++;
            numsCn[i]--;
            process( ans, idx , ansCol , data , pos, nums, numsSzie, numsCn, n);
            pos--;
            numsCn[i]++;
        }
    }                      
}

int** permuteUnique(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    //>>>>> sort and organize "nums" to newNums and numsCount
    qsort(nums, numsSize, sizeof(int), cmpfunc);
    int* newNums = malloc(numsSize * sizeof(int));
    int* numsCount = malloc(numsSize * sizeof(int));
    newNums[0] = nums[0];
    numsCount[0] = 1;
    int newNumsSize = 1;
    for(int i = 1; i < numsSize; i++){
        if(nums[i] == nums[i-1]){
            numsCount[newNumsSize-1]++;
        }
        else{
            newNums[newNumsSize] = nums[i];
            numsCount[newNumsSize] = 1;
            newNumsSize++;
        }
    }
    newNums = realloc(newNums, newNumsSize * sizeof(int));
    numsCount = realloc(numsCount, newNumsSize * sizeof(int));
    //<<<<< end
    
    int** ans = malloc(50000 * sizeof(int*));
    returnColumnSizes[0] = malloc(50000 * sizeof(int));
    
    int* idx = calloc(1 , sizeof(int));
    int* data = malloc(8 * sizeof(int));
    
    process( ans, idx, returnColumnSizes[0], data , 0, newNums, newNumsSize, numsCount, numsSize);
    ans = realloc(ans, (*idx) * sizeof(int*));
    returnColumnSizes[0] = realloc(returnColumnSizes[0], (*idx) * sizeof(int));
    * returnSize = *idx;
    
    //free no use memory
    free(idx);
    free(data);
    free(newNums);
    free(numsCount);
    return ans;

}