struct pq {
    int soldiers;
    int row;
};
struct pq *q;
int heap_size;

void swap(struct pq *q, int a, int b)
{
    struct pq temp = q[a];
    q[a] = q[b];
    q[b] = temp;
}

bool is_smaller(struct pq a, struct pq b)
{
    if (a.soldiers < b.soldiers || (a.soldiers == b.soldiers && a.row < b.row))
        return true;
    return false;
}

void heapify(struct pq *q, int p_idx, int size)
{
    int min_idx = p_idx;
    int l_idx = p_idx * 2 + 1;
    int r_idx = p_idx * 2 + 2;
    
    // find min, and if q[i].soldiers are same, then compare q[i].row 
    if (l_idx < size && is_smaller(q[l_idx], q[min_idx]))
        min_idx = l_idx;
    if (r_idx < size && is_smaller(q[r_idx], q[min_idx]))
        min_idx = r_idx;

    if (min_idx != p_idx) { /* base case */
        swap(q, min_idx, p_idx);
        heapify(q, min_idx, size);
    }
}

void build_heap(struct pq *q, int size)
{
    for (int i = size / 2 -1; i >= 0; i--)
        heapify(q, i, size);
}

int heap_pop(struct pq *q)
{
    int ret = q[0].row;
    heap_size--;
    swap(q, 0, heap_size);
    heapify(q, 0, heap_size);
    return ret;
}

void print_arr(struct pq *q, int size)
{
    for (int i = 0; i < size; i++)
        printf("[%d]%d ", q[i].row, q[i].soldiers);
    printf("\n");
}

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* kWeakestRows(int** mat, int matSize, int* matColSize, int k, int* returnSize){
    *returnSize = k;
    heap_size = matSize;
    int * ret = (int *)malloc(sizeof(int) * k);
    q = (struct pq *)malloc(sizeof(struct pq) * 101);
    memset(q, 0, sizeof(struct pq) * 101);
    for (int i = 0; i < matSize; i++) {
        int cnt = 0;
        while (cnt < *matColSize && mat[i][cnt] != 0)
            cnt++;
        q[i].row = i; // {0, 1, 2, 3, 4, 5} idx 
        q[i].soldiers = cnt;
    }
    build_heap(q, heap_size);
    for (int i = 0; i < k; i++)
        ret[i] = heap_pop(q);
        
    return ret;
}