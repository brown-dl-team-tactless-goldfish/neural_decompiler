int shortestPath(int** grid, int gridSize, int* gridColSize, int k) {
  const int moves[][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
  const int num_moves = sizeof(moves) / sizeof(moves[0]);
  int rows = gridSize;
  int cols = *gridColSize;
  int* const buf = malloc((k + 1) * rows * cols * sizeof(int));
  
  buf[0] = 0;
  for (int i = 1; i < (k + 1) * rows * cols; ++i) {
    buf[i] = -1;
  }
  int (*best)[rows][cols] = (int (*)[rows][cols])buf;

  struct point_queue queue;
  queue_init(&queue);

  struct point start = {0, 0, 0};
  queue_push(&queue, start);
  do {
    struct point curr = *queue_top(&queue);
    queue_pop(&queue);

    for (int i = 0; i < num_moves; ++i) {
      /*
      Add move only if;
      * _next_ remains in the grid
      * _next_ doesn't hit a wall with no more removals allowed
      * _next_ hasn't already been visited
      */
      struct point next = {curr.removed, curr.row + moves[i][0], curr.col + moves[i][1]};
      if (!(0 > next.row || next.row == rows || 0 > next.col || next.col == cols ||
          (grid[next.row][next.col] && k < ++next.removed) ||
          0 <= best[next.removed][next.row][next.col])) {
        best[next.removed][next.row][next.col] = best[curr.removed][curr.row][curr.col] + 1;
        queue_push(&queue, next);
      }
    }
  } while (queue_size(&queue));

  /* Find the smallest successful path we found */
  int ret = INT_MAX;
  do {
    int* pos = &best[k][rows - 1][cols - 1];
    if (0 <= *pos) {
      ret = (ret < *pos) ? ret : *pos;
    }
  } while (0 <= --k);

  queue_uninit(&queue);
  free(best);
  return (ret == INT_MAX) ? -1 : ret;
}