class Solution {
public:
    vector<vector<int>> queensAttacktheKing(vector<vector<int>>& queens, vector<int>& king) {
        unordered_map<int, unordered_set<int>> quick_queens;
        for(auto q: queens) {
            quick_queens[q[0]].insert(q[1]);
        }
        return bfs(quick_queens, king);
    }
private:
    vector<pair<int,int>> _offsets = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}};
	int _grid_size = 8;

    vector<vector<int>> bfs(unordered_map<int,unordered_set<int>>& queens, vector<int>& king) {
        vector<vector<int>> res;
        queue<tuple<int, int, int>> q;
        vector<bool> forbidden(8, false);
        for(int i = 0; i < 8; i++)
            need_inspection(forbidden, king[0], king[1], i, q);
        int cnt = 0;
        while(!q.empty()) {
            tuple<int,int, int> curr;
            curr = q.front();
            q.pop();
            int r = get<0>(curr);
            int c = get<1>(curr);
            int dir = get<2>(curr);
            unordered_map<int,unordered_set<int>>::iterator it;
            it = queens.find(r);
            if(it != queens.end() && it->second.find(c) != it->second.end()) {
                res.push_back({r, c});
                forbidden[dir] = true;
                cnt++;
                if(cnt == 8)
                    return res;
            }
            need_inspection(forbidden, r, c, dir, q);            
        }
        return res;
    }
    
    void need_inspection(vector<bool>& forbidden, int r, int c, int dir, queue<tuple<int,int,int>>& q)  {
        if(forbidden[dir])
            return;
        int newr = r + _offsets[dir].first;
        int newc = c + _offsets[dir].second;
        if(newr >= 0 && newr < _grid_size && newc >= 0 && newc < _grid_size)
            q.push(make_tuple(newr, newc, dir));
    }
};