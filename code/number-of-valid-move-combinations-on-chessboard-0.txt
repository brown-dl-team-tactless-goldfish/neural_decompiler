class Solution {
    const int dx[8] = {-1, -1, -1, 0, 1, 1, 1, 0};
    const int dy[8] = {-1, 0, 1, 1, 1, 0, -1, -1};
    
    int recur(vector<vector<int>> &states) {
        unordered_set<int> st;
        int n = states.size();
        for(auto s: states) {
            int v = s[0]*9+s[1];
            if(st.find(v)!=st.end())
                return 0;
            st.insert(v);
        }
        int ok = 0, idx = -1;
        for(int i=0; i<n; i++) {
            if(states[i][2]) {
                ok += 1;
                idx = i;
            }
        }
        if(!ok)
            return 1;
        if(ok==1) {
            int ans = 1;
            int x = states[idx][0], y = states[idx][1], k = states[idx][3];
            while(1) {
                x += dx[k], y += dy[k];
                if(x<1 or y<1 or x>8 or y>8)
                    break;
                if(st.find(x*9+y)!=st.end())
                    break;
                ans += 1;
            }
            return ans;
        }
        int ans = 0;
        for(int mask=0; mask<(1<<n); mask++) {
            vector<vector<int>> next;
            bool ok = 1;
            for(int i=0; i<n; i++) {
                if(states[i][2]==0 and (mask>>i)&1) {
                    ok = 0;
                    break;
                }
                if(!((mask>>i)&1)) {
                    next.push_back({states[i][0], states[i][1], 0, states[i][3]});
                    continue;
                }
                int x = states[i][0]+dx[states[i][3]];
                int y = states[i][1]+dy[states[i][3]];
                if(x<1 or x>8 or y<1 or y>8) {
                    ok = 0;
                    break;
                }
                next.push_back({x, y, 1, states[i][3]});
            }
            if(!ok)
                continue;
            ans += recur(next);
        }
        return ans;
    }
    
public:
    unordered_map<string, vector<int>> mp;
    
    int utility(int idx, vector<int> cur, vector<string> &pieces, vector<vector<int>> &positions) {
        if(idx==(int)pieces.size()) {
            vector<vector<int>> states = positions;
            for(int i=0; i<(int)cur.size(); i++) {
                states[i].push_back(1);
                states[i].push_back(cur[i]);
                if(cur[i]==-1) {
                    states[i][2] = 0;
                    continue;
                }
                states[i][0] += dx[cur[i]];
                states[i][1] += dy[cur[i]];
                if(states[i][0]<1 or states[i][0]>8 or states[i][1]<1 or states[i][1]>8)
                    return 0;
            }
            return recur(states);
        }
        int ans = 0;
        for(auto itr: mp[pieces[idx]]) {
            cur.push_back(itr);
            ans += utility(idx+1, cur, pieces, positions);
            cur.pop_back();
        }
        return ans;
    }
    int countCombinations(vector<string>& pieces, vector<vector<int>>& positions) {
        mp["queen"] = {-1, 0, 1, 2, 3, 4, 5, 6, 7};
        mp["rook"] = {-1, 1, 3, 5, 7};
        mp["bishop"] = {-1, 0, 2, 4, 6};
        vector<int> cur;
        return utility(0, cur, pieces, positions);
    }
};