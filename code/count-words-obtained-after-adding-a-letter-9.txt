public:
    
    class TrieNode 
    {
        public:
        bool is_word;
        unordered_map<char, TrieNode*> children;
        TrieNode() : is_word(false){}
            
    };
    class Trie
    {
        public:
        TrieNode* root;
        
        Trie()
        {
            root = new TrieNode();
        }
        void insert(string str) 
        {
            TrieNode* current = root;
            for (auto c : str)
            {
                if (current->children.find(c) == current->children.end()) 
                {
                    current->children[c]= new TrieNode();
                }
                current = current->children[c];
            }
            current->is_word = true;
        }
        
        bool find(string str) 
        {
            TrieNode* current = root;
            for(int i = 0; i < str.size(); i++)
            {
                if (current->children.find(str[i]) == current->children.end())
                {
                   return false;
                }          
                current = current->children[str[i]];   
            }
            
            return (current->is_word);
        }
        
    };
    int wordCount(vector<string>& startWords, vector<string>& targetWords) {
        
        Trie* trie = new Trie();
        int counter = 0;
        for (auto w : startWords)
        {
            sort(w.begin(), w.end());
            trie->insert(w);
        }
        for (auto w : targetWords)
        {
            sort(w.begin(), w.end());
            for (int i = 0; i < w.size(); i++)
            {
                string str = w.substr(0, i) + w.substr(i + 1);
                if (trie->find(str))
                {
                    counter++;
                    break;
                }
            }

        }
        return counter;
    }
};