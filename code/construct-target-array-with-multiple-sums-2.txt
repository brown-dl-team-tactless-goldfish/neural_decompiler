struct TargetRecord
{
    int nTarget;

    struct TargetRecord* pstParent;
    struct TargetRecord* pstLeft;
    struct TargetRecord* pstRight;
};

int* CompareNumber(int* pFirst, int* pSecond)
{
    return (*pSecond) - (*pFirst);
}

struct TargetRecord* InsertTree(struct TargetRecord* pstRoot, int nTarget)
{
    if(pstRoot == NULL)
    {
        pstRoot = (struct TargetRecord*) malloc(sizeof(struct TargetRecord));
        pstRoot->nTarget = nTarget;
        pstRoot->pstParent = NULL;
        pstRoot->pstLeft = NULL;
        pstRoot->pstRight = NULL;
    }
    else if(nTarget < pstRoot->nTarget)
    {
        if(pstRoot->pstLeft == NULL)
        {
            pstRoot->pstLeft = (struct TargetRecord*) malloc(sizeof(struct TargetRecord));
            pstRoot->pstLeft->nTarget = nTarget;
            pstRoot->pstLeft->pstParent = pstRoot;
            pstRoot->pstLeft->pstLeft = NULL;
            pstRoot->pstLeft->pstRight = NULL;
        }
        else
        {
            InsertTree(pstRoot->pstLeft, nTarget);
        }
    }
    else
    {
        if(pstRoot->pstRight == NULL)
        {
            pstRoot->pstRight = (struct TargetRecord*) malloc(sizeof(struct TargetRecord));
            pstRoot->pstRight->nTarget = nTarget;
            pstRoot->pstRight->pstParent = pstRoot;
            pstRoot->pstRight->pstLeft = NULL;
            pstRoot->pstRight->pstRight = NULL;
        }
        else
        {
            InsertTree(pstRoot->pstRight, nTarget);
        }
    }   
    
    return pstRoot;
}

struct TargetRecord* DeleteMax(struct TargetRecord* pstMax, struct TargetRecord** ppstHead)
{
    if(pstMax == NULL) return pstMax;

    // check left child first since left child is still larger than parent
    if(pstMax->pstLeft != NULL)
    {
        // modify pstParent's link
        struct TargetRecord* pstParent = pstMax->pstParent;
        if(pstParent != NULL)
        {
            pstParent->pstRight = pstMax->pstLeft;
        }
        else
        {
            // modify pstHead since original pstHead (current pstMax) will be deleted
            *ppstHead = pstMax->pstLeft;
        }

        // delete old pstMax
        pstMax = pstMax->pstLeft;
        free(pstMax->pstParent);
        pstMax->pstParent = pstParent;

        // trace next pstMax
        while(pstMax->pstRight != NULL) pstMax = pstMax->pstRight;
    }
    else if(pstMax->pstParent != NULL)
    {
        pstMax = pstMax->pstParent;
        free(pstMax->pstRight);
        pstMax->pstRight = NULL;
    }
    else
    {
        free(pstMax);
        pstMax = NULL;
        *ppstHead = NULL;
    }
    
    return pstMax;
}

void FreeMemory(struct TargetRecord* pstRoot)
{
    if(pstRoot == NULL) return;

    if(pstRoot->pstLeft != NULL) FreeMemory(pstRoot->pstLeft);
    if(pstRoot->pstRight != NULL) FreeMemory(pstRoot->pstRight);

    free(pstRoot);
}

bool isPossible(int* target, int targetSize){
    // quick sort from maximum to minimum
    qsort(target, targetSize, sizeof(int), CompareNumber);
/*
    for(unsigned short i=0; i<targetSize; i++)
    {
        printf("target[i: %d]: %d\n", i, target[i]);
    }
//*/
    // filter by special cases
    if(target[0] == 1) return true;
    if(target[0] < targetSize) return false;
    if(targetSize == 1) return target[0] == 1;

    // check maximum first and get the result
    int nCheckTarget = target[0];
    for(unsigned short i=1; i<targetSize; i++)
    {
        nCheckTarget -= target[i];

        // maximum is smaller than sum of rest, return false
        if(nCheckTarget <= 0) return false;
    }
    int nRestSumTarget = target[0] - nCheckTarget;
    if(target[0] > nRestSumTarget)
    {
        nCheckTarget = (nRestSumTarget == 1)? 1: target[0] % nRestSumTarget;
        if(nCheckTarget == 0) return false;
    }

    //printf("target[0]:%d, nCheckTarget: %d, nRestSumTarget: %d\n", target[0], nCheckTarget, nRestSumTarget);

    // store next nCheckTarget
    struct TargetRecord *pstHead = NULL, *pstMax = NULL;
    if(nCheckTarget > 1)
    {
        if(nCheckTarget < targetSize) return false;

        pstHead = InsertTree(pstHead, nCheckTarget);
        pstMax = pstHead;
    }
    
    // check rest targets
    bool bRet = true, bFromTree = false;
    unsigned short usTargetIndex = 1;
    nCheckTarget += nRestSumTarget; // the maximum one is the sum of all previous elements
    while(usTargetIndex < targetSize || pstHead != NULL)
    {
        if(nCheckTarget == targetSize) break;
/*
        if(usTargetIndex < targetSize)
        {
            printf("target[usTargetIndex: %d]: %d", usTargetIndex, target[usTargetIndex]);
        }
        if(pstHead != NULL)
        {
            printf(", pstMax->nTarget: %d", pstMax->nTarget);
        }
        printf("\n");
//*/
        // ***get current maximum target***
        // case 1: rest sum (nCheckTarget - nCurrMaxTarget) - nCurrMaxTarget
        // case 2: nCurrMaxTarget- rest sum (nCheckTarget - nCurrMaxTarget)
        int nCurrMaxTarget = 0;
        if(usTargetIndex == targetSize || pstHead != NULL && pstMax->nTarget >= target[usTargetIndex])
        {
            bFromTree = true;
            nCurrMaxTarget = pstMax->nTarget;
        }
        else
        {
            bFromTree = false;
            nCurrMaxTarget = target[usTargetIndex++];
        }
        
        // sum of rest target is equal to pstMax, should be at least 1 difference
        if(nCheckTarget == (nCurrMaxTarget << 1))
        {
            bRet = false;
            break;
        }

        // get new different check data
        int nNewCheckTarget = nCheckTarget - (nCurrMaxTarget << 1);
        if(nNewCheckTarget < 0)
        {
            nRestSumTarget = nCheckTarget - nCurrMaxTarget;
            if(nRestSumTarget <= 0)
            {
                bRet = false;
                break;
            }

            nNewCheckTarget = (nRestSumTarget == 1)? 1: nCurrMaxTarget % nRestSumTarget;
            if(nNewCheckTarget == 0)
            {
                bRet = false;
                break;
            }
        }
        else
        {
            if(nNewCheckTarget > nCurrMaxTarget)
            {
                bRet = false;
                break;
            }
        }

        // the maximum one is the sum of all previous elements
        nCheckTarget = nNewCheckTarget + nRestSumTarget;

        // delete current max tree if it is checked
        if(bFromTree) pstMax = DeleteMax(pstMax, &pstHead);

        // add tree if necessary
        if(nNewCheckTarget > 1)
        {
            if(nNewCheckTarget < targetSize)
            {
                bRet = false;
                break;
            }

            // update next pstMax
            pstHead = InsertTree(pstHead, nNewCheckTarget);
            if(pstMax == NULL)
            {
                pstMax = pstHead;
            }
            else
            {
                if(nNewCheckTarget >= pstMax->nTarget) pstMax = pstMax->pstRight;
            }
        }
    }

    // free memory
    FreeMemory(pstHead);
    
    return bRet;
}