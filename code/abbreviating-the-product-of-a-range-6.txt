class Solution
{
    public:
    void reduceNumber(unsigned long long& val,unsigned long long x,unsigned long long& count)
    {
        while (val%x==0)
        {
            val/=x;
            count++;
        }
    }
    void getBackOriginal(unsigned long long& val,unsigned long long two,unsigned long long five,unsigned long long& mod)
    {
        if (two<five)
        {
            five-=two;
            while (five--)
                val=(val*5)%mod;
        }
        else if (five<two)
        {
            two-=five;
            while (two--)
                val=(val*2)%mod;
        }
    }
    string abbreviateProduct(int left, int right)
    {
        unsigned long long original=1,suffix=1,two=0,five=0,mod1=1e10,mod2=1e13;
        double power=0;
        for (long long i=left;i<=right;i++)
        {
            unsigned long long val=i;
            power=power+(double)(log10(i));
            
            //Reduce number by removing multiple of 2 and 5 from them and count them
            reduceNumber(val,2,two);
            reduceNumber(val,5,five);
            
            //Maintain two number suffix and original by taking modulus with different numbers
            suffix=(suffix*val)%mod1;
            original=(original*val)%mod2;
        }
        
        //Get original number back by multiplying extra two or five
        getBackOriginal(suffix,two,five,mod1);
        getBackOriginal(original,two,five,mod2);
        
        string ans="";
        //If suffix is equal to original it means final product has 10 or maybe less digits
        if (original==suffix)
            ans=to_string(original)+'e'+to_string(min(two,five));
        else
        {
            power=power-(int)(power)+4.0;
            long long prefix=pow(10,power);
            string temp=to_string(suffix);
            for (int i=temp.length()-1;i>temp.length()-6;i--)
                ans=temp[i]+ans;
            ans=to_string(prefix)+"..."+ans+'e'+to_string(min(two,five));
        }
        return ans;
    }
};