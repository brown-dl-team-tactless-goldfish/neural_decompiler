public class Solution
{
    private int min = int.MaxValue;
    public int MinimumIncompatibility(int[] nums, int k)
    {
        Array.Sort(nums);
        DFS(nums, nums.Length / k, 0, 0, 1, 0, 1);
        return min == int.MaxValue ? -1 : min;
    }

    private void DFS(int[] nums, int groupSize, int start, int end, int curSize, int sum, int used)
    {
        if (curSize == groupSize) // Current group is full, try to build next group
        {
            sum += nums[end] - nums[start]; //Calculate new sum. nums are sorted, so end is max and start is min
            if (sum >= min) return; //No need to continue
            for (int newStart = start + 1; newStart < nums.Length; newStart++) //Find new start index for next group
            {
                int bit = 1 << newStart;
                if ((used & bit) == bit) continue;
                DFS(nums, groupSize, newStart, newStart, 1, sum, used | bit);
                return; //Important! Always pick the smallest available number, no need to continue the loop.
            }
            min = sum; //Can't find new start, meaning all numbers are used already, set min.
        }
        else // Current group is not full
        {
            for (int newEnd = end + 1; newEnd < nums.Length; newEnd++) //Try to add more bigger number to the group
            {
                int bit = 1 << newEnd;
                if ((used & bit) == bit || nums[newEnd] == nums[end]) continue;
                DFS(nums, groupSize, start, newEnd, curSize + 1, sum, used | bit);
            }
        }
    }
}