class Encrypter {
public:
    string charmap[26];
    vector<char> rmap[26][26];
    
    struct trienode{
        char c;
        trienode* child[26];
        bool isend;
        
        trienode(char cc){
            c = cc;
            for(int i=0;i<26;i++){
                child[i] =nullptr;
            }
            isend =false;
        }
        
        
        trienode(){
            c = '#';
            for(int i=0;i<26;i++){
                child[i] =nullptr;
            }
            isend =false;
        }
    }*root;
    
    void insert(trienode* root,string word){
        trienode* travel = root;
        
        for(int i=0;i<word.size();i++){
            int c = word[i]-'a';
            if(!travel->child[c]){
                travel->child[c] = new trienode(word[i]);
            }
            travel = travel->child[c];
        }
        travel->isend = true;
    }
    
    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& words) {
        
        for(int i=0;i<26;i++){
            for(int j=0;j<26;j++){
                rmap[i][j].clear();
            }
        }
        for(int i=0;i<26;i++){
            charmap[i] = "";
        }
        
        for(int i=0;i<keys.size();i++){
            charmap[keys[i]-'a'] = values[i];
            rmap[values[i][0]-'a'][values[i][1]-'a'].push_back(keys[i]);
        }
        
        root = new trienode('$');
        for(auto word : words){
            insert(root,word);
        }
    }
    
    string encrypt(string word1) {
        string ans = "";
        for(auto c : word1){
            ans+=charmap[c-'a'];
        }
        return ans;
    }
    
    int dfs(string &word,int idx,trienode* travel){
        int n = word.size();
        
        if(!travel)return 0;
        
        if(idx==n){
            return travel->isend;
        }
        
        if(rmap[word[idx]-'a'][word[idx+1]-'a'].size()==0)return 0;
        
        int ans = 0;
        for(char c : rmap[word[idx]-'a'][word[idx+1]-'a']){
            ans+=dfs(word,idx+2,travel->child[c-'a']);  
        }
        return ans;
    }
    
    int decrypt(string word2) {
        return dfs(word2,0,root);
    }
};


/**
 * Your Encrypter object will be instantiated and called as such:
 * Encrypter* obj = new Encrypter(keys, values, dictionary);
 * string param_1 = obj->encrypt(word1);
 * int param_2 = obj->decrypt(word2);
 */``