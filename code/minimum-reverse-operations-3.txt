class Solution 
{
private:
    
    struct TreeNode
    {
        int val;

        TreeNode* left;
        TreeNode* right;
        TreeNode* parent;

        TreeNode(const int& v)
        {
            val    = v;
            left   = nullptr;
            right  = nullptr;
            parent = nullptr;
        }
    };

    class Tree
    {
    public:

        Tree(const std::vector<int>& v)
        {
            root = initFrom(v, 0, v.size() - 1);
        }
        TreeNode* find(const int& val)
        {
            return find(root, val);
        }
        TreeNode* next(TreeNode* node)
        {
            if (node->right)
            {
                node = node->right;
                while (node->left)
                    node = node->left;

                return node;
            }
        
            TreeNode* parent = node->parent;
            while (parent && node == parent->right) 
            {
                node = parent;
                parent = parent->parent;
            }
            return parent;
        }
        TreeNode* erase(TreeNode* node)
        {
            if (!node)
                return nullptr;

            TreeNode* parent = node->parent;
            if (!node->left && !node->right)
            {
                TreeNode* nextNode = next(node);
                if (!parent)
                {
                    root = nullptr;
                }
                else
                {
                    if (parent->left == node)
                        parent->left = nullptr;
                    else
                        parent->right = nullptr;
                }
                
                return nextNode;
            }
            else if (!node->left) 
            {
                TreeNode* nextNode = next(node);

                if (!parent)
                {
                    root = node->right;
                    node->right->parent = nullptr;
                }
                else if (parent->left == node)
                {
                    parent->left = node->right;
                    node->right->parent = parent;
                }
                else
                {
                    parent->right = node->right;
                    node->right->parent = parent;
                }

                delete node;
                return nextNode;
            }
            else if (!node->right) 
            {
                TreeNode* nextNode = next(node);
                if (!parent)
                {
                    root = node->left;
                    node->left->parent = nullptr;
                }
                else if (parent->left == node)
                {
                    parent->left = node->left;
                    node->left->parent = parent;
                }
                else
                {
                    parent->right = node->left;
                    node->left->parent = parent;
                }

                delete node;
                return nextNode;
            }
            else
            {
                TreeNode* temp = node->right;
                while (temp->left)
                    temp = temp->left;

                node->val = temp->val;

                erase(temp);
                return node;
            }
        }

    private:      
        TreeNode* initFrom(const std::vector<int>& vec, int start, int end)
        {       
            if (start > end)
                return nullptr;
        
            int mid = (start + end) / 2;
            TreeNode* node = new TreeNode(vec[mid]);
            node->left  = initFrom(vec, start, mid - 1);
            node->right = initFrom(vec, mid + 1, end);

            if (node->left)
                node->left->parent = node;
            if (node->right)
                node->right->parent = node;

            return node;
        }
        TreeNode* find(TreeNode* node, const int& val)
        {
            TreeNode* stored = nullptr;
            while (node)
            {
                if (node->val >= val)
                {
                    stored = node;
                    node = node->left;
                }
                else
                {
                    node = node->right;
                }
            }
            return stored;
        }
    private:

        TreeNode* root;
    };
public:    
    std::vector<int> minReverseOperations(int n, int p, std::vector<int>& banned, int k) 
    {
        std::vector<int> visited(n, -1);
        std::vector<int> ban(n , 0);
        for (const int& b: banned)
        {
            ban[b] = -1;
            visited[b] = -1;
        }
        
        std::vector<int> vOdd, vEven;
        for (int i = 0; i < n; ++i) 
        {            
            if (!ban[i] && i != p) 
            {
                if (i & 1)
                    vOdd.push_back(i);
                else
                    vEven.push_back(i);
            }
        }          

        Tree odd(vOdd);
        Tree even(vEven);    
        
        std::queue<int> q;
        q.push(p);
        visited[p] = 0;
        while (!q.empty())    
        {
            int curr = q.front();
            q.pop();

            int begin = std::abs(curr - k + 1);
            int end   = n - 1 - std::abs(n - curr - k);

            Tree& tree = begin & 1 ? odd: even;
            TreeNode* entry = tree.find(begin);
            while (entry && entry->val <= end)
            {
                q.push(entry->val);
                visited[entry->val] = visited[curr] + 1;
                entry = tree.erase(entry);
            }
        }
        return visited;
    };
};