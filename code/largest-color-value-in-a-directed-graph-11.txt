class Solution {
private: 
    int n ;
    int helper(int k, const string& colors, vector<int>inDegree, const vector<vector<int>>&graph){
        int ret = 0 ;
        vector<int>count(n) ; //record node i that has the maximum k 
        queue<int>q ;
        int nodes = 0 ; // count how many node in queue 
        
        //step 1 : inDegree[i] == 0, put into queue
        for(int i = 0; i < n; i++){
            if(inDegree[i] == 0)
            {
                count[i] = (colors[i] == k + 'a') ;
                q.push(i) ;
                nodes++ ;
            }
        }
        while(!q.empty()){
            int cur = q.front() ;
            q.pop() ;
            for(auto& nxt : graph[cur]){
                count[nxt] = max(count[nxt], count[cur] + (colors[nxt]-'a' == k) ) ;
                ret = max(ret, count[nxt]) ;
                inDegree[nxt]-- ;
                if(inDegree[nxt] == 0){
                    q.push(nxt) ;
                    nodes++ ; 
                }
            }
        }
        if(nodes != n)
            return -1 ;
        return ret ;
    }
public:
    int largestPathValue(string colors, vector<vector<int>>& edges) {
        this->n = colors.size() ;
        vector<vector<int>>graph(n) ;
        vector<int>inDegree(n) ; 
        unordered_set<char>colorSet ;
        for(auto& ch : colors)
            colorSet.insert(ch) ;
        for(auto& e : edges){
            int u = e[0] ;
            int v = e[1] ;
            graph[u].push_back(v) ;
            inDegree[v]++ ;
        }
        
        int ret = 1 ;  // there are no edges
        for(auto& ch : colorSet){
            int ans = helper(ch-'a', colors, inDegree, graph) ;
            if(ans == -1)  // has cycle
                return -1 ;
            ret = max(ret, ans) ;
        }
        return ret ;
    }
};