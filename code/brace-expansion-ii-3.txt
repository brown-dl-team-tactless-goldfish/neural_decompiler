class Solution {
public:
    inline unordered_set<string> Product(unordered_set<string> set1, unordered_set<string> set2) {
        unordered_set<string> result;
        for (const string & str1 : set1)
            for (const string & str2 : set2)
                result.insert(str1 + str2);
        return result;
    }
    inline unordered_set<string> Product(unordered_set<string> set_of_strings, string &s) {
        unordered_set<string> result;
        for (const string & str : set_of_strings)
            result.insert(str + s);
        return result;
    }
    inline unordered_set<string> Union(unordered_set<string> set1, unordered_set<string> set2) {
        for (const string & str2 : set2)
            set1.insert(str2);
        return set1;
    }
    inline unordered_set<string> Union(unordered_set<string> set_of_strings, char c) {
        set_of_strings.insert(string() + c);
        return set_of_strings;
    }
    
    inline int FindEndingBrace(const string &exp, int start) {
        int count = 0, end = start;
        while (end < exp.size()) {
            char c = exp[end];
            if (c == '{') {
                ++count;
            } else if (c == '}') {
                --count;
                if (count == 0)
                    break ;
            }
            ++end;
        }
        return end;
    }
    unordered_set<string> EvaluateProduct(const string &exp, int start, int &end) {
        unordered_set<string> result = { string() };
        int subexpression_start = start;
        while (start < exp.size()) {
            char c = exp[start];
            if (c == '{') {
                int subexpression_end = FindEndingBrace(exp, start);
                subexpression_start = start;
                auto sub_result = move(Evaluate(exp, subexpression_start, subexpression_end));
                result = Product(result, sub_result);
                start = subexpression_end + 1;
            } else if ('a' <= c && c <= 'z') {
                string str = string() + c;
                ++start;
                while (start < exp.size() && 'a' <= exp[start] && exp[start] <= 'z') {
                    str = str + static_cast<char>(exp[start]);
                    ++start;
                }
                result = Product(result, str);
            } else if (c == '}' || c == ',') {
                end = start + 1;
                break ;
            }
        }
        if (start >= exp.size())
            end = exp.size();
        return result;
    }
    
    unordered_set<string> Evaluate(const string &exp, int start, int end) {
        unordered_set<string> result;
        while (start <= end && exp[start] == '{' && end == FindEndingBrace(exp, start)) {
            ++start;
            --end;
        }
        int index = start;
        while (index <= end) {
            char c = exp[index];
            if (c == '{' || 'a' <= c && c <= 'z') {
                int next_start;
                auto sub_result = move(EvaluateProduct(exp, index, next_start));
                result = Union(result, sub_result);
                index = next_start;
            } else if (c == '}') {
                break ;
            } else {
                assert(c == ',');
                ++index;
            }
        }
        return result;
    }
    vector<string> braceExpansionII(string expression) {
        if (expression.empty())
            return {};
        auto set_of_strings = Evaluate(expression, 0, expression.size() - 1);
        vector<string> result;
        for (const string &str : set_of_strings)
            result.push_back(str);
        sort(result.begin(), result.end());
        return result;
    }
};