class Solution {
public:
    vector<vector<string>> deleteDuplicateFolder(vector<vector<string>>& paths) {
        auto* root = Build(paths);
        FillHash(root);
        unordered_map<long long int, vector<TreeNode*>> hash_node;
        FillHashNode(root, hash_node);
        Trim(root, hash_node);
        vector<string> prefix;
        vector<vector<string>> result;
        Recover(root, prefix, result);
        return result;
    }
private:
    struct TreeNode {
        long long int hash_value = 0;
        map<string, TreeNode*> subdirs;
    };
    TreeNode* Build(const vector<vector<string>>& paths) {
        auto* root = new TreeNode;
        for (const auto& path : paths) {
            auto* p = root;
            for (const auto& dir : path) {
                auto iter = p->subdirs.find(dir);
                if (iter == p->subdirs.end()) {
                    auto* new_node = new TreeNode;
                    p->subdirs[dir] = new_node;
                }
                p = p->subdirs[dir];
            }
        }
        return root;
    }
    void FillHash(TreeNode* root) {
        if (root->subdirs.empty()) {
            return;
        }
        auto& hash_value = root->hash_value;
        for (auto& [name, ptr] : root->subdirs) {
            FillHash(ptr);
            hash_value *= kBase;
            hash_value %= kMod;
            hash_value += ptr->hash_value;
            hash_value %= kMod;
            hash_value *= kBase;
            hash_value %= kMod;
            hash_value += std::hash<string>()(name);
            hash_value %= kMod;
        }
    }
    void FillHashNode(TreeNode* root, unordered_map<long long int, vector<TreeNode*>>& hash_node) {
        if (root->subdirs.empty()) {
            return;
        }
        hash_node[root->hash_value].push_back(root);
        for (auto& [_, ptr] : root->subdirs) {
            FillHashNode(ptr, hash_node);
        }
    }
    void Trim(TreeNode* root, unordered_map<long long int, vector<TreeNode*>>& hash_node) {
        auto iter = root->subdirs.begin();
        while (iter != root->subdirs.end()) {
            if (hash_node[iter->second->hash_value].size() > 1) {
                root->subdirs.erase(iter++);
            } else {
                Trim(iter->second, hash_node);
                ++iter;
            }
        }
    }
    void Recover(TreeNode* root, vector<string>& prefix, vector<vector<string>>& dest) {
        for (const auto& [name, ptr] : root->subdirs) {
            prefix.push_back(name);
            dest.push_back(prefix);
            Recover(ptr, prefix, dest);
            prefix.pop_back();
        }
    }
    long long int const kBase = 37;
    long long int const kMod = 1000000007;
};