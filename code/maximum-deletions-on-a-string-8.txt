class Solution {
public:
 string s;
 vector<unsigned int> hash, pows;
 unordered_map<int,int> visited;
   
 int deleteString(string s) {  
   this->s = s;
   if(isBad()) return s.size();
   fill();
      
  return helper(0, 1, 0, 1);
 }
 
   
 int helper( int a, int b, int id1, int id2){                                   //Body of DFS
   int mask = (id1<<12) + id2, ans = 1;
   if(visited.count(mask)){return visited[mask];}
   
   for(; b < s.size(); a++, id2++, b +=2)
     if((hash[a+1] - hash[id1])*pows[id2] == (hash[b+1] - hash[id2])*pows[id1]) //check if our hashes is equal
       if(id2 + 1 == s.size()) ans = max(ans, 2);                                            //if we in last position
       else ans = max(ans, 1 + helper(id2, id2+1, id2, id2+1));                              //if not
   
   return visited[mask] = ans;
 }
 
 
 void fill(){                                                                  //fill table of hashes and powers
   int n = s.size();
   hash.resize(n+1);
   pows.resize(n);
     
   pows[0] = 1, hash[0] = 0, hash[1] = s[0];
   for(int i = 1; i != n; i++ )
     hash[i+1] = s[i] * (pows[i] = pows[i-1]*1000000007) + hash[i];
 }
 
 bool isBad(){
   for(int i = 1; i < s.size();)
     if(s[0] != s[i++]) return false;
   
   return true;
 }
};