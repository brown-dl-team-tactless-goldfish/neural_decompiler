class Solution {
public:
    int maximumInvitations(vector<int>& favorite) {
        const auto n = (int)favorite.size();
        vector<bool> done(n);
        vector<bool> visiting(n);
        // set of person-ids (of mutual-favorite persons)
        unordered_set<int> mutualFavorites;

        int maxCircle = 0;
        int countOfTwoPersonCircles = 0;

        for (int i = 0; i < n; ++i) {
            if (done[i]) {
                continue;
            }
            // do DFS starting from person #i, and compute the circle size;
            // if no circle is found, zero will be returned.
            auto [circleSize, _] = dfs(i, favorite, done, visiting, mutualFavorites);
            maxCircle = max(maxCircle, circleSize);
            if (circleSize == 2) {
                ++countOfTwoPersonCircles;
            }
        }
        // figure out the actual number of persons that can chain up to the circles of twos.
        // invert the graph, for bfs
        vector<vector<int>> adj(n);
        for (int i = 0; i < n; ++i) {
            int j = favorite[i];
            adj[j].emplace_back(i);
        }

        // Do BFS on the reversed graph, to grow the chain of friends that rooted at each person in
        // circles of twos.
        // in other words, for each root vertex we probe for the max depth.
        int personsInSpecialCases = 2 * countOfTwoPersonCircles;
        for (const auto root : mutualFavorites) {
            int depth = bfs(root, adj, mutualFavorites);
            personsInSpecialCases += depth;
        }

        return max(maxCircle, personsInSpecialCases);
    }

private:
    static int
    bfs(int root, const vector<vector<int>>& adj, const unordered_set<int>& mutualFavorites) {
        queue<int> q;
        int depth = 0;
        // since there aren't circles for these BFSs,
        // we don't need to track the visited-ness.
        for (int u : adj[root]) {
            if (mutualFavorites.count(u) == 0) {
                q.emplace(u);
            }
        }
        while (!q.empty()) {
            ++depth;
            int qsz = q.size();
            while (qsz--) {
                // for easier debugging, we can use:
                // while (qsz > 0) { --qsz; ... }
                int u = q.front();
                q.pop();
                for (auto v : adj[u]) {
                    q.emplace(v);
                }
            }
        }
        // cout << "depth from root #" << root << " is: " << depth << endl;
        return depth;
    }

    /// \brief do DFS starting from person #i, and compute the circle size;
    /// if no circle is found, zero will be returned.
    /// \param mutualFavorites maintains the persons that are in circles of two persons, for they
    /// are special cases.
    /// \returns a two-tuple, with the first element representing the size of the circle, and the
    /// second element indicates whether the current node is within the circle or not.
    static tuple<int, bool>
    dfs(int i,
        const vector<int>& favorite,
        vector<bool>& doneFlags,
        vector<bool>& visitingFlags,
        unordered_set<int>& mutualFavorites) {
        if (doneFlags[i]) {
            return {0, false};
        }
        // detected a circle
        if (visitingFlags[i]) {
            visitingFlags[i] = false; // mark the start/end of the circle.
            return {0, true};
        }
        visitingFlags[i] = true;
        auto [circleSize, withinTheCircle] =
                dfs(favorite[i], favorite, doneFlags, visitingFlags, mutualFavorites);
        doneFlags[i] = true;
        if (withinTheCircle) {
            if (visitingFlags[i]) {
                return {circleSize + 1, true};
            } else {
                // this is the start/end of the circle.
                // so, the parent vertex is no longer within the circle.
                int newCircleSize = circleSize + 1;
                if (newCircleSize == 2) {
                    // this is a circle of couplets.
                    // we'll handle it specially
                    int j = favorite[i];
                    mutualFavorites.insert(i);
                    mutualFavorites.insert(j);
                }
                return {newCircleSize, false};
            }
        }
        return {circleSize, false};
    }
};