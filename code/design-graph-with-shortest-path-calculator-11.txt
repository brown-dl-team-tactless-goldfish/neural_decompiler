constexpr int maxNodes = 100;

class Graph {
    vector<pair<int, int>> connections[maxNodes];
    int costs[maxNodes];
    int minPath(int start, int dest) {
        // edge case
        if (start == dest) return 0;
        // support variables
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        // preparing costs and pq;
        fill(costs, costs + maxNodes, INT_MAX);
        costs[start] = 0;
        for (auto &connection: connections[start]) {
            auto [to, cost] = connection;
            pq.push({cost, to, start});
        }
        // Dijkstra!
        while (pq.size()) {
            // popping the top of pq
            auto &top = pq.top();
            int cost = top[0], currNode = top[1], prevNode = top[2];
            pq.pop();
            // already been here
            if (costs[currNode] != INT_MAX) continue;
            costs[currNode] = cost;
            if (currNode == dest) break;
            for (auto &connection: connections[currNode]) {
                auto [to, cost] = connection;
                pq.push({costs[currNode] + cost, to, currNode});
            }
        }
        return costs[dest];
    }
public:
    Graph(int n, vector<vector<int>> &edges) {
        for (auto &edge: edges) connections[edge[0]].push_back({edge[1], edge[2]});
    }
    
    void addEdge(vector<int> edge) {
        connections[edge[0]].push_back({edge[1], edge[2]});
    }
    
    int shortestPath(int n1, int n2) {
        int res = minPath(n1, n2);
        return res == INT_MAX ? -1 : res;
    }
};