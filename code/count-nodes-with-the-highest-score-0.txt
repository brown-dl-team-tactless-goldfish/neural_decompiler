#define MAX(a,b) ((a) > (b) ? (a) : (b))

struct pair {
    int nums;
    int totalnodes;
    int node1;
    int node2;
    long long ans;
};

int dfs(struct pair* res, int parentsSize, int tar) {
    if (!res[tar].nums) {
        res[tar].totalnodes = 1;
        return 1;
    }
    if (!res[tar].node2) {
        int l = (!res[res[tar].node1].totalnodes) ? dfs(res, parentsSize, res[tar].node1) : res[res[tar].node1].totalnodes;
        res[tar].totalnodes = l + 1;
        return l + 1;
    }
    int l = (!res[res[tar].node1].totalnodes) ? dfs(res, parentsSize, res[tar].node1) : res[res[tar].node1].totalnodes;
    int r = (!res[res[tar].node2].totalnodes) ? dfs(res, parentsSize, res[tar].node2) : res[res[tar].node2].totalnodes;
    res[tar].totalnodes = l + r + 1;
    return l + r + 1;
}

int countHighestScoreNodes(int* parents, int parentsSize) {
    if (parentsSize == 2) return 2;
    struct pair* res = (struct pair*) calloc(parentsSize, sizeof(struct pair));
    for (int i = 1; i < parentsSize; i++) {
        (res[parents[i]].nums)++;
        if (!res[parents[i]].node1) {
            res[parents[i]].node1 = i;
        } else {
            res[parents[i]].node2 = i;
        }
    }
    res[0].totalnodes = parentsSize;
    for (int i = 1; i < parentsSize; i++) {
        if (res[i].totalnodes != 0) continue;
        res[i].totalnodes = dfs(res, parentsSize, i);
    }
    long long max = INT_MIN;
    int cnt = 0;
    for (int i = 0; i < parentsSize; i++) {
        if (res[i].totalnodes == 1) {
            res[i].ans = parentsSize - res[i].totalnodes;
        } else {
            long long tmp = (!res[i].node2) ? res[res[i].node1].totalnodes : (long long) res[res[i].node1].totalnodes * (long long) res[res[i].node2].totalnodes;
            res[i].ans = (i == 0) ? tmp : tmp * (parentsSize - res[i].totalnodes);
        }
        max = MAX(max, res[i].ans);
    }
    for (int i = 0; i < parentsSize; i++) {
        if (res[i].ans == max) cnt++;
    }
    free(res);
    return cnt;
}
