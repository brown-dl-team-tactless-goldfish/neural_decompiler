public class Solution {

	/*
	 * analysis:
	 * 
	 *  仅考虑会出现后置0的情况
	 *  
	 *  case 1 : K = 0
	 *      res = 5, 对应 0!,1!,2!,3!,4!
	 *  case 2 : K = 1
	 *      res = 5, 对应 5!,6!,7!,8!,9!
	 *      
	 *  考虑 后置0的出现条件：
	 *      10 = 10 * 1 | 2 * 5
	 *  然后
	 *      n! = (n-1)!*n
	 *      若(n-1)!有x个后置0，则n的后置0数量必定>=x
	 *      
	 *  根据乘积计算,令f(n) = x ,表示为n!的后置0有x位
	 *      f(1)=f(2)=f(3)=f(4)=f(0) 2,3,4,0 中不存在乘积=10的倍数
	 *      f(5)=f(6)=f(7)=f(8)=f(9) 6,7,8,9 中除了(5!中产生的后置0) 剩下的数字同样不会产生后置0
	 *   
	 *      然后 f(0) != f(5) => f(5) != f(10) ... => f(n) != f(n + 5) [只要+5就必定会出现一对 2 * 5 或者是 10的倍数]
	 *      故结果 必定是 0 或 5
	 *      
	 *  然后再看后置0的出现规则：
	 *  
	 *      f(n) = num => {  由于f(1...4)  = f(0)  f(6...9) = f(5), 故直接考虑 n%5 == 0 的值即可.
	 *          num == 0 => 0
	 *          int res = 0;
	 *          while(num % 5 = 0) { // 每出现一次5 后置零必+1 ，有5必有2  2 * 5 = 10
	 *              res++;
	 *              num/=5;
	 *          }
	 *      }
	 *   
	 * 根据后置0规则来看(5*n)测试结果
	 * 
	 *  5=>1
	 *  10=>1
	 *  15=>1
	 *  20=>1
	 *  25=>2
	 *  
	 *  => { { 1[4]2 }[4] 1[4] 2 }[4] ....
	 *  4个1后出现一个2
	 *  4个2后出现一个3
	 *  
	 *  根据此规则映射到K上去=>
	 *  
	 *  4*1 + 2 = 6 = 5 * 1 + 1 缺失部位: (4,6)
	 *  { 4*1 + 2 } * 4 + 4* 1 + 3 =  5 * 6 + 1 缺失部位: (29,31)
	 *  sum = 5 * prev + 1 缺失部位: (sum - last, sum)
	 *  ....
	 *  
	 */

    public int PreimageSizeFZF(int K) {
        int prev = 1, sum = 1, last = 1;
        while (K > sum)
        {
            last++;
            prev = sum;
            sum = 5 * sum + 1;
        }

        if (K == sum) return 5;

        while (K > 0)
        {
            if (K / 5 == prev) return 0;
            K %= prev;
            last--;
            if (K > prev - last && K < prev) return 0;
            prev = (prev - 1) / 5;
        }

        return 5;
    }
}