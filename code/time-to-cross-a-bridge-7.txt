class Solution {
public:
    const int l2r = 0; 
    const int pickOld = 1;
    const int r2l = 2; 
    const int putNew = 3;
    int findCrossingTime(int n, int k, vector<vector<int>>& time) {
        vector<pair<int,int>> t(k);
        for(int i = 0;i<k;i++) {
            t[i] = {time[i][0] + time[i][2], i};
        }
        sort(t.begin(),t.end(),[](auto& a, auto& b) {
            if(a.first == b.first) {
                return a.second > b.second; 
            }
            return a.first > b.first; 
        });
        vector<int> i2e(k);
        for(int i = 0;i<k;i++) {
            i2e[t[i].second] = -i; 
        }
        int T = 0; 
        multimap<int,pair<int,int>> actions; // time, ith_work, action
        priority_queue<pair<int,int>> ls; 
        priority_queue<pair<int,int>> rs; 
        for(int i = 0;i<k;i++) {
            ls.push({i2e[i],i});
        }
        int pickOld_cnt = 0; 
        while(true) {
            //cout<<"T= "<<T<<endl;
            auto ptr = actions.begin(); 
            while(ptr != actions.end()) {
                auto x = *ptr; 
                int t = x.first; 
                if(t<=T) {
                    auto [i, a] = x.second; 
                    cout<<"T"<<t<<" : "<<i<<"th worker finish "<<(a == putNew? "putNew" : "pickOld")<<endl;
                    if(a == putNew) {
                        ls.push({i2e[i], i});
                    } else if(a == pickOld) {
                        pickOld_cnt--; 
                        rs.push({i2e[i], i});
                    }
                    auto need_delete = ptr; 
                    ptr++; 
                    actions.erase(need_delete);
                } else {
                    break; 
                }
            }
            if(rs.size() > 0) {
                auto [e,i] = rs.top(); 
                rs.pop(); 
                cout<<"T"<<T<<" -> T"<<T+time[i][2]<<" : "<<i<<"th worker from right to left"<<endl;
                T += time[i][2];
                if(n == 0 && pickOld_cnt == 0 && rs.size() == 0) {
                    break; 
                }
                actions.insert({T+time[i][3], {i, putNew}});
            } else if(ls.size() > 0 && n > 0) {
                auto [e,i] = ls.top(); 
                ls.pop(); 
                cout<<"T"<<T<<" -> T"<<T+time[i][0]<<" : "<<i<<"th worker from left to right"<<endl;
                T += time[i][0];
                n--; 
                actions.insert({T + time[i][1], {i, pickOld}});
                pickOld_cnt++; 
                
            } else {
                auto ptr = actions.begin(); 
                if(ptr == actions.end()) {
                    return -1; 
                }
                auto x = *ptr; 
                T = x.first; 
                auto [i, a] = x.second; 
                cout<<"T"<<T<<" : "<<i<<"th worker finish "<<(a == putNew? "putNew" : "pickOld")<<endl;
                if(a == putNew) {
                    ls.push({i2e[i], i});
                } else if(a == pickOld) {
                    pickOld_cnt--; 
                    rs.push({i2e[i], i});
                }
                actions.erase(ptr);
            }
        }
        return T; 
    }
};