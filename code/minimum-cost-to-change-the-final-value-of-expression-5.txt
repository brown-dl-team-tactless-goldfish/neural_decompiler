class Solution {
public:
    int minOperationsToFlip(string expression) {
        // Convert into Reverse Polish Notation
        std::stack<char> s;
        string exp;
        int n = expression.size();
        for(int i = 0; i < n; i++) {
            char c = expression[i];
            switch(c) {
                case '0':
                case '1': {
                    exp += c;
                    break;
                } case '(': {
                    s.push(c);
                    break;
                } case ')': {
                    while(!s.empty() and s.top() != '(') {
                        char t = s.top();
                        s.pop();
                        exp += t;
                    }
                    if(not s.empty()) s.pop();
                    break;
                } case '|':
                  case '&': {
                    while(!s.empty()  and s.top() != '(') {
                        char temp = s.top();
                        s.pop();
                        exp += temp;
                    }
                    s.push(c);
                    break;
                }
            }
        }
        
        while(not s.empty()) {
            char temp = s.top();
            s.pop();
            exp += temp;
        }
        
        // Evaluate the equation while keeping track the partial minimum cost
        stack<pair<int,int>> st;
        for(int i = 0; i < exp.size(); i++) {
            char c = exp[i];
            if(c == '0' or c == '1') {
                st.push(make_pair(c - '0', 1));
            } else if (c == '&' or c == '|') {
                auto v1 = st.top();
                st.pop();
                auto v2 = st.top();
                st.pop();
                int cnt, v;
                if(v1.first == 0 and v2.first == 0) {
                    if(c == '&') {
                        cnt = min(v1.second + v2.second, min(1 + v1.second, 1 + v2.second));
                        v = 0;
                    } else {
                        cnt = min(v1.second, v2.second);
                        v = 0;
                    }
                } else if ((v1.first == 0 and v2.first == 1) or (v1.first == 1 and v2.first == 0)) {
                    if(c == '&') {
                        cnt = 1;
                        v = 0;
                    } else {
                        cnt = 1;
                        v = 1;
                    }
                } else if (v1.first == 1 and v2.first == 1) {
                    if(c == '&') { 
                        v = 1;
                        cnt = min(v1.second, v2.second);
                    } else {
                        v = 1;
                        cnt = min(v1.second + v2.second, 1 + min(v1.second, v2.second));
                    }
                }
                st.push(make_pair(v, cnt));
            }
        }
        auto r = st.top();
        return r.second;
    }
};