class Solution {
    long long make(long long rev, long long buf1, long long ind1, long long buf2, long long ind2) {
        return (rev << 48) | (buf1 << 36) | (ind1 << 24) | (buf2 << 12) | ind2;
    }
    
    bool dfs(const string& s1, const string &s2, unordered_map<long long, bool>& have, int rev, int buf1, int ind1, int buf2, int ind2) {
        const long long state = make(rev, buf1, ind1, buf2, ind2);
        const auto t = have.find(state);
        if (t != have.end()) {
            return t->second;
        }
        bool& r = have[state];
        if (buf1 == 0) {
            if (ind1 >= s1.length()) {
                return r = buf2 == 0 && ind2 >= s2.length();
            }
            if (isalpha(s1[ind1])) {
                return r = dfs(s1, s2, have, rev, 1000 + s1[ind1] - 'a', ind1 + 1, buf2, ind2);
            }
            for (int i = ind1; i < s1.length() && isdigit(s1[i]); ++i) {
                buf1 = buf1 * 10 + s1[i] - '0';
                if (dfs(s1, s2, have, rev, buf1, i + 1, buf2, ind2)) {
                    return r = true;
                }
            }
            return r = false;
        }
        if (buf2 == 0) {
            return r = dfs(s2, s1, have, rev ^ 1, buf2, ind2, buf1, ind1);
        }
        if (buf1 >= 1000) {
            if (buf2 >= 1000) {
                return r = buf1 == buf2 && dfs(s1, s2, have, rev, 0, ind1, 0, ind2);
            }
            return dfs(s1, s2, have, rev, 0, ind1, buf2 - 1, ind2);
        }
        if (buf2 >= 1000) {
            return r = dfs(s1, s2, have, rev, buf1 - 1, ind1, 0, ind2);
        }
        const int buf = min(buf1, buf2);
        return r = dfs(s1, s2, have, rev, buf1 - buf, ind1, buf2 - buf, ind2);
    }
    
public:
    bool possiblyEquals(string s1, string s2) {
       unordered_map<long long, bool> have;
       return dfs(s1, s2, have, 0, 0, 0, 0, 0);
        
    }
};