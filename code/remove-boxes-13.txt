class Solution {
public:


	int dfs(vector<int>& boxes,vector<vector<vector<int>>>& dp,int l, int r, int p )
	{
	// only consider how to deal with the last element
	// two options: attach the last element to front substirng ending with the same color
	// or erase the last element with its trailing same color boxes
		if(l>r) return 0;

		if(dp[l][r][p]) return dp[l][r][p];

		dp[l][r][p]=max(dp[l][r][p],dfs(boxes,dp,l,r-1,0)+(p+1)*(p+1));// burst the last element

		for(int i=l;i<r;i++)
		{
			if(boxes[i]==boxes[r])
			{
				dp[l][r][p]=max(dp[l][r][p],dfs(boxes,dp,l,i,p+1)+dfs(boxes,dp,i+1,r-1,0));// attach the last element to front substring
			}

			// ABACAA =>ABACA[k+1] the last element attached to front and it returns 0
		}

		return dp[l][r][p];
	}
	int removeBoxes(vector<int>& boxes) {
		int n=boxes.size();
		vector<vector<vector<int>>> dp(n,vector<vector<int>>(n,vector<int>(n)));
		dfs(boxes,dp,0,n-1,0);
		return dp[0][n-1][0];

	}
};