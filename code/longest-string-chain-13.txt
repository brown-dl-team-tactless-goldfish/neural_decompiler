class StrListHash {
public:
    size_t operator()(const list<char>& l) const {
        size_t hashRes = 0;
        
        size_t multiplier = 1;
        for (const auto& c : l) {
            hashRes += c * multiplier;
            multiplier = 1 + (multiplier << 1);
        }
        
        return hashRes;
    }
};

class Solution {
public:
    int longestStrChain(vector<string>& words) {
        sort(words.begin(), words.end(), [](const string& w1, const string& w2) { return w1.length() < w2.length(); });
        
        unordered_map<list<char>, int, StrListHash> cache;
        cache[list<char>{}] = 0; 
        
        // Build dp cache
        for (const auto& ow : words) {
            list<char> w(ow.begin(), ow.end());
            
            int result = 1;
            for (auto iter = w.begin(); iter != w.end(); ++iter) {
                auto val = *iter;
                iter = w.erase(iter);
                
                if (cache.find(w) != cache.end()) {
                    result = max(result, cache[w]+1);
                }
                
                iter = w.insert(iter, val);
            }
            
            if (cache.find(w) == cache.end()) {
                cache[w] = 1;   
            }
            
            cache[w] = max(cache[w], result);
        }
        
        // Get result
        int maxLen = 1;
        for (const auto& kv : cache) {
            maxLen = max(maxLen, kv.second);
        }
        
        return maxLen;
    }
};