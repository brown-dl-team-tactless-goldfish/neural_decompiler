
#define HASH_TABLE_SIZE 1000

typedef struct hash_entry_s
{
    char * string;
    unsigned occurences;
    struct hash_entry_s *next;
} hash_entry_t;

unsigned hashstring(char *string)
{
    char *s = string;
    unsigned val = *s;
    while (*s++) val+=*s;
    return val % HASH_TABLE_SIZE;
}

void insertintohashtable(hash_entry_t **table, char *string)
{
    
    unsigned hashval = hashstring(string);
    
    hash_entry_t *current = table[hashval];
    hash_entry_t *prev = NULL;
    while (current)
    {
        if (strncmp(current->string, string, 50) == 0){
            current->occurences++;
            return;
        }
        prev = current;
        current=current->next;
    }
    
    hash_entry_t *entry = (hash_entry_t *)malloc(sizeof(hash_entry_t));
    entry->occurences = 1;
    entry->next = current;
    entry->string = string;
    
    current = entry;
    if (prev != NULL)
        prev->next = current;
    else
        table[hashval] = current; 
}

unsigned hashgetocc(hash_entry_t **table, char *string)
{
   
    unsigned hashval = hashstring(string);
    
    hash_entry_t *current = table[hashval];
    while (current)
    {
        if (strcmp(current->string, string) == 0){
            return current->occurences;
        }
        current=current->next;
    }
    
    return 0;
}

static void swap(hash_entry_t **heap, unsigned a, unsigned b)
{
    hash_entry_t * temp = heap[a];
    heap[a] = heap[b];
    heap[b] = temp;
}

static int elementcompare(hash_entry_t *a, hash_entry_t *b)
{
    if (a->occurences > b->occurences) return 1;
    if (a->occurences < b->occurences) return -1;
    return (-1*strcmp(a->string, b->string));
}

unsigned heapsize;
static void bubbledown(hash_entry_t **heap, unsigned index)
{
    // Smallest at the top
    unsigned left = (index *2) + 1;
    unsigned right = (index *2) + 2;
    unsigned parent = index;
   
    unsigned largest = parent;
   
    if (left < heapsize && elementcompare(heap[left], heap[parent]) > 0)
        largest = left;
    if (right < heapsize && elementcompare(heap[right],  heap[largest]) >0 )
        largest = right;
   
    // Bail out if we are done bubbling down
    if (largest == parent)  return;
   
    swap(heap, parent, largest);

    bubbledown(heap, largest);
}

static void bubbleup(hash_entry_t **heap, unsigned index)
{
    // bail out if we are done bubbling up
    if (index == 0) return;
   
    unsigned parent = ((index-1)/2);
    if (elementcompare(heap[index], heap[parent]) > 0) swap(heap, index, parent);
   
    // call on parent
    bubbleup(heap, parent);
   
}
static void insertintoheap(hash_entry_t **heap, hash_entry_t *element)
{
    heap[heapsize++] = element;
    bubbleup(heap, heapsize-1);
}


static hash_entry_t* popheap(hash_entry_t **heap)
{
    hash_entry_t *retval = heap[0];
   
    swap(heap, heapsize-1, 0);

    heapsize--;

    bubbledown(heap, 0);

    return retval;
}

char ** topKFrequent(char ** words, int wordsSize, int k, int* returnSize){
    heapsize = 0;
    *returnSize = k;
    
    char ** retarray = malloc(sizeof(char*) * k);
    
    hash_entry_t *table[HASH_TABLE_SIZE] = {NULL};
    hash_entry_t *heap[HASH_TABLE_SIZE] = {0};
    
    for (int i = 0; i < k; i++)
        retarray[i] = malloc(sizeof(char) * 10);
    
    for (int i = 0; i < wordsSize; i++)
       insertintohashtable(table, words[i]);

    signed k_copy = k;
    for (unsigned int i = 0; i < HASH_TABLE_SIZE; i++)
    {
        hash_entry_t *current = table[i];
        if (current == NULL)
            continue;
       
        while (current)
        {
            insertintoheap(heap, current);
            current=current->next;
            k_copy--;
        }
    }
    
    for (int i = 0; i < k; i++)
        retarray[i] = popheap(heap)->string;
 
    return retarray;
    
}