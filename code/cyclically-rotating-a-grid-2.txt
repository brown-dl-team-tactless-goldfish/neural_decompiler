class Solution {
    void cycle(int step[][3], vector<vector<int>>& grid, vector<int>& tmp, bool read,
          int x, int y, int startindex, int layerc)
    {
        for(int s=0; s<4; s++)
        {
            int xs = step[s][0], ys = step[s][1], sc = step[s][2];
            for(int i=0; i<sc; i++)
            {
                x+=xs, y+=ys;
                if (read)
                    tmp[startindex++] = grid[x][y];
                else
                {
                    startindex = startindex%layerc;
                    grid[x][y] = tmp[startindex++];
                }
            }
        }
    }
public:
    vector<vector<int>> rotateGrid(vector<vector<int>>& grid, int k) {
        int n = grid.size();
        int m = grid[0].size();
        int c = min(n/2,m/2);
        //step[#][3]: {step in direction x, step in direction y, step count}
        int step[4][3] = {{1,0,n-1},{0,1,m-1},{-1,0,n-1},{0,-1,m-1}};
        vector<int> tmp(2*(n+m)-4);
        for(int layeri=0; layeri<c; layeri++)
        {
            step[0][2] = step[2][2] = n-1;
            step[1][2] = step[3][2] = m-1;
			//ready data to tmp array
            cycle(step, grid, tmp, true, layeri, layeri, 0, 0);
            int layerc = 2*(m+n)-4;
			//rotate layeri-th array
            cycle(step, grid, tmp, false, layeri, layeri, layerc-k%layerc, layerc);
            n-=2;
            m-=2;
        }
        return grid;
    }