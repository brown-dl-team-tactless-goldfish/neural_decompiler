class Solution {
    unordered_map<char, char> opp;
public:
    bool checkMove(vector<vector<char>>& g, int rMove, int cMove, char color) {
		// store opposites of both types of colors in map for easy access afterwards
        opp['B'] = 'W';
        opp['W'] = 'B';
		// direction vectors
        int dr[8] = {-1,-1,0,1,1, 1, 0,-1};
        int dc[8] = {0, 1, 1,1,0,-1,-1,-1};
		// check in every direction one by one
        for (int i = 0; i < 8; i++) {
            if (check(g, dr[i], dc[i], rMove+dr[i], cMove+dc[i], color))
                return true;
        }
        return false;
    }
    
    inline bool check(vector<vector<char>>& g,
                      int dr, int dc, int x, int y, char color) {
        int R = g.size(), C = g[0].size();
        int moves = 0;
		// keep moving in the direction while it has opposite color
        while (x>=0 && x<R && y>=0 && y<C && g[x][y] == opp[color]) {
            moves++;
            x += dr, y += dc;
        }
		// if moved out of the grid
        if (x < 0 or x >= R or y < 0 or y >= C) return false;
		// check if the path length is at least 3, and currently we are at the new color only.
        return moves >= 1 and g[x][y] == color;
    }
};