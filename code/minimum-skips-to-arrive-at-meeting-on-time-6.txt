class Solution {
public:

    int speed_ceil(int x, int speed){
        // Return next integer multiple of speed that is >= x
        int rem = x % speed;
        if (rem) return x+speed-rem;
        return x;
    }
    int minSkips(vector<int>& dist, int speed, int hoursBefore) {
        int n = dist.size();
        int dp[n];
        int total = 0;
        int over = dist[0] / speed;
        int remainder = dist[0] % speed;
        
        hoursBefore -= over;
        dist[0] = remainder;
        total += remainder;
        dp[0] = remainder;
        
        for (int i = 1; i < n; i++){
            // Reduce all values modulo speed
            over = dist[i] / speed;
            remainder = dist[i] % speed;
            dist[i] = remainder;
            total += remainder;
            hoursBefore -= over;
            dp[i] = speed_ceil(dp[i-1], speed) + dist[i];
        }
        
        long scaled_hours = (long)hoursBefore * speed;
        if (total > scaled_hours) return -1;
        if (dp[n-1] <= scaled_hours) return 0;

        int last, temp;
        
        for (int skip = 1; skip < n; skip++){
            
            last = dp[skip];
            dp[skip] = dp[skip-1] + dist[skip];
            for (int j = skip+1; j < n; j++){
                temp = dp[j];
                dp[j] = min(speed_ceil(dp[j-1], speed), last) + dist[j];
                last = temp;
            }
            
            if (dp[n-1] <= scaled_hours) return skip;
        }
        return n-1;
    }
    
};