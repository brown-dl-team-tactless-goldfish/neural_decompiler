/**
 * Definition for a Node.
 * struct Node {
 *     int val;
 *     struct Node *left;
 *     struct Node *right;
 *     struct Node *next;
 * };
 */

typedef struct Node * queue_data_t;

typedef enum queue_er_em {
    QUEUE_OK = 0,
    QUEUE_EMPTY = 1,
    QUEUE_FULL = 2,
    QUEUE_ERROR = 0xFF
} queue_er_em;

typedef struct _queue_t {
    queue_data_t *value;
    int buf_size;
    int offer_i;
    int poll_i;
    int count;
} queue_t;

queue_t *create_queue(int buf_size) {
    queue_t *queue = malloc(sizeof(queue_t));
    memset(queue, 0, sizeof(queue_t));
    queue->buf_size = buf_size;
    queue->value = malloc(buf_size*sizeof(queue_data_t));
    memset(queue->value, 0, buf_size*sizeof(queue));

    return queue;
}

queue_er_em offer_queue(queue_t *queue, queue_data_t *tdata) {
    if(queue->count >= queue->buf_size) return QUEUE_ERROR;
    memcpy(&queue->value[queue->offer_i++], tdata, sizeof(queue_data_t));
    if(queue->offer_i == queue->buf_size) queue->offer_i = 0;
    queue->count++;
    return QUEUE_OK;
}

queue_er_em poll_queue(queue_t *queue, queue_data_t *rdata) {
    if(queue->count < 1) return QUEUE_EMPTY;
    memcpy(rdata, &queue->value[queue->poll_i++], sizeof(queue_data_t));
    if(queue->poll_i == queue->buf_size) queue->poll_i = 0;
    queue->count--;
    return QUEUE_OK;
}

inline int get_queue_data_count(queue_t *queue) {
    return queue->count;
}

bool is_queue_empty(queue_t *queue) {
    return !(queue->count!=0);
}


struct Node *connect(struct Node *root) {
    if(root == NULL) return NULL;
    queue_t *buf = create_queue(500);
    struct Node *node = root;

    /* Using BFS, first init */
    if(node->left != NULL) {
        offer_queue(buf, &node->left);
    }
    if(node->right != NULL) {
        offer_queue(buf, &node->right);
    }

    while(!is_queue_empty(buf)) {
        int count = get_queue_data_count(buf);
        struct Node *prev = NULL;
        for(int i=0;i<count;i++) {
            poll_queue(buf, &node);
            if(prev != NULL) {
                prev->next = node;
            }
            prev = node;

            if(node->left != NULL) {
                offer_queue(buf, &node->left);
            }
            if(node->right != NULL) {
                offer_queue(buf, &node->right);
            }
        }
    }

    return root;
}
