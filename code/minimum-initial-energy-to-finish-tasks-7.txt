class Solution {
public:
    static bool sortDiff(const vector<int> &v1, const vector<int> &v2){
        return v1[1] - v1[0] > v2[1] - v2[0];
    }
    int minimumEffort(vector<vector<int>>& tasks) {
        sort(tasks.begin(), tasks.end(), sortDiff);
        int idx = 1;
        int start = tasks[0][1];
        int left = start - tasks[0][0];
        int need = 0;
        while(idx < tasks.size()){
            if(tasks[idx][1] - left > 0){
                need += tasks[idx][1] - left;
                left = tasks[idx][1];
            }
            left = left - tasks[idx][0];
            idx++;
        }
        return start + need;
    }
};
/*
TC: O(NLogN)
SC: O(1)

Logic:
We will start with tasks[0][1].
We calculate what's left (start - tasks[i][0]), and hence, add the number in 'need' and 'left' which is required to make it eligible to do the next tasks (so, that left >= tasks[i+1][1]).

But, how will we know which tasks to pick first, or before the other tasks?
My first hunch was to pick the task with maximum requirement(tasks[i][1]) first. But, by the below use-cases I concluded that it is irrelevant. 
The task we need to pick first is the task from which we will save the most i.e., with max(tasks[i][1] - tasks[i][0]).
So, the solution is to sort the array as max saving, and just implement our previous logic in a while loop.

Few Use-Cases I used to conclude my theory:
UC 1.1
[10,12] [9,12]
start = 12
[9,12] | left = 2 | need = 10 -> left = 12
ans = 22

UC 1.2
[9,12] [10,12]
start = 12
[10,12] | left = 3 | need = 9 -> left = 12
ans = 21

UC 2.1
[9,12] [10,11]
start = 12
[10,11] | left = 3 | need = 8 -> left = 11
ans = 20

UC 2.2
[10,11] [9,12]
start = 11
[9,12] | left = 1 | need = 11 -> left = 12
ans = 23

UC 3.1
[9,12] [6,11]
start = 12
[10,11] | left = 3 | need = 8 -> left = 11
ans = 20

UC 3.2
[6,11] [9,12]
start = 11
[9,12] | left = 5 | need = 7 -> left = 12
ans = 18

UC 4
[10,12] [2,4] [1,3] [10,11] [8,9]
start = 12
[2,4] [1,3] [10,11] [8,9] | left = 2 | need = 2 -> left = 4
[1,3] [10,11] [8,9] | left = 2 | need = 2+1 -> left = 3
[10,11] [8,9] | left = 2 | need = 2+1+9 -> left = 11
[8,9] | left = 1 | need = 2+1+9+8 -> left = 9
ans = start + need = 12 + 20 = 32

*/