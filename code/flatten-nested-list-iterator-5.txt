struct StackElt {
  struct NestedInteger **lst;
  int size, p;
};

struct NestedIterator {
  struct StackElt *stk;
  int size, sp;
};

static void advance(struct NestedIterator *iter) {
  while (iter->sp > 0) {
    struct StackElt *e = iter->stk + (iter->sp - 1);
    // Advance stack top to next integer.
    ++e->p;
    for (;;) {
      // A: If current stack element is exhausted, pop and restart.
      if (e->p >= e->size) {
        --iter->sp;
        break;
      }
      struct NestedInteger *i = e->lst[e->p];
      // If pointed NI is an integer. We're done.
      if (NestedIntegerIsInteger(i)) return;
      // Else push new list and go to A.
      if (iter->sp == iter->size) {
        iter->size *= 2;
        iter->stk = realloc(iter->stk, iter->size * sizeof *iter->stk);          
      }
      e = iter->stk + iter->sp++;
      e->lst = NestedIntegerGetList(i);
      e->size = NestedIntegerGetListSize(i);
      e->p = 0;
    }
  }
  return iter;
}

struct NestedIterator *nestedIterCreate(struct NestedInteger **lst, int size) {
  struct NestedIterator *iter = malloc(sizeof *iter);
  iter->size = 32;
  iter->stk = malloc(iter->size * sizeof *iter->stk);
  iter->stk[0] = (struct StackElt) { .lst = lst, .size = size, .p = -1 };
  iter->sp = 1;
  advance(iter);
  return iter;
}

bool nestedIterHasNext(struct NestedIterator *iter) {
  return iter->sp > 0;
}

int nestedIterNext(struct NestedIterator *iter) {
  struct StackElt *e = iter->stk + (iter->sp - 1);
  int val = NestedIntegerGetInteger(e->lst[e->p]);
  advance(iter);
  return val;
}

/** Deallocates memory previously allocated for the iterator */
void nestedIterFree(struct NestedIterator *iter) {
  free(iter->stk);
  free(iter);
}
