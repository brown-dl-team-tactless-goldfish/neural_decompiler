#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx2,bmi,bmi2,lzcnt,popcnt")
class BookMyShow
{
public:
    struct tree
    {
        constexpr int static N = 1e5;
        long long t[4 * N + 5], tsum[4 * N + 5];

        // Dont use build tree better use point update

        void update(int v, int tl, int tr, int pos, int val)
        {
            if (tl == tr)
            {
                t[v] = val;
                return;
            }
            int mid = (tl + tr) / 2;
            if (pos <= mid)
                update(2 * v, tl, mid, pos, val);
            else
                update(2 * v + 1, mid + 1, tr, pos, val);
            t[v] = min(t[2 * v], t[2 * v + 1]);
        }

        int query(int v, int tl, int tr, int l, int r)
        {
            if (tr < l || tl > r)
                return INT_MAX;
            if (l <= tl && tr <= r)
                return t[v];
            int mid = (tl + tr) / 2;
            return min(query(2 * v, tl, mid, l, r), query(2 * v + 1, mid + 1, tr, l, r));
        }
        long long querysum(int v, int tl, int tr, int l, int r)
        {
            if (tr < l || tl > r)
                return 0ll;
            if (l <= tl && tr <= r)
                return tsum[v];
            int mid = (tl + tr) / 2;
            long long x = querysum(2 * v, tl, mid, l, r);
            x += querysum(2 * v + 1, mid + 1, tr, l, r);
            return x;
        }
        void updatesum(int v, int tl, int tr, int pos, int val)
        {
            if (tl == tr)
            {
                tsum[v] = val;
                return;
            }
            int mid = (tl + tr) / 2;
            if (pos <= mid)
                updatesum(2 * v, tl, mid, pos, val);
            else
                updatesum(2 * v + 1, mid + 1, tr, pos, val);
            tsum[v] = (tsum[2 * v] + tsum[2 * v + 1]);
        }
        void clr(int n)
        {
            for (int i = 0; i < 4 * n + 5; i++)
                t[i] = 0, tsum[i] = 0;
        }
    };
    int tr, ts, li = 1;
    tree seg;
    BookMyShow(int n, int m)
    {
        tr = n, ts = m;
        seg.clr(n + 1);
    }

    vector<int> gather(int k, int maxRow)
    {
        vector<int> v;
        int mn = seg.query(1, 1, tr, 1, maxRow + 1);
        if (ts - mn < k)
            return v;
        int l = li, r = maxRow + 1;
        int ar = 0, sn = 0;
        while (l <= r)
        {
            int mid = (l + r) / 2;
            int q = seg.query(1, 1, tr, l, mid);
            q = ts - q;
            if (q >= k)
            {
                ar = mid;
                r = mid - 1;
            }
            else
                l = mid + 1;
        }
        sn = seg.query(1, 1, tr, ar, ar);
        seg.update(1, 1, tr, ar, sn + k);
        seg.updatesum(1, 1, tr, ar, sn + k);
        v.push_back(ar - 1), v.push_back(sn);
        return v;
    }

    bool scatter(int k, int maxRow)
    {
        long long tot = seg.querysum(1, 1, tr, 1, maxRow + 1);
        long long yy = ts;
        yy *= (maxRow + 1);
        yy -= tot;
        if (yy < k)
            return false;
        while (li <= maxRow + 1 && k > 0)
        {
            int y = seg.query(1, 1, tr, li, li);
            int x = min(k, ts - y);
            seg.update(1, 1, tr, li, x + y);
            seg.updatesum(1, 1, tr, li, x + y);
            if (y + x == ts)
                li++;
            k -= x;
        }
        return true;
    }
};