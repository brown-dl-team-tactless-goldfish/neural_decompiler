class Solution {
public:
    class UnionFind {
        vector<pair<int, long long>> st;
        public:
        UnionFind(int n, vector<int>& nums) {
            st = vector<pair<int, long long>> (n);
            for (int i = 0; i < n; i++) {
                st[i].first = i;
                st[i].second = nums[i];
            }
        }
        int find(int v) {
            if (v == st[v].first) return v;
            return st[v].first = find(st[v].first);
        }
        long long findValue(int v) {
            int pos = find(v);
            return st[pos].second;
        }
        void merge(int u, int v) {
            int x = find(u);
            int y = find(v);
            if (x != y) {
                st[x].first = y;
                st[y].second += st[x].second;
            }
        }
    };
    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {
        int n = nums.size();
        vector<bool> mark(n);
        vector<long long> sol(n);
        mark[removeQueries[n - 1]] = true;
        UnionFind uf(n, nums);
        set<long long> mxSegment;
        mxSegment.insert(nums[removeQueries[n - 1]]);
        for (int i = n - 2; i >= 0; i--) {
            long long mxValue = *prev(mxSegment.end());
            sol[i] = mxValue;
            int pos = removeQueries[i];
            mark[pos] = true;
            if (pos - 1 >= 0 && mark[pos - 1]) {
                uf.merge(pos, pos - 1);
            }
            if (pos + 1 < n && mark[pos + 1]) {
                uf.merge(pos, pos + 1);
            }
            long long segValue = uf.findValue(pos);
            mxSegment.insert(segValue);
        }
        return sol;
    }
};