#define TREE_SIZE 100

struct StackTree {
    bool is_left_visited;
    bool is_right_visited;
    struct TreeNode* current_node;
};

int top;

void init() {
	top = -1;
}

void push(struct StackTree* stack, struct TreeNode* p) {
	if (top < TREE_SIZE - 1) {
		stack[++top].current_node = p;
		stack[top].is_left_visited = false;
		stack[top].is_right_visited = false;
	}
}


struct StackTree *pop(struct StackTree stack[TREE_SIZE]) {
	if (top >= 0)
		return &stack[top--];
	return NULL;
}

struct StackTree *peak(struct StackTree* stack) {
	if (top >= 0)
		return &stack[top];
	return NULL;
}

void insertString(char** output, int index, int node, bool lastNode) {
	char s[6];
	if (lastNode) {
		sprintf(s, "%d", node);
		strcat(output[index], s);
		return;
	}
	sprintf(s, "%d->", node);
	strcat(output[index], s);
}

char** binaryTreePaths(struct TreeNode* root, int* returnSize) {
	struct StackTree stack[TREE_SIZE], *current_root = NULL;
	*returnSize = 0;
	char** output = (char**)malloc(sizeof(char*) * 64);
	init();
	
	push(stack, root);
	current_root = peak(stack);
	output[(*returnSize)] = (char*)malloc(sizeof(char) * 1000);
	output[(*returnSize)][0] = '\0';

	while (top >= 0) {
		if (current_root->current_node->left == NULL && current_root->current_node->right == NULL) {
			for (int i = 0; i < top; i++) {
				insertString(output, (*returnSize), stack[i].current_node->val, false);
			}
			insertString(output, (*returnSize), stack[top].current_node->val, true);
			(*returnSize)++;
			output[(*returnSize)] = (char*)malloc(sizeof(char) * 1000);
			output[(*returnSize)][0] = '\0';
			current_root = pop(stack);
			current_root = peak(stack);
		}
		else if (current_root->is_left_visited == true && current_root->is_right_visited == true) {
			current_root = pop(stack);
			current_root = peak(stack);
		}
		else if (current_root->is_left_visited == true) {
			if (current_root->current_node->right != NULL) {
				current_root->is_right_visited = true;
				push(stack, current_root->current_node->right);
				current_root = peak(stack);
			}
			else {
				current_root = pop(stack);
				current_root = peak(stack);
			}
		}
		else if (current_root->current_node->left != NULL) {
			current_root->is_left_visited = true;
			push(stack, current_root->current_node->left);
			current_root = peak(stack);
		}
		else if (current_root->current_node->right != NULL) {
			current_root->is_left_visited = true;
			current_root->is_right_visited = true;
			push(stack, current_root->current_node->right);
			current_root = peak(stack);
		}
	}
	return output;
}