typedef struct {
    struct TreeNode **base;
    struct TreeNode **top;
    int stacksize;
} Stack;

typedef struct {
    Stack *a;
    Stack *b;
} Queue;

Stack *stackCreate(int initSize) {
    Stack *s = (Stack*)malloc(sizeof(Stack));
    if (!s) {
        return 0;
    }
    s->base = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * initSize);
    if (!s->base) {
        free(s);
        return 0;
    }
    s->top = s->base;
    s->stacksize = initSize;
    return s;
}

void stackDestroy(Stack *stack) {
    free(stack->base);
    free(stack);
}

bool stackEnlarge(Stack *stack) {
    struct TreeNode **n = (struct TreeNode**)realloc(stack->base, sizeof(struct TreeNode*) * (stack->stacksize + 10));
    if (!n) {
        return false;
    }
    stack->base = n;
    stack->stacksize += 10;
    return true;
}

struct TreeNode* stackPop(Stack *stack) {
    if (stack->top == stack->base) {
        //error
        return 0;
    }
    stack->top -= 1;
    return *(stack->top);
}

bool stackPush(Stack *stack, struct TreeNode *val) {
    if (stack->top - stack->base == stack->stacksize) {
        if (!stackEnlarge(stack)) {
            return false;
        }
    }
    *(stack->top) = val;
    stack->top += 1;
    return true;
}

struct TreeNode* stackPeek(Stack *stack) {
    if (stack->top == stack->base) {
        return 0;
    }
    return *(stack->top -1);
}

bool stackEmpty(Stack *stack) {
    if (stack->base == stack->top) {
        return true;
    }
    return false;
}

int stackSize(Stack *stack) {
    return (stack->top - stack->base);
}

/* Create a queue */
void queueCreate(Queue *queue, int maxSize) {
    //queue = (Queue*)malloc(sizeof(Queue));
    queue->a = stackCreate(maxSize);
    queue->b = stackCreate(maxSize);
}

/* Push element x to the back of queue */
void queuePush(Queue *queue, struct TreeNode *element) {
    stackPush(queue->a, element);
}

/* Removes the element from front of queue */
void queuePop(Queue *queue) {
    if (!stackEmpty(queue->b)) {
        stackPop(queue->b);
    } else {
        while (!stackEmpty(queue->a)) {
            struct TreeNode *ele = stackPop(queue->a);
            stackPush(queue->b, ele);
        }
        stackPop(queue->b);
    }
}

/* Get the front element */
struct TreeNode* queuePeek(Queue *queue) {
    if (!stackEmpty(queue->b)) {
        return *(queue->b->top -1);
    } else {
        while (!stackEmpty(queue->a)) {
            struct TreeNode *ele = stackPop(queue->a);
            stackPush(queue->b, ele);
        }
        return *(queue->b->top -1);
    }
}

/* Return whether the queue is empty */
bool queueEmpty(Queue *queue) {
    return (stackEmpty(queue->a) && stackEmpty(queue->b));
}

int queueSize(Queue *queue) {
    return (queue->a->top - queue->a->base + queue->b->top - queue->b->base);
    
}
/* Destroy the queue */
void queueDestroy(Queue *queue) {
    free(queue->a->base);
    free(queue->a);
    free(queue->b->base);
    free(queue->b);
}

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *columnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** levelOrderBottom(struct TreeNode* root, int** columnSizes, int* returnSize) {
    Queue queue, *q;
    q = &queue;
    queueCreate(q, 1000000);
    
    if (!root) {
        *columnSizes = 0;
        *returnSize = 0;
        return 0;
    }
    
    Stack *s_elem = stackCreate(1000000);
    Stack *s_array = stackCreate(1000000);
    
    queuePush(q, root);
    while (!queueEmpty(q)) {
        int count = queueSize(q);
        stackPush(s_array, (struct TreeNode*)count);
        
        int i;
        for (i = 0; i < count; i++) {
            struct TreeNode *ele = queuePeek(q);
            queuePop(q);
            if (ele->left) queuePush(q, ele->left);
            if (ele->right) queuePush(q, ele->right);
            
            stackPush(s_elem, (struct TreeNode*)ele->val);
        }
    }
    
    int total_array = stackSize(s_array);
    int total_ele = stackSize(s_elem);
    *columnSizes = (int*)malloc(sizeof(int) * total_array);
    *returnSize = total_array;
    int **arrays = (int**)malloc(sizeof(int*) * total_array);
    
    while (!stackEmpty(s_array)) {
        int j;
        for (j = 0; j < total_array; j++) {
            int array_size = (int)stackPop(s_array);
            *(*columnSizes + j) = array_size;
            
            int k;
            int *addr = (int*)malloc(sizeof(int) * array_size);
            for (k = array_size-1; k >= 0; k--) {
                int val = (int)stackPop(s_elem);
                addr[k] = val;
            }
            arrays[j] = addr;
        }
    }

    stackDestroy(s_elem);
    stackDestroy(s_array);
    queueDestroy(&queue);
    
    return arrays;
}