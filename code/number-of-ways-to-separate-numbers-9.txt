template <int MOD = 1'000'000'007, typename T = long long> struct mod_int {
  T v{};
  constexpr mod_int() = default;
  constexpr mod_int(T vx) : v((vx % MOD + MOD) % MOD) {}
  constexpr mod_int &operator=(T vx) {
    v = (vx + MOD) % MOD;
    return *this;
  }
#define OP(op)                                                                                                         \
  constexpr friend mod_int operator op(const mod_int &a, const mod_int &b) {                                           \
    return ((a.v op b.v) % MOD + MOD) % MOD;                                                                           \
  }                                                                                                                    \
  constexpr friend mod_int operator op(T a, const mod_int &b) {                                                        \
    return (((a % MOD + MOD) % MOD op b.v) % MOD + MOD) % MOD;                                                         \
  }                                                                                                                    \
  constexpr mod_int &operator op##=(const mod_int &other) {                                                            \
    v = ((v op other.v) % MOD + MOD) % MOD;                                                                            \
    return *this;                                                                                                      \
  }
  OP(+)
  OP(-)
  OP(*)
#undef OP
  constexpr friend bool operator==(const mod_int &a, const mod_int &b) { return a.v == b.v; }
  constexpr friend bool operator!=(const mod_int &a, const mod_int &b) { return a.v != b.v; }
};

class Solution {
public:
    int numberOfCombinations(string num) {
        int n = num.size();

        vector<vector<bool>> can_split(n + 1, vector<bool>(n + 1));
        for (int k = 1; k <= n / 2; k++) { // start sliding window where both number is length k
            queue<pair<bool, int>> q;
            for (int i = 0; i < k - 1; i++) {
                if (num[i] != num[k + i]) {
                    q.push({num[i] <= num[k + i], i});
                }
            }
            for (int i = 0; i + k * 2 <= n; i++) {
                while (!q.empty() && q.front().second < i) { // remove out of the window comparisons
                    q.pop();
                }
                if (num[i + k - 1] != num[i + k * 2 - 1]) {
                    q.push({num[i + k - 1] <= num[i + k * 2 - 1], i + k - 1});
                }
                can_split[i][k] = q.empty() || q.front().first; // if queue is empty, then every digit is equal
            }
        }

		// dp[i][k] is the answer at index i with all the answers where length of left number is **at least** k
        vector<vector<mod_int<>>> dp(n + 1, vector<mod_int<>>(n + 1));
        for (int i = 0; i < n; i++) {
            dp[i][n - i] = num[i] != '0'; // answer for entire suffix starting at index i
        }
        for (int i = n - 1; i >= 0; i--) {
            if (num[i] == '0') { // starts with 0, skip
                continue;
            }

            mod_int<> res = 1; // prefix sum answer
            for (int k = n - i - 1; k >= 1; k--) {
			    // dp[i + k][k] includes the answer of dp[i + k][k + 1]
                res += can_split[i][k] ? dp[i + k][k] : dp[i + k][k + 1];
                dp[i][k] = res;
            }
        }

        return dp[0][1].v;
    }
};