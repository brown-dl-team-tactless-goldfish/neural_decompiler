class Combination{
public:
    using ll=long long;
    Combination(int size) : factorial(size) {
        factorial[0] = 1;
        for(int i=1; i<size; i++) factorial[i] = i * factorial[i-1] % mod;
    }
    
    ll power(ll a, ll b){ 
        ll x = 1, y = a % mod; 
        while (b > 0){ 
            if (b%2) x = x * y % mod; 
            y = y * y % mod; 
            b /= 2; 
        } 
        return x % mod; 
    }	 
 
    ll modular_inverse(ll n){ 
        return power(n, mod-2); 
    } 

    ll nCr(ll n, ll k){ 
        return factorial[n] * modular_inverse(factorial[k] * factorial[n - k]) % mod;
    } 
    
    vector<ll> factorial;
    static constexpr ll mod = 1e9+7;
};

class Solution {
public:
    vector<int> waysToFillArray(vector<vector<int>>& queries) {
        init();
        Combination cb(20001);
        vector<int> res;
        for(auto& q:queries){
            int n = q[0], k = q[1];
            auto factors = numFactor(k);
            long cnt = 1;
            for(auto i:factors) {
               cnt *= cb.nCr(i+n-1, n-1); 
               cnt %= mod;
            }
            res.push_back(cnt);
        }
        return res;
    }
    
    void init(){
        for(int i=2;i<100;i++){
            if(all_of(vprime.begin(), vprime.end(), [=](int j){
                return i % j != 0;
            })) vprime.push_back(i);            
        }
    }
    
    vector<int> numFactor(int x){
        vector<int> res;
        int sq = 1 + sqrt(x);
        for(auto p:vprime){
            if(p>sq) break;
            int cnt = 0;
            while(x % p == 0){
                x/= p;
                cnt++;
            }
            if(cnt>0) res.push_back(cnt);
        }
        if(x>1) res.push_back(1);
        return res;
    }
    
    vector<int> vprime;
    const long mod = 1000000007;
};