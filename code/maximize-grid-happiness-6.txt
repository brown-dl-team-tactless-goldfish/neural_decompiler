class Solution {
public:
    int m;
    int n;
    int in;
    int ex;
    int comb[7] = {0, 40, 120, 200, 320, 400, 520};
    void decode(int mask, vector<int>& layout)
    {
        int i = 0;
        while (mask > 0)
        {
            int r = mask % 3;
            layout[i] = r;
            mask = mask / 3;
            i++;
        }
        return;
    }

    int getdis(vector<int>& l, vector<int>& r)
    {
        int res = 0;
        for (int i = 0; i < l.size(); i++)
        {
            if (r[i] != 0)
            {
                res += (r[i] == 2) ? 40 : 120;
                if (l[i] != 0)
                {
                    res += (l[i] == 2) ? 20 : -30;
                    res += (r[i] == 2) ? 20 : -30;
                }

                if (i > 0 && r[i - 1] != 0)
                {
                    res += (r[i - 1]) == 2 ? 20 : -30;
                    res += (r[i] == 2) ? 20 : -30;
                }
            }
        }
        return res;
    }

    bool valid(int in, int ex, vector<int>& layout)
    {
        for (auto& v : layout)
        {
            // 1 in 2 ex
            if (v == 1)
            {
                in--;
            }
            else if (v == 2)
            {
                ex--;
            }
            if (in < 0 || ex < 0)
            {
                return false;
            }
        }
        return true;
    }
    void info(vector<int>& layout, pair<int, int>& p)
    {
        for (auto& v : layout)
        {
            if (v == 1)
            {
                p.first++;
            }
            else if (v == 2)
            {
                p.second++;
            }
        }
        return;
    }
    int getMaxGridHappiness(int x, int y, int introvertsCount, int extrovertsCount) {
        
        m = min(x, y);
        n = max(x, y);
        in = introvertsCount;
        ex = extrovertsCount;
        int exp = pow(3, m);
        
        if (m*n == 25) return in * 120 + comb[ex];
        if (m*n == 20) {
            if (in+ex == 12) return in * 120 + comb[ex] - 10;
            else return in * 120 + comb[ex];
        }

        // cout << exp << endl;
        vector<int> layout(m);
        vector<vector<vector<int>>> dp(in + 1, vector<vector<int>>(ex + 1, vector<int>(exp, INT_MIN)));
        vector<vector<vector<int>>> cur(in + 1, vector<vector<int>>(ex + 1, vector<int>(exp, INT_MIN)));
        vector<vector<int>> diffdp(exp, vector<int>(exp, 0));
        // first in ,  second ex
        vector<pair<int, int>> maskinfo(exp);
        for (int mask = 0; mask < exp; mask++)
        {
            decode(mask, layout);
            vector<int> layout1(m);
            pair<int, int> inf(0, 0);
            info(layout, inf);
            maskinfo[mask] = inf;
            for (int mask1 = 0; mask1 < exp; mask1++)
            {
                decode(mask1, layout1);
                diffdp[mask][mask1] = getdis(layout, layout1);
            }
        }

        for (int i = 0; i < n; i++)
        {
            
            if (i == 0)
            {
                for (int mask1 = 0; mask1 < exp; mask1++)
                {
                    decode(mask1, layout);
                    auto& inf1 = maskinfo[mask1];
                    if (inf1.first <= in && inf1.second <= ex)
                    {
                        dp[in - inf1.first][ex - inf1.second][mask1] = diffdp[0][mask1];
                    }
                }
                // cur = dp;
            }
            else
            {
                for (int mask = 0; mask < exp; mask++)
                {
                    for (int k1 = 0; k1 <= in; k1++)
                    {
                        for (int k2 = 0; k2 <= ex; k2++)
                        {
                            cur[k1][k2][mask] = INT_MIN;
                        }
                    }
                }
                for (int mask = 0; mask < exp; mask++)
                {
                    for (int mask1 = 0; mask1 < exp; mask1++)
                    {
                        auto& inf1 = maskinfo[mask1];
                        for (int k1 = inf1.first; k1 <= in; k1++)
                        {
                            for (int k2 = inf1.second; k2 <= ex; k2++)
                            {
                                if (dp[k1][k2][mask] != INT_MIN)
                                {
                                    cur[k1 - inf1.first][k2 - inf1.second][mask1] = max(cur[k1 - inf1.first][k2 - inf1.second][mask1], dp[k1][k2][mask] + diffdp[mask][mask1]);
                                }
                            }
                        }
                    }
                }
                dp.swap(cur);
            }
        }

        int res = 0;
        for (int k1 = 0; k1 <= in; k1++)
        {
            for (int k2 = 0; k2 <= ex; k2++)
            {
                for (int mask = 0; mask < exp; mask++)
                {
                    res = max(res, dp[k1][k2][mask]);
                }
            }
        }
        return res;
    }
};