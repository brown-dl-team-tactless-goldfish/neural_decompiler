class Solution {
public:
    using VI = vector< int >;
    using VVI = vector< VI >;
    using Graph = unordered_map< int,unordered_set< int > >;
    using Node = pair< int,bool >; // id, color
    static constexpr int INF = static_cast< int >( 1e5 );
    struct Hash {
        size_t operator()( const Node& node ) const {
            return ( 10 * node.first ) + node.second;
        }
    };
    using Seen = unordered_set< Node, Hash >;
    using Queue = queue< Node >;
    VI shortestAlternatingPaths( int N, VVI& A, VVI& B ){
        VI D( N, INF );
        D[ 0 ] = 0;
        Graph red = gen( A ),
              blue = gen( B );
        Queue q({ { 0, true }, { 0, false } });
        Seen seen{ { 0, true }, { 0, false } };
        for( auto depth{ 1 }; ! q.empty(); ++depth ){
            auto M = q.size();
            while( M-- ){
                auto node = q.front(); q.pop();
                auto u = node.first;
                auto color = ! node.second; // next color must be opposite of current color
                auto adj = color ? red : blue;
                for( auto v: adj[ u ] ){
                    if( D[ v ] > depth )
                        D[ v ] = depth;
                    if( seen.insert({ v, color }).second )
                        q.push({ v, color });
                }
            }
        }
        transform( D.begin(), D.end(), D.begin(), [&]( auto x ){ return x == INF ? -1 : x; });
        return D;
    }
private:
    Graph gen( const VVI& E, Graph G={} ){
        for( auto& edge: E ){
            auto[ u,v ] = tie( edge[ 0 ], edge[ 1 ] );
            G[ u ].insert( v );
        }
        return G;
    }
};