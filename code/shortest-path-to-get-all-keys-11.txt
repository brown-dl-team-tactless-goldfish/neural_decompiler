class Solution {
public:
    set<vector<int>> set;
    vector<int> DIR = {1, 0, -1, 0, 1};
    int n, m, keys = 0, start = -1;
    int shortestPathAllKeys(vector<string>& g) {
        n = g.size(), m = g[0].size();
        queue<vector<int>> q;
        for(int i = 0; i < n; i++)
            for(int j = 0; j < m; j++){
                if(g[i][j] >= 'a' && g[i][j] <= 'z')
                    keys++;
                else if(g[i][j] == '@')
                    start = i * m + j, g[i][j] = '.';
            }
        vector<int> temp(keys + 1);
        temp[0] = start;
        set.insert(temp);
        q.push(temp);
        int level = 0;
        while(!q.empty()){
            int sz = q.size();
            while(sz--){
                auto state = q.front();
                q.pop();
                for(int i = 1; i < keys + 1 && state[i]; i++){
                    if(i == keys)
                        return level;
                }
                
                int r = state[0] / m, c = state[0] % m;
                for(int k = 0; k < 4; k++){
                    int nr = r + DIR[k], nc = c + DIR[k + 1];
                    
                    if(nr < 0 || nc < 0 || nr == n || nc == m || g[nr][nc] == '#' || (isupper(g[nr][nc]) && !state[g[nr][nc] - 'A' + 1]))
                        continue;
                    auto b = state;
                    if(islower(g[nr][nc]))
                        b[g[nr][nc] - 'a' + 1] = 1;
                    b[0] = nr * m + nc;
                    if(set.find(b) != set.end())
                        continue;
                    set.insert(b);
                    q.push(b);
                }
            }
            level++;
        }
        return -1;
    }
};