/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** minimumAbsDifference(int* arr, int arrSize, int* returnSize, int** returnColumnSizes){

int i,temp1=0,temp2=0,d=0,a[100000][2],k=0;
double min=+INFINITY;
quick_sort(arr,0, arrSize - 1);
    
for(i=0;i<arrSize;i++)
{
printf("%d\n",arr[i]);
}
    
for(i=1;i<arrSize;i++)
{
if(arr[i]-arr[i-1]<min)
min=arr[i]-arr[i-1];
}
    
printf("MIN is %f\n",min); 

for(i=1;i<arrSize;i++)
{
if(arr[i]-arr[i-1]==min)
{
 a[k][0]=arr[i-1];
 a[k][1]=arr[i];
    
  printf("[%d,%d]\n",a[k][0],a[k][1]);   
    ++k;
}
}
 
/*
for(i=0;i<k;i++)
{
  printf("[%d,%d]\n",a[i][0],a[i][1]);
}
*/
 printf("VALUE OF K IS %d\n",k);

*returnSize=k;
int **pascal =(int **)malloc(k*sizeof(int *));
   *returnColumnSizes =(int *)malloc(k*sizeof(int));
    
    for (int i = 0; i < k;i++){
        (*returnColumnSizes)[i]=2;
        
        pascal[i] = (int*)malloc(2*sizeof(int));
        pascal[i][0] = a[i][0];
        pascal[i][1] = a[i][1];
      }

return pascal;
}    

 
void quick_sort(int nums[],int f, int l) {
  int i, j, t, p = 0;

  if (f < l) {
    p = f;
    i = f;
    j = l;

    while (i < j) {
      while (nums[i] <= nums[p] && i < l)
        i++;
      while (nums[j] > nums[p])
        j--;
      if (i < j) {
        t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
      }
    }

    t = nums[p];
    nums[p] = nums[j];
    nums[j] = t;
    quick_sort(nums,f, j - 1);
    quick_sort(nums,j + 1, l);
  }
}
