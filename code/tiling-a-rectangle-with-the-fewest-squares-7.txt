class Solution {
public:
// help to tell start from (x,y) as left top croner, can you make a squre with side length l 
bool help2(vector<vector<int>>& board, int x, int y, int l) {
    for (int i = x; i <= x + l - 1; i++) {
        for (int j = y; j <= y + l - 1; j++) {
            if (i >= board.size() || j>=board[0].size())
                return false;
            if (board[i][j])
                return false;
        }
    }
    return true;
}
// help to tell where is the most left top empty cell(i,j), and what is the max side length of square can make from this cell. {i,j, max side length squre from ij}
vector<int> help(vector<vector<int>>& board) {
    int k = 1;
    int i = 0;
    for (; i < (int)board.size(); i++) {
        int j = 0;
        for (; j <(int)board[0].size(); j++) {
            // cout  << i << " " << j << endl;
            if (board[i][j] == 0) {
                for (; k <= 13; k++) {
                    if (i + k - 1 < board.size() && j + k - 1 < board[0].size()) {
                        if (!help2(board, i, j, k)) {
                            break;
                        }
                    } else {
                        break;
                    }
                }
                return {i,j,k-1};
            }
        }
    }
    return {};
}

// use for back tracking , can set a square to 0 or 1.
void help3(vector<vector<int>>& board, int x, int y, int l, int flag) {
    for (int i = x; i <= x + l - 1; i++) {
        for (int j = y; j <= y + l - 1; j++) {
            board[i][j] = flag;
        }
    }
}
void dfs(vector<vector<int>>& board, int cur_square, int left, int& result) {
    if (cur_square >= result)
        return;
    if (left == 0) {
        
        result = min(result, cur_square);
        return;
    }
    vector<int> h = help(board);

    
     for (int k = h[2]; k >=1; k--) {
        help3(board,h[0],h[1],k,1);
        dfs(board, cur_square + 1, left - k*k, result);
        help3(board,h[0],h[1],k,0);
    }
}

int tilingRectangle(int n, int m) {
    if (n==m)
        return 1;
    if (n > m) {
        swap(n,m);
    }
    vector<vector<int>> board(n, vector<int>(m,0));
    int result = INT_MAX;
    dfs(board, 0, m * n, result);
    
    return result;
}
};