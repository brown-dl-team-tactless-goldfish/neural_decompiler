#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
#define pi pair<int , int>
#define ppi pair<pi ,int>
int mod = 1e9+7;
typedef tree<int,null_type,less_equal<int> ,rb_tree_tag,tree_order_statistics_node_update> pbds;
void solve(vector<int> &nums, vector<vector<int>> &dp1, vector<vector<int>> &dp2)
{
    int n = nums.size();
    pbds p1, p2;
    p1.insert(nums[0]);
    // dp1[x][y] --> num of element on left of x less then nums[x].
    for(int j=1;j<n;j++)
    {
        for(int k=j+1;k<n;k++)
        {
            if(nums[j]>nums[k])
            {
                dp1[j][k] = p1.order_of_key(nums[k]);                
            }
        }
        p1.insert(nums[j]);
    }
    p2.insert(nums[n-1]);
    map<int,int> mp;
    mp[nums[n-1]]++;
	// dp1[x][y] --> num of element on right of y greater then nums[x].
    for(int k=n-2;k>1;k--)
    {
        for(int j=k-1;j>0;j--)
        {
            if(nums[j] > nums[k])
            {
                dp2[j][k] = (n-1-k) - p2.order_of_key(nums[j]) - mp[nums[j]]; 
            }
        }
        mp[nums[k]]++;
        p2.insert(nums[k]);
    }
    return;
}
class Solution {
public:
    long long countQuadruplets(vector<int>& nums){
        long long ans = 0, n = nums.size();
        vector<vector<int>> dp1(n, vector<int>(n));
        vector<vector<int>> dp2(n, vector<int>(n));
        solve(nums, dp1, dp2);
        for(int j=1;j<n-2;j++)for(int k=j+1;k<n-1;k++)if(nums[j] > nums[k])ans += (1LL*dp1[j][k]*dp2[j][k]);
        return ans;
    }
};