struct LL
{
    int val;
    struct LL* next;
};

struct LL* adj_list[12];
bool visited[12];
int endGeneindex;

bool are_connected (char* src, char* dest)
{
    int count = 0;

    for (int i = 0; i < 8; i++)
    {
        count += (src[i] != dest[i]);
        if (count > 1)
            break;
    }
    if (count == 1)
        return 1;
    return 0;
}

struct LL* new_node (int val)
{
    struct LL* t = (struct LL*) malloc (sizeof(struct LL));
    t->val = val;
    t->next = NULL;
    return t;
}

void save (int i, int j)
{
    if (!adj_list[i])
        adj_list[i] = new_node(j);
    else
    {
        struct LL* sen = new_node (0);
        sen->next = adj_list[i];
        while (sen->next)
            sen = sen->next;

        sen->next = new_node (j);
    }
}

void create_graph (char** B, int N, char* start, char* end)
{
    memset (adj_list, 0, sizeof(struct LL*) * (12));
    endGeneindex = -1;
    for (int i = 0; i < N; i++)
        for (int j = i+1; j < N; j++)
        {
            if (are_connected(B[i], B[j]))
            {
                save (i, j);
                save (j, i);
            }
        }
    for (int i = 0; i < N; i++)
    {
        if (are_connected(B[i], start))
        {
            save (N, i);
        }
        if (strcmp (B[i], end) == 0)
        {
            endGeneindex = i;
        }
    }
    memset (visited, 0, sizeof(bool) * (N+1));
}

int minMutation(char * startGene, char * endGene, char ** bank, int bankSize)
{
    int N = bankSize;
    int q[12];
    int dq[12];
    int head = 0;
    int tail = 0;
    int s;
    int depth;
    int min_depth = INT_MAX;
    struct LL* sen, *temp = new_node (0);
    sen = temp;

    create_graph (bank, N, startGene, endGene);

    if (endGeneindex < 0)
        return -1;

    // insert root into queue.
    q[head] = N;
    dq[head] = 0;
    // root is visited
    visited[q[head]] = 1;
    head++;

    // while q not empty
    while (head > tail)
    {
        // dequeue to s.
        s = q[tail];
        depth = dq[tail];
        if (s == endGeneindex)
        {
            min_depth = min_depth > depth ? depth : min_depth;
        }
        tail++;
        sen = temp;
        sen->next = NULL;
        sen->next = adj_list[s];
        while (sen->next)
        {
            if (visited[sen->next->val] == 0)
            {
                //printf ("visiting %d->%d\n", s, q[head]);
                q[head] = sen->next->val;
                dq[head] = depth + 1;
                visited[q[head]] = 1;
                head++;
            }
            sen = sen->next;
        }
    }
    if (min_depth == INT_MAX)
        return -1;
    return min_depth;
}