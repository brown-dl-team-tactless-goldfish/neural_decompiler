class Solution {
public:
   struct Data {
      int value;
      int label;
      bool operator<(const Data& rhs)const { return value < rhs.value; }
   };


   int largestValsFromLabels(vector<int>& values, vector<int>& labels, int num_wanted, int use_limit) {
      priority_queue<Data> q;
      int res = 0, size = 0;
      unordered_map<int, int> labelCounter;
      for (int i = 0; i < values.size(); i++)
         q.push({ values[i], labels[i] });

      while (!q.empty() && size < num_wanted) {
         auto [value, label] = q.top(); q.pop();
         if (labelCounter[label]++ < use_limit) {
            res += value;
            size++;
         }
      }
      return res;
   }
};