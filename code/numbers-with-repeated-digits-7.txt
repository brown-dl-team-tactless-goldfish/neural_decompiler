class Solution {
public:
    int numDupDigitsAtMostN(int N) {
        int invalid = 0;
        
        // Begin by calculating all of the invalid numbers up to 10^(L-1), where L is the length of our number (e.g. For 350, we would find all invalid numbers between 1 and 99)
        int c = floor(log10(N+1))+1;
        for (int i = 0;i < c-1;i++) {
            invalid += 9 * perm(9, i);
        }

        // For each digit, calculate the possible invalid permutations that are available up until that digit.
        int digits = 0;
        for (int i = 0;i < c;i++) {
            // Get the left most digit.
            int digit = ((N+1) / (int)pow(10, c-i-1)) % 10;
            // Count up to the digit. Note that if it's the first digit, we start at 1 to avoid finding permutations when the first digit is a 1 since there are none.
            for (int j = (i > 0 ? 0 : 1);j < digit;j++) {
                // If we've had the same digit to the left of it previously, then we don't need to count it again.
                // E.g. If our number is 350, when get to 330-339 we've already considered all possible invalid permutations for that number range and can skip it.
                if (((digits >> j) & 1) == 0) {
                    invalid += perm(9 - i, c - i - 1);
                }
            }
            // If we end up finding a digit we've already searched, we can finish here.
            if ((digits >> digit) & 1)
                break;
            digits |= 1 << digit;
        }

        return N - invalid;
    }
    
    int perm(int m, int n) {
        int out = 1;
        while (m > 1 && n > 0) {
            out *= m;
            m--;
            n--;
        }
        return out;
    }
};