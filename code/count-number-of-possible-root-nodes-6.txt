class Solution {
public:
    typedef array<int, 2> ai;
    map<ai, int> mp;
    int ans = 0;
    int vis[200001] = {};
    int trav(vector<vector<int>>& adj, int pos){
        if(vis[pos]++) return 0;
        int ans = 0;
        for(auto i : adj[pos]){
            ai t = {pos, i};
            if(mp.count(t) && !vis[i]) ans++; 
            ans += trav(adj, i);
        }
        return ans;
    }
    int vis2[200001] = {};
    int dfs(vector<vector<int>>& adj, int pos, int guesses, int k){
        if(vis2[pos]++) return 0;
        int ans = guesses>=k; 
        for(auto i : adj[pos]){
            bool bad = false;
            bool good = false;
            ai t = {pos, i};
            ai t2 = {i, pos};
            if(mp.count(t)) bad = true; // now {i, pos} is how the tree is arranged so if we counted this guess it is now wrong
            if(mp.count(t2)) good = true; // if {i, pos} is a guess, then we can include it now
            ans += dfs(adj, i, guesses-bad+good, k); // new guess count is therefore guess count - the one we unlinked + the new one if it exists 
        }
        return ans;
    }

    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {
        vector<vector<int>> adj(edges.size()+1);
        for(auto & i : edges){ // create adjacency list
            adj[i[0]].push_back(i[1]);
            adj[i[1]].push_back(i[0]);
        }
        for(auto & i : guesses){ // put guesses in a map for log n queries
            ai t = {i[0], i[1]};
            mp[t]++;
        }
        int ans = 0;
        int ok = trav(adj, 0); // count correct guesses rooted at 0 
        ans = dfs(adj, 0, ok, k); // perform dfs on entire tree rooted at 0 using method described
        return ans;
    }
};