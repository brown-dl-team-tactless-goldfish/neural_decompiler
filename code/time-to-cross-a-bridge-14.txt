class Solution {
public:
    int findCrossingTime(int n, int k, vector<vector<int>>& time) {
        priority_queue<pair<int, int>> wait_left;
        priority_queue<pair<int, int>> wait_right;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pick;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> put;
        int last_put = 0;
        int t = 0;
		
		// Create Initial Ordering On Left Side of Bridge
        for (int it = 0; it < k; ++it) {
            wait_left.push({time[it][0] + time[it][2], it});
        }
        while (n > 0 || !wait_right.empty() || !pick.empty() || !put.empty()) {
			// Set Up Ordering On Right Side . If we have workers who came and picked the parcel then we Push Them to wait_right Queue order them in Order of Their Efficiency For crossing Bridge From Right To Left
            while (!pick.empty() && pick.top().first <= t) {
                auto [_, cur] = pick.top();
                pick.pop();
                wait_right.push({time[cur][0] + time[cur][2], cur});
            }
			// Think Which worker will be Joining The Waiting List on Left Side of Bridge ? Who came to NewWareHouse Put Their Parcel and Ready For Next Parcel. So we Pop worker who finish their work of putting parcel in given limit time and then we add them to wait_left quque To bring new parcel
            while (!put.empty() && put.top().first <= t) {
                auto [_, cur] = put.top();
                put.pop();
                wait_left.push({time[cur][0] + time[cur][2], cur});
            }
			// Pick Worker From Right Queue who have Highest Priority This is added to queue Of People putting their picked parcel to NewWareHouse and Update the time of last put.
            if (!wait_right.empty()) {
                auto [eff, worker] = wait_right.top();
                wait_right.pop();
                
                last_put = max(last_put, t + time[worker][2]);
                put.push({t + time[worker][2] + time[worker][3], worker});
                t += time[worker][2];
                continue;
            }
            if (n > 0 && !wait_left.empty()) {
                auto [eff, worker] = wait_left.top();
                wait_left.pop();
                
                pick.push({t + time[worker][0] + time[worker][1], worker});
                t += time[worker][0];
                --n;
                continue;
            }

            
            int p_time = INT_MAX;
            if (!pick.empty()) {
                p_time = min(p_time, pick.top().first);
            }
            if (!put.empty()) {
                p_time = min(p_time, put.top().first);
            }
            if (p_time != INT_MAX) {
                t = p_time;
            } else {
                break;
            }
        }
        return last_put;
    }
};