constexpr auto numInts() {
    array<int, sizeof(int) * CHAR_BIT> num_ints = {};
    num_ints[0] = 1;
    num_ints[1] = 2;
    for (int w = 2; w < sizeof(int) * CHAR_BIT; ++w) num_ints[w] = num_ints[w - 2] + num_ints[w - 1];
    return num_ints;
}

// kNumInt[w] is the number of w-bit binary number without consecutive 1s
constexpr auto kNumInts = numInts();

class Solution {
public:
    int findIntegers(int const num) {
        int n[2] = {1, (num & 1) + 1};
        // Consider the low-order (s + 1) bits of num (let's call that number x)
        // and compute the number of binary numbers <= x without consecutive 1s
        // using is a simple linear recurrence depending on
        // whether the 2 most significant bits of x
        // are 11, 10, or 0*
        for (int s = 1; s < sizeof(int) * CHAR_BIT; ++s) {
            auto const nxt =
                (num & (1 << s)) ?
                    (num & (1 << (s - 1)) ?
                     kNumInts[s - 1] /* 11 */: n[0] /* 10 */) + kNumInts[s] : 
            n[1] /* 00 or 01 */;
            n[0] = n[1];
            n[1] = nxt;
        }
        return n[1];
    }
};

auto const _ = [](){
std::ios::sync_with_stdio(false);
std::cin.tie(nullptr);
return 0;
}();