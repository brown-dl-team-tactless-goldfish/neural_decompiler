typedef struct DSU{
    int* rank;
    int* root;
}DSU;
//create disjoint-set object
DSU* createDSU(int size){
    DSU* dsu = malloc(sizeof(DSU));
    dsu->rank = calloc(size, sizeof(int));
    dsu->root = malloc(size * sizeof(int));
    for(int i = 0; i < size; i++)
        dsu->root[i] = i;
    return dsu;
}
//find root of element
int find(int* root, int x){
    if(x == root[x])
        return x;
    return root[x] = find(root, root[x]);
}
//unite the roots of two sets
void setUnion(int* root, int* rank, int x, int y){
    int rootX = find(root, x);
    int rootY = find(root, y);
    if(rootX != rootY){
        if(rank[rootX] > rank[rootY])
            root[rootY] = rootX;
        else if(rank[rootY] > rank[rootX])
            root[rootX] = rootY;
        else{
            root[rootX] = rootY;
            rank[rootY]++;
        }
    }
}
//free dsu object
void freeDSU(DSU* dsu, int size){
    free(dsu->root);
    free(dsu->rank);
    free(dsu);
}

int makeConnected(int n, int** connections, int connectionsSize, int* connectionsColSize){
    if(connectionsSize < n - 1)//edge case: not enough connections to connect all devices
        return -1;

    int networks = n;//network count starts with amount of total devices
    DSU* dsu = createDSU(n);//create our disjoint set object
    int* root = dsu->root;
    int* rank = dsu->rank;

    for(int i = 0; i < connectionsSize; i++){
        int computer1 = connections[i][0];
        int computer2 = connections[i][1];
        //if computers are on different networks
        if(find(root, computer1) != find(root, computer2)){
            setUnion(root, rank, computer1, computer2);//connect computers
            networks--;//we've connected two computers, there is now one less network
        }
    }
    freeDSU(dsu, n);//free our dsu object to avoid memory leaks
    return networks - 1;//number of connections left to make will be number of networks > 1.
}