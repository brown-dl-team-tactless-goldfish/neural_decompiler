typedef struct point{
    int val;
    int posi[2];
}POINT;


//sort decrease
int cmpfunc(const void* a, const void* b){
    POINT* A = (POINT*)a;
    POINT* B = (POINT*)b;
    return B->val - A->val;
}

int longestIncreasingPath(int** matrix, int matrixSize, int* matrixColSize){
    int i, j;
    int m = matrixSize;
    int n = * matrixColSize;
    
    int** dp = (int**)malloc(m * sizeof(int*));
    for( i = 0; i < m ; i++){
        dp[i] = calloc(n , sizeof(int));
    }
    
    POINT* arr = (POINT*)malloc(m * n * sizeof(POINT));
    int idx = 0;
    for( i = 0; i  < m ; i++){
        for( j  = 0; j < n; j++){
            arr[idx].val = matrix[i][j];
            arr[idx].posi[0] = i;
            arr[idx].posi[1] = j;
            idx++;
        }
    }
    int x, y;
    int LIP = 0; // ans
    int temp;
    qsort(arr, m*n, sizeof(POINT), cmpfunc);
    for(i = 0; i < m*n; i++){
        temp = 1;
        x = arr[i].posi[0] ;
        y = arr[i].posi[1] ;

        //up
        if(x > 0 && matrix[x-1][y] > arr[i].val){
            temp = (temp > (dp[x-1][y] + 1)) ? temp : dp[x-1][y] + 1; 
        }
        //down
        if(x < (m-1) && matrix[x+1][y] > arr[i].val){
            temp = (temp > (dp[x+1][y] + 1)) ? temp : dp[x+1][y] + 1; 
        }
        //left
        if(y > 0 && matrix[x][y-1] > arr[i].val){
            temp = (temp > (dp[x][y-1] + 1)) ? temp : dp[x][y-1] + 1; 
        }
        //right
        if(y < (n-1) && matrix[x][y+1] > arr[i].val){
            temp = (temp > (dp[x][y+1] + 1)) ? temp : dp[x][y+1] + 1; 
        }
        dp[x][y] = temp;
        LIP = (temp > LIP) ? temp : LIP;
    }
    
    //free memory
    free(arr);
    for(i = 0; i < m; i++){
        free(dp[i]);
    }
    free(dp);
    
    return LIP;
}