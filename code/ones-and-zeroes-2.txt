
struct StringRecord
{
    char cZero;
    char cOne;
    char cStrLen;
};

int* CompareNumberZero(void* pFirst, void* pSecond)
{
    // if different strlen, smaller strlen will be priority
    if(((struct StringRecord*)pFirst)->cStrLen != ((struct StringRecord*)pSecond)->cStrLen)
    {
        return ((struct StringRecord*)pFirst)->cStrLen - ((struct StringRecord*)pSecond)->cStrLen;
    }

    // same strlen, less 1 will be priority
    return ((struct StringRecord*)pFirst)->cOne - ((struct StringRecord*)pSecond)->cOne;
}

int* CompareNumberOne(void* pFirst, void* pSecond)
{
    // if different strlen, smaller strlen will be priority
    if(((struct StringRecord*)pFirst)->cStrLen != ((struct StringRecord*)pSecond)->cStrLen)
    {
        return ((struct StringRecord*)pFirst)->cStrLen - ((struct StringRecord*)pSecond)->cStrLen;
    }

    // same strlen, less 0 will be priority
    return ((struct StringRecord*)pFirst)->cZero - ((struct StringRecord*)pSecond)->cZero;
}

int FindMaxFormInner(struct StringRecord astStringRecord[], int nIndex, int nValidStr, int nM, int nN, int nSubset, int nRet)
{
    // update nRet if current nSubset is larger
    if(nSubset > nRet) nRet = nSubset;

    // return directly if out of boundry
    if((nM ==0 && nN == 0) || (nSubset + nValidStr - nIndex <= nRet)) return nRet;
    if(astStringRecord[nIndex].cStrLen > nM+nN) return nRet;

    char cZero = 0, cOne = 0;
    while(nIndex < nValidStr)
    {
        // if current 0's and 1's are exactly the same of last time, skip it
        // only check if 0's and 1's are less than nM and nN respectively
        if((cZero != astStringRecord[nIndex].cZero || cOne != astStringRecord[nIndex].cOne) && astStringRecord[nIndex].cZero <= nM && astStringRecord[nIndex].cOne <= nN)
        {
            cZero = astStringRecord[nIndex].cZero;
            cOne = astStringRecord[nIndex].cOne;
            
            int nTmp = FindMaxFormInner(astStringRecord, nIndex+1, nValidStr, nM-astStringRecord[nIndex].cZero, nN-astStringRecord[nIndex].cOne, nSubset+1, nRet);
            if(nTmp > nRet) nRet = nTmp;

            // we get maximum subset already
            if(nRet == nValidStr) return nRet;
        }
        
        // keep choosing next nIndex if we have better result
        nIndex++;
    }

    return nRet;
}

int findMaxForm(char ** strs, int strsSize, int m, int n){
    // only store valid strs
    int nValidStr = 0;
    struct StringRecord astStringRecord[strsSize];
    for(int i=0; i<strsSize; i++)
    {
        astStringRecord[nValidStr].cZero = 0;
        astStringRecord[nValidStr].cStrLen = strlen(strs[i]);

        for(char j=0; j<astStringRecord[nValidStr].cStrLen; j++)
        {
            if(strs[i][j] == '0') astStringRecord[nValidStr].cZero++;
        }
        astStringRecord[nValidStr].cOne = astStringRecord[nValidStr].cStrLen - astStringRecord[nValidStr].cZero;

        if(astStringRecord[nValidStr].cZero <= m && astStringRecord[nValidStr].cOne <= n) nValidStr++;
    }
    
    // use different qsort base on different m & n
    qsort(astStringRecord, nValidStr, sizeof(struct StringRecord), (m>=n)?CompareNumberZero:CompareNumberOne);
    
    return FindMaxFormInner(astStringRecord, 0, nValidStr, m, n, 0, 0);
}