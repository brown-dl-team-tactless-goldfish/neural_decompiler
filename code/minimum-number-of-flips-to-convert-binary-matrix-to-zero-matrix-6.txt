    int minFlips(vector<vector<int>>& mat) {
        // since the max mat size would be 3*3 according to the question
        // so we can use an integer to store the snapshot of the mat
        // then we do BFS to each snapshot, that's flipping each cell on that snapshot one by one
        // if we can reach a mat with all 0s, return the step takes, otherwise return -1
        auto snapshot = encodeMat(mat);
        if (snapshot == 0) {
            return 0;
        }
        int rows = mat.size();
        int columns = mat[0].size();
        unordered_set<int> visited;
        queue<int> q;
        visited.insert(snapshot);
        q.push(snapshot);
        int steps = 0;
        while (q.size() > 0) {
            int qSize = q.size();
            for (int i = 0; i < qSize; i++) {
                auto curShot = q.front();
                q.pop();
                for (int r = 0; r < rows; r++) {
                    for (int c = 0; c < columns; c++) {
                        auto nextShot = flip(mat, curShot, r, c);
                        if (nextShot == 0) {
                            return steps + 1;
                        }
                        if (visited.find(nextShot) != visited.end()) {
                            continue;
                        }
                        q.push(nextShot);
                        visited.insert(nextShot);
                    }
                }
            }
            steps++;
        }
        return -1;
    }
    
    int encodeMat(vector<vector<int>>& mat) {
        int res = 0;
        int rows = mat.size();
        int columns = mat[0].size();
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns; j++) {
                if (mat[i][j] == 0) {
                    continue;
                }
                int offset = i * columns + j;
                res |= 1 << offset;
            }
        }
        return res;
    }
    
    // we can use xor to do flip, that's 1^1 = 0, 0^1 = 1, 0^0 = 0, 1^0 = 1
    int flip(vector<vector<int>>& mat, int snapShot, int row, int column) {
        int rows = mat.size();
        int columns = mat[0].size();
        vector<pair<int, int>> points { {0, 0}, {-1, 0}, {1, 0}, {0, 1}, {0, -1} };
        for (auto& p : points) {
            int r = row + p.first;
            int c = column + p.second;
            if (r < 0 || r >= rows || c < 0 || c >= columns) {
                continue;
            }
            int offset = r * columns + c;
            snapShot ^= 1 << offset;
        }
        return snapShot;
    }