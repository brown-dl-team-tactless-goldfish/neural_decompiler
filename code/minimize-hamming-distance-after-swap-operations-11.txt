class Solution {
public:
    int minimumHammingDistance(vector<int>& source, vector<int>& target, vector<vector<int>>& allowedSwaps) {
        int n = source.size();
        vector<int> ds(n, 0);
        iota(begin(ds), end(ds), 0);
        for (auto& allowedSwap : allowedSwaps) {
            int u = allowedSwap[0], v = allowedSwap[1];
            unionSet(ds, u, v);
        }

        unordered_map<int, vector<int>> groups;
        for (int i = 0; i < n; ++i) {
            int id = findSet(ds, i);
            groups[id].emplace_back(i);
        }

        int ans = 0;
        for (auto& [_, indexes] : groups) {
            unordered_multiset<int> set1, set2;
            for (int index : indexes) {
                set1.emplace(source[index]);
                set2.emplace(target[index]);
            }
            ans += diff(set1, set2);
        }

        return ans;
    }

private:
    int diff(unordered_multiset<int>& set1, unordered_multiset<int>& set2) {
        for (int e : set1) {
            if (set2.count(e) > 0) {
                set2.erase(set2.find(e));
            }
        }
        return set2.size();
    }

    void unionSet(vector<int>& ds, int u, int v) {
        linkSet(ds, findSet(ds, u), findSet(ds, v));
    }

    int findSet(vector<int>& ds, int u) {
        return (ds[u] == u) ? u : (ds[u] = findSet(ds, ds[u]));
    }

    void linkSet(vector<int>& ds, int u, int v) {
        ds[u] = v;
    }
};