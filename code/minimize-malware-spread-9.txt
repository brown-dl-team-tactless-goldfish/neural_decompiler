class Solution {
    vector<int>Father ;
    int findFather(int i){
        if(i != Father[i])
            Father[i] = findFather(Father[i]) ;
        return Father[i] ;
    }
    
    void unionSet(int a, int b){
        a = findFather(a) ;
        b = findFather(b) ;
        if(a < b)
            Father[b] = a ;
        else
            Father[a] = b ;
    }
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size() ;
        Father.resize(n) ;
        for(int i = 0; i < n; i++)
            Father[i] = i ;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(i == j)
                    continue ;
                if(graph[i][j] == 0)
                    continue ;
                if(findFather(i) != findFather(j))
                    unionSet(i, j) ;
            }
        }
        
        unordered_map<int, vector<int>>Family ;
        for(int i = 0; i < n; i++){
            Father[i] = findFather(i) ;
            Family[Father[i]].push_back(i) ;
        }
        
        unordered_map<int, vector<int>>infected ;
        for(auto& x : initial){
            int root = Father[x] ;
            infected[root].push_back(x) ;
        }
        
        int MaxGroup = 0 ;
        int ret = -1 ;
        //find infected item is only one in his family
        for(auto m : infected){
            int r = m.first ;
            if(m.second.size() == 1){
                if(Family[r].size() > MaxGroup){
                    MaxGroup = Family[r].size() ;
                    ret = m.second[0] ;
                }
                else if(Family[r].size() == MaxGroup)
                    ret = min(ret, m.second[0]) ;
            }
    
        }
        if(ret == -1)
            ret = *min_element(initial.begin(), initial.end()) ;
        return ret ;
    }
};