class Solution {
public:
    int find(vector<int>& a, int x) {
        if(a[x] == x) {
            return x; 
        }
        return a[x] = find(a,a[x]);
    }
    
    void connect(vector<int>& a, vector<int>& r, int i, int j) {
        int i_ = find(a,i);
        int j_ = find(a,j);
        if(i_ == j_) {
            return;
        }
        if(r[i_] > r[j_]) {
            a[j_] = i_; 
        } else {
            a[i_] = j_; 
            if(r[i_] == r[j_]) {
                r[j_]++; 
            }
        }
    }
    
    vector<int> groupStrings(vector<string>& words) {
        unordered_map<int,int> m; 
        vector<int> tmp; 
        for(int i = 0;i<words.size();i++) {
            int v = 0; 
            for(auto ch : words[i]) {
                v |= 1 << (ch - 'a');
            }
            m[v] = i;
            tmp.push_back(v);
        }
        vector<int> a(words.size());
        for(int i = 0;i<a.size();i++) {
            a[i] = i; 
        }
        vector<int> r(words.size());
        for(int i = 0;i<tmp.size();i++) {
            const int v = tmp[i];
            for(int c = 0;c<26;c++) {
                const int y = v ^ (1<<c);
                auto ptr = m.find(y);
                if(ptr != m.end()) {
                    connect(a,r,i,ptr->second);
                }
                if(v&(1<<c)) {
                    for(int b = 0;b<26;b++) {
                        if(y&(1<<b)) {
                            continue; 
                        }
                        const int x = y ^ (1<<b);
                        ptr = m.find(x);
                        if(ptr != m.end()) {
                            connect(a,r,i,ptr->second);
                        }
                    }
                }
            }
        }
        unordered_map<int,int> q; 
        int l = 0; 
        for(int i = 0;i<words.size();i++) {
            const int x = find(a,i);
            l = max(l,++q[x]); 
        }
        return {static_cast<int>(q.size()),l};
    }
};