
class Children
{
    public int? left;
    public int? right;
}

public class Solution 
{
    public IList<TreeNode> DelNodes(TreeNode root, int[] to_delete)
    {
        var toDelete = new HashSet<int>(to_delete);
        var g = new Dictionary<int, Children>();
      
        // Create graph with deleted nodes, save roots
        var roots = new List<int>();
        AddToGraph(g, root, toDelete, roots, true);   
        
        // Create new trees using roots and graph
        var result = new List<TreeNode>();
        foreach (var r in roots)
            result.Add(CreateNode(r, g));
        
        return result;
    }
    
    private TreeNode CreateNode(int root, Dictionary<int, Children> g)
    {
        return 
            new TreeNode
            {
                val = root,
                left = g[root].left.HasValue ? CreateNode(g[root].left.Value, g) : null,
                right = g[root].right.HasValue ? CreateNode(g[root].right.Value, g) : null,
            };
    }
    
    private void AddToGraph(
        Dictionary<int, Children> g,
        TreeNode node, 
        HashSet<int> toDelete,
        List<int> roots,
        bool parentDeleted)
    {
        bool deleteCurrent = toDelete.Contains(node.val);
            
        if (parentDeleted && !deleteCurrent)
            roots.Add(node.val);
        
        if (!deleteCurrent)
        {
            g[node.val] = new Children();
        
            if (node.left != null && !toDelete.Contains(node.left.val))
                g[node.val].left = node.left.val;
        
            if (node.right != null && !toDelete.Contains(node.right.val))
                g[node.val].right = node.right.val;
        }
        
        if (node.left != null)
            AddToGraph(g, node.left, toDelete, roots, deleteCurrent);
        
        if (node.right != null)
            AddToGraph(g, node.right, toDelete, roots ,deleteCurrent);
    }
}