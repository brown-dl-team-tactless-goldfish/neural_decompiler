class Solution {
public:
    int ans;
    unordered_map<string, bool>vis;
    void dfs(string board, int id, string hand){
        int len = board.size();
        if(len == 0){
            if(ans != -1) ans = min(ans, id);
            else ans = id;
            vis[hand.substr(0, id)] = true;
            return;
        }
        if((ans != -1 && id >= ans) || id == hand.length()) return;
        int cnt = 0;
        string tmp;
        for(int i = 0; i < len; ++i){
            if(board[i] == hand[id]){
                cnt = 0;
                while(i < len && board[i] == hand[id]) cnt++, i++;
                if(cnt == 1) tmp = board.substr(0, i - cnt + 1) + hand[id] + board.substr(i);
                else{
                    int l = i - cnt - 1, r = i;
                    int ll = l, rr = r;
                    while(l >= 0 && r < len && board[l] == board[r]){
                        char c = board[l];
                        while(l >= 0 && board[l] == c) l--;
                        while(r < len && board[r] == c) r++;
                        if(r - rr + ll - l < 3) break;
                        ll = l, rr = r;
                    }
                    tmp = board.substr(0, ll + 1) + board.substr(rr);
                } 
                
                dfs(tmp, id + 1, hand);
            }
        }
    }
    int findMinStep(string board, string hand) {
        int len = hand.size();
        ans = -1;
        int* tmp = new int[len];
        for(int i = 0; i < len; ++i) tmp[i] = i;
        do{
            string now;
            bool flag = false;
            for(int i = 0; i < len; ++i){
                now += hand[tmp[i]];
                if(vis[now]){
                    flag = true;
                    break;
                }
            }
            if(!flag) dfs(board, 0, now);
        }while(next_permutation(tmp, tmp + len));
        return ans;
    }
};