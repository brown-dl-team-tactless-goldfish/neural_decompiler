bool isDigit(char c) {
    return c >= '0' && c <= '9';
}

// abc
// a2[b]
// 2[a]b
// 2[2[4[a]]]
char * decodeString(char * s){
    // printf("call decodeString: %s\n", s);
    bool pn = true; // mode to parse number.
    int rn = 0; // cur repeat number.
    int l = 0; // level
    int lr = 0; // next level start
    char *t = malloc(2000); // NOTE: I did not calculate, but ... need big enough.
    int ti = 0;
    for (int i=0;s[i]!='\0';i++) {
        if (s[i] == '[') { // [
            if (!l)
                lr = i+1; // NOTE: only on the same level, we reset next level start.
            l++;
            pn = false; // stop parse number mode.
        } else if (s[i] == ']') { // ]
            l--;
            if (!l) { // only handle current level, deeper level pass to sub routine.
                // dirty hack to pass sub string in c.
                s[i] = '\0';
                char * nt = decodeString(s+lr);
                // restore
                s[i] = ']';
                int ll = strlen(nt);
                // repeat sub routine returned string.
                // printf("rn: %d\n", rn);
                for (int j=0;j<rn;j++) {
                    memcpy(t+ti, nt, ll);
                    ti+=ll;
                }
            }
            if (!l) { // if cur level and encounter ']', reset repeat counter, not need it anymore, we need to parse next one.
                rn = 0;
                pn = true;
            }
                
        } else if (isDigit(s[i])) { // digits
            //printf("is digit: %c\n", s[i]);
            if (pn) { // if in parse number mode, parse repeat number
                rn *= 10;
                rn += (s[i] - '0');
            } 
        } else { // alphabet
            if (!l) { // if in current level and lowercase character, just copy to final result.
                t[ti++] = s[i];
            }
        }
    }
    t[ti] = '\0';
    // printf("return %s\n", t);
    return t;
}