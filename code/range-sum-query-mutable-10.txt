#define MAXN	100000

typedef struct {
    int tree[MAXN];
    int num[MAXN];
    int size;
} NumArray;

void build(NumArray *na, int node, int a, int b) {
    if (a>b) {
        return;
    }
    if (a==b) {
        na->tree[node] = na->num[b];
        return;
    }
    int left = 2*node+1, right = 2*node+2;
    build(na, left, a, (a+b)/2);
    build(na, right, (a+b)/2+1, b);
    na->tree[node] = na->tree[left] + na->tree[right];
}

NumArray* numArrayCreate(int* nums, int numsSize) {
    NumArray *na = (NumArray*)malloc(sizeof(NumArray));

    for (int i=0; i<numsSize; i++) {
        na->tree[i] = nums[i];

        na->num[i] = nums[i];
    }

    na->size = numsSize;
    build(na, 0,  0, numsSize-1);
    return na;
}

void numArrayUpdate(NumArray* obj, int i, int val) {
    int pos = i+obj->size;
    obj->num[i] = val;
    obj->tree[pos] = val;

    int l, r, p;
    while (pos>0) {
        l=r=pos;
        if (pos%2==0) {	// right leaf if idx from zero
            l=pos-1;
            p = (pos-2)/2;
        }
        else {
            r=pos+1;
            p=(pos-1)/2;
        }
        obj->tree[p] = obj->tree[l] + obj->tree[r];
        pos/=2;
    }
}

int numArraySumRange(NumArray* obj, int i, int j) {
	if(i>j) return -1000;
	if(i==j) return obj->num[i];
	int a = numArraySumRange(obj, i, (i+j)/2);
	int b = numArraySumRange(obj, (i+j)/2+1, j);
	return a+b;
}

void numArrayFree(NumArray* obj) {
    free(obj);
}