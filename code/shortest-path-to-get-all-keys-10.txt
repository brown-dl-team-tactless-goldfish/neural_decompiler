class Solution {
public:
  
  static int Count(int keys){
    int ans = 0;
    for (int i=0; i < 31; ++i){
      if (keys & (1 << i)) ++ans;
    }
    return ans;
  }
  
  static bool HaveKeyFor(int keys, char lock){
    lock -= 'A';
    return (1 << lock) & keys;
  }
  
  struct DefaultDist {
    int d{10000000};
  };
  
  int shortestPathAllKeys(vector<string>& grid) {
    auto const m = grid.size();
    auto const n = grid[0].size();
    auto start = pair(0,0);
    auto keys = 0;
    for (int i=0; i<m; ++i)
      for (int j=0; j<n; ++j){
        if (grid[i][j] == '@') start = pair(i,j);
        if (grid[i][j] >= 'a' && grid[i][j] <= 'z') ++keys; 
      }
    
    map<tuple<int,int,int>,DefaultDist> dist; //i,j,keys -> dist
    using Node = tuple<int,int,int,int>; // (d, i, j, keys (bitmap))
    queue<Node> q;
    q.push({0, start.first, start.second, 0});
    while (!q.empty()){
      auto [d, i, j, k] = q.front();
      q.pop();
      auto const c = grid[i][j]; 
      if (c >= 'a' && c <= 'z') k |= 1 << (c - 'a');
      if (Count(k) == keys) return d;
      
      for (auto const [next_i, next_j] : {pair(i+1, j), pair(i-1, j), pair(i, j+1), pair(i, j-1)}){
        if (next_i >= m || next_j >= n) continue;
        auto const x = grid[i][j];
        if (x == '#') continue;
        if (x >= 'A' && x <= 'Z' && !HaveKeyFor(k, x)) continue;
        if (d+1 >= dist[{next_i, next_j, k}].d) continue;
        dist[{next_i, next_j, k}].d = d+1;
        q.push({d+1, next_i, next_j, k});
      }
    }
    
    return -1;
  }
};