public IList<IList<int>> PalindromePairs(string[] words)
{
	// declare variables variables
	int n = words.Length;
	Node fwd = new Node(), rev = new Node(), ptr;
	var pairs = new List<IList<int>>();
	
	// iterate to build tries
	for (int i = 0; i < n; i++)
	{
		// check for exact reversal at previous index
		f(i);
		
		// add to forward trie
		ptr = fwd;
		for (int j = 0; j < words[i].Length; j++)
		{
			ptr = ptr[words[i][j]] ??= new Node();
		}
		ptr.Index = i;
		
		// add to reverse trie
		ptr = rev;
		for (int j = words[i].Length - 1; j >= 0; j--)
		{
			ptr = ptr[words[i][j]] ??= new Node();
		}
		ptr.Index = i;
	}
	
	// iterate to check for palindromes
	for (int i = 0; i < n; i++)
	{
		// expand odd-length palindromes
		for (int j = 0; j < words[i].Length; j++)
		{
			g(i, j, j);
		}
		// expand even-length palindromes
		for (int j = 1; j < words[i].Length; j++)
		{
			g(i, j - 1, j);
		}
	}
	
	// check if word at index i has a match in the reverse trie
	void f(int i)
	{
		ptr = rev;
		foreach (char c in words[i])
		{
			ptr = ptr[c];
			if (ptr == null)
			{
				return;
			}
		}
		if (ptr.Index.HasValue)
		{
			pairs.Add(new[] { ptr.Index.Value, i });
			pairs.Add(new[] { i, ptr.Index.Value });
		}
	}
	
	// check if word at index i can be expanded at specified starting l and r
	void g(int i, int l, int r)
	{
		// expand until we hit an edge
		while (l >= 0 && r < words[i].Length)
		{
			if (words[i][l--] != words[i][r++])
			{
				return;
			}
		}
		// more characters to the left, use forward trie
		if (l >= 0)
		{
			ptr = fwd;
			while (l >= 0)
			{
				ptr = ptr[words[i][l--]];
				if (ptr == null)
				{
					return;
				}
			}
			if (ptr.Index.HasValue)
			{
				pairs.Add(new[] { i, ptr.Index.Value });
			}
		}
		// more characters to the right, use reverse trie
		else if (r < words[i].Length)
		{
			ptr = rev;
			while (r < words[i].Length)
			{
				ptr = ptr[words[i][r++]];
				if (ptr == null)
				{
					return;
				}
			}
			if (ptr.Index.HasValue)
			{
				pairs.Add(new[] { ptr.Index.Value, i });
			}
		}
		// both edges hit, this is a palindrome, check for empty match
		else
		{
			if (fwd.Index.HasValue)
			{
				pairs.Add(new[] { fwd.Index.Value, i });
				pairs.Add(new[] { i, fwd.Index.Value });
			}
		}
	}

	return pairs;
}

public class Node
{
	private Node[] nodes = new Node[26];

	public int? Index;
	public Node this[char c]
	{
		get => nodes[c - 'a'];
		set => nodes[c - 'a'] = value;
	}
}