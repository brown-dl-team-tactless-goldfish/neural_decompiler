/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
void doubleQueue(struct TreeNode *** queue, int * num){
    *num = *num * 2;
    *queue = (struct TreeNode **)realloc(*queue, sizeof(struct TreeNode **) * (*num));
}

struct TreeNode ** inse(struct TreeNode ** queue, struct TreeNode * cur, int * end, int * num){
    queue[*end] = cur;
    *end = *end + 1;
    if ((*end) >= (*num)){
        doubleQueue(&queue, num);
    }
    return queue;
}

struct TreeNode * del(struct TreeNode ** queue, int * start){
    *start = *start + 1;
    return queue[*start - 1];
}

void refresh(struct TreeNode ** queue, int * start, int * end){
    for (int i = (*start); i < (*end); i++){
        queue[i - (*start)] = queue[i];
    }
    *end = *end - *start;
    *start = 0;
}

int maxLevelSum(struct TreeNode* root){
    struct TreeNode ** queue = malloc(sizeof(struct TreeNode **) * 20);
    int start = 0;
    int end = 0;
    int num = 20;
    int levelNum = 20;
    int level = 1;
    int * levelSum = malloc(sizeof(int) * 20);
    for (int i = 0; i < 20; i++){
        levelSum[i] = 0;
    }
    inse(queue, root, &end, &num);
    int flag = end;
    while (start < end){
        struct TreeNode * temp;
        while (start < flag){
            temp = del(queue, &start);
            if (temp != NULL){
                levelSum[level] += (temp->val);
                queue = inse(queue, temp->left, &end, &num);
                queue = inse(queue, temp->right, &end, &num);
            }
        }
        refresh(queue, &start, &end);
        flag = end;
        level++;
        if (level == levelNum){
            levelSum = realloc(levelSum, sizeof(int) * levelNum * 2);
            for (int i = levelNum; i < levelNum * 2; i++){
                levelSum[i] = 0;
            }
            levelNum *= 2;
        }
    }
    int max = 0;
    int result = 0;
    for (int i = 1; i <= level; i++){
        if (levelSum[i] > max){
            max = levelSum[i];
            result = i;
        }
    }
    return result;
}