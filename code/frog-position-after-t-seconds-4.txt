class Solution {
public:
    bool f(int i, vector<vector<int>>&g, unordered_set<int>& v, stack<int>& cur, stack<int>& result) {
        cur.push(i);
        if(i == 1){
            result = cur;
            return true;
        }
        bool ret = false;
        for(auto j : g[i]){
            if(!v.count(j)){
                v.insert(j);
                ret = f(j,g,v,cur,result);
                v.erase(j);
                if(ret){
                    break;
                }
            }
        }
        cur.pop();
        return ret; 
    }
    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {
        vector<vector<int>> g(n+1);
        for(auto& e : edges){
            g[e[0]].push_back(e[1]);
            g[e[1]].push_back(e[0]);
        }
        stack<int> s, result; 
        unordered_set<int> v; 
        f(target,g,v,s,result);
        if(result.size()>t+1){
            return 0;
        }
        if(result.size()<t+1){
            if(g[target].size()>1){
                return 0;
            }
            if(target == 1 && g[1].size()>0){
                return 0;
            }
        }
        if(result.size()==1){
            return 1; 
        }
        double ret = 1.0/g[1].size();
        result.pop();
        while(result.top() != target){
            int x = result.top();
            result.pop();
            ret *= 1.0/(g[x].size() - 1);
        }
        return ret; 
        
    }
};