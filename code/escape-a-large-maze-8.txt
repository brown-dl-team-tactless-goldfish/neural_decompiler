class Solution {
public:
    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {
        vector<int> dir = {1, 0, -1, 0, 1}; 
        
        unordered_set<long long> forbid; 
        for (auto blk : blocked) forbid.insert(((long long)blk[0] << 32) + blk[1]); 
        
        function<bool(int, int, int, int)> dfs = [&](int sx, int sy, int tx, int ty) {
            stack<pair<int, int>> stk; 
            stk.emplace(sx, sy); 
            unordered_set<long long> seen = {((long long)sx << 32) + sy}; 
            while (stk.size()) {
                auto [x, y] = stk.top(); stk.pop(); 
                if (abs(x - sx) + abs(y - sy) > 200 || x == tx && y == ty) return true; 
                for (int k = 0; k < 4; ++k) {
                    int xx = x + dir[k], yy = y + dir[k+1]; 
                    if (0 <= xx && xx < 1e6 && 0 <= yy && yy < 1e6) {
                        long long key = ((long long)xx << 32) + yy; 
                        if (forbid.find(key) == forbid.end() && seen.find(key) == seen.end()) {
                            stk.emplace(xx, yy); 
                            seen.emplace(key); 
                        }
                    }
                }
            }
            return false; 
        }; 
        
        return dfs(source[0], source[1], target[0], target[1]) && dfs(target[0], target[1], source[0], source[1]); 
    }
};