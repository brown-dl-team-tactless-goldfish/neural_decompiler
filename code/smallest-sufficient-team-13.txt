class Solution {
public:
    int getSkills(vector<string> &skills, map<string, int>&skillToIndMap){
        int mask = 0;
        for(string skill : skills)
            mask |= (1<<skillToIndMap[skill]);
        return mask;
    }
    vector<int> smallestSufficientTeam(vector<string>& req_skills, vector<vector<string>>& people) {
        map<string, int> skillToIndMap;
        for(int i=0;i<size(req_skills);i++)
            skillToIndMap[req_skills[i]] = i;
        int reqSkills = getSkills(req_skills, skillToIndMap);
        map<int, vector<int>> minPersonReqForSkills;
        // used for adding the first person skill;
        minPersonReqForSkills[0] = {};
        for(int ind = 0; ind < size(people); ind++){
            int personSkills = getSkills(people[ind], skillToIndMap);
            for(int skillMask = 0; skillMask <= reqSkills; skillMask++){
                if(minPersonReqForSkills.find(skillMask)==minPersonReqForSkills.end())continue;
                int newSkill = (skillMask | personSkills);
                if(minPersonReqForSkills.find(newSkill)==minPersonReqForSkills.end() || size(minPersonReqForSkills[skillMask]) + 1 < size(minPersonReqForSkills[newSkill])){
                    vector<int> newGroup(minPersonReqForSkills[skillMask]); 
                    newGroup.push_back(ind);
                    minPersonReqForSkills[newSkill] = newGroup;
                }
            }
        }
        return minPersonReqForSkills[reqSkills];
    }
};

/*

all subsets - 2^60 - not possible
if each person skill is represented by an integer using the bit representtion
then, the merger of the skills of two groups would be an OR operation

what is 2^16 -> 65k = 6.somethin * 10^4 = 7*10^4 = (10^5)
total skill combination * number of persons = n*10^5 = 6*10^6
dp state = min person required per skill subset

*/