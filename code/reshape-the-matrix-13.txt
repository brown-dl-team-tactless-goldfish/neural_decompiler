int** matrixReshape(int** mat, int matSize, int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes){

    // if the matrix already has the required resolution
    // or required resolution not correct
    if ((matSize == r && *matColSize == c) || (r * c != *matColSize * matSize)) {
        // then set settnigs from the inputed matrix
        *returnSize = matSize;
        *returnColumnSizes = (int*) malloc(matSize * sizeof(int));
        for (int i = 0; i < matSize; i++)
            // just array with lenght of row
            // matrices are rectangular - lines have one lenght
            *(*returnColumnSizes + i) = *matColSize;
        // and return the inputed matrix
        return mat;
    }

    // else set required resolution
    *returnSize = r;
    *returnColumnSizes = (int*) malloc(r * sizeof(int));
    for (int i = 0; i < r; i++)
         *(*returnColumnSizes + i) = c;

    // and allocate memory for new matrix
    int** matrix = (int**) malloc(r * sizeof(int*));
    for (int i = 0; i < r; i ++)
        matrix[i] = (int*) malloc(c * sizeof(int));

    // iterators for the inputed matrix
    int row_entered = 0, col_entered = 0;

    // going trought new matrix
    for (int row = 0; row < r; row++) {
        for (int col = 0; col < c; col++) {
            // fill matrix        from the entered one
            matrix[row][col] = mat[row_entered][col_entered];

            if (col_entered < *matColSize - 1)
                // go to next column in current row (go to next element in row)
                col_entered++;
            else
            {
                // if come to end of current row (last column)
                row_entered++;   // go to next row
                col_entered = 0; // go to first column
            }               
        }
    }

    return matrix;
}