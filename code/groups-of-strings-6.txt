        public int[] GroupStrings(string[] words)
        {
            int n= words.Length;
            var uf = new UnionFind(n);
			//group all words to diffierent length
            var dict = new Dictionary<int, Dictionary<int,int>>();//store {len, {bit, index}} pairs
            for (int i = 0; i < n; i++)
            {
                int len = words[i].Length;
                int bit = 0;//must convert to bit, or TLE
                foreach(var c in words[i])
                    bit |= 1 << (c - 'a');
                if (!dict.ContainsKey(len))
                    dict.Add(len, new Dictionary<int, int>());
                if (dict[len].ContainsKey(bit))
                    uf.Union(dict[len][bit], i);//union duplicates
                else dict[len].Add(bit,i);
            }
            //union all replace pairs of same length
            foreach(var i in dict.Keys)
            {
                var keys = dict[i].Keys.ToList();
                for(int k1 = 0; k1 < keys.Count-1; k1++)
                {
                    for (int k2 = k1+1; k2 < keys.Count; k2++)
                    {
                        if (GroupStrings_Ones(keys[k1] ^ keys[k2]) == 2)//all replace pairs contain 2 ones of their xor
                            uf.Union(dict[i][keys[k1]], dict[i][keys[k2]]);
                    }
                }
            }
            //union all delete pairs of 1 length diff, this is very important to reduce O(n1*n2) to O(n1*26) , n1,n2 is count of same length words of i,i-1
            for (int i = 1; i <= 26; i++)
            {
                if (!dict.ContainsKey(i) || !dict.ContainsKey(i - 1)) continue;
                foreach(var num in dict[i].Keys)
                {
                    for(int j = 0; j < 26; j++)
                    {
                        if((num & (1 << j)) != 0)// if current bit is 1
                        {
                            int delete = num & (~(1 << j));//try to find if delete exist
                            if (dict[i - 1].ContainsKey(delete))
                                uf.Union(dict[i][num], dict[i - 1][delete]);
                        }
                    }
                }
            }
            int maxCount = 0;
            HashSet<int> indexSet = new HashSet<int>();
            int[] arr = new int[n];
            for(int i = 0; i < n; i++)
            {
                int k = uf.Find(i);
                indexSet.Add(k);
                maxCount = Math.Max(maxCount, ++arr[k]);
            }
            return new int[] { indexSet.Count, maxCount };
        }
		
        private int GroupStrings_Ones(int n)
        {
            int count = 0;
            int seed = 1;
            for(int i = 0; i < 26 && count <=2; i++)
            {
                if ((n & (seed)) != 0) count++;
                seed<<=1;
            }
            return count;
        }
		public class UnionFind
		{
			public int[] parent;
			public int[] rank;
			public int GroupCount;
			public UnionFind(int n)
			{
				GroupCount = n;
				parent = new int[n];
				rank = new int[n];
				for(int i = 0; i < n; i++)
				{
					parent[i] = i;
				}
			}

			public int Find(int i)
			{
				while (parent[i] != i)
				{
					i=parent[i];
				}
				return i;
			}

			public bool IsConnected(int x, int y)
			{
				return Find(x) == Find(y);
			}

			public void Union(int p, int q)
			{
				int rootP = Find(p);
				int rootQ = Find(q);
				if (rootP == rootQ) return;
				if (rank[rootQ] > rank[rootP])
				{
					parent[rootP] = rootQ;
				}
				else
				{
					parent[rootQ] = rootP;
					if (rank[rootP] == rank[rootQ])
					{
						rank[rootP]++;
					}
				}
				GroupCount--;
			}
    }
