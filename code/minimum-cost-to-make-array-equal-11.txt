class Solution:
    # First, sort [num, cost] pairs according to num
    # Then we can safely assume the final target is one of the nums
    # The total cost is sum(abs(num-target)*cost) which we wish to minimize
    # The absolute difference means if we are considering nums[i] at pivot, left of it is (nums[i] - nums[j])*cost[j] and right of it is (nums[j] - nums[i])*cost[j]
    # Therefore it is advisable to keep the prefix sums of cost and num*cost
    # This would allow for O(1) readout of change in costs
    
    def minCost(self, nums: List[int], cost: List[int]) -> int:
        n, data = len(nums), []
        for i in range(n):
            data.append([nums[i], cost[i]])
        data.sort()
        prefix_cost, prefix_mult = [0], [0]
        for num, c in data:
            prefix_cost.append(c + prefix_cost[-1])
            prefix_mult.append(num*c + prefix_mult[-1])
        result = float('Inf')
        for i in range(n):
            result = min(result, prefix_mult[-1] - prefix_mult[i+1] - prefix_mult[i] + data[i][0]*(prefix_cost[i] + prefix_cost[i+1] - prefix_cost[-1]))
        return result

public class Solution {
    public long MinCost(int[] nums, int[] cost) {
        int n = nums.Length;
        var data = new List<Tuple<int, int>>();
        for (int i = 0; i < n; i++)
        {
            data.Add(new Tuple<int, int>(nums[i], cost[i]));
        }
        data.Sort();
        List<long> prefix_cost = new List<long>();
        List<long> prefix_mult = new List<long>();
        prefix_cost.Add(0);
        prefix_mult.Add(0);
        foreach (var item in data)
        {
            int num = item.Item1;
            int c = item.Item2;
            prefix_cost.Add(prefix_cost[prefix_cost.Count - 1] + c);
            prefix_mult.Add(prefix_mult[prefix_mult.Count - 1] + (long)c*num);
        }
        long result = Int64.MaxValue;
        for (int i = 0; i < n; i++)
        {
            result = Math.Min(result, prefix_mult[n] - prefix_mult[i+1] - prefix_mult[i] + (data[i].Item1)*(prefix_cost[i+1] + prefix_cost[i] - prefix_cost[n]));
        }
        return result;
    }
}