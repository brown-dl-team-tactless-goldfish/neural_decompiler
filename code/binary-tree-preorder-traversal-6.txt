/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#define MIN_NODES_AMOUNT (10)
#define FREE(mem)           \
    do                      \
    {                       \
        if (NULL != (mem))  \
        {                   \
            free((mem));    \
            (mem) = NULL;   \
        }                   \
    } while (false);

typedef struct stack_s
{
    size_t size;
    size_t max_size;
    struct TreeNode** nodes;
} stack_t;

stack_t* stack_create(size_t max_size)
{
    stack_t* stack = NULL;
    
    /* Validate parameters */
    if (0 == max_size)
    {
        (void)fprintf(stderr, "%s Received bad args.\n", __func__);
        goto l_cleanup;
    }
    
    /* Allocate memory for the stack*/
    stack = (stack_t*)calloc(1, sizeof(*stack));
    if (NULL == stack)
    {
        (void)fprintf(stderr, "%s: Calloc failed.", __func__);
        goto l_cleanup;
    }
    stack->nodes = (struct TreeNode**)calloc(max_size, sizeof(*(stack->nodes)));
    if (NULL == stack->nodes)
    {
        (void)fprintf(stderr, "%s: Calloc failed.", __func__);
        goto l_cleanup;
    }
    stack->size = 0;
    
l_cleanup:
    return stack;
}

void stack_push(stack_t* stack, struct TreeNode* node_to_push)
{
    /* Validate parameters */
    if ((NULL == stack) || (NULL == node_to_push))
    {
        (void)fprintf(stderr, "%s: Received bad args.\n", __func__);
        return;
    }
    
    if (stack->size >= stack->max_size)
    {
        /* Allocate additional space for the stack */
        stack->max_size += MIN_NODES_AMOUNT;
        stack->nodes = (struct TreeNode**)realloc(stack->nodes,
                                                  (sizeof(*(stack->nodes)) * stack->max_size));
        if (NULL == stack->nodes)
        {
            (void)fprintf(stderr, "%s: Realloc failed.\n", __func__);
            return;
        }
    }
    
    stack->nodes[stack->size] = node_to_push;
    stack->size++;
}

struct TreeNode* stack_pop(stack_t* stack)
{
    struct TreeNode* node = NULL;

    /* Validate parameters */
    if (NULL == stack)
    {
        (void)fprintf(stderr, "%s: Received bad args.\n", __func__);
        goto l_cleanup;
    }
    
    if (0 >= stack->size)
    {
        (void)fprintf(stderr, "%s: Stack is empty!\n", __func__);
        goto l_cleanup;
    }

    node = stack->nodes[stack->size - 1];
    stack->nodes[stack->size - 1] = NULL;
    stack->size--;

l_cleanup:
    return node;
}

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* preorderTraversal(struct TreeNode* root, int* returnSize)
{
    struct TreeNode* curr_node = root;
    stack_t* stack = NULL;
    size_t arr_size = 0;
    size_t max_arr_size = MIN_NODES_AMOUNT;
    int* out_array = NULL;
    
    /* Validate parameters */
    if (NULL == returnSize)
    {
        (void)fprintf(stderr, "%s: Received bad args.\n", __func__);
        goto l_cleanup;
    }
    
    /* Allocate memory for out_array */
    out_array = (int*)calloc(MIN_NODES_AMOUNT, sizeof(*out_array));
    if (NULL == out_array)
    {
        (void)fprintf(stderr, "%s: Calloc failed.", __func__);
        goto l_cleanup;
    }
    /* Initialize the stack */
    stack = stack_create(MIN_NODES_AMOUNT);
    if (NULL == stack)
    {
        (void)fprintf(stderr, "%s: Failed to initialize the stack.\n", __func__);
        goto l_cleanup;
    }
    
    do
    {
        if (NULL != curr_node)
        {
            if (arr_size >= max_arr_size)
            {
                /* Allocate additional space for the out_array */
                max_arr_size += MIN_NODES_AMOUNT;
                out_array = (int*)realloc(out_array, (sizeof(*out_array) * max_arr_size));
                if (NULL == out_array)
                {
                    (void)fprintf(stderr, "%s: Realloc failed.", __func__);
                    goto l_cleanup;
                }
            }
            
            /* Visit the root first */
            out_array[arr_size] = curr_node->val;
            arr_size++;

            /* Push the right node so we can return to it later */
            if (NULL != curr_node->right)
            {
                stack_push(stack, curr_node->right);
            }

            /* Visit the left node */
            curr_node = curr_node->left;   
        }
        else
        {
            /* Reached an end, visit the most recent right node */
            curr_node = stack_pop(stack);
        }
    } while ((0 != stack->size) || (NULL != curr_node));
    
    *returnSize = arr_size;
    
l_cleanup:
    if (NULL != stack)
    {
        FREE(stack->nodes);
        FREE(stack);    
    }
    return out_array;
}
