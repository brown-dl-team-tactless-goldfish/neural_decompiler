class Solution {
  public:
    vector <long long> handleQuery (vector <int>& nums1, vector <int>& nums2, vector <vector <int>>& queries) {
      int n = nums1.size();
      int64_t answer = std::accumulate(nums2.begin(), nums2.end(), int64_t(0));
      std::vector <long long> results;
      
      struct node {
        int value = 0;
        bool lazy = false;
      };
      
      std::vector <node> tree (4 * n);
      
      auto build = [&] (auto self, int v, int tl, int tr) -> void {
        if (tl == tr)
          tree[v].value = nums1[tl] == 1;
        else {
          int tm = (tl + tr) / 2;
          self(self, 2 * v + 1, tl, tm);
          self(self, 2 * v + 2, tm + 1, tr);
          tree[v].value = tree[2 * v + 1].value + tree[2 * v + 2].value;
        }
      };
      
      auto push = [&] (int v, int tl, int tr) {
        if (not tree[v].lazy)
          return;
        int tm = (tl + tr) / 2;
        tree[2 * v + 1].value = tm - tl + 1 - tree[2 * v + 1].value;
        tree[2 * v + 2].value = tr - tm - tree[2 * v + 2].value;
        tree[2 * v + 1].lazy ^= true;
        tree[2 * v + 2].lazy ^= true;
        tree[v].lazy = false;
      };
      
      auto update = [&] (auto self, int v, int tl, int tr, int l, int r) -> void {
        if (l > r)
          return;
        if (tl == l and tr == r) {
          tree[v].value = tr - tl + 1 - tree[v].value;
          tree[v].lazy ^= true;
          return;
        }
        push(v, tl, tr);
        int tm = (tl + tr) / 2;
        self(self, 2 * v + 1, tl, tm, l, std::min(r, tm));
        self(self, 2 * v + 2, tm + 1, tr, std::max(l, tm + 1), r);
        tree[v].value = tree[2 * v + 1].value + tree[2 * v + 2].value;
      };
      
      build(build, 0, 0, n - 1);
      
      for (auto &v: queries) {
        if (v[0] == 1)
          update(update, 0, 0, n - 1, v[1], v[2]);
        else if (v[0] == 2)
          answer += (int64_t)tree[0].value * v[1];
        else
          results.push_back(answer);
      }
      
      return results;
    }
};