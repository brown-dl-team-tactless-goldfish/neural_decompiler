class Solution {
public:
    int minimumMoves(vector<vector<int>>& grid) {
        const int n = grid.size();
        const vector<pair<int,int>> dirs = {{0,1}, {0,-1},{1,0},{-1,0}};
        auto visited = vector(n, vector(n, vector(2, false)));
        queue<pair<State, int>> q;
        q.push(pair(State(grid), 0));
        visited[0][0][0] = true;
        while(!q.empty()){
            auto [s, step] = q.front(); q.pop();
            for(auto p : s.neighbor()){
                if(p.i == n-1 && p.j == n-2) return step+1;
                if(visited[p.i][p.j][p.rotate]) continue;
                visited[p.i][p.j][p.rotate] = true;
                q.push(pair(p, step+1));
            }
        }
        return -1;
    }
    
    struct State{
        State(const vector<vector<int>>& grid) : g(grid), n(grid.size()){}
        
        vector<State> neighbor() const{
            static const vector<pair<int,int>> dirs = {{0,1}, {1,0}};
            vector<State> res;
            for(auto [di, dj]:dirs){
                State p = *this;
                p.i = i+di, p.j = j+dj;
                if(p.isValid()) res.push_back(p);
            }
            
            if(isValidToRotate()){
                State r = *this;
                r.rotate = !r.rotate;
                if(r.isValid()) res.push_back(r);
            }           
            return res;
        }
        
        bool isValid() const{
            int i1 = i, j1 = j+1;
            if(rotate) i1 = i+1, j1=j;
            return isValid(i, j) && isValid(i1, j1);
        }
        
        bool isValidToRotate() const{
            return isValid(i, j) && isValid(i, j+1) && isValid(i+1, j) && isValid(i+1, j+1);
        }
        
        bool isValid(int x, int y) const{
            return x>=0 && x<n && y>=0 && y<n && g[x][y] == 0;
        }
        
        const vector<vector<int>>& g;
        const int n;
        int i = 0;
        int j = 0;
        bool rotate = false;
    };
};