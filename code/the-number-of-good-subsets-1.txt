class Solution {
public:
    int mod = 1e9 + 7;
    long pow (int a, int p) {
        if (!p) return 1;
        long t = pow(a, p >> 1);
        t = (t * t) % mod;
        return p & 1 ? (t * a % mod) : t; 
    }
    
    int numberOfGoodSubsets(vector<int>& nums) {
        vector<int> p(31);
        int pcnt = 0;
        for (int i = 2; i < 31; i++) {
            if (!(i % 4) || !(i % 9) || !(i % 25)) continue;
            int j = 2;
            for (; j * j <= i; j++) {
                if (!(i % j)) {
                    int k = i / j;
                    p[i] = p[j] | p[k];
                    break;
                }
            }
            if (!p[i]) p[i] |= 1 << (pcnt++); 
        }
        
        vector<long> dp(1 << pcnt);
        unordered_map<int, long> cnt;
        for (auto t : nums) cnt[t]++;
        dp[0] = pow(2, cnt[1]);
        for (auto t : cnt) {
            if (!p[t.first]) continue;
            for (int i = 0; i < 1 << pcnt; i++) {
                if (i & p[t.first]) continue;
                dp[i | p[t.first]] = (dp[i | p[t.first]] + dp[i] * t.second) % mod;
            }
        }
        return accumulate(begin(dp) + 1, end(dp), 0l) % mod;
    }
};