int cmpfunc (const void * a, const void * b) {
   return ( *(int*)a - *(int*)b );
}

int* powerfulIntegers(int x, int y, int bound, int* returnSize){
   
    int px=1,py=1,count=0;
    int *N = (int *)malloc((bound+1)*sizeof(int));
    
    // Solve special case when x=1 and y=1
    if(x==1 && y==1){
        if(bound>1){
            N[0]=2;
            *returnSize = 1;
            return N;
        }
        *returnSize = 0;
        return N;
    }
    
    // Brute Force
    for(px=1;px+py<=bound;px*=x){
        for(py=1;px+py<=bound;py*=y){
            N[count++] = px+py;
            printf("%d ",px+py);
            if(y==1) break;  // avoid infinite loop 1->1*1*1....
        }
        py=1;
        if(x==1) break;  // avoid infinite loop 1->1*1*1....
    }
    
    // Sort Array using Quick Sort
    qsort(N, count, sizeof(int), cmpfunc);
    
    // Remove duplicates from sorted Array
    int i,k=0;
    for(i=0;i<count-1;i++){
        if(N[i] != N[i+1]){
            N[k] = N[i];
            k++;
        }
    }
    N[k]=N[count-1];
    
    *returnSize = k+1;
    return N;
}