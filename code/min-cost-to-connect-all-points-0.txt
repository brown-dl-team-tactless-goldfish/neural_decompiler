// sort 3rd
int cmpfunc( const void* p1,  const void* p2){
   int* arr1 = *(int**)p1;
   int* arr2 = *(int**)p2;
  if(arr1[2] == arr2[2]) 
      return arr1[0] - arr2[0]; 
  return arr1[2] - arr2[2];
}

int UnionFind(int* UNION, int val){
    if(UNION[val] == val)
        return val;
    
    return UnionFind(UNION, UNION[val]);
}

bool UnionSet(int* UNION, int* USize, int a, int b){
    int Find_a = UnionFind(UNION , a);
    int Find_b = UnionFind(UNION , b);
    if(Find_a == Find_b)
        return false;
    if(USize[Find_a] > USize[Find_b]){
        UNION[Find_b] = UNION[Find_a] ;
        USize[Find_a] += USize[Find_b];
    }
    else{
        UNION[Find_a] = UNION[Find_b] ;
        USize[Find_b] += USize[Find_a];        
    }
    return true;
}  

int minCostConnectPoints(int** points, int pointsSize, int* pointsColSize){
    int n = pointsSize;
    int tatal_e = n*(n-1)/2 ;
    
    int** table = malloc( tatal_e * sizeof(int*));
    for(int i = 0; i < tatal_e; i++){
        table[i] = malloc( 3 * sizeof(int) );
    }
    int idx = 0;
    for(int i = 0; i < pointsSize; i++){
        for(int j = i+1;  j < pointsSize; j++){
            table[idx][0] = i;
            table[idx][1] = j;
            table[idx][2] = abs( points[i][0] - points[j][0] ) + abs( points[i][1] - points[j][1] ) ;
            idx++;
        }
    }   
    qsort(table, idx , sizeof(int*), cmpfunc) ;

    int* UNION = malloc( n * sizeof(int) );
    int* USize = malloc( n * sizeof(int) );
    for(int i = 0; i < n; i++){
        UNION[i] = i;
        USize[i] = 1;
    } 
    int ans = 0;
    int edge = 0;
    for(int i = 0; i < idx; i++){
        if( UnionSet(UNION, USize, table[i][0], table[i][1]) ){
            ans += table[i][2];
            edge++;
            if( edge == (n-1))
                break;
        }
    }
    
    return ans;

}