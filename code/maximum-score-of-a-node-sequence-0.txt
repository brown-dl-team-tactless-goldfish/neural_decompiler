class Solution {
    //sort and only save 3 of highest score neighbours
    void push_rank(const vector<int>& scores, vector<int> &rank, int node) {
        rank.push_back(node);
        for (int i = (int)rank.size() - 1; i - 1 >= 0; i--) {
            if (scores[rank[i]] > scores[rank[i - 1]]) {
                swap(rank[i], rank[i - 1]);
            }
        }
        if (rank.size() > 3) {
            rank.pop_back();
        }
    }
public:
    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {
        int n = scores.size();
        vector<vector<int>> ranks(n);    //node -> sorted [highest score neighbour node]
        for (const vector<int> &edge : edges) {
            int a = edge[0];
            int b = edge[1];
            push_rank(scores, ranks[a], b);
            push_rank(scores, ranks[b], a);
        }
        int result = -1;
        for (const vector<int> &edge : edges) {
            int a = edge[0];
            int b = edge[1];
            for (int c : ranks[a]) {
                for (int d : ranks[b]) {
                    if (c == b || c == d || d == a) {
                        continue;
                    }
                    // a, b, c, d are different
                    result = max(result, scores[a] + scores[b] + scores[c] + scores[d]);
                }
            }
        }
        return result;
    }
};