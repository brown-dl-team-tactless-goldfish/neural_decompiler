class Solution {
public:
    unordered_map<int, unordered_set<int>> g;
    int N = 0;
    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {
        N = edges.size();
        for(auto & e : edges) {
            g[e[0]].insert(e[1]);
            g[e[1]].insert(e[0]);
        }
        return dfs(0, 0, -1, bob, amount).first;
    }

    pair<int, int> dfs(int n, int d0, int p, int bob, vector<int>& amount) {
        int db = n == bob ? 0 : N, res = n == bob ? 0 : amount[n], leaf = 1;
        for(int nxt : g[n]) {
            if(nxt == p) continue;
            auto [r, d] = dfs(nxt, d0+1, n, bob, amount);
            db = min(d, db);
            res = leaf == 1 ? r : max(res, r);
            leaf = 0;
        }
        if(!leaf && d0 < db) res += amount[n];
        if(!leaf && d0 == db) res += amount[n]/2;

        return {res, db+1};
    }
};