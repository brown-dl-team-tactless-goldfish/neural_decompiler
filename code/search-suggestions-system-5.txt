// return 1 if a < b lexicographically or b is null
int myCompare(char *a, char *b) {
    if (b == NULL) {
        return 1;
    }
    int i = 0;
    while(a[i] && b[i]) {
        if (a[i] > b[i]) {
            return 0;
        } else if (a[i] < b[i]) {
            return 1;
        }
        i++;
    }
    if (a[i]) {
        return 0;
    } else {
        return 1;
    }
}


char *** suggestedProducts(char ** products, int productsSize, char * searchWord, int* returnSize, int** returnColumnSizes){
    char *** ret = (char ***) malloc(strlen(searchWord) * sizeof(char **));
    *returnColumnSizes = (int *) malloc(strlen(searchWord) * sizeof(int));
    *returnSize = strlen(searchWord);
    char *p1 = NULL, *p2 = NULL, *p3 = NULL;
    char **currentData =  products;
    int dataSize = productsSize;
    char **nextData = NULL;
    for (int i=0; i< strlen(searchWord); i++) {
        char ** reti = (char **) malloc( 3 * sizeof(char *));
        ret[i] = reti;
        int nextDataSize = 0;
        nextData = (char**) malloc(dataSize * sizeof(char*));
        p1 = NULL;
        p2 = NULL;
        p3 = NULL;
        for (int j=0; j<dataSize; j++) {
            if (currentData[j][0] == searchWord[i]) {
                nextData[nextDataSize++] = & currentData[j][1];
                if (myCompare(currentData[j], p1)) {
                    p3 = p2;
                    p2 = p1;
                    p1 = currentData[j];
                } else if (myCompare(currentData[j], p2)) {
                    p3 = p2;
                    p2 = currentData[j];
                } else if (myCompare(currentData[j], p3)) {
                    p3 = currentData[j];
                }
            }
        }
        int suggestsNumber = 0;
        if (p1 != NULL) {
            ret[i][suggestsNumber] = (char *) malloc((strlen(p1) + i) * (sizeof(char) + 1));
            strcpy(ret[i][suggestsNumber], p1 - i);
            suggestsNumber++;
        }
        if (p2 != NULL) {
            ret[i][suggestsNumber] = (char *) malloc((strlen(p2) + i) * (sizeof(char) + 1));
            strcpy(ret[i][suggestsNumber], p2 - i);
            suggestsNumber++;
        }
        if (p3 != NULL) {
            ret[i][suggestsNumber] = (char *) malloc((strlen(p3) + i) * (sizeof(char) + 1));
            strcpy(ret[i][suggestsNumber], p3 - i);
            suggestsNumber++;
        }
        *(*returnColumnSizes + i) = suggestsNumber;
        if (i != 0) {
            free(currentData);
        }
        currentData = nextData;
        dataSize = nextDataSize;
    }
    return ret;
}
