/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
struct TreeNode * build_root(int max_val)
{ 
    struct TreeNode * new_node = (struct TreeNode *)malloc(sizeof(struct TreeNode));
    new_node->val = max_val;
    new_node->left = NULL;
    new_node->right = NULL;
    return new_node;
}

struct TreeNode * build_tree(int * nums, int start_index, int end_index)
{

    int i=0;
    int max_num = INT_MIN;
    int index = 0;
    
    for(i=start_index;i<=end_index;i++)
    {
        if(nums[i] >= max_num)
        {
            max_num = nums[i];
            index = i;
        }
    }
    
    struct TreeNode * new_node = (struct TreeNode *)malloc(sizeof(struct TreeNode));
    new_node->val = max_num;
    
    if(index!=start_index)
    {
        new_node->left = build_tree(nums, start_index, index-1);
    }
    else if(index==start_index)
    {
        new_node->left = NULL;
    }
    
    if(index!=end_index)
    {
        new_node->right = build_tree( nums, index+1, end_index);
    }
    else if(index==end_index)
    {
        new_node->right = NULL;
    }
    return new_node;
    
}


struct TreeNode* constructMaximumBinaryTree(int* nums, int numsSize)
{
    int max_val = INT_MIN;
    int i=0;
    int index = 0;
    for(i=0; i<numsSize; i++)
    {
        if(nums[i] >= max_val)
        {
            max_val = nums[i];
            index = i;
        }
    }
    
    struct TreeNode * root = NULL;   
    root = build_root(max_val);         //Build the root Node
    
    //Build the left subtree
    if(index!=0)
    {
        root->left = build_tree(nums, 0, index-1);
    }
    
    //Build the left subtree
    if(index!=numsSize-1)
    {
        root->right = build_tree(nums, index+1, numsSize-1);
    }
    
    return root;
}