class Solution {
public:
    unordered_map<int, unordered_set<int>*> memo;
        
    int scoreOfStudents(string s, vector<int>& answers) {
        int len = s.size();
        int goodAns = solve(s);
        unordered_set<int>* partialAns = solve_partial(s, 0, len - 1);
        int ans = 0;
        for (int i = 0; i < answers.size(); ++i) {
            if (answers[i] == goodAns) {
                ans += 5;
            } else if (partialAns->find(answers[i]) != partialAns->end()) {
                ans += 2;
            }
        }
        return ans;
    }
    
    int solve(string& s) {
        stack<int> stk;
        for (int i = 0; i < s.size(); ++i) {
            if (stk.empty()) {
                stk.push(s[i] - '0');
            } else {
                if (s[i] == '+') {
                    stk.push(-1);
                } else if (s[i] == '*') {
                    stk.push(-2);
                } else {
                    int value = (s[i] - '0');
                    while (!stk.empty() && stk.top() == -2) {
                        stk.pop();
                        value *= stk.top();
                        stk.pop();
                    }
                    stk.push(value);
                }
            }
        }
        int ans = 0;
        while (!stk.empty()) {
            ans += stk.top();
            stk.pop();
            if (!stk.empty()) {
                stk.pop();
            }
        }
        return ans;
    }
    
    unordered_set<int>* solve_partial(string& s, int left, int right) {
        if (memo.find(left * 1000 + right) != memo.end()) {
            return memo[left * 1000 + right];
        }
        unordered_set<int>* ret = new unordered_set<int>();
        if (left == right) {
            ret->insert(s[left] - '0');
            memo[left * 1000 + right] = ret;
            return ret;
        }
        for (int i = left + 1; i < right; i += 2) {
            unordered_set<int>* leftAns = solve_partial(s, left, i - 1);
            unordered_set<int>* rightAns = solve_partial(s, i + 1, right);
            for (auto it1 = leftAns->begin(); it1 != leftAns->end(); ++it1) {
                for (auto it2 = rightAns->begin(); it2 != rightAns->end(); ++it2) {
                    if (s[i] == '+') {
                        if (*it1 + *it2 <= 1000) {
                            ret->insert(*it1 + *it2);
                        }
                    } else {
                        if (*it1 * *it2 <= 1000) {
                            ret->insert(*it1 * *it2);
                        }
                    }
                }
            }
        }
        memo[left * 1000 + right] = ret;
        return ret;
    }
};