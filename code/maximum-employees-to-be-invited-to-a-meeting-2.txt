class Solution {
public:
    vector<vector<int>> child;
    unordered_set<int> st;
    int ans=0;
    int sub(int indx, unordered_set<int>& visit,int level){
        int tmp=level;
        st.erase(indx);
        visit.insert(indx);
        for(auto c: child[indx]){
		   // forms a cycle if c is visited
            if(visit.count(c)) {ans= max(ans,level); break;}
            else  { if(st.count(c)) {tmp=max(tmp, sub(c,visit,level+1));  }}
        }
        return tmp;
    }
    int maximumInvitations(vector<int>& favorite) {
        int n=favorite.size(); if(n<=3) return n;
        vector<vector<int>> cyc; 
        child=vector<vector<int>>(n, vector<int>());
        for(int i=0;i<n;i++){ 
         if(favorite[favorite[i]]==i) 
            {if(favorite[i]<i)cyc.push_back({i, favorite[i]});}
         else {st.insert(i); child[favorite[i]].push_back(i);}
        }
        unordered_set<int> tmp;
		// case 1
        for(auto p:cyc){ ans+=( sub(p[0], tmp,1)+sub(p[1],tmp,1));}
		// case 2
        while(st.size()>0){
            int t=*st.begin(); st.erase(t); tmp={};
            sub(t,tmp,1);
        }  
        return ans;
    }
};