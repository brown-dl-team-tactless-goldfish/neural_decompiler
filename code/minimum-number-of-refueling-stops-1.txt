/*
想法很簡單 我們要確定 當我的油量有 x 時 我到當前的加油站時  此時還需要加幾次油就可以到終點
那我們的陣列如下 

說明目前的狀況 有一個count
count 是指 加油的次數

gas[0] = 30  這是指  如果我的汽油 >= 5  那我 需要加 0 次油 就可以到終點
gas[1] = 25  這是指  如果我的汽油 >= 25 那我 需要加 1 次油 就可以到終點
gas[2] = 10  這是指  如果我的汽油 >= 10 那我 需要加 2 次油 就可以到終點
gas[i] = j   這是指  如果我的汽油 >= j  那我 需要加 i 次油 就可以到終點
(i < count)


舉例     位置  汽油
初始油量    0   10

           6   12 
          10   11
          17    1
          19   10
          27    2

終點距離   31

此流程需要反推 從最後一個加油站開始

只考慮最後一個加油站跟終點之間的關係 我們可以知道

如果 我身上的汽油 >= 終點到加油站的距離(31-27) 那我此時不用加油 可以直接開到終點 那我們就得知
gas[0] = 4 如果我的汽油 >= 4  那我 需要加 0 次油 就可以到終點
但如果不夠呢 所以我們需要將要加油的情況下考慮進去
這個加油站 我們最多只能加 2 的油 但是距離終點卻還有 4 所以得知
gas[1] = 2 如果我的汽油 >= 2  那我 需要加 1 次油 就可以到終點
此時的 count 就是 2  因為我目前的如果比2還小 那就代表我到不了終點了

那考慮完最後一個加油站 我們已經得到了我們最初始的狀況 
gas[0] = 4 
gas[1] = 2
如果比 2 還小 那我們到不了終點
count = 2
這個表的意思就如上述所述 我們可以從0該開始檢查 如果 油量 >= gas[i] 那我需要加油的次數就是 i
如果都找不到 那就是  -1 (無法到達終點)

接著考慮倒數第二個加油站 
我們得知 倒數第二個加油站距離最後的加油站為 (27-19)

我們剛剛的表還要接著繼續用 我們先假設 """如果這裡沒有加油站 那我如果在此處的情況會怎樣"""
因為此處距離下一個加油站距離為 8 所以將我們的表都先+8

gas[0] = 12 此時 如果沒有加油站  我的汽油 >= 12  那我 需要加 0 次油 就可以到終點
gas[1] = 10 此時 如果沒有加油站  我的汽油 >= 10  那我 需要加 1 次油 就可以到終點   

但因為這邊有加油站 我們有可能可以加油
此時就要思考  """我有沒有辦法加完油之後 情況可以比剛剛更好"""
原本如果我不加油的情況 我至少需要10的油量 就可以加一次油到終點 (到下個加油站再加油)
但如果我現在就加油 加完之後油就有至少 12 的話 這樣的情況也是 加一次油就到終點
那如果我希望加完油之後有12 那就代表我身上至少要有 12-10 的油 (這個加油站可以加10的油)
就是說 如果我身上有至少 2 的油 我可以加 1 次油就到終點
也就是說如果  gas[1] > gas[0] - (這個加油站能加的油量)

這個不等式的意思是  我原本以為我至少需要 gas[1] 的油就可以到達終點  
但發現了這個加油站後 我發現我先在這個加油站加油 也可以到同樣的效果
而且還可以在更少油的狀況

因此我們需要更新 gas[1] = gas[0] - (這個加油站能加油的)
gas[1] = 2  我的汽油 >= 2  那我 需要加 0 次油 就可以到終點

此時我們得到  (我們目前在19的位置)
這樣還沒結束 因為最後一個看的數字不是 0 
代表我們可以考慮看看 有沒有可能 我們 "只要能到達這個點 就代表可以到達終點"

目前的狀況就是說 如果我們的油當時 < 10 就代表我們無法到達終點 (因為兩個加油站距離8) (((((演算法中會用last存起來)))))


gas[2] = gas[1](((last))) - (這個加油站能加的油量)    ***此處需搞清楚 gas 的時間  下面的演算法會用last 存起來
gas[2] = 10 - 10 = 0  (如果小於0 那也是填入0)
count++;

gas[0] = 12
gas[1] =  2
gas[2] =  0
count = 3

接著繼續往回找

*/

int minRefuelStops(int target, int startFuel, int** stations, int stationsSize, int* stationsColSize){
    if (stationsSize == 0){
        return startFuel >= target ? 0 : -1;
    }
    int gas[stationsSize+1];
    int count = 2;
    if (stationsSize >= 1){
        gas[0] = target-stations[stationsSize-1][0];
        gas[1] = gas[0]-stations[stationsSize-1][1];
        if (gas[1] < 0){
            gas[1] = 0;
        }
    }
    /*
    for (int j = 0 ; j < count ; j++){
        printf("%d ",gas[j]);
    }
    printf("\n");
    */
    for (int i = stationsSize-2 ; i >= 0 ; i--){
        int next = stations[i+1][0] - stations[i][0];
        gas[0] += next;
        int last = gas[0];   //這個數字可能會被更新 要先複製一份起來
        for (int j = 1 ; j < count ; j++){ 
            gas[j] += next;
            if (gas[j] > last-stations[i][1]){
                int k = last;
                last = gas[j];
                gas[j] = k-stations[i][1];
                if (gas[j] <= 0){
                    gas[j] = 0;
                    count = j+1;
                    break;
                }
            } else {
                last = gas[j];
            }
        }
        
        if (gas[count-1] != 0){
            gas[count] = last-stations[i][1] > 0 ? last-stations[i][1] : 0;
            count++;
        }
        /*
        for (int j = 0 ; j < count ; j++){
            printf("%d ",gas[j]);
        }
        printf("\n");
        */
    }
    for (int i = 0 ; i < count ; i++){
        if (startFuel >= gas[i] + stations[0][0]){
            return i;
        }
    }
    return -1;
}