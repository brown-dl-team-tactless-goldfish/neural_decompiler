class Solution {
public:
    int dp[100001];
    int MOD = 1000000007;
    
    int decode(string &s, int r)
    {
        long long count;
        
        if(r<0) return 1L;
        
        // single number ways 9 for *, otherwise 1 
        else if(r==0) count = (s[r] == '*' ? 9L : 1L);
        
        // return memorized value
        else if(dp[r]!=-1L) return dp[r];
        
        // "10" or "20" are 2 possible ways for "*0", otherwise 1 
        else if(s[r]=='0') count = (s[r-1]=='*' ? 2L : 1L) * decode(s,r-2);
                
        // "0*" have 9 possible ways, otherwise 1
        else if(s[r-1]=='0') count = (s[r] == '*' ? 9L : 1L) * decode(s,r-1);
        
        // "X*" have 4 cases 
        // "**" have 9 possible ways for single value and 15 possible ways for double value
        // "1*" have 9 possible ways for single value and 18 possible ways for double value
        // "2*" have 9 possible ways for single value and 6 possible ways for double value
        // "3*" to "9*" have 9 possible ways for single value and no possible ways for double value
        else if(s[r]=='*')
        {
            if(s[r-1]=='*') count = (9L * decode(s,r-1)) %MOD + (15L * decode(s,r-2)) %MOD;
            else if(s[r-1]=='1') count = (9L * decode(s,r-1))%MOD + (9L * decode(s,r-2)) %MOD;
            else if(s[r-1]=='2') count = (9L * decode(s,r-1))%MOD + (6L * decode(s,r-2)) %MOD;
            else count = (9L * decode(s,r-1)) %MOD;
        }
            
        // "*X" have 2 cases
        // "*1" to "*6" have 1 way for single value and 2 way for double value 
        // "*7" to "*9" have 1 way for single value and 1 way for double value 
        // EX => "13" and "23" for "*3" and "17" for "*7"
        else if(s[r-1]=='*')
        {
            if(s[r]>'6') count = decode(s,r-1)%MOD + decode(s,r-2)%MOD;
            else count = decode(s,r-1)%MOD + (2L * decode(s,r-2)) %MOD; 
        } 
        
        // "XY" can be only single value if "XY" > "26" 
        else if((s[r-1]-'0')*10 + (s[r]-'0') > 26) count = decode(s,r-1);
        
        // "XY" can be both single and double value if "XY" <= "26"
        else count = decode(s,r-1)%MOD + decode(s,r-2)%MOD;
        
        return dp[r] = count % MOD;
    }
    
    int numDecodings(string s) {
        
        int n = s.length();
        
        // check if given string has leading zero and return 0
        if(s[0]=='0') return 0;
        for(int i=1;i<n;i++)
        {
            dp[i] = -1;
            if(s[i]=='0' && (s[i-1]=='#' || s[i-1]=='0' || s[i-1]>'2')) return 0;
        }
        
        // scan string from last to first and recursively calculate ways using DP
        return decode(s,n-1);
    }
};