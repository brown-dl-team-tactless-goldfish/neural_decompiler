/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
void dfs(int parent, int node, int* ans, int* count, int** adj, int* adjSize, char* labels)
{
    int index = labels[node] - 'a';
    int previous = count[index];
    count[index]++;

    for(int i = 0; i < adjSize[node]; i++)
        if(parent != adj[node][i])
            dfs(node, adj[node][i], ans, count, adj, adjSize, labels);
    ans[node] = count[index] - previous;
}
int* countSubTrees(int n, int** edges, int edgesSize, int* edgesColSize, char * labels, int* returnSize)
{
    int* count = calloc(26, sizeof(int));
    int* ans = malloc(n * sizeof(int));
    *returnSize = n;
    int** adj = malloc(n * sizeof(int*));
    int* adjSize = calloc(n, sizeof(int));
    //dynamically allocate and initialize adjacency list
    for(int i = 0; i < n - 1; i++)
    {
        int a = edges[i][0], b = edges[i][1];
        if(adjSize[a] == 0)
        {
            adjSize[a]++;
            adj[a] = malloc(sizeof(int));
        }
        else
            adj[a] = realloc(adj[a], ++adjSize[a] * sizeof(int));
        adj[a][adjSize[a] - 1] = b;
        if(adjSize[b] == 0)
        {
            adjSize[b]++;
            adj[b] = malloc(sizeof(int));
        }
        else
            adj[b] = realloc(adj[b], ++adjSize[b] * sizeof(int));
        adj[b][adjSize[b] - 1] = a;
    }
    dfs(-1, 0, ans, count, adj, adjSize, labels);
    //free everything
    free(count);
    for(int i = 0; i < n; i++)
        free(adj[i]);
    free(adj);
    free(adjSize);
    return ans;
}