
struct cell {
        int x;
        int y;
};

void __enque_around(struct cell *queue, int *front, char **board, int i, int j)
{
        ++(*front);
        queue[*front].x = i;
        queue[*front].y = j;
        board[i][j] = 'Y'; //arbitary char to mark it in middle state
}

void enque_around(struct cell *queue, int *front, char **board, int h, int w, int i, int j)
{
        if (i > 0 && board[i - 1][j] == 'O')
                __enque_around(queue, front, board, i - 1, j);
        if (i + 1 < h && board[i + 1][j] == 'O')
                __enque_around(queue, front, board, i + 1, j);
        if (j > 0 && board[i][j - 1] == 'O')
                __enque_around(queue, front, board, i, j - 1);
        if (j + 1 < w && board[i][j + 1] == 'O')
                __enque_around(queue, front, board, i, j + 1);
}

bool is_on_border(int h, int w, int i, int j)
{
        return i == 0 || j == 0 || i == h - 1 || j == w - 1;
}

bool check_region_surrounded(char **board, int h, int w, int i, int j, struct cell *queue, int *front, int *rear)
{
        int tmp_rear;
        int tmp_front;
        int x, y;
        bool on_board = false;
        
        while (*rear < *front) {
                tmp_rear = *rear;
                tmp_front = *front;
                
                while (tmp_rear < tmp_front) {
                        ++tmp_rear;
                        
                        x = queue[tmp_rear].x;
                        y = queue[tmp_rear].y;
                        if (is_on_border(h, w, x, y))
                                on_board = true;
                        enque_around(queue, front, board, h, w, x, y);
                }
                
                *rear = tmp_front;
        }
        
        return !on_board;
}

void set_region(char **board, int h, int w, int i, int j, char c)
{
        board[i][j] = c;
        
        if (i > 0 && board[i - 1][j] == 'Y')
                set_region(board, h, w, i - 1, j, c);
        if (i + 1 < h && board[i + 1][j] == 'Y')
                set_region(board, h, w, i + 1, j, c);
        if (j > 0 && board[i][j - 1] == 'Y')
                set_region(board, h, w, i, j - 1, c);
        if (j + 1 < w && board[i][j + 1] == 'Y')
                set_region(board, h, w, i, j + 1, c);
}

void solve(char** board, int boardSize, int* boardColSize)
{
        int h = boardSize;
        int w = boardColSize[0];
        
        struct cell *queue = malloc(sizeof(struct cell) * w * h);
        int rear = -1;
        int front = -1;
        
        int i, j;
        for (i = 0; i < h; i++) {
                for (j = 0; j < w; j++) {
                        if (board[i][j] != 'O')
                                continue;
                        
                        __enque_around(queue, &front, board, i, j);
                        if (check_region_surrounded(board, h, w, i, j, queue, &front, &rear))
                                set_region(board, h, w, i, j, 'X');
                }
        }
        
        for (i = 0; i < h; i++) {
                for (j = 0; j < w; j++) {
                        if (board[i][j] == 'Y')
                                board[i][j] = 'O';
                }
        }
}