bool mySolveSudoku(char** board);
int getPossibleCharArray(char** board, int pos, char *array);
int findEmptyCellPos(char** board);

void solveSudoku(char** board, int boardSize, int* boardColSize){
    mySolveSudoku(board);
    return;
}

bool mySolveSudoku(char** board)
{
    int i, pos, possibleCharArraySize;
    int row, col;
    char possibleCharArray[9];

    pos = findEmptyCellPos(board);
    if (pos == -1) {
        return true;    // solved
    }

    row = pos / 9;
    col = pos % 9;

    possibleCharArraySize = getPossibleCharArray(board, pos, possibleCharArray);
    if (possibleCharArraySize == 0) {
        return false;   // it's wrong way
    }

    for (i = 0; i < possibleCharArraySize; i++) {
        board[row][col] = possibleCharArray[i]; // try the possible char
        if (mySolveSudoku(board)) {
            return true;
        } else {
            // try next one possible char
            // no code here
        }
    }

    board[row][col] = '.';  // revert to empty cell
    return false; // it's wrong way
}

// @return <int> arraySize
int getPossibleCharArray(char** board, int pos, char *array)
{
    int map[9] = {0};   // 0 means the number not appear
    int i, j, val;
    int row, col;
    int arraySize = 0;

    row = pos / 9;
    col = pos % 9;

    for (i = 0; i < 9; i++) {
        if (board[row][i] != '.') {
            val = board[row][i] - '1';    // '1' ~ '9' => 0 ~ 8
            map[val] = 1;   // appeared
        }

        if (board[i][col] != '.') {
            val = board[i][col] - '1';    // '1' ~ '9' => 0 ~ 8
            map[val] = 1;   // appeared
        }
    }

    // sub-box
    int box_row = row / 3;  // row = 0 ~ 8 => box_row = 0 ~ 2
    int box_col = col / 3;  // col = 0 ~ 8 => box_col = 0 ~ 2
    int row_begin = box_row * 3;
    int row_end   = row_begin + 2;
    int col_begin = box_col * 3;
    int col_end   = col_begin + 2;

    for (i = row_begin; i <= row_end; i++) {
        for (j = col_begin; j <= col_end; j++) {
            if (board[i][j] != '.') {
                val = board[i][j] - '1';    // '1' ~ '9' => 0 ~ 8
                map[val] = 1;   // appeared
            }
        }
    }

    arraySize = 0;
    for (i = 0; i < 9; i++) {
        if (map[i] == 0) {
            array[arraySize++] = (char)(i + '1');
        }
    }

    return arraySize;
}

// @return <int> found: 0~80, not found: -1
int findEmptyCellPos(char** board)
{
    int row, col;

    for (row = 0; row < 9; row++) {
        for (col = 0; col < 9; col++) {
            if (board[row][col] == '.') {
                return row * 9 + col;
            }
        }
    }

    return -1;
}