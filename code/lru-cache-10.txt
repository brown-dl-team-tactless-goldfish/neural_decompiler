#define MAX_KEYS 10001

typedef struct node_t_ {
    int key;
    int value;
    struct node_t_ *prev;
    struct node_t_ *next;
} node_t;

typedef struct {
    // input
    int capacity;           // LRU capacity
    
    // DLL - LRU order
    node_t *head;           // always points to the most recently used entry (last to be evicted)
    node_t *tail;           // always points to the least recently used entry (first to be evicted)
    
    //DT - LRU presence
    int size;               // LRU usage
    node_t *node[MAX_KEYS]; // direct table is faster and cheaper than hash since MAX CAPACITY is 3000
    node_t *nodes;          // allocated LRU entries
} LRUCache;

LRUCache* lRUCacheCreate(int capacity) {
    LRUCache *obj;
    
    if ((obj = calloc(1, sizeof(LRUCache))) != NULL) {                  // successfully allocated object
        if ((obj->nodes = calloc(capacity, sizeof(node_t))) == NULL) {  // if unable to allocate entries
            free(obj);                                                  // free object
            return NULL;                                                // cache create call fails
        }
        obj->capacity = capacity;                                       // set capacity to capacity
    }
    return obj;                                                         // return allocated object
}

void list_add(LRUCache* obj, node_t *node)
{
    node->next = obj->head;                                             // node's next points to head node
    node->prev = NULL;                                                  // node's prev points to NULL
    if (obj->head == NULL) {                                            // if DLL is emtpy
        obj->tail = node;                                               // tail now points to the new node
    } else {
        obj->head->prev = node;                                         // otherwise, head node's prev points to new 
    }
    obj->head = node;                                                   // and head now points to node
}

void list_remove(LRUCache* obj, node_t *node)
{
    if (node == obj->tail) {                                            // if we are removing tail node
        obj->tail = node->prev;                                         // tail now points to node's prev
    } else {
        node->next->prev = node->prev;                                  // node's next's prev points to node's prev
    }
    if (node == obj->head) {                                            // if we are removing head node
        obj->head = node->next;                                         // head now points to node's next
    } else {
        node->prev->next = node->next;                                  // node's prev's next points to node's next
    }   
}

int lRUCacheGet(LRUCache* obj, int key) {
    node_t* node = obj->node[key];                                      // get node from direct table
    if (node == NULL) {                                                 // key is not in LRU
        return -1;                                                      // return -1
    }
    list_remove(obj, node);                                             // remove node from LRU
    list_add(obj, node);                                                // put it back at the head
    return node->value;                                                 // return value associated with key
}

void lRUCachePut(LRUCache* obj, int key, int value) {
    node_t* node = obj->node[key];                                      // get node from direct table
    if (node == NULL) {                                                 // key is not in LRU
        if (obj->size == obj->capacity) {                               // and LRU is full
            node = obj->node[obj->tail->key];                           // recycle oldest entry
            obj->node[obj->tail->key] = NULL;                           // remove key from cache
            list_remove(obj, obj->tail);                                // remove tail node
        } else {
            node = &obj->nodes[obj->size++];                            // allocate a new entry
        }
        obj->node[key] = node;                                          // add key to cache
    } else {
        list_remove(obj, node);                                     // remove node from list
    }
    node->key = key;                                                // set node key
    node->value = value;                                            // set node value
    list_add(obj, node);                                            // add node back at the head
}

void lRUCacheFree(LRUCache* obj) {
    free(obj->nodes);
    free(obj);
}

/**
 * Your LRUCache struct will be instantiated and called as such:
 * LRUCache* obj = lRUCacheCreate(capacity);
 * int param_1 = lRUCacheGet(obj, key);
 
 * lRUCachePut(obj, key, value);
 
 * lRUCacheFree(obj);
*/