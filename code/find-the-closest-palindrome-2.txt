if (strlen(n) == 1)   /* This is another special case if the input is smaller than 10.*/
{
    int res = atoi(n) - 1;
    char *p = malloc(2);
    p[0] = res + '0';
    p[1] = '\0';
    return p;
}
 
char *p = NULL;
p = Special_cases(n);                                                            
if (p != NULL) {return p;}    
if (strlen(n)%2 == 1 && isPalin(n) == true)  
{
    p =  palin_with_median(n);
    return p;
}
if (strlen(n)%2 == 0 && isPalin(n) == true) 
{
    p =  palin_without_median(n);
    return p;
}

/*
    Now if the input isn't a special case or a palindrome.
	
    I copy the left half of the input into the right half, set an offset to 1, and if the        
	result is bigger than the input I set the offset to -1, and add it to the median of           
	the input or the middle number that is closer to the beginning and copy again.
	
    So this guarantees that I get 2 strings that represent the closest palindromes               
	(could check but it is pointless), one bigger than the input the other smaller.
	
    I than check for the differences between the strings and the input and return the            
	smallest, if the diffrences are the same I return the string that represents the             
	smaller palindrome.       
*/

long l_n = atol(n);
int len = strlen(n);
int i = 0;
int j = len-1;
int median = 0;
if (len%2 == 1) {median++;}

char *temp = malloc(len+1);
temp[len] = '\0';

while (i < len/2 + median)
{
    temp[i] = n[i];
    temp[j] = n[i];
    i++;
    j--;
}

int offset = 1;
long l_temp = atol(temp);

if (l_n < l_temp)
{
    offset = -1;
}

i = 0;
j = len-1;
if (len%2 == 1) 
{
    n[len/2] += offset;
}
else {n[len/2 - 1] += offset;}

char *temp2 = malloc(len+1);
temp2[len] = '\0';

while (i < len/2 + median)
{
    temp2[i] = n[i];
    temp2[j] = n[i];
    i++;
    j--;
}
long l_temp2 = atol(temp2);

long diff = l_n - l_temp;
if (diff < 0) {diff *= -1;}
long diff2 = l_n - l_temp2;
if (diff2 < 0) {diff2 *= -1;}

if (diff < diff2)
{
    free(temp2);
    temp2 = NULL;
    return temp;
}
if (diff == diff2)
{
    if (l_temp < l_temp2)
    {
        free(temp2);
        temp2 = NULL;
        return temp;
    }
    free(temp);
    temp = NULL;
    return temp2;
}

free(temp);
temp = NULL;
return temp2;

/*
    0 ms and 6 MB
    Side notes: I use long because we can't know the size of the number the input                
	represents and I constantly transfer the results to long, using atol, and                    
	vice versa, using sprintf, for convenience. 
*/   