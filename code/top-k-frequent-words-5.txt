/* My Analysis
 *  Time Complexity: O(nlogn) + O(n) + O(nlogn) + O(n)
 *  Space Complexity: O(n)
 */

int compareString(const void* str1, const void* str2)
{
    // descending order
    return strcmp(*(char**)str2, *(char**)str1);
}

int compareInteger(const void* n1, const void* n2)
{
    // descending order
    return (*(int*)n2 - *(int*)n1);
}

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char ** topKFrequent(char ** words, int wordsSize, int k, int* returnSize){
    char** pRetVal = NULL;

    *returnSize = k;
    pRetVal = (char**)malloc((*returnSize)*sizeof(char*));
    if (pRetVal == NULL)
    {
        perror("malloc");
        *returnSize = 0;
        return pRetVal;
    }

    // descending order; Time Complexity: O(nlogn)
    qsort(words, wordsSize, sizeof(char*), compareString);

    // 1 <= words.length <= 500
#define COUNT_IDX   (1000)
    int idx = 0;
    // Space Complexity: O(n)
    int count[wordsSize];
    count[idx] = idx + COUNT_IDX;
    int i;
    // Time Complexity: O(n)
    for (i=1; i<wordsSize; ++i)
    {
        if (strcmp(words[i-1], words[i]) == 0)
        {
            count[idx] += COUNT_IDX;
            count[i] = i;
            continue;
        }
        count[i] = i + COUNT_IDX;
        idx = i;
    }

    // descending order; Time Complexity: O(nlogn)
    qsort(count, wordsSize, sizeof(int), compareInteger);

    // Time Complexity: O(n)
    for (i=0; i<(*returnSize); ++i)
    {
        pRetVal[i] = words[count[i]%1000];
    }

    return pRetVal;
}