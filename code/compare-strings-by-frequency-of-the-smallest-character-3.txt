struct node{
    int value;
    struct node* next;
};
int f(char* w);
struct node * insert_value(struct node * head, int v);

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* numSmallerByFrequency(char ** queries, int queriesSize, char ** words, int wordsSize, int* returnSize){
    int* q = malloc(queriesSize*sizeof(int));
    struct node *w = NULL;
    struct node *p;
    
    int idx_q, idx_w, count, tmp;
    int w_max = 0;
    
    *returnSize = queriesSize;
    
    for(idx_w = 0; idx_w < wordsSize; idx_w ++){
        tmp = f(words[idx_w]);
        w = insert_value(w, tmp);
    }
    
    for(idx_q = 0; idx_q < queriesSize; idx_q ++){
        count = 0;
        tmp = f(queries[idx_q]);
        p = w;
        while(p && p->value > tmp){
            count++;
            p = p->next;
        }
        q[idx_q] = count;
    }  
    
    free(w);
    
    
    return q;
}

int f(char* w){
    int count = 0;
    char c = 123;
    while(*w!='\0'){
        if(c>(*w)){
            count = 1;
            c = *w;
        } else if(c==(*w)) {
            count ++;
        }
        w++;
    }
    return count;
}

struct node * insert_value(struct node * head, int v){
    struct node * p, *prev, *curr;
    if(!head){
        p = malloc(sizeof(struct node));
        p->value = v;
        p->next = NULL;
        return p;
    }
    
    if(head->value > v){
        prev = head;
        curr = head->next;
    } else {
        p = malloc(sizeof(struct node));
        p->value = v;
        p->next = head;
        return p;
    }
        
    while(curr){
        if(curr->value > v){
            prev = curr;
            curr = curr->next;
        } else {
            p = malloc(sizeof(struct node));
            p->value = v;
            p->next = curr;
            prev->next = p;
            return head;
        }
    }
    
    p = malloc(sizeof(struct node));
    p->value = v;
    p->next = NULL;
    prev->next = p;
    
    return head;    
}
