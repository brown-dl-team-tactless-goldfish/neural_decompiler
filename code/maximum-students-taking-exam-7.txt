class Solution {
    // Given a row represented by char and a mask, check if we can select the seats indicated by the mask.
    // Return the # of seats, if not valid, return -1.
    int line(vector<char>& row, int mask) {
        int sum = 0, last = -2;
        for(int i=0; i<row.size(); i++) {
            if(mask & (1 << i)) {
                if(row[i] == '#') return -1;
                else {
                    sum += 1;
                    if(i == (last + 1)) return -1;
                    else last = i;
                }
            } 
        }
        return sum;
    }
    
    // Given two masks that contains the select seats of 2 adjacent rows, check if they are valid.
    bool twoLines(int maskC,  int maskP, int n) {
        for(int i=0; i<n; i++) {
            if(1 << i & maskP) {
                if(i - 1 >= 0 && ((1 << (i - 1)) & maskC)) return false;
                if(i + 1 < n && ((1 << (i + 1)) & maskC)) return false;
            }
        }
        return true;
    }
    
public:
    int maxStudents(vector<vector<char>>& seats) {
        int m = seats.size(), n = seats[0].size();
        int len = pow(2, n);
        
        vector<int> prev(len, -1);
        vector<int> cur(len, -1);
        for(int i=0; i<len;++i) {
            prev[i] = line(seats[m-1], i);
        }
        
        for(int l = m-2; l >=0; l--) {
            for(int c=0; c<len; c++) {
                int cntCur = line(seats[l], c);
                if(cntCur == -1) continue; // Mask of current row is not valid.
                
                for(int p=0; p<len; p++) {
                    if(prev[p] == -1) continue; // Mask of previous row is not valid.
                    if(twoLines(c, p, n)) cur[c] = max(cur[c], cntCur + prev[p]);
                }
            }
            
            prev = cur;
        }
        
        int ans = 0;
        for(auto a : cur) ans = max(ans, a);
        return ans;
    }
};