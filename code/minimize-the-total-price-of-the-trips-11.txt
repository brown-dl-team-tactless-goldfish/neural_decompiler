class Solution {
public:
    
    vector<int> graph[57];
    vector<int> G[57];
    vector<int> cont;

    void dfs(int u,int p = -1){
        if(p !=-1)
            G[p].push_back(u);
        
        for(auto v:graph[u]){
            if(v == p)continue;
            dfs(v,u);
        }
    }
    vector<int> d;
    void dfs2(int u,int t,int p = -1){
        
        if(u == t)d[u] = 1;
        
        for(auto v:graph[u]){
            if(v == p)continue;
            dfs2(v,t,u);
            d[u]+=d[v];
        }
        
        cont[u]+=d[u];
    }
    
    
    int dp[57][2];
    vector<int> P;
    
    int solve(int u,int p){
        int &x = dp[u][p];
        if(x!=-1)return x;
        
        if(p){
            int ans = cont[u]*P[u];
            for(auto v:G[u]){
                ans+=solve(v,0);
            }
            return x = ans;
                        
        }
        else{
            int ans1 = cont[u]*(P[u]/2);
            int ans2 = cont[u]*P[u];
            
            for(auto v:G[u]){
                ans1+=solve(v,1);
                ans2+=solve(v,0);
            }
            return x = min(ans1,ans2);
        }
        
        return 0;
    }    
    
    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {
        for(auto c:edges){
            int u = c[0];
            int v = c[1];
            graph[u].push_back(v);
            graph[v].push_back(u);
        }
        
        dfs(0);
        P = price;
        cont.resize(n);
        for(auto c:trips){
            int u = c[0];
            int v = c[1];
            d.assign(n,0);
            dfs2(u,v);
        }
        memset(dp,-1,sizeof dp);
        int ans1 = solve(0,0);
        int ans2 = solve(0,1);
        return min(ans1,ans2);
        
    }
};