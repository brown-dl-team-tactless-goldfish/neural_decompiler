class Solution {
    int updateMap(map<int, int>& m) {
        auto it = m.begin();
        int index = 0, last = it->first;
        m[it->first] = index;
        it++;
        for( ; it != m.end(); it++) {
            if(it->first == last+1) {
                m[it->first] = ++index;
            }
            else {
                index += 2;
                m[it->first] = index;
            }
            last = it->first;
        }
        return index+1;
    }
    
    bool isValidNeighbor(int row, int col, int **nodes, queue<vector<int>>& q, int rowMax, int colMax) {
        if(row < 0 || col < 0 || row >= rowMax || col >= colMax || nodes[row][col] > 0)
            return false;
        vector<int> t;
        t.push_back(row);
        t.push_back(col);
        nodes[row][col] = 1;  // marking it as visited
        q.push(t);
        return true;
    }
    
public:
    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {
        //Fetching all the possible values for rows and columns for blocked elements, source, target, matrix two extreme corners (0,0) and (999999,999999)
        map<int, int> rows, cols;
        for(int i =0; i < blocked.size(); i++) {
            rows.insert(pair<int, int>(blocked[i][0], -1));
            cols.insert(pair<int, int>(blocked[i][1], -1));
        }
        rows.insert(pair<int, int>(source[0], -1));
        cols.insert(pair<int, int>(source[1], -1));
        rows.insert(pair<int, int>(target[0], -1));
        cols.insert(pair<int, int>(target[1], -1));
        rows.insert(pair<int, int>(0, -1));
        cols.insert(pair<int, int>(0, -1));
        rows.insert(pair<int, int>(999999, -1));
        cols.insert(pair<int, int>(999999, -1));
        
        // Creating compressed matrix row map and column map.
        int numR = updateMap(rows);
        int numC = updateMap(cols);
        
        int **nodes = new int*[numR];
        for(int i =0; i < numR; i++) {
            nodes[i] = new int[numC]();
        }
        source[0] = rows[source[0]];
        source[1] = cols[source[1]];
        target[0] = rows[target[0]];
        target[1] = cols[target[1]];
        for(int i=0; i < blocked.size(); i++) {
            nodes[rows[blocked[i][0]]][cols[blocked[i][1]]] = 2;
        }
        queue<vector<int>> q;
        q.push(source);
        vector<int> t;
        while(!q.empty()) {
            t = q.front();
            q.pop();
            if(isValidNeighbor(t[0]-1, t[1], nodes, q, numR, numC))
                if(t[0]-1 == target[0] && t[1] == target[1])
                    return true;
            if(isValidNeighbor(t[0], t[1]-1, nodes, q, numR, numC))
                if(t[0] == target[0] && t[1]-1 == target[1])
                    return true;
            if(isValidNeighbor(t[0]+1, t[1], nodes, q, numR, numC))
                if(t[0]+1 == target[0] && t[1] == target[1])
                    return true;
            if(isValidNeighbor(t[0], t[1]+1, nodes, q, numR, numC))
                if(t[0] == target[0] && t[1]+1 == target[1])
                    return true;
        }
        return false;
    }
};