/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#define MAX(x,y) ((x) > (y) ? (x): (y))

int calcMaxPathSum(struct TreeNode* root, int* maxSum) {
    if (root == NULL) {
        return 0;
    }
    
    int leftMax = calcMaxPathSum(root->left, maxSum);
    int rightMax = calcMaxPathSum(root->right, maxSum);
    
    // assume current roots value is maximum since, its children may be negative
    // thus, for negative values, we ignore roots children and just take root value
    int max = root->val;
    
    // check if total sum of current root and its left sub-tree is greater than root itself
    if (leftMax + root->val > max) {
        max = leftMax + root->val;
    }
    
    // check if total sum of current root and its right sub-tree is greater than previous maximum between root's value and sum of root's value and its left subtree
    if (rightMax + root->val > max) {
        max = rightMax + root->val;
    }
    
    // take total sum of current sub-tree
    int sum = leftMax + rightMax + root->val;
    
    // if current sub-tree's sum is less than current roots value, 
    // let's jus take current 
    sum = MAX(max, sum);
    
    // if total sum between EITHER side of subtree+root->val and sum of ALL subtrees+root->val is greater than what we've calculated so far, lets just update the max sum so far to this new value
    *maxSum = MAX(*maxSum, sum);

    return max;
}

int maxPathSum(struct TreeNode* root){
    // cant initialize this value to 0 because
    // assume your tree has all negative values, for such tree, answer is going to be largest negative value of the tree
    // but if we initialize maxSum to 0, this negative value will be always less than 0 and we will always return 0 as max sum, unless we add special check for maxSum = 0, its just easy to instead initalize maxSum to smallest possible 32 bit int value
    int maxSum = INT32_MIN;
    
    calcMaxPathSum(root, &maxSum);
    
    return maxSum;
}