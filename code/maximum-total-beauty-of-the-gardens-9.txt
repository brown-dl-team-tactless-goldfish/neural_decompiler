long long maximumBeauty(vector<int>& F, long long newFlowers, int T, int full, int partial) {
    sort(F.begin(), F.end());
    vector<int64_t> ps(1); // prefix sum
    for (int &i : F) {
        i = min(i, T); // shave off those higher than target
        ps.push_back(ps.back() + (int64_t)i);
    }
    int64_t ans = 0;
    for (int64_t n = F.size(), pc = n, fc = 0; fc <= n; fc++) { // count up full ones
        int64_t x = newFlowers - (T * fc - (ps[n] - ps[n - fc]));
        if (x < 0) // x remaining flowers to fill partial ones
            break;
        for (pc = min(pc, n - fc); pc > 0 && F[pc - 1] * pc - ps[pc] > x; pc--); // count down partial ones
        int64_t pm = pc && F[0] < T ? min<int64_t>(T - 1, (x + ps[pc]) / pc) : 0;
        ans = max(ans, fc * full + pm * partial);
    }
    return ans;
}