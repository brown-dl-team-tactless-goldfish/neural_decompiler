struct TreeNode* helper(struct TreeNode* root, int* to_delete, int to_deleteSize, struct TreeNode** result, int* count, bool isRoot)
{
    int i;
    struct TreeNode *left, *right;
    
    if(root==NULL)
        return NULL;
    
    for(i=0;i<to_deleteSize;i++)
    {
        if(root->val == to_delete[i])
        {
            left = helper(root->left, to_delete, to_deleteSize, result, count, false);
            if(left)
            {
                result[*count] = left;
                (*count)++;
            }
            right = helper(root->right, to_delete, to_deleteSize, result, count, false);
            if(right)
            {
                result[*count] = right;
                (*count)++;
            }
            free(root);
            return NULL;
        }
    }
    
    if(isRoot)
    {
        result[*count] = root;
        (*count)++;
    }
    
    root->left = helper(root->left, to_delete, to_deleteSize, result, count, false);
    root->right = helper(root->right, to_delete, to_deleteSize, result, count, false);
    
    return root;
}

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
struct TreeNode** delNodes(struct TreeNode* root, int* to_delete, int to_deleteSize, int* returnSize){
    struct TreeNode** result = (struct TreeNode**)malloc(1024*sizeof(struct TreeNode*));
    int count=0;
    
    helper(root, to_delete, to_deleteSize, result, &count, true);
    *returnSize = count;
    
    return result;
}
