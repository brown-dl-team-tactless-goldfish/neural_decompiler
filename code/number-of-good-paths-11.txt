public class Solution {
    public int NumberOfGoodPaths(int[] vals, int[][] edges) {
        int n = vals.Length, answer = 0;
        SortedDictionary<int, List<int>> sortedValsMap = new SortedDictionary<int, List<int>>();
        for(int i = 0; i < n; i++){
            if(!sortedValsMap.ContainsKey(vals[i]))
                sortedValsMap.Add(vals[i], new List<int>());
            sortedValsMap[vals[i]].Add(i);
        }

        List<int>[] g = new List<int>[n];
        for(int i = 0; i < g.Length; i++) g[i] = new List<int>();
        foreach(int[] edge in edges){
            int a = edge[0], b = edge[1];
            if(vals[a] >= vals[b])
                g[a].Add(b);
            if(vals[b] >= vals[a])
                g[b].Add(a);
        }
        
        UnionFind uf = new UnionFind(n);        
        foreach(var kvp in sortedValsMap){
            foreach(int a in kvp.Value){
                foreach(int b in g[a]){
                    uf.Union(a,b);
                }
            }
            Dictionary<int,int> groupMap = new Dictionary<int,int>();
            foreach(int a in kvp.Value) {
                int parent = uf.Find(a);
                if(!groupMap.ContainsKey(parent))
                    groupMap.Add(parent, 0);
                groupMap[parent]++;
            }            
            foreach(int val in groupMap.Values) {
                answer += (val*(val-1)/2);
            }
            answer += kvp.Value.Count;
        }
        return answer;
    }
    
    private class UnionFind{
        int[] arr;
        public UnionFind(int size){
            this.arr = new int[size];
            for(int i = 0; i < size; i++)
                this.arr[i] = i;
        }
        public int Find(int x){
            if(arr[x] == x)
                return x;
            return arr[x] = Find(arr[x]);
        }
        public void Union(int x, int y){
            x = Find(x);
            y = Find(y);
            if(x != y){
                arr[y] = x;
            }
        }
    }
}