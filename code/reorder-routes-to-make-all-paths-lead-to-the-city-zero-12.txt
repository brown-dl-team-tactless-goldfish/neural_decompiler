class Solution {
public:
    int minReorder(int n, vector<vector<int>>& connections) {
        // BFS, start from 0 and find its 1st degree connections from both directions.
        // Then traverse the 2nd degree connections and change the routes if needed.
        // Do this until we reach all the nodes.
		// Notice we cannot revisit a node, hence we need to store them in a set.
        unordered_map<int, vector<int>> dest, home;
        unordered_set<int> visited;
        for (const auto& c : connections)
        {
            dest[c[0]].push_back(c[1]);
            home[c[1]].push_back(c[0]);
        }
        
        int count = 0;
        vector<int> curLevel{0};
        while (!curLevel.empty())
        {
            vector<int> nextLevel;
            for (int cur : curLevel)
            {
                visited.insert(cur);
                for (int next : dest[cur])
                {
                    if (visited.find(next) == visited.end())
                    {
                        ++count;
                        nextLevel.push_back(next);
                    }
                }
                
                for (int next : home[cur])
                {
                    if (visited.find(next) == visited.end())
                    {
                        nextLevel.push_back(next);
                    }
                }
            }
            
            curLevel = nextLevel;
        }
        
        return count;
    }
};