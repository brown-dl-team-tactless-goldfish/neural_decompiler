int Parent[305];
int Size[305];

// Utility Functions to implement DSU ......

int find(int x){
    
    if(Parent[x]==x){
        return x;
    }
    
    int temp=find(Parent[x]);
    
    Parent[x]=temp;
    
    return temp;
    
}


void Union(int x,int y){
    
    int lx=find(x);
    int ly=find(y);
    
    if(lx!=ly){
        
        if(Size[lx]>Size[ly]){
            Size[lx]+=Size[ly];
            Parent[ly]=lx;
        }
        
        else{
            Size[ly]+=Size[lx];
            Parent[lx]=ly;
        }
        
    }
    
}


int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    
    int n=graph.size();
    
    for(int i=0;i<n;i++){
        Parent[i]=i;
        Size[i]=1;
    }
    
    
    // First Imp. Task is to group all the nodes using DSU......
    
    for(int i=0;i<n;i++){
        
        for(int j=0;j<n;j++){
            
            if(graph[i][j]==1 && i!=j){
                
                int p1=find(i);
                int p2=find(j);
                
                Union(p1,p2);
                
            }
            
        }
        
    }
    
    
    // Create an array for considering if an parent of a particular group used more than once or not , if Yes,the removal of the initial[i] doesn't make any diff. ....

    
    vector<int>infected(n,0);
    
    for(int e:initial){
        
        int p=find(e);
        
        infected[p]++;
        
    }
    
    
    // Now Size of a group is greater than the other , then removing its parent is most optimal , as after removing these we can able to disinfect the whole group...
    
    int maxSize=-1,res=n+1;
    
    for(int e:initial){
        
        int p=find(e);
        
        if(infected[p]==1 && Size[p]>=maxSize){
            
            if(Size[p]==maxSize){
                
                res=min(res,e);
                
            }
            
            else{
                
                res=e;
                
            }
            
            maxSize=Size[p];
            
        }
        
    }
    
    
    if(res==n+1){
        
        for(int e:initial){
            res=min(res,e);
        }
        
    }
    
    return res;
    
}