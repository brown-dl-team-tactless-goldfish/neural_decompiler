    public class Solution
    {
        private class SegTree
        {
            public class Node
            {
                public readonly long Left;
                public readonly long Right;

                public Node(long left, long right)
                {
                    Left = left;
                    Right = right;
                }

                public Node LeftChild;
                public Node RightChild;
                public bool IsLeaf => LeftChild == null && RightChild == null;
                public long Max;
            }

            public readonly Node Root;

            public SegTree(long min, long max)
            {
                Root = new Node(min, max);
            }

            public long GetHeight(Node node, long from, long to)
            {
                if (from > node.Right || to < node.Left)
                {
                    return 0;
                }

                if (node.IsLeaf)
                {
                    return node.Max;
                }


                long leftCand = GetHeight(node.LeftChild, Math.Max(from, node.LeftChild.Left), Math.Min(to, node.LeftChild.Right));
                long rightCand = GetHeight(node.RightChild, Math.Max(from, node.RightChild.Left), Math.Min(to, node.RightChild.Right));

                return Math.Max(leftCand, rightCand);
            }

            public void Cover(Node node, long from, long to, long height)
            {
                if (from > node.Right || to < node.Left)
                {
                    return;
                }

                if (node.Left == from && node.Right == to)
                {
                    node.LeftChild = null;
                    node.RightChild = null;
                    node.Max = height;
                    return;
                }

                if (node.Right == node.Left)
                {
                    node.Max = height;
                    return;
                }

                if (node.IsLeaf)
                {
                    long mid = node.Left + (node.Right - node.Left) / 2;
                    node.LeftChild = new Node(node.Left, mid);
                    node.RightChild = new Node(mid + 1, node.Right);
                }

                Cover(node.LeftChild, Math.Max(from, node.LeftChild.Left), Math.Min(to, node.LeftChild.Right), height);
                Cover(node.RightChild, Math.Max(from, node.RightChild.Left), Math.Min(to, node.RightChild.Right), height);

                node.Max = Math.Max(node.LeftChild.Max, node.RightChild.Max);

                if (node.LeftChild != null && node.RightChild != null)
                {
                    if (node.LeftChild.IsLeaf && node.RightChild.IsLeaf && node.LeftChild.Max == node.RightChild.Max)
                    {
                        //remove reduntant childs when parent interval is fully covered
                        node.LeftChild = null;
                        node.RightChild = null;
                    }
                }
            }
        }


        public IList<int> FallingSquares(int[][] positions)
        {
            checked
            {
                long maxHeight = 0;
                IList<int> res = new List<int>(positions.Length);
                long min = int.MaxValue;
                long max = int.MinValue;

                foreach (var square in positions)
                {
                    min = Math.Min(min, square[0]);
                    max = Math.Max(max, (long) square[0] + square[1]);
                }

                SegTree tree = new SegTree(min, max);

                foreach (var square in positions)
                {
                    long left = square[0];
                    long size = square[1];
                    long right = left + size - 1;

                    var currentHeight = tree.GetHeight(tree.Root, left, right);
                    currentHeight += size;
                    tree.Cover(tree.Root, left, right, currentHeight);

                    maxHeight = Math.Max(maxHeight, currentHeight);
                    res.Add((int)maxHeight);
                }

                return res;
            }
        }
    }