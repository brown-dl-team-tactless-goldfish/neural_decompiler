class Solution {
public:
    int numberOfGoodSubsets(vector<int>& nums) {
        const int MOD = 1'000'000'007; 
        
        int primes[10] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29}; 
        unordered_map<int, int> mp; 
        for (int i = 0; i < 10; ++i) mp[primes[i]] = i+1; 
        
        vector<int> freq(31); 
        for (auto& x : nums) ++freq[x]; 
        
        vector<int> masks(31); 
        masks[1] = 1; 
        for (int x = 2; x < 31; ++x) {
            int bits = 0, xx = x; 
            bool dup = false; 
            for (auto& k : primes) 
                while (xx % k == 0) {
                    if ((bits >> mp[k]) & 1) {
                        dup = true; 
                        break; 
                    }
                    bits |= 1 << mp[k]; 
                    xx /= k; 
                }
            if (not dup) masks[x] = bits; 
        }
        
        auto power = [](long x, int p, int m) {
            long ans = 1; 
            while (p) {
                if (p & 1) {
                    ans = ans * x % m; 
                    --p; 
                } else {
                    x = x * x % m; 
                    p /= 2; 
                }
            }
            return ans; 
        }; 
        
        int M = 1 << 11; 
        vector<vector<long>> dp(32, vector<long>(M)); 
        for (int m = 2; m < M; ++m) dp[31][m] = 1; 
        
        for (int x = 30; x >= 1; --x) 
            for (int m = 0; m < M; ++m) {
                dp[x][m] = dp[x+1][m]; 
                if (freq[x] && masks[x]) {
                    if (x == 1) dp[x][m] = power(2, freq[1], MOD) * dp[x][m] % MOD; 
                    else if ((m & masks[x]) == 0) dp[x][m] = (dp[x][m] + freq[x] * dp[x+1][m | masks[x]]) % MOD; 
                }
            }
        return dp[1][0]; 
    }
};