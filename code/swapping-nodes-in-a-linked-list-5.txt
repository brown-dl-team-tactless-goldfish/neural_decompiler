int get_length (struct ListNode* node)
{
    if (!node)
        return 0;
    return (1 + get_length(node->next));
}
int len;

struct ListNode* case3 (struct ListNode* head, int k)
{
    /* Use a sentinel node */
    struct ListNode* sen = (struct ListNode*) malloc (sizeof(struct ListNode));
    sen->next = head;
    struct ListNode* sen2 = sen;

    // skip k - 1 nodes
    for (int i = 0; i < k-1; i++)
    {
        sen = sen->next;
    }
    struct ListNode* backup = sen->next;
    sen->next = sen->next->next;
    backup->next = sen->next->next;
    sen->next->next = backup;
    return sen2->next;
}

struct ListNode* case2 (struct ListNode* head, int k)
{
    /* Use a sentinel node */
    struct ListNode* sen = (struct ListNode*) malloc (sizeof(struct ListNode));
    struct ListNode* sen2;
    sen->next = head;
    sen2 = sen;

    // skip k - 1 nodes from sen
    for (int i = 0; i < k-1; i++)
        sen = sen->next;

    struct ListNode* ptr2 = head;

    // skip N - k - 1 nodes from head
    for (int i = 0; i < len-k-1; i++)
        ptr2 = ptr2->next;

    // Detach front node
    struct ListNode* backup = sen->next;
    sen->next = sen->next->next;

    // Attach later node
    struct ListNode* n = sen->next;
    sen->next = ptr2->next;

    backup->next = ptr2->next->next;
    sen->next->next = n;

    ptr2->next = backup;
    return sen2->next;

}
/*
Case 1
    1 -> 2 -> |3| -> 4 -> 5   k = 3

Case 2
    1 -> |2| -> 3 -> |4| -> 5   k = 2 or 4

Case 3
    1 -> |2| -> |3| -> 4   k = 2 or 3
*/
struct ListNode* swapNodes(struct ListNode* head, int k)
{
    len = get_length(head);

    // Case 1
    if (len % 2 == 1 && len / 2 + 1 == k)
        return head;

    /* Reduce k to less than len/2 */
    if (k > len/2)
        k = len-k+1;

    // Case 3
    if (len % 2 == 0 && len / 2 == k)
        return case3 (head, k);

    // Case 2
    return case2 (head, k);
}

