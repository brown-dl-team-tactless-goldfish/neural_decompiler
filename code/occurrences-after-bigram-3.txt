
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

typedef struct char_q_element
{
    char c;
    struct char_q_element *next;
} char_q_element;


typedef struct char_q
{
    char_q_element *head;
    char_q_element *tail;
    int size;
} char_q;

typedef struct string_q_element
{
    char *s;
    struct string_q_element *next;
} string_q_element;

typedef struct string_q
{
    string_q_element *head;
    string_q_element *tail;
    int size;
} string_q;

char_q_element *mk_element(char c)
{
    char_q_element *e = malloc(sizeof(char_q_element));
    assert(e != NULL);
    e->c = c;
    e->next = NULL;
    return e;
}

void char_q_element_free(char_q_element *e)
{
    assert(e != NULL);
    free(e);
}

char_q *mk_char_q()
{
    char_q *q = malloc(sizeof(char_q));
    assert(q != NULL);
    q->head = NULL;
    q->tail = NULL;
    q->size = 0;
    return q;
}

void char_q_free(char_q *q)
{
    assert(q != NULL);
    if (q->head != NULL)
    {
        char_q_element *e = q->head;
        while (e != NULL)
        {
            char_q_element *next = e->next;
            char_q_element_free(e);
            e = next;
        }
    }
    free(q);
}

void char_q_push(char_q *q, char c)
{
    assert(q != NULL);
    char_q_element *e = mk_element(c);
    if (q->head == NULL)
    {
        q->head = e;
        q->tail = e;
    }
    else
    {
        assert(q->tail != NULL);
        q->tail->next = e;
        q->tail = e;
    }
    q->size++;
}

char char_q_pop(char_q *q)
{
    assert(q != NULL);
    assert(q->size > 0);
    char_q_element *e = q->head;
    assert(e != NULL);
    char c = e->c;
    q->head = e->next;
    char_q_element_free(e);
    q->size--;
    if (q->size == 0)
    {
        q->tail = NULL;
        assert(q->tail == NULL);
        assert(q->head == NULL);
    }
    return c;
}

char *char_q_empty(char_q *q)
{
    assert(q != NULL);
    if (q->size == 0)
    {
        return "";
    }
    else
    {
        char *result = (char *)malloc(sizeof(char) * (q->size + 1));
        int total_size = q->size;
        for (int i = 0; i < total_size; i++)
        {
            char c = char_q_pop(q);
            result[i] = c;
        }
        result[total_size] = '\0';
        assert(q->size == 0);
        return result;
    }
}



void string_copy(char *dest, char *src)
{
    int i = 0;
    while (src[i] != '\0')
    {
        dest[i] = src[i];
        i++;
    }
    dest[i] = '\0';
}

string_q_element *mk_string_element(char *s)
{
    string_q_element *e = malloc(sizeof(string_q_element));
    assert(e != NULL);
    e->s = s;
    e->next = NULL;
    return e;
}

void string_q_element_free(string_q_element *e)
{
    assert(e != NULL);
    free(e);
}

string_q *mk_string_q()
{
    string_q *q = malloc(sizeof(string_q));
    assert(q != NULL);
    q->head = NULL;
    q->tail = NULL;
    q->size = 0;
    return q;
}

void string_q_free(string_q *q)
{
    assert(q != NULL);
    string_q_element *e = q->head;
    while (e != NULL)
    {
        string_q_element *next = e->next;
        string_q_element_free(e);
        e = next;
    }
    free(q);
}

void string_q_push(string_q *q, char *s)
{
    assert(q != NULL);
    string_q_element *e = mk_string_element(s);
    if (q->head == NULL)
    {
        q->head = e;
        q->tail = e;
    }
    else
    {
        assert(q->tail != NULL);
        q->tail->next = e;
        q->tail = e;
    }
    q->size++;
}

char *string_q_pop(string_q *q)
{
    assert(q != NULL);
    if (q->head == NULL)
    {
        return NULL;
    }
    else
    {
        assert(q->tail != NULL);
        string_q_element *e = q->head;
        q->head = e->next;
        q->size--;
        if (q->size == 0)
        {
            q->tail = NULL;
            assert(q->tail == NULL);
            assert(q->head == NULL);
        }
        char *s = e->s;
        string_q_element_free(e);
        return s;
    }
}

char **string_q_empty(string_q *q, int *returnSize)
{
    assert(q != NULL);
    *returnSize = q->size;
    char **result = (char **)malloc(sizeof(char *) * q->size);
    int total_size = q->size;
    for (int i = 0; i < total_size; i++)
    {
        result[i] = string_q_pop(q);
    }
    return result;
}


void string_arr_free(char **arr, int size)
{
    int i = 0;
    for (i = 0; i < size; i++)
    {
        free(arr[i]);
    }
    free(arr);
}

size_t string_length(char *s)
{
    size_t i = 0;
    while (s[i] != '\0')
    {
        i++;
    }
    return i;
}

char **get_tokens(char *s, char delim, int *returnSize)
{
    char *token;
    string_q *s_q = mk_string_q();
    char_q *c_q = mk_char_q();
    assert(s_q != NULL && c_q != NULL);
    if (s == NULL)
    {
        *returnSize = 0;
        return NULL;
    }
    else if (s[0] == '\0')
    {
        *returnSize = 0;
        return NULL;
    }
    for (int i = 0; s[i] != '\0'; i++)
    {
        if (s[i] == delim)
        {
            token = char_q_empty(c_q);
            string_q_push(s_q, token);
        }
        else
        {
            char_q_push(c_q, s[i]);
        }
    }
    token = char_q_empty(c_q);
    string_q_push(s_q, token);
    char **tokens = string_q_empty(s_q, returnSize);
    string_q_free(s_q);
    char_q_free(c_q);
    return tokens;
}

int equal_strings(char *s1, char *s2)
{
    if (s1 == NULL && s2 == NULL)
    {
        return 1;
    }
    else if (s1 == NULL || s2 == NULL)
    {
        return 0;
    }
    else
    {
        int i = 0;
        while (s1[i] != '\0' && s2[i] != '\0')
        {
            if (s1[i] != s2[i])
            {
                return 0;
            }
            i++;
        }
        if (s1[i] == '\0' && s2[i] == '\0')
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
}
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char **findOcurrences(char *text, char *first, char *second, int *returnSize)
{
    int *numTokens = malloc(sizeof(int));
    char **tokens = get_tokens(text, ' ', numTokens);
    string_q *s_q = mk_string_q();
    if (*numTokens < 3)
    {
        *returnSize = 0;
        return NULL;
    }
    for (int i = 0; i < *numTokens; i++)
    {
        if (i > 1 && equal_strings(tokens[i - 2], first) && equal_strings(tokens[i - 1], second))
        {
            char *s = malloc(sizeof(char) * (string_length(tokens[i]) + 1));
            string_copy(s, tokens[i]);
            string_q_push(s_q, s);
        }
    }
    string_arr_free(tokens, *numTokens);
    char **result = string_q_empty(s_q, returnSize);
    string_q_free(s_q);
    free(numTokens);
    return result;
}

