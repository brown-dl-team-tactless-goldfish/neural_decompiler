
    void earliestAndLatest_(int a, int b, int& first, int& second, int n, vector<vector<vector<bool>>>& m, int curr) {
        
        if (a + b == n + 1) {
            first = min(curr, first);
            second = max(curr, second);
            return;
        }
        
        if (m[a][b][curr]) return;
        
        for (int i = 0; i < (1 << ((n + 1) / 2)); ++i) {
            
            int newa = 1, newb = 2;
            
            for (int j = 0; j < ((n + 1) / 2); ++j) {
                
                int pos = j + 1;
                
                if (pos == a || pos == b || pos == n - a + 1 || pos == n - b + 1) continue;
                
                if (i & (1 << j)) pos = n - pos + 1;
                
                if (pos < a) ++newa;
                if (pos < b) ++newb;
                
            }
            
            earliestAndLatest_(newa, newb, first, second, (n + 1) / 2, m, curr + 1);
            
        }
        
        m[a][b][curr] = true;
        return;
    }
    
    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {
        int first = INT_MAX, second = INT_MIN;
        
        vector<vector<vector<bool>>> m(29, vector<vector<bool>>(29, vector<bool>(5, false)));
        
        earliestAndLatest_(firstPlayer, secondPlayer, first, second, n, m, 1);
        
        return vector<int> {first, second};
    }