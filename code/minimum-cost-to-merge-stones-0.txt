public:
    #define vi vector<int>
    #define vii vector<vector<int>>
    #define viii vector<vector<vector<int>>>
    int mergeStones(vector<int>& stones, int k) {
        if ((stones.size() - 1) % (k - 1) != 0) return -1;
        
        vector<int> presum = {0};
        for (auto& it: stones){
            presum.push_back(presum.back() + it);
        }
        viii dp(stones.size() + 1, vii(stones.size() + 1, vi(k + 1, -1)));
        
        return recur(presum, dp, 0, stones.size() - 1, 1, k);
    }
    
    int recur(vi& presum, viii& dp, int left, int right, int curr_piles, int k){
        if (left + curr_piles - 1 == right){
            return dp[left][right][curr_piles] = 0;
        }
        if (left + curr_piles - 1 > right){
            return dp[left][right][curr_piles] = INT_MAX; // we can not do that 
        }
        
        if (dp[left][right][curr_piles] == -1){
            if (curr_piles == 1){
                int temp = recur(presum, dp, left, right, k, k);
                if (temp != INT_MAX){
                    dp[left][right][1] = temp + presum[right + 1] - presum[left];
                }else{
                    dp[left][right][1] = INT_MAX;
                }
            }else{
                int new_piles = curr_piles - 1;
                int get = INT_MAX;
                for (int i = left; i < right; ++ i){
                    int a = recur(presum, dp, left, i, new_piles, k);
                    int b = recur(presum, dp, i + 1, right, 1, k);
                    if (a != INT_MAX && b != INT_MAX){
                        get = min(get, a + b);
                    }
                }
                dp[left][right][curr_piles] = get;
            }
        }
        
        return dp[left][right][curr_piles];
    }