class Solution {
public:
    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {
        vector<int> indice(queries.size(), 0);
        iota(indice.begin(), indice.end(), 0);
        sort(indice.begin(), indice.end(), [&](auto& i, auto& j) {
            return queries[i][1] < queries[j][1];
        });
        
        const int N = nums.size();
        const int M = nums[0].size();
        vector<int> ret(queries.size(), 0);
        vector<int> tmpIndice(N);
        vector<int> numsIndice(N);
        iota(numsIndice.begin(), numsIndice.end(), 0);

        int qi = 0;
        for (int i = M-1; i >= 0; --i) {
            vector<int> cnt(10, 0);
            for (int j = 0; j < N; ++j) {
                ++cnt[nums[numsIndice[j]][i] - '0'];
            }
            
            for (int j = 1; j < 10; ++j) {
                cnt[j] += cnt[j-1];
            }
            
            for (int j = N-1; j >= 0; --j) {
                tmpIndice[cnt[nums[numsIndice[j]][i] - '0'] - 1] = numsIndice[j];
                --cnt[nums[numsIndice[j]][i] - '0'];
            }
            numsIndice.swap(tmpIndice);
            
            // check queries
            auto trim = M - i;
            while (qi < indice.size() && queries[indice[qi]][1] == trim) {
                ret[indice[qi]] = numsIndice[queries[indice[qi]][0] - 1];
                ++qi;
            }
            if (qi > indice.size()) {
                break;
            }
        }
        
        return ret;
    }
};