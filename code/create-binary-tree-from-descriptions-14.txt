class Solution {
    private:
         unordered_map<int,pair<TreeNode*,bool>>mp;
public:
    TreeNode* createBinaryTree(vector<vector<int>>& nums) {
        fun(nums,0);
        for(auto p:mp)
            if(p.second.second==false)
                return p.second.first;
        return nullptr;
    }
    void fun(vector<vector<int>>& nums,int index)
    {
        if(index==nums.size())
            return;
        
        TreeNode* root;
        auto it=mp.find(nums[index][0]);
        if(it!=mp.end())
          root=mp[nums[index][0]].first;
        else 
        {   
            root=new TreeNode(nums[index][0]);
            mp[nums[index][0]].second=false;
            mp[nums[index][0]].first=root;
        }
        it=mp.find(nums[index][1]);
        TreeNode* child;
        if(it!=mp.end())
            child=mp[nums[index][1]].first;
        else
        {child=new TreeNode(nums[index][1]);
         mp[nums[index][1]].first=child;
        }
        
        mp[child->val].second=true;
        if(nums[index][2]==1)
            root->left=child;
        else
            root->right=child;
        fun(nums,index+1);
    }
};

Time Complexity: O(2*n)
Space Complexity: O(n)