

class Solution {
public:
    int minimumOperations(TreeNode* root) {
        queue<TreeNode*>q;   
        q.push(root);
        int ans = 0;
        while(!q.empty()){
            int nodeCount = q.size();
            vector<int>level;
            while (nodeCount > 0) {
                TreeNode *node = q.front();
                level.push_back(node->val);
                q.pop();
                if (node->left != NULL)
                    q.push(node->left);
                if (node->right != NULL)
                    q.push(node->right);
                nodeCount--;
            }
            ans += minSwaps(level);
        }     
        return ans;
    }
    int minSwaps(vector<int>nums)
{
    int len = nums.size();
    map<int, int> map;
    for (int i = 0; i < len; i++)
        map[nums[i]] = i;
 
    sort(nums.begin(), nums.end());
    vector<bool>visited(len,false);
    int ans = 0;
    for (int i = 0; i < len; i++) {
        if (visited[i] || map[nums[i]] == i)
            continue;
 
        int j = i, cycle_size = 0;
        while (!visited[j]) {
            visited[j] = true;
             j = map[nums[j]];
            cycle_size++;
        }
         if (cycle_size > 0) {
            ans += (cycle_size - 1);
        }
    }
    return ans;
}
};