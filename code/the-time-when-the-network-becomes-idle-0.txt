int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) 
{
	int result=0,m=edges.size(),n=patience.size();
	vector<int> total[n]; // store the graph of edges
	bool seen[n]; // check if the node has been visited
	memset(seen,false,n);
	seen[0]=true;
	for(int i=0;i<m;i++)
	{
		total[edges[i][0]].push_back(edges[i][1]);
		total[edges[i][1]].push_back(edges[i][0]);
	}
	queue<int> q; // for bfs
	q.push(0); // start from root
	int c=0;
	while(!q.empty())
	{
		int s=q.size();
		c++; // the distance between the traversed node and root
		for(int i=0;i<s;i++)
		{
			int p=q.front(),t=total[p].size();
			q.pop();
			for(int i=0;i<t;i++)
			{
				if(!seen[total[p][i]])
				{
					q.push(total[p][i]);
					result=max(result,2*c+(2*c-1)/patience[total[p][i]]*patience[total[p][i]]);
					seen[total[p][i]]=true;   
				}
			}
		}
	}
	return result+1;
}