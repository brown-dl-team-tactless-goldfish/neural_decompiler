typedef struct stackt{
    int *arr;
    int front;
    int stackSize;
}stackT;

bool isStackEmpty(stackT *stack){
    return stack->front == -1;
}

bool isStackFull(stackT *stack){
    return stack->front == stack->stackSize;
}

stackT *createStack(int stackSize){
    stackT *stack = malloc(sizeof(stackT));
    if(!stack)  return NULL;
    stack->arr = malloc(sizeof(int)*stackSize);
    if(!stack->arr) return NULL;
    stack->front = -1;
    stack->stackSize = stackSize;
    return stack;
}

int stackPush(stackT *stack, int inputIdx){
    if(isStackFull(stack))  return -1;
    stack->arr[++stack->front] = inputIdx;
    return 1;
}

int stackPop(stackT *stack){
    if(isStackEmpty(stack))  return -1;
    return stack->arr[stack->front--];
}

int stackPeek(stackT *stack){
    if(isStackEmpty(stack))  return -1;
    return stack->arr[stack->front];
}

void freeStack(stackT *stack){
    free(stack->arr);
    free(stack);
}


bool validateStackSequences(int* pushed, int pushedSize, int* popped, int poppedSize){
    
    if(pushedSize != poppedSize)    return false;
    
    stackT *stack = createStack(pushedSize);
    if(!stack)  return false;
    
    int stackPopPtr = 0;
    for(int i=0; i<pushedSize; i++){
        // push one item at a time
        stackPush(stack, pushed[i]);
        // pop as much as you can, greedily
        while((!isStackEmpty(stack)) && stackPeek(stack) == popped[stackPopPtr]){
            stackPop(stack);
            stackPopPtr++;
        }
    }
    free(stack);
    return (stackPopPtr == pushedSize);
    
}