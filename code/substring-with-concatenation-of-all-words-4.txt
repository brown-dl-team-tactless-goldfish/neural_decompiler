#define SIZE 10067

typedef struct {
    int count;
    char *str;
} Pair;

int hash(char *s, int len)
{
    const int p = 31;
    const int m = 1e9 + 9;
    long long hash_value = 0;
    long long p_pow = 1;
    
    for(int i = 0; i < len; i++)
    {
        hash_value = (hash_value + (s[i] - 'a' + 1) * p_pow) % m;
        p_pow = p_pow * p % m;
    }
    
    return (int)hash_value;
}

static int get_index(Pair* table, char* w, int len)
{
    int index = hash(w, len) % SIZE;
    
    if(table[index].count == 0 || !memcmp(table[index].str, w, len * sizeof(char)))
        return index;
    
    index = (index + 1) % SIZE;
    while(table[index].count != 0 && memcmp(table[index].str, w, len * sizeof(char)))
        index = (index + 1) % SIZE;
    
    return index;
}

Pair* ht_create()
{
    Pair* obj = (Pair*)calloc(SIZE, sizeof(Pair));
    
    return obj;
}

int ht_insert(Pair* table, char* w, int len)
{
    int index = get_index(table, w, len);
    
    if(table[index].count == 0)
        table[index].str = w;
    
    table[index].count += 1;
    
    return table[index].count;
}

void ht_delete(Pair* table, char* w, int len)
{
    int index = get_index(table, w, len);
    
    table[index].count -= 1;
}

int ht_find(Pair* table, char* w, int len)
{
    int index = get_index(table, w, len);
    
    return table[index].count;
}

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* findSubstring(char * s, char ** words, int wordsSize, int* returnSize){
    int* ans = (int*)malloc(sizeof(int) * 1000);
    *returnSize = 0;
    
    Pair* words_table = ht_create();
    
    int wdlen = strlen(words[0]), slen = strlen(s);
    for(int i = 0; i < wordsSize; i++)
    {
        ht_insert(words_table, words[i], wdlen);
    }
    
    int windownSize = wdlen * wordsSize;
    
    for(int i = 0; i < wdlen; i++)
    {
        Pair* record_table = ht_create();
        
        int start_index = i;
        for(int j = i; j + wdlen <= slen; j += wdlen)
        {
             // Insert current words s[j -> j + wdlen], and return the current word count
            int cur_count = ht_insert(record_table, &s[j], wdlen);
            int word_count = ht_find(words_table, &s[j], wdlen);
            
            // delete word in the record_table form start_index until they are equal
            while(word_count < cur_count)
            {
                ht_delete(record_table, &s[start_index], wdlen);
                start_index += wdlen;
                cur_count = ht_find(record_table, &s[j], wdlen);
            }
            
            if(j - start_index + wdlen == windownSize)
                ans[(*returnSize)++] = start_index;
        }
        
        free(record_table);
    }
    
    free(words_table);
    
    ans = (int*)realloc(ans, sizeof(int) * (*returnSize));
    
    return ans;
}