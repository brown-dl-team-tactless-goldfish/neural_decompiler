    int time;
    int rootCalls;
    
    void dfs(vector<vector<int>> &gr, int u , int par, vector<int> &disc,vector<int> &low,vector<bool> &vis, vector<bool> &AP)
    {
        disc[u] = low[u] = time++;
        
        vis[u] = true;
        
        for(int v : gr[u])
        {
            if(!vis[v])
            {
                
                if(par == -1)
                    rootCalls++;
                
                dfs(gr, v , u, disc, low, vis, AP);
                if(disc[u] <= low[v])
                {
                    AP[u] = true;
                }
                
                low[u] = min(low[u], low[v]);
                
            }
            else if(v != par)
            {
                low[u] = min(low[u], disc[v]);
            }
        }
    }
    int minDays(vector<vector<int>>& grid) {
        
        int n = grid.size(), m = grid[0].size();
        
        vector<vector<int>> gr(n * m);
        vector<vector<int>> dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        int OneCnt = 0;
        
        //Make Graph 
        //Each grid is numbered as (i * m + j)
        
        for(int i = 0; i < grid.size(); i++)
        {
            for(int j = 0; j < grid[0].size(); j++)
            {
                if(grid[i][j] == 1)
                {
                    OneCnt++;
                    int num1 = j + i * m;
                    for(int k = 0; k < 4; k++)
                    {
                        int x = i + dir[k][0], y = j + dir[k][1];
                        if(x < n && x >= 0 && y < m && y >= 0 && grid[x][y] == 1)
                        {
                            int num2 = y + x * m;
                            gr[num1].push_back(num2);
                        }
                    }
                }
            }
        }
        
        vector<int> disc(n * m), low(n * m);
        vector<bool> vis(n * m, false), AP(n * m, false);
        int x = 0;
        time = 0;

        
        
        //Run Normal Trajan's Algorithm
        for(int i = 0; i < n * m; i++)
        {
            rootCalls = 0;
            int r = i / m;
            int c = i % m;
            if(!vis[i] && grid[r][c] == 1)
            {
                dfs(gr, i , -1, disc, low, vis, AP);
                x++;
            }
            if(rootCalls == 1)
            {
                AP[i] = false;
            }
            
        }
        
        
        // if x > 1 means that components were disconnected from beginning
        if(x > 1)
        {
            return 0;
        }
        
        //check if there is one vertex(grid) such that it is critical/ Articulation point
        for(int z : AP)
        {
            if(z)return 1;
        }
        
        //Handle the corner cases
        if(OneCnt == 0)
        {
            return 0;
        }
        if(OneCnt == 1)
            return 1;

        
        return 2;
    }
