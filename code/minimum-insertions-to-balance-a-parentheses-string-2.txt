int minInsertions(char * s){
    int open = 0;
    int close = 0;
    int insertions = 0;
    // Time complexity - O(n) - only one for loop, the inner while loop increments the
    // same counter, so there are still only n iterations in total
    // Space complexity - O(1) - only three local variables are used
    int length = strlen(s);
    for (int i = 0; i < length; i++) {
        char ch = s[i];
        if (ch == '(') {
            open++;
        } else if (ch == ')') {
            // Get all the consecutive close parentheses
            close++;
            while (i + 1 < length && s[i + 1] == ')') {
                close++;
                i++;
            }

            // Number of close parentheses is not even, need to append one
            // more close parenthesis to make it balanced
            if (close % 2 == 1) {
                insertions++;
                close++;
            }
            // There are more close parentheses than the open ones, so need to add some open
            // parentheses to make it balanced, so increment the insertion count
            int openNeeded = close / 2;
            if (open < openNeeded) {
                insertions += openNeeded - open;
                open += openNeeded - open;
            }

            // Subtract the number of balanced parentheses that have been processed
            open -= openNeeded;
            close -= openNeeded * 2;
        }
    }

    // Need more close parenthesis to balance the remaining
    // open parentheses
    if (open > 0) {
        insertions += open * 2;
    }

    return insertions;
}