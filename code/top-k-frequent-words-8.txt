

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char ** grid;
int cnt;
typedef struct Trie 
{
    int endmark;
    struct Trie *next[26];

} Trie;

typedef struct Node
{
    int data;
    char* s;
    struct Node* left, *right;
} Node;

Node* nodeCreate(int data, char *s)
{
    Node* node= (Node*) malloc(sizeof(Node));
    node->data= data;
    node->s= s;
    node->left= NULL;
    node->right= NULL;
    return node;
}

void nodeInsert(Node* obj, int data, char* s)
{
    Node* cur= obj;
    while(1)
    {
        if(data>= cur->data)
        {
            if(cur->right== NULL) 
            {
                cur->right= nodeCreate(data, s);
                break;
            }
            else cur= cur->right;
        }
        else
        {
            if(cur->left== NULL)
            {
                cur->left= nodeCreate(data, s);
                break;
            }
            else cur= cur->left;
        }
    }
}
//Returns concatenated string a+b with a new reference
char* Concate(char* a, char* b)
{
    int len_a= 0, len_b= 0,i;
    for(i= 0; a[i]; i++) len_a++;
    for(i= 0; b[i]; i++) len_b++;
    char* s= (char*) malloc(sizeof(char)*(len_a+len_b+1));
    for(i= 0; i<len_a; i++) s[i]= a[i];
    for(int j= 0; j<len_b; j++, i++)
    {
        s[i]= b[j];
    }
    s[i]= '\0';
    return s;
}

//returns string of a single character char ch input
char* charToStr(char ch)
{
    char* s= (char*) malloc(sizeof(char)*2);
    s[0]= ch;
    s[1]= '\0';
    return s;
}
/** Initialize your data structure here. */

Trie *trieCreate()
{
    Trie *root= (Trie*) malloc(sizeof(Trie));
    root->endmark= 0;
    for(int i= 0; i<26; i++)
    {
        root->next[i]= NULL;
    }
    return root;
}

/** Inserts a word into the trie. */
void trieInsert(Trie* obj, char * word)
{
    Trie *cur= obj;
    for(int i= 0; word[i]; i++)
    {

        int id= word[i]-'a';
        if(cur->next[id]== NULL)
        {
            cur->next[id]= trieCreate();
        }
        cur= cur->next[id];
    }
    cur->endmark++;
}

void trieFree(Trie* obj)
{
    for(int i= 0; i<26; i++)
    {
        if(obj->next[i]!= NULL) trieFree(obj->next[i]);
    }
    free(obj);
}

//Prints all the words saved in Trie in dictionary order taking Trie *root and empty string as input
void trieToBST(Trie* obj, char* s, Node* bst)
{
    if(obj== NULL) return;
    
    for(int i= 25; i>=0; i--)
    {
        char ch= i+'a';
        trieToBST(obj->next[i], Concate(s, charToStr(ch)), bst);
    }
    if(obj->endmark)
    {
        nodeInsert(bst, obj->endmark, s);
    }
}

void getAns(Node* obj, int k)
{
    if(cnt>=k || obj== NULL) return;
    getAns(obj->right, k);
    grid[cnt++]= obj->s;
    getAns(obj->left, k);
}
char ** topKFrequent(char ** words, int wordsSize, int k, int* returnSize)
{
    grid= (char**)malloc(sizeof(char*)*10000);
    Trie* root= trieCreate();
    Node* bst= nodeCreate(0, "");
    cnt= 0;
    
    for(int i= 0; i<wordsSize; i++)
    {
        trieInsert(root,words[i]);
    }
    
    trieToBST(root, "", bst);
    getAns(bst, k);
    
    
    *returnSize= k;
    return grid;
}

