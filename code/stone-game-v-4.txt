
int n;
// prefix sum array 
vector<int> prefix;
// dp array to memoize 
vector<vector<int>> dp;

int go(vector<int> &a, int st, int en) {
      if(st >= en) {
            return 0;
      }
      
	  // memoized result 
      int &ans = dp[st][en];
      if(ans != -1) {
            return ans;
      }

      ans = 0;
	  // total sum of this segment
      int tot = prefix[en+1] - prefix[st];
      int s1 = 0, s2;

      for(int i=st; i<en; i++) {
	  // break the segment at i 
	  // and proceed with the lesser sum
            s1 += a[i];
            s2 = tot - s1;
            if(s1 < s2) {
				// i is the ending index
                  ans = max(ans, s1 + go(a, st, i));
            } else if(s1 > s2){
				// i+1 is the starting index
                  ans = max(ans, s2 + go(a, i+1, en));
            } else {
				// lest just try out both the possiblities 
                  ans = max({ans, s1 + go(a, st, i), s2 + go(a, i+1, en)});
            }
      }
	  
      return ans;
}

int stoneGameV(vector<int>& a) {
      // initialize
	  n = (int)a.size();
      prefix.assign(n+1, 0);
      dp.assign(n+1, vector<int>(n+1, -1));
      // prefix a=calculation
	  for(int i=0; i<n; i++) {
            prefix[i+1] = prefix[i] + a[i];
      }
      return go(a, 0, n-1);
}

