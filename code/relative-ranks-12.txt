// struct heap_element[i]: contain "original index" and "score value"
// char **answer
// 1. run through score array to fill original_indice array O(n)
// 2. build a heap with score/original_indice arrayb Time O(nlogn)
// 3. heap sort O((n-1) * logn) and fill the rank name into answer O(n)
// 4. return answer
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
typedef struct {
    int index;
    int score;
} heap_element_t;

void swap(heap_element_t *a, heap_element_t *b) 
{
    heap_element_t tmp = *a;
    *a = *b;
    *b = tmp;
}

// Top-down DFS recurrsion
// Purpose: check and adjust the relation of node and its children nodes
void heapify(heap_element_t *heap_array, int heapSize, int node_index) 
{
    // Base case: to check the relation, record the candidate node_index (largest value) is node or its children
    int candidate_node_index = node_index;
    int left_child_index = 2 * node_index + 1;
    int right_child_index = 2 * node_index + 2;
    if (left_child_index < heapSize && heap_array[left_child_index].score > heap_array[candidate_node_index].score)
        candidate_node_index = left_child_index;
    if (right_child_index < heapSize && heap_array[right_child_index].score > heap_array[candidate_node_index].score)
        candidate_node_index = right_child_index;
    if (candidate_node_index == node_index) // terminate condition
        return;
    // else if candidate_node_index change then do below
    // Recurrsive steps: 
    //     swap the node and child who has candidate_node_index
    //     recurrsively check and adjust the relation of new child node and its children
    swap(&heap_array[candidate_node_index], &heap_array[node_index]);
    heapify(heap_array, heapSize, candidate_node_index); // content of candidate changed back to node
}

/* Simple MaxHeap Sort
for (int i = 0, tail_index = scoreSize-1; i < scoreSize; i++, tail_index--) {
	heap_element_t TakeAway = ScoreHeap[0];
	ScoreHeap[0] = ScoreHeap[tail_index];
	heapify(ScoreHeap, tail_index, 0); // tail_index just equal (heap size -1)
}
*/

char *itos_autoNew(int num)
{
    char *rts = malloc(8 * sizeof(char)); // 8 (presented by 1000000) can switch to digits cal.
    sprintf(rts, "%d", num);
    return rts;
}

char **findRelativeRanks(int *score, int scoreSize, int *returnSize){
    char **answer = malloc(scoreSize*sizeof(char *));
    heap_element_t *ScoreHeap = malloc(scoreSize*sizeof(heap_element_t));
    // 1. run through score array to fill original_indice array O(n)
    for (int i = 0; i < scoreSize; i++) {
        ScoreHeap[i].index = i;
        ScoreHeap[i].score = score[i];
    }
    // 2. build a heap with score/original_indice array Time O(nlogn)
    // build a MaxHeap tree with array
    for (int i = scoreSize/2 - 1; i >= 0; i--)
        heapify(ScoreHeap, scoreSize, i);
    // 3. heap sort O((n-1) * logn) and fill the rank name into answer O(n)
    for (int i = 1, tail_index = scoreSize-1; i <= scoreSize; i++, tail_index--)  {
        // char * strcpy ( char * destination, const char * source );
        if (i == 1) {// Gold Medal
            answer[ScoreHeap[0].index] = malloc(sizeof(char) * (strlen("Gold Medal") + 1));
            strcpy(answer[ScoreHeap[0].index], "Gold Medal");
        }
        else if (i == 2) {// Silver Medal
            answer[ScoreHeap[0].index] = malloc(sizeof(char) * (strlen("Silver Medal") + 1));
            strcpy(answer[ScoreHeap[0].index], "Silver Medal");
        }
        else if (i == 3) {// Bronze Medal
            answer[ScoreHeap[0].index] = malloc(sizeof(char) * (strlen("Bronze Medal") + 1));
            strcpy(answer[ScoreHeap[0].index], "Bronze Medal");
        }
        else
             answer[ScoreHeap[0].index] = itos_autoNew(i);
        ScoreHeap[0] = ScoreHeap[tail_index];
        heapify(ScoreHeap, tail_index, 0);
    }
    // 4. return answer
	free(ScoreHeap);
    *returnSize = scoreSize;
    return answer;
}