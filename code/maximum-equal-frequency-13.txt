class Solution {
public:
    int maxEqualFreq(vector<int>& nums) {
         if (nums.empty()) {
             return 0;
         }
    
        // save count of each element
        unordered_map<int, int> counter;

        // save count of element with the same count
        unordered_map<int, int> bucket;

        int longest = 0;
        int maxCount = 0;
        for (int i = 0; i < nums.size(); i++) {
            // update counter of each count
            bucket[counter[nums[i]]]--;
            counter[nums[i]]++;
            bucket[counter[nums[i]]]++;
            maxCount = max(counter[nums[i]], maxCount);

            // three conditions .

            // 1. Each element appear once only
            // eg. 11111111, we can revome witchever element.
            bool equalOnce = (maxCount == 1);

            // 2. All elements until i appear equal times except one element appear once(the element is a new one).
            // eg. 1112223334445, we can remove 5
            // 3 * 4 + 1 == 13
            bool equalExceptOneSingle = (maxCount * bucket[maxCount] + 1) == (i + 1);

            // 3. All elements until i appear equal times except one element appear greater than others by 1.
            // eg. 1112223334444, we can remove 4
            // 3 * 4 + 1 == 13
            bool equalExceptOneGreater = ((maxCount - 1) * (bucket[maxCount - 1] + 1) + 1 == i + 1);

            // update longest length of array until i (length == i + 1)
            if (equalOnce || equalExceptOneSingle || equalExceptOneGreater) {
                longest = i + 1;
            }
        }

        return longest;

    }
};