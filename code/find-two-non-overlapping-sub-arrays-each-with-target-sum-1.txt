// Comment out to increase debuggability (which increases run time)
#define assert

#define INVALID 0xFFFFFFFFU
#define MIN(a,b) ((a) < (b) ? (a) : (b))

int minSumOfLengths(int* arr, int arrSize, int target){
    // Since we only do 'idx - len' below, we only need to hold the maximum
    // length number of previous bests. Since arr[i] > 0, there will be at most
	// 'target' elements used to sum to target. Add 1 to leave gap between the
	// start and end of the circular buffer.
    const uint32_t bsfSize = 1 + MIN(arrSize, target);
    uint32_t bestSoFar[bsfSize];
    uint32_t curSum = 0;
    uint32_t lastStart = 0;
    uint32_t minLen = INVALID;
    
    bestSoFar[bsfSize - 1] = INVALID;
    for (uint32_t i = 0; i < arrSize; i++) {
        const uint32_t idx = i % bsfSize;

        curSum += arr[i];
        while (curSum > target) {
            curSum -= arr[lastStart++];
        }
        if (idx == 0) {
            bestSoFar[0] = bestSoFar[bsfSize - 1];
        } else {
            bestSoFar[idx] = bestSoFar[idx - 1];
        }
        if (curSum == target) {
            const uint32_t len = i - lastStart + 1;
            const uint32_t pIdx = (len > idx) ? (bsfSize - (len - idx)) : (idx - len);
            
            assert(len < bsfSize);
            assert(0 <= pIdx && pIdx < bsfSize);
            assert (((pIdx + len) % bsfSize) == idx);
            assert(pIdx != idx);

            if (bestSoFar[idx] == INVALID || len < bestSoFar[idx]) {
                bestSoFar[idx] = len;
            }
            if (bestSoFar[pIdx] != INVALID) {
                const totalLen = len + bestSoFar[pIdx];
                if (totalLen < minLen) {
                    minLen = totalLen;
                }
            }
        }
    }

    if (minLen == INVALID) {
        return -1;
    } else {
        return minLen;
    }
}