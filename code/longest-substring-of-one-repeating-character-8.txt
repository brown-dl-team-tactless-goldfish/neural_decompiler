class Solution {
public:
    int n = 0;
    int m = 0;
    vector<int> longestRepeating(string s, string qc, vector<int>& qi) {
        n = s.size();
        m = qc.size();
        // vector<int> dp(n, -1);
        int i = 0;
        multiset<int> mp;
        map<int, int> seg;
        while ( i < n) {
            char c = s[i];
            int j = i + 1;
            while (j < n && s[j] == c) {
                j++;
            } 
            int l = j - i;
            seg[i] = j;
            i = j;
            mp.insert(l);
        }
        vector<int> ans;
        for (int i = 0; i < m; i++) {
            int j = qi[i];
            char c = qc[i];
            if (s[j] == c) {
                auto iter = mp.rbegin();
                ans.push_back(*iter);
                continue;
            }
            s[j] = c;
            //cout << i << "," << s << endl;
            
            auto sseg = seg.upper_bound(j);
            auto oseg = prev(sseg);
            int a = oseg->first;
            int b = oseg->second;
            int ol = b - a;
            seg.erase(oseg);
            auto mpiter = mp.find(ol);
            mp.erase(mpiter);
            int l = 1;
            int na = j;
            int nb = j + 1;
            
            if (j - 1 >= 0 && c == s[j - 1]) {
                auto oseg = seg.upper_bound(j);
                auto pre = prev(oseg);
                int a1 = pre->first;
                int b1 = pre->second;
                l += b1 - a1;
                seg.erase(pre);
                auto mpiter = mp.find(b1 - a1);
                mp.erase(mpiter);
                na = a1;
            }  else if (j - 1 >= 0 && c != s[j - 1]) {
                if (a < j) {
                seg[a] = j;
                mp.insert(j - a);
                }
            }
            
            if (j + 1 < n && c == s[j + 1]) {
                auto sseg = seg.lower_bound(j + 1);
                int a2 = sseg->first;
                int b2 = sseg->second;
                l += b2 - a2;
                seg.erase(sseg);
                auto mpiter = mp.find(b2 - a2);
                mp.erase(mpiter);
                nb = b2;
            } else if (j + 1 < n && c != s[j + 1]) {
                if (j + 1 < b) {
                    seg[j + 1] = b;
                    mp.insert(b - j - 1);
                }
            }
            
            seg[na] = nb;
            mp.insert(l);
            
            auto iter = mp.rbegin();
            ans.push_back(*iter);
            continue;
        }
        return ans;
        
    }
};