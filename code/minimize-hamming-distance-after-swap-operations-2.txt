int minimumHammingDistance(vector<int>& source, vector<int>& target, vector<vector<int>>& allowedSwaps) {
    int n = source.size();
    
    vector<int> group(n, -1);
    
    for(auto& c : allowedSwaps) {
        
        int x = parent(group, c[0]);
        int y = parent(group, c[1]);
        
        if (x != y) {
            if (y < x) group[x] = y;
            else group[y] = x;
        }
    }
    
    std::unordered_map<int, vector<int>> scan;
    for(int i = 0; i < n; ++i) {
        int p = parent(group, i);
        scan[p].push_back(i);
    }
    
    int res = 0;
    for(auto& it : scan) {
        int leg = it.second.size();
        
        std::unordered_map<int, int> count;
        for(auto& c : it.second) {
            ++count[source[c]];
            --count[target[c]];
        }
        
        int diff = 0;
        for(auto& it2 : count) {
            diff += std::abs(it2.second);
        }
        
        res += (diff / 2);
    }
    
    return res;
    
}

int parent(vector<int>& group, int x) {
    if (group[x] == -1) group[x] = x;
    
    if (x == group[x]) return x;
    else {
        group[x] = parent(group, group[x]);
        return group[x];
    }
}