// Intuitive: Use Dfs and for each stop, check based on the current fuel info, all the stations we can reach
// Try out each station and follow the same process
// Optimized DP:
// For each station, check out the farthest station we could reach. This could be found by iterating through all previous stations
// and getting the max distance amoung them
// Complexity: O(n2)
// Further Optimization:
// In each loop we are trying to find the max range/distance we can find using all the stations before the current index
// This looks like application of Heap where we store all the stations reachable from the current fuel status and get the max distance possible using the fuel 
// from the stations within reachable distance
public class Solution {
    public int MinRefuelStops(int target, int startFuel, int[][] stations) {
        var maxHeap = new MaxHeap(stations.Length);
        var curRange = startFuel;
        var stationIndex = 0;
        var fillUps = 0;
        while(curRange < target)
        {
            // Find all fuel stations within the range of curRange
            while(stationIndex < stations.Length && stations[stationIndex][0] <= curRange)
            {
                maxHeap.Add(stations[stationIndex][1]);
                stationIndex++;
            }
            
            // if we cant find any stations within the range and curRange < target, means the target is not reachable
            if(maxHeap.Count() == 0) return -1;
            
            // Add the max range possible
            curRange += maxHeap.GetMax();
            fillUps++;
        }
        
        return fillUps;
    }
    
    public int MinRefuelStops_On2(int target, int startFuel, int[][] stations) {
        if(stations.Length == 0 && target > startFuel)
            return -1;
        // var cache = new Dictionary<string, int>();
        // var minStationCount = Dfs_Memo(target, startFuel, stations, 0, cache);
        // return minStationCount == int.MaxValue ? -1 : minStationCount;
        
        var len = stations.Length;
        var dp = new long[len + 1]; // DP[i] is the max distance we can travel after refuelling from i number of stations
        dp[0] = startFuel;
        for(var i = 0 ; i < len; i++)
        {
            for(var j = i; j >=0 ; j--)
            {
                // if we can reach the current station
                if(dp[j] < stations[i][0])
                    continue;
                
                dp[j+1] = Math.Max(dp[j+1], dp[j] + (long)stations[i][1]);
            }
        }
        
        // At this point, we have the max distance we can travel from each fueling stations including the fuels that we can get from the previous gas stations
        // At any time, if we reach target, then we have to refuel from all those stations
        for(var i = 0 ; i < dp.Length; i++)
        {
            if(dp[i] >= target) return i;
        }
        
        return -1;
    }
    
    
    private int Dfs_Memo(int target, int currentFuel, int[][] stations, int lastStationIndex, Dictionary<string, int> cache)
    {
        if(currentFuel >= target)
            return 0;
        
        // variables during each call: currentFuel, lastStationIndex
        var key = $"{currentFuel}:{lastStationIndex}";
        if(cache.ContainsKey(key))
            return cache[key];
        
        // Find all stations within the range from current fuel
        var minStationCount = int.MaxValue;
        for(var i = lastStationIndex; i < stations.Length; i++)
        {
            var station = stations[i];
            
            // can't reach this station
            if(currentFuel < station[0])
                continue;
            
            // Take the fuel from this station and proceed
            var updatedFuel = currentFuel + station[1];
            
            // Can only try the station next to the current one
            var curStationCount = Dfs_Memo(target, updatedFuel, stations, i + 1, cache);
            
            // we cant reach the end by picking the current gas station
            if(curStationCount == int.MaxValue)
                continue;
            
            minStationCount = Math.Min(minStationCount, curStationCount + 1);
        }
        
        cache[key] = minStationCount;
        return minStationCount;
    }
    
     private class MaxHeap{
        
        List<int> heap;
        public MaxHeap(int capacity)
        {
            heap = new List<int>(capacity);
        }
         
        public int Count()
        {
            return heap.Count;
        }
        
        public int GetMax()
        {
            if(heap.Count == 0) return int.MinValue;
            
            int max = heap[0];
            heap[0] = heap[heap.Count - 1];
            heap.RemoveAt(heap.Count - 1);
            HeapifyDown(0);
            return max;
        }
        
        public void Add(int val)
        {
            heap.Add(val);
            HeapifyUp(heap.Count - 1);
        }
        
        public int Peek()
        {
            return heap[0];
        }
        
        public void Remove(int val)
        {
            int index = heap.IndexOf(val);
            if (index == -1) return;

            if(index  == heap.Count - 1)
            {
                heap.RemoveAt(heap.Count - 1);    
                return;
            }
            
            heap[index] = heap[heap.Count - 1];
            heap.RemoveAt(heap.Count - 1);
            
            if (heap.Count <= 1) return;
            
            var parent = GetParent(index);
            
            // Either the deleted index is the root or the parent is smaller
            if(index == 0 || heap[parent] > heap[index])
                HeapifyDown(index);
            else
                HeapifyUp(index);
        }
        
        private void HeapifyDown(int index)
        {
            while(index < heap.Count)
            {
                var leftChild = GetLeftChild(index);
                var rightChild = GetRightChild(index);
                
                var newIndex = rightChild < heap.Count && heap[leftChild] < heap[rightChild] ? rightChild : leftChild;
                
                if(newIndex >= heap.Count)
                    break;
                
                if(heap[newIndex] < heap[index])
                    break;
                
                Swap(index, newIndex);
                index = newIndex;                
            }
        }
        
        private void HeapifyUp(int index)
        {
            while(index > 0)
            {
                var parent = GetParent(index);
                if(heap[parent] > heap[index])
                    break;
                
                Swap(parent, index);
                index = parent;                
            }
        }
        
        private int GetParent(int i) => (i-1)/2;
        
        private int GetLeftChild(int i) => 2*i+1;
        
        private int GetRightChild(int i) => 2*i+2;
        
        private void Swap(int i, int j)
        {
            int temp = heap[i];
            heap[i] = heap[j];
            heap[j] = temp;
        }
        
    }
}