struct DSU {
	vector<int> e;
	DSU(int N) { e = vector<int>(N, -1); }
	int get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }
	bool same_set(int a, int b) { return get(a) == get(b); }
	int size(int x) { return -e[get(x)]; }
	bool unite(int x, int y) { 
		x = get(x), y = get(y);
		if (x == y) return false;
		if (e[x] > e[y]) swap(x, y);
		e[x] += e[y]; e[y] = x;
		return true;
	}
};
class Solution {
public:
    int numberOfGoodPaths(vector<int>& vals, vector<vector<int>>& edges) {
        int n = vals.size();
        int re= n;
        map<int, vector<int>> vti;
        for(int i = 0; i <n; i++){
            vti[vals[i]].push_back(i);
        }
        DSU a(n);
        priority_queue<array<int,3>, vector<array<int,3>>, greater<array<int, 3>>> pq;
        for(vector<int> i : edges){
            pq.push({max(vals[i[0]], vals[i[1]]), i[0], i[1]});
        }
        set<int> seen;
        sort(vals.begin(), vals.end());
        for(int i = 0; i < n; i++){
            if(seen.count(vals[i])) continue;
            seen.insert(vals[i]);
            while(!pq.empty() && pq.top()[0] <= vals[i]) {
                a.unite(pq.top()[1], pq.top()[2]);
                pq.pop();
            }    
            int m = vti[vals[i]].size();
            map<int, int> b;
            for(int j = 0; j<m; j++){
                b[a.get(vti[vals[i]][j])]++;
            }
            for(pair<int, int> const& g: b){
                re += g.second * (g.second-1) /2;
            }
        }
        return re;
    }   
};