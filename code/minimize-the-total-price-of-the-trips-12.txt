class Solution {
    int dp[55][2];
public:
    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {
        vector<vector<int>> graph(n);
        for (int i = 0; i < n-1; i++) {
            int u = edges[i][0];
            int v = edges[i][1];
            graph[u].push_back(v);
            graph[v].push_back(u);
        }

        vector<int> counter(n);
        vector<int> path;
        int m = trips.size();
        for (int i = 0; i < m; i++) {
            int start = trips[i][0];
            int end = trips[i][1];
            path.clear();
            path.push_back(start);
            DFS1(start, end, -1, graph, path);
            for (int node: path) counter[node]++;
        }

        vector<int> costs(n);
        for (int i = 0; i < n; i++) {
            costs[i] = counter[i] * price[i];
        }
        for (int i = 0; i < 55; i++) {
            dp[i][0] = -1;
            dp[i][1] = -1;
        }
        return min(DFS2(0, -1, 1, graph, costs), DFS2(0, -1, 0, graph, costs));
    }

    bool DFS1(int node, int end, int parent, vector<vector<int>>& graph, vector<int>& path) {
        if (node == end) return true;
        for (auto nxt: graph[node]) {
            if (nxt == parent) continue;
            path.push_back(nxt);
            if (DFS1(nxt, end, node, graph, path)) return true;
            path.pop_back();
        }
        return false;
    }

    int DFS2(int node, int parent, int half, vector<vector<int>>& graph, vector<int>& costs) {
        if (dp[node][half] != -1) return dp[node][half];
        
        int cost = costs[node];
        if (half) cost /= 2;

        int SubCost = 0;
        for (auto nxt: graph[node]) {
            if (nxt == parent) continue;
            int curr = DFS2(nxt, node, 0, graph, costs);
            if (!half) curr = min(curr, DFS2(nxt, node, 1, graph, costs));
            SubCost += curr;
        }
        
        dp[node][half] = cost + SubCost;
        return dp[node][half];

    }
};