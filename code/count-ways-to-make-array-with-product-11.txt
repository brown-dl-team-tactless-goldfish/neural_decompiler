class Solution {
public:

// since N can go upto n + k so for a safer side chosen 20005
#define N 20005

	int fact[N];
    int inv_fact[N];
    int MOD = 1e9+7;
    
	// below functions like mul, my_pow, inv, binomial are standard binomial theorm
	// read - https://www.hackerearth.com/practice/math/number-theory/basic-number-theory-1/tutorial/
    int mul(int a, int b)
    {
        return (1LL * a * b) % MOD;
    }
    
    int my_pow(int a, int b)
    {
        int ret = 1;
        while (b) {
            if (b & 1) {
                ret = mul(ret, a);
            }
            a = mul(a, a);
            b = b >> 1;
        }
        return ret;
    }
    
    int sum(int a, int b)
    {
        return (a + b)%MOD;
    }
    
    int sub(int a, int b)
    {
        return (MOD + a - b)%MOD;
    }
    
    int inv(int a)
    {
        return my_pow(a, MOD-2);
    }
    
    int binomial(int n, int r)
    {
        if (n < 0 || r < 0 || r > n) return 0;
        
        return mul(fact[n], mul(inv_fact[r], inv_fact[n-r]));
    }
    
    // get the prime factors and their powers as a tupe in vi
    void get_prime_factors(int K, vector<pair<int, int>> &vi) {
        int cnt = 0;
        int _K = K;
        for (int i = 2; i*i <= K; i++) {
            pair<int, int> pp = {-1, -1};
            if (K % i == 0) {
                pp.first = i;
                pp.second = 0;
            }
            while (K%i == 0) {
                pp.second++;
                K = K/i;
                cnt++;
            }
            if (pp.first != -1)
                vi.push_back(pp);
        }
        
        if (K >= 2 && K != _K) {
            vi.push_back({K, 1});
            cnt++;
        }
        return;
    }
    
    vector<int> waysToFillArray(vector<vector<int>>& q) {
        vector<int> ans(q.size(), 0);

		// pre-calculate factorial & inverse_factorial (under modulo N) until N. The time complexity will only be NlogN.
        fact[0] = fact[1] = 1;
        for (int i = 1; i < N; i++) {
            fact[i] = mul(fact[i-1], i);
            inv_fact[i] = inv(fact[i]);
        }

        for (int i = 0; i < q.size(); i++) {
            vector<pair<int, int>> vi;
            int n, k;
            n = q[i][0];
            k = q[i][1];
            get_prime_factors(k, vi);
            if (k == 1 || n == 1) {
                // if k = 1 then there is only 1 way
                // if n is 1 then also there is only 1 way.
                ans[i] = 1;
            } else if (vi.size() == 0) {
                // means that this is a prime number
                // so ans will be [1, 1, 1, k] => this will have total of n ways.
                ans[i] = n;
            } else {
                // look at stars and bars problem
                // x1 + x2 + x3 + x4 + x5 = 25
                // in how many different ways you can divide 25 among group of 5 ppl such that each can get 0 or more. 
                // (25 + 5 - 1)C(5-1)
				// also refer to this solution here for clear explaination of above problem. 
				// https://www.toppr.com/ask/question/the-number-of-ways-in-which-15-identical-apples-10-identical-oranges-can-be/
				// note that for [[2, 36]] = you should know how to calculate ans as 9 (mathematically)
				
                int val = 1;
                for (int j = 0; j < vi.size(); j++) {
                    int stars = vi[j].second;
					int bars = n;
                    val = mul(val, binomial(stars + bars - 1, bars - 1));
                }                
				ans[i] = val;
            }
        }
        return ans;
    }
};