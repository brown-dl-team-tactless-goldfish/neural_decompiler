    int checkRecord(int n) {
        // if we don't consider A first and if f(n) is the valid result number for n
        // then we can see that 
        // if string end with P, then there are f(n-1) strings are valid
        // if string end with PL, then there are f(n-2) strings are valid
        // if string end with PLL, then there are f(n-3) strings are valid
        // so f(n) = f(n-1) + f(n-2) + f(n-3)
        // for A, there can be at least A in the string, if there's no A, then the result equals to f(n)
        // if there's an A, A can be in every position, so there are C = f(0) * f(n-1) + f(1) * f(n-2) + ... + f(n-1) * f(0) possible string combinations
        // so the final result is f(n) + C
        // since the res would be a modulo of 1e9 + 7, and (a + b) % m = (a % m + b % m) % m
        // if C(i) = f(i) * f(n - i - 1), then C = C(0) + C(1) + ... C(n-1)
        // result = (f(n) + C) % m
        // = (f(n-1) + f(n-2) + f(n-3) + C(0) + C(1) + ... C(n-1)) % m
        // = (f(n-1) % m + f(n-2) % m + f(n-3) % m + C(0) % m + C(1) % m + ... C(n-1) % m) % m
        int m = 1e9 + 7;
        int dpLength = max(n, 2);
        vector<long> dp (dpLength + 1, 0);
        dp[0] = 1;
        dp[1] = 2;
        dp[2] = 4;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] % m + dp[i - 2] % m + dp[i - 3] % m;
        }
        long sum = dp[n];
        for (int i = 0; i <= n - 1; i++) {
            sum += (dp[i] * dp[n - (i + 1)]) % m;
        }
        return sum % m;
    }