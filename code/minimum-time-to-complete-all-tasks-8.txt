class Solution {
public:
    static bool comp(vector<int>&a, vector<int>&b){
        if(a[1]!=b[1])
        return a[1]<b[1];
        
        return a[0]>b[0];
    }
    int findMinimumTime(vector<vector<int>>& tasks) {
        int ans=0;
        int n=tasks.size();
        vector<int> req(n,0),cng(n,0);
        sort(tasks.begin(),tasks.end(),comp); // Sort the vector based upon ascending order of ending time of interval
        for(int i=0;i<n;i++){
            req[i]=tasks[i][2];
        }
        
        for(int i=0;i<n;i++){
            if(req[i]>0){  // if current task has not yet been completed then work upon it and
                ans+=req[i]; // also subtract that time from all possible work where we can work simultaneously
                for(int j=0;j<n;j++){
                    if(tasks[j][0]<=tasks[i][1] && i!=j){
                        int a=req[i];
                        int b=tasks[i][1]-tasks[j][0]+1-cng[j];
                        req[j]-=min(a,b);
                        cng[j]+=min(a,b); // It will make sure that the same interval doesn't count twice.(see explanation)
                        if(req[j]<0) req[j]=0;
                    }
                }
                req[i]=0;
            }
        }
        return ans;
    }
};