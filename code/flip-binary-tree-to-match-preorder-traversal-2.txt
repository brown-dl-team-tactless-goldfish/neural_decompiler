/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#define ARRAY_SIZE 100UL
static int flippedArray[ARRAY_SIZE] = {0};
static int fIndex = 0;

int preorderTraverse(struct TreeNode *node, int *voyage, int voyageSize, int *index) {
    int ret = 0;
    struct TreeNode *tmp = NULL;
    int index_bak = *index;
    bool flipped = false;

    if (*index >= voyageSize || NULL == node)
        return 0;

    if (node->val != voyage[*index])
        return -1;

flip:
    if (flipped) {
        tmp = node->left;
        node->left = node->right;
        node->right = tmp;
    }

    *index = index_bak + 1;
    ret = preorderTraverse(node->left, voyage, voyageSize, index);
    if (-1 == ret) {
        if (!flipped) {
            flipped = true;
            goto flip;
        }
        else {
            return -1;
        }
    }

    ret = preorderTraverse(node->right, voyage, voyageSize, index);
    if (-1 == ret) {
        if (!flipped) {
            flipped = true;
            goto flip;
        }
        else {
            return -1;
        }
    }

    if (flipped) {
        flippedArray[fIndex++] = node->val;
    }

    return 0;
}
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* flipMatchVoyage(struct TreeNode* root, int* voyage, int voyageSize, int* returnSize) {
    int index = 0;
    int ret = 0;

    fIndex = 0;
    *returnSize = 1;

    ret = preorderTraverse(root, voyage, voyageSize, &index);
    if (-1 != ret)
        *returnSize = fIndex;
    else
            flippedArray[0] = -1;

    return flippedArray;
}