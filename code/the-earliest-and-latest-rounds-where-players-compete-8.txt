public class Solution
{
    public int[] EarliestAndLatest(int n, int firstPlayer, int secondPlayer)
    {
        var res = DFS(n, firstPlayer - 1, secondPlayer - 1, new (int Min, int Max)?[n + 1, n + 1, n + 1]);
        return new int[] { res.Min, res.Max };
    }

    private (int Min, int Max) DFS(int len, int firstPlayer, int secondPlayer, (int Min, int Max)?[,,] memo)
    {
        if (firstPlayer + secondPlayer + 1 == len)
            return (1, 1);

        if (memo[len, firstPlayer, secondPlayer].HasValue)
            return memo[len, firstPlayer, secondPlayer].Value;

        int min = len;
        int max = 0;
        int nextLen = (len + 1) / 2;
        for (int mask = 0; mask < (1 << nextLen); mask++)
        {
            int nextFirstPlayer = firstPlayer;
            int nextSecondPlayer = secondPlayer;
            bool valid = true;
            for (int n = 0; n < len / 2; n++)
            {
                int m = (mask & 1 << n) == 0 ? n : len - n - 1;
                if (m == firstPlayer || m == secondPlayer)
                    valid = false;
                if (m < firstPlayer)
                    nextFirstPlayer--;
                if (m < secondPlayer)
                    nextSecondPlayer--;
            }

            if (!valid) continue;

            var next = DFS(nextLen, nextFirstPlayer, nextSecondPlayer, memo);
            min = Math.Min(min, next.Min + 1);
            max = Math.Max(max, next.Max + 1);
        }

        memo[len, firstPlayer, secondPlayer] = (min, max);
        return memo[len, firstPlayer, secondPlayer].Value;
    }
}