class Solution {
public:
    int findCrossingTime(int n, int k, vector<vector<int>>& time) {
        priority_queue<pair<int, int>> leftBank, rightBank, leftWarehouse, rightWarehouse;
        int idx = 0;
        for (auto &t: time) {
            // efficiency, index
            leftBank.push({t[0] + t[2], idx++});
        }
        
        int curtime = 0;
        while (n) {
            int newtime = 0;
            // select lowest efficiency worker from the right bank if exists
            if (!rightBank.empty()) {
                auto [ef, idx] = rightBank.top();
                rightBank.pop();
                newtime = curtime + time[idx][2];
                --n; // a box has been delivered
                leftWarehouse.push({-newtime - time[idx][3], idx}); // (time at which it will reach the bank, index)
            }
            // select lowest efficiency from left bank if exists and if requirement is still there
            else if (!leftBank.empty() && rightBank.size() + rightWarehouse.size() < n) {
                auto [ef, idx] = leftBank.top();
                leftBank.pop();
                newtime = curtime + time[idx][0];
                rightWarehouse.push({-newtime - time[idx][1], idx}); // (time at which it will reach the bank, index)
            }
            // otherwise wait for any worker to arrive at either bank
            else {
                newtime = -max(leftWarehouse.empty() ? -1e9 : leftWarehouse.top().first, rightWarehouse.empty() ? -1e9 : rightWarehouse.top().first);
            }
            
            // process events till newtime
            while (!leftWarehouse.empty() && -leftWarehouse.top().first <= newtime) {
                auto [t, idx] = leftWarehouse.top();
                leftWarehouse.pop();
                leftBank.push({time[idx][0] + time[idx][2], idx});
            }
            while (!rightWarehouse.empty() && -rightWarehouse.top().first <= newtime) {
                auto [t, idx] = rightWarehouse.top();
                rightWarehouse.pop();
                rightBank.push({time[idx][0] + time[idx][2], idx});
            }
            curtime = newtime;
        }
        return curtime;
    }
};