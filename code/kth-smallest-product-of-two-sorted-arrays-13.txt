class Solution {
public:
     int maximiseSmall(vector<int> &nums2 ,long long val ,long long midval){
        int l=0;
        int r=nums2.size()-1;
        int res= -1;
        while(l<=r){
            long long mid=(l+r)/2;
            if(val*nums2[mid]<=midval){  /* maximise the left side of nums2 as val is positive
											and hence we need to have as many negative/small
											numbers which are mostly found on left side */
                res=mid;
                l=mid+1;
            }
            else{
                r=mid-1;
            }
        }
        return res+1;
    }
    
    int maximiseLarge(vector<int> &nums2 ,long long val ,long long midval){
        int l=0;
        int r=nums2.size()-1;
        int res=nums.size()+1;
        while(l<=r){
            long long mid=(l+r)/2;
            if(val*nums2[mid]<=midval){  /* maximise the right side of nums2 as val is negative
										    and hence we need to have as many positive/large
											numbers which are mostly found on right side,
											as negative*positive=negative. So finally we subtract
											res from nums2.size() to get how many numbers were on 
											the right side */
                res=mid;
                r=mid-1;
            }
            else{
                l=mid+1;
            }
        }
        return nums2.size()-res;
    }
    
    bool isPossible(vector<int> &nums1, vector<int> nums2, long long midval, long long k){
        long long cnt=0;
        for(int i=0;i<nums1.size();i++){
            long long val=nums1[i];                        
			/* If val == 0, product of val and each element in nums2 will be 0. And if midval>=0, 
			then because all products are 0, all products will be smaller or equal to midval. 
			So we can add all products in the answer */
			if(val==0 && midval>=0){
                cnt+=nums2.size();
            }
            else if(val>0){
                cnt+=maximiseSmall(nums2,val,midval);
            }
            else if(val<0){
                cnt+=maximiseLarge(nums2,val,midval);
            }
        }
        return cnt>=k;
    }
    
    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {
        long long low=-1e10;
        long long high=1e10;
        long long res=0;
        while(low<=high){
            long long mid=(high+low)/2;
            if(isPossible(nums1,nums2,mid,k)==true){
                res=mid;
                high=mid-1;
            }
            else{
                low=mid+1;
            }
        }
        return res;
    }
};