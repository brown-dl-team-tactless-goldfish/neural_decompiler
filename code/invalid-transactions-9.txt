class Solution {
public:
    struct Action {
        Action(int i,int t,string c):index(i),time(t),city(c) {}
        int index;
        int time;
        string city;
    };
    
    const int maxAmount=1000;
    const int minPeriod=60;
    
    vector<string> invalidTransactions(const vector<string>& transactions) {
        
        unordered_map<string, vector<Action>> acts;
        unordered_set<string> invalid;
        
        for(int i=0; i<transactions.size(); ++i) {
            
            size_t pos=-1;
            string name;
            while(transactions[i][++pos]!=',') name+=transactions[i][pos];
            
            string tmp;
            while(transactions[i][++pos]!=',') tmp+=transactions[i][pos];
            int time=stoi(tmp);
            tmp.clear();
            
            while(transactions[i][++pos]!=',') tmp+=transactions[i][pos];
            int amount=stoi(tmp);
            
            string city=transactions[i].substr(++pos);
            //----------------------------------------------
            
            if(maxAmount < amount) invalid.insert(transactions[i]);
            
            bool invalid_current=false;
            for(const auto& a:acts[name]) {
                
                if(minPeriod < abs(a.time-time) or a.city==city) continue;
                invalid.insert(transactions[a.index]);
                invalid_current=true;
                
            }
            if(invalid_current) invalid.insert(transactions[i]);
            
            acts[name].emplace_back(i,time,city);
        }
        return {invalid.begin(),invalid.end()};
    }
};