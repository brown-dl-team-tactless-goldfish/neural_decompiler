//------------------------------------------------------------------------------------------------------------------------------------------
// The idea of the algorithm is to count the continues positives and negatives sequence
// When we are at positive number we will increase our positive counter and will increase the negative only if we counter a negative number
// When we are at negative number we will need to swap between the counters and increase by one
// When we are at zero number, we will reset our counters and continue the process.
// Run time O(numsSize)
//------------------------------------------------------------------------------------------------------------------------------------------
int getMaxLen(int* nums, int numsSize)
{
    int positiveCount, negativeCount, tmp, res;
    positiveCount = negativeCount = res = 0;
    
    for(int i = 0; i < numsSize ; i++)
    {
        int switchCase = nums[i] < 0 ? -1 : nums[i] == 0 ? 0 : 1;
        switch(switchCase)
        {
            case 0: // Zero
                positiveCount = negativeCount = 0;
                break;
            case -1: // Negative
                tmp = positiveCount;
                positiveCount = negativeCount > 0 ? negativeCount + 1 : 0;
                negativeCount = tmp + 1;
                break;
            case 1: // Positive
                positiveCount++;
                if(negativeCount)
                    negativeCount++;
        }
        
        res = positiveCount > res ? positiveCount : res;
    }
    
    return res;
}