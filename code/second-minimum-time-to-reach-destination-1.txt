class Solution 
{
    public:
    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) 
    {
        int m=edges.size();
        vector<int> total[n+1]; // the graph of the edges
        for(int i=0;i<m;i++)
        {
            total[edges[i][0]].push_back(edges[i][1]);
            total[edges[i][1]].push_back(edges[i][0]);
        }
        int c=0,duration=0,step=-1;
		// c is the step count
		// duration is the time required to the node
		// step is the minimum steps required to get to node n
        int counter[n+1]; // the number of steps required to get to the node
        bool check[n+1]; // to prevent revisiting a node if the step count is 2 steps greater or more
        memset(counter,-1,sizeof(counter));
        memset(check,false,sizeof(check));
        deque<int> q={1};
        while(true)
        {
            int s=q.size();
            c++;
            if((duration/change)%2) duration=duration+change-duration%change; // time required to get here
            duration+=time;
            if(step!=-1&&c==step+2) return duration;
            for(int i=0;i<s;i++)
            {
                int p=q.front();
                q.pop_front();
                for(int j=0;j<total[p].size();j++)
                {
                    if(counter[total[p][j]]==-1||(counter[total[p][j]]==c-1&&!check[total[p][j]]))
                    {
                        q.push_back(total[p][j]);
                        if(counter[total[p][j]]==c-1)
                        {
                            check[total[p][j]]=true;
                            if(total[p][j]==n&&step!=-1) return duration;
                        }
                        counter[total[p][j]]=c;
                        if(total[p][j]==n) step=c;
                    }
                }
            }
        }
        return duration;
    }
};