class Solution {
public:
    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {
        // support variables
        int len = vals.size(), n1, n2, val;
        priority_queue<int, vector<int>, greater<int>> neighbours[len];
        int res = INT_MIN;
        // populating neighbours
        for (auto &edge: edges) {
            // updating the loop variables
            n1 = edge[0], n2 = edge[1], val = vals[n2];
            // updating the neighbours of n1 if val is positive
            if (val > 0) {
                auto &currPQ = neighbours[n1];
                currPQ.push(val);
                if (currPQ.size() > k) currPQ.pop();
            }
            // updating the neighbours of n2 if val is positive
            val = vals[n1];
            if (val > 0) {
                auto &currPQ = neighbours[n2];
                currPQ.push(val);
                if (currPQ.size() > k) currPQ.pop();
            }
        }
        // checking each node as a star centre
        for (int i = 0, tmp; i < len; i++) {
            auto &currPQ = neighbours[i];
            tmp = vals[i];
            // adding all the elements in currPQ to tmp
            while (currPQ.size()) {
                tmp += currPQ.top();
                currPQ.pop();
            }
            // updating res
            res = max(res, tmp);
        }
        return res;
    }
};