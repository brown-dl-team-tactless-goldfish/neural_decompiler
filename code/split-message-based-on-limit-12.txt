

class Solution {
public:
    // Figure out number of digits required to given number
    int getTotalDigits(int n) {
        int maxDigits = (log10(n)+1);
        int result = 0;
        int power10 = 10;
        int num = n;
        for (int i = 0; i < maxDigits; i++) {
            result += num;
            // remove each digits combination number from total number of digits
            num = n - (power10-1); 
            power10 = power10*10;
        }
        return result;
    }
    
    bool possibleToFit(int len, int numPackets,int limit, bool &impossible) {
        int maxPacketDigits = (log10(numPackets)+1);
        int maxHeader = maxPacketDigits*2 + 3;  // accmodating denominator and tags </>
        // if maximumm possible header is less than limit then return not possible
        if (maxHeader >= limit) {
            impossible = true;
            return true;
        }
        // header size is total Digits + header
        int header = getTotalDigits(numPackets) + (maxPacketDigits + 3)*numPackets;
        int maxData = limit*numPackets;
        int totalData = header + len;
        // if macData with nubmer of packets is just greater or equal to total Data to be packaged
        return (maxData >= totalData);
    }
    
    vector<string> splitMessage(string message, int limit) {
        vector<string> data;
        int len = message.size();
        if (limit <= 5)
            return data;
        int packets = (len/limit) + 1;
        bool impossible = false;
        // Converge to find the optimial data to be sent
        while (!possibleToFit(len,packets,limit,impossible)) {
            packets++;
        }
        // if header is greater than the limit of the packet
        if (impossible)
            return data;
        
        int pos = 0;
        // iterate on each packets by packet to pack the data
        for (int i = 1; i <= packets; i++) {
            string header = "<"+ to_string(i) + "/" + to_string(packets) + ">";
            int rem = limit - header.size();
            string s;
            // for last packet of the daa
            rem =  min(rem,(len-pos));
            for (int i = 0; i < rem; i++) {
                s.push_back(message[pos++]);
            }
            string final = s + header;
            data.push_back(final);
        }
        return data;
    }
};