class Solution {
public:
    int maxSumMinProduct(vector<int>& nums) {
        
        int n = nums.size();
        vector<long long>prefixSum(n);
        
        // store prefix sum of the given array
        prefixSum[0] = nums[0];
        for(int i=1;i<n;i++)
            prefixSum[i]+=prefixSum[i-1]+nums[i];
        
        long long res = 0L;
        long long curr;
        long long sum;
        int index;
        stack<int>stak;    // monote stack
        
        for(int i=0;i<=n;i++)
        {
            // for each current value loop until stak is empty or previous min value is found
            // stak top values are potential max values who's previous min value is in the stak
            // so the product => potential max value * prefixSum[previous min value to current value]
            // also at last until stak is empty process all the values
            while(!stak.empty() && (i==n || nums[stak.top()]>nums[i]))
            {
                index = stak.top();
                stak.pop();
                curr = nums[index];
                
                // sum between previous min value and current value
                sum = (prefixSum[i-1] - (stak.empty() ? 0 : prefixSum[stak.top()]));
                
                // update max product
                res = max(res, curr * sum);                 
            }   

            rightStak.push(i);
        }

        return res % 1000000007;
    }
};