vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {
        unordered_map<int, int> m;
        priority_queue<int> maxHeap;
        for(auto &c:items){
            int price = c[0], wt = c[1];
            maxHeap.push(wt);
            if(m.find(wt) != m.end()) {
                if(m[wt] > price) m[wt] = price;
            }
            else m[wt] = price;
        }
       
        vector<int> copy(queries.size(), 0);
        for(int i=0; i<queries.size(); i++) copy[i] = queries[i];
        sort(queries.begin(), queries.end());
        
        unordered_map<int, int> sorted;
        
        for(int i=queries.size()-1; i>=0; i--){
            int c = queries[i];
			// We can afford this
            if(m[maxHeap.top()] <= c) sorted[c] = maxHeap.top();
            else{
			//We can't afford what is at top currently. So, pop until we reach a weight that we can afford. 
                while(maxHeap.size() && m[maxHeap.top()] > c) maxHeap.pop();
                if(maxHeap.size()) sorted[c] = maxHeap.top();
            }
        }
        vector<int> res(queries.size(), 0);
		//Insert elements at right place as per queries[]
        for(int i=0; i<copy.size(); i++) res[i] = sorted[copy[i]];
        
        return res;
    }