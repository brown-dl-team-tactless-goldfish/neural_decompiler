class Solution {
public:
    void dfs(int cur,vector<int> &visited,vector<int>& nums,map<int,vector<int>> &tree){
        if (!visited[nums[cur]]){
            visited[nums[cur]]=true;
            for (auto i:tree[cur]) dfs(i,visited,nums,tree);
        }
    }
    vector<int> smallestMissingValueSubtree(vector<int>& parents, vector<int>& nums) {
        ios_base::sync_with_stdio(false);cin.tie(NULL);
        int n=nums.size();
        vector<int> ans(n,1);
        if (count(nums.begin(),nums.end(),1)==0) return ans;
        map<int,vector<int>> tree;
        for (int i=0;i<n;i++){
            tree[parents[i]].push_back(i);
        }
        vector<int> visited(*max_element(nums.begin(),nums.end())+2,false);
        int curNode=find(nums.begin(),nums.end(),1)-nums.begin();
        int curMissNo=1;
        while (curNode!=-1){
            dfs(curNode,visited,nums,tree);
            while (visited[curMissNo]) curMissNo++;
            ans[curNode]=curMissNo;
            curNode=parents[curNode];
        }
        return ans;
    }
};