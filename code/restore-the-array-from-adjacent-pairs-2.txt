#define HASH_SIZE 200001

typedef struct map_node
{
    int node1;
    int index1;
    int node2;
    int index2;
    int freq;
}map_node_t;


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* restoreArray(int** adjacentPairs, int adjacentPairsSize, int* adjacentPairsColSize, int* returnSize){

    map_node_t table[HASH_SIZE];
    memset(table,0,sizeof(map_node_t) * HASH_SIZE);
    int current_node = 0;
    int current_index = 0;
    int current_val = 0;
    int count = 0;
    int* ret_arr = (int*)malloc(sizeof(int) * adjacentPairsSize * 2);
    
    
    // fill hash table
    for(size_t i = 0 ; i < adjacentPairsSize ; i++)
    {
        if(table[adjacentPairs[i][0] + 100000].freq == 0)
        {
            table[adjacentPairs[i][0] + 100000].node1 = i;
            table[adjacentPairs[i][0] + 100000].index1 = 0;
        }else
        {
            table[adjacentPairs[i][0] + 100000].node2 = i;
            table[adjacentPairs[i][0] + 100000].index2 = 0;
        }
        table[adjacentPairs[i][0] + 100000].freq += 1;
        
        if(table[adjacentPairs[i][1] + 100000].freq == 0)
        {
            table[adjacentPairs[i][1] + 100000].node1 = i;
            table[adjacentPairs[i][1] + 100000].index1 = 1;
        }else
        {
            table[adjacentPairs[i][1] + 100000].node2 = i;
            table[adjacentPairs[i][1] + 100000].index2 = 1;
        }
        table[adjacentPairs[i][1] + 100000].freq += 1;

    }
        
    for(size_t i = 0 ; i < HASH_SIZE ; i++)
    {
        if(table[i].freq == 1)
        {
            current_node = table[i].node1;
            current_index = table[i].index1;
            table[i].freq--;
            break;
        }
    }
    
    ret_arr[count] = adjacentPairs[current_node][current_index];
    count++;
    current_index = current_index ^ 1;
    ret_arr[count] = adjacentPairs[current_node][current_index];
    current_val = ret_arr[count];
    count++;
    
    for(size_t i = 0 ; i < adjacentPairsSize - 1; i++)
    {
          if(table[current_val + 100000].node1 == current_node)
          {
              current_node = table[current_val + 100000].node2;
              current_index = table[current_val + 100000].index2 ^ 1;
          }else
          {
              current_node = table[current_val + 100000].node1;
              current_index = table[current_val + 100000].index1 ^ 1;
          }
        
        ret_arr[count] = adjacentPairs[current_node][current_index];
        current_val = ret_arr[count];
        count++;
    }
    
    
    *returnSize = adjacentPairsSize + 1;
    return ret_arr;
}