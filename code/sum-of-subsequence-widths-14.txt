#define all(x) begin(x), end(x)
#define has(c, x) (c.find(x) != c.end())
#define vec vector
#define umap unordered_map
#define uset unordered_set
#define valid(i, j, m, n) (i >= 0 && i < m && j >= 0 && j < n)

template <typename T> T &amin(T &a, const T &b) { return a = min(a, b); }
template <typename T> T &amax(T &a, const T &b) { return a = max(a, b); }

using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using vi = vec<int>;
using vvi = vec<vec<int>>;
using vvvi = vec<vec<vec<int>>>;
using vl = vec<ll>;
using vvl = vec<vec<ll>>;
using vs = vec<string>;
using vvs = vec<vec<string>>;
using vpii = vec<pii>;
using vvpii = vec<vec<pii>>;
using tiii = tuple<int, int, int>;

constexpr int dx[] = {-1, 0, 0, 1, -1, -1, 1, 1};
constexpr int dy[] = {0, -1, 1, 0, -1, 1, -1, 1};
constexpr int MXN = (int)1e6;
constexpr int INF = (int)1e9 + 15;
constexpr ll INFL = ll(1e18) + 15;
constexpr double EPS = 1e-9;
constexpr int P = 31;
constexpr int P2 = 33;
constexpr int M = (int)1e9 + 7;
constexpr int M2 = (int)1e9 + 9;

constexpr ll binpow(ll a, ll b, ll m) {
  a %= m;
  ll res = 1;
  while (b > 0) {
    if (b & 1)
      res = res * a % m;
    a = a * a % m;
    b >>= 1;
  }
  return res;
}
constexpr int extended_gcd(int a, int b, int &x, int &y) {
  x = 1, y = 0;
  int x1 = 0, y1 = 1, a1 = a, b1 = b;
  while (b1) {
    int q = a1 / b1;
    tie(x, x1) = make_tuple(x1, x - q * x1);
    tie(y, y1) = make_tuple(y1, y - q * y1);
    tie(a1, b1) = make_tuple(b1, a1 - q * b1);
  }
  return a1;
}

class Solution {
public:
  int sumSubseqWidths(vector<int> &nums) {
    map<int, int> mp;
    for (int v : nums) {
      mp[v]++;
    }
    vpii p(all(mp));
    int n = p.size();

    ll ans = 0, res = 0, between_subsets = 1, subsets_cnt = 0;
    for (int i = 1; i < n; i++) {
      ll diff = p[i].first - p[0].first;
      ll left_subsets = binpow(2, p[0].second, M) - 1;
      ll right_subsets = binpow(2, p[i].second, M) - 1;
      ll end_subsets = (left_subsets * right_subsets) % M;

      res += (diff * (end_subsets * between_subsets) % M) % M;
      res %= M;

      subsets_cnt += (end_subsets * between_subsets) % M;
      subsets_cnt %= M;

      between_subsets *= right_subsets + 1;
      between_subsets %= M;
    }
    for (int i = 0; i < n - 1; i++) {
      ans += res;
      ans %= M;

      ll diff = p[i + 1].first - p[i].first;
      ll left_subsets = binpow(2, p[i].second, M) - 1;
      ll right_subsets = binpow(2, p[i + 1].second, M) - 1;

      res -= (diff * (left_subsets * right_subsets) % M) % M;
      res = (res % M + M) % M;
      subsets_cnt -= (left_subsets * right_subsets) % M;
      subsets_cnt = (subsets_cnt % M + M) % M;

      ll k = n - i - 2;
      ll remove = (k * (left_subsets * (right_subsets + 1) % M) % M) % M;
      int inv_remove, y;
      extended_gcd(remove, M, inv_remove, y);
      inv_remove = (inv_remove % M + M) % M;

      res *= inv_remove;
      res %= M;
      res *= (k * right_subsets) % M;
      res %= M;

      subsets_cnt *= inv_remove;
      subsets_cnt %= M;
      subsets_cnt *= (k * right_subsets) % M;
      subsets_cnt %= M;

      res -= (subsets_cnt * diff) % M;
      res = (res % M + M) % M;
    }
    return ans;
  }
};
#endif