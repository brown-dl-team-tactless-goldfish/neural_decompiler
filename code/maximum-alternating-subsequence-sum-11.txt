class Solution {
public:
    long long maxAlternatingSum(vector<int>& nums) {
        int n=nums.size(); 
        vector<vector<long long int>> dp(n+1,vector<long long int>(2)); //DP[I][J] = max alternating sum, upto nums[...I] inclusive of Ith element and if J is 0, it means than the Ith element is in odd index, and if J is 1 it means its in the even index
        
        dp[1][1]=nums[0]; //first element is increasing 
        dp[1][0]=0; //nothing is decreasing when we have only 1 element i.e no odd indice element
        long long int mx1=nums[0],mx0=0; //prefix max, mx1 = largest value of dp[x][1] till the current index, mx0 is for dp[x][0]...
        
        for(int i=2;i<=n;i++) {
            dp[i]=dp[i-1];
            dp[i][1]=max(dp[i][1],mx0+nums[i-1]); //if i want to place an element in the even index, i can take the maximum prefix such that it ends with an odd index
            dp[i][0]=max(dp[i][0],mx1-nums[i-1]); //similar to dp[i][1]
            
            mx1=max(mx1,dp[i][1]); //maximize mx1,mx0
            mx0=max(mx0,dp[i][0]);
        }
        return max(dp[n][0],dp[n][1]);
    }
};