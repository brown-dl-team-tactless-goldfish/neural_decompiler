bool cmp(pair<int,int> a,pair<int,int> b){
    return a.second>b.second;
}
class Solution {
public:
    int reachableNodes(vector<vector<int>>& edges, int M, int N) {
        unordered_map<int,vector<pair<int,int>>> next;
        unordered_map<int,bool> visited;
        map<pair<int,int>,int> avail;//number of available intemediates still available.
        for (auto i:edges){
            next[i[0]].push_back(make_pair(i[1],i[2]+1));
            next[i[1]].push_back(make_pair(i[0],i[2]+1));
            avail[make_pair(i[0],i[1])]=avail[make_pair(i[1],i[0])]=i[2];
        }
        priority_queue<pair<int,int>,vector<pair<int,int>>,decltype(&cmp)> Q(cmp);
        Q.push(make_pair(0,0));
        int ans=0;
        while (!Q.empty()){
            pair<int,int> cur=Q.top();
            Q.pop();
            if (visited[cur.first]) continue;
            //cout<<"visiting "<<cur.first<<" len: "<<cur.second<<endl;
            ++ans;
            visited[cur.first]=true;
            for (auto i:next[cur.first]){
                //cout<<"expanding: "<<cur.first<<"->"<<i.first<<endl;
                int used=min(M-cur.second,i.second-1);
                if (used>avail[make_pair(i.first,cur.first)]) used=avail[make_pair(i.first,cur.first)];
                ans+=used;
                avail[make_pair(i.first,cur.first)]-=used;
                avail[make_pair(cur.first,i.first)]-=used;
                if (!visited[i.first]&&M-cur.second>=i.second) Q.push(make_pair(i.first,cur.second+i.second));
            }
        }
        return ans;
    }
};