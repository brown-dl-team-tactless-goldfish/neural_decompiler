

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */

int** ans;
int ansTop;
int* path;
int pathTop;

int* length;

int comp(const void* a, const void* b){
    return *(int*)a-*(int*)b;
}

void backTracking(int* candidates, int candidatesSize, int targetSum, int startIndex){
    if(targetSum == 0){
        int* tmp=malloc(sizeof(int)*pathTop);
        for(int i=0; i<pathTop; i++){
            tmp[i]=path[i];
        }
        ans[ansTop]=tmp;
        length[ansTop++]=pathTop;
    }else if(targetSum < 0){
        return;
    }
    for(int i=startIndex; i<candidatesSize && targetSum-candidates[i]>=0; i++){
        if(i>startIndex && candidates[i]==candidates[i-1]){
            continue;
        }
        path[pathTop++]=candidates[i];
        backTracking(candidates, candidatesSize, targetSum-candidates[i], i+1);
        pathTop--;
    }
}

int** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){
    ans=malloc(sizeof(int*)*300);
    path=malloc(sizeof(int)*300);
    length=malloc(sizeof(int)*300);
    
    ansTop=pathTop=0;
    
    qsort(candidates, candidatesSize, sizeof(int), comp);
    
    backTracking(candidates, candidatesSize, target, 0);
    *returnSize=ansTop;
    *returnColumnSizes=malloc(sizeof(int)*ansTop);
    
    for(int i=0; i<ansTop; i++){
        (*returnColumnSizes)[i]=length[i];
    }
    
    return ans;
    
}