   
#define node TreeNode

int ExcessDeficitOf(node* root, int& total_moves){

    if(root==NULL)  return 0; // since no tree exists

    //[ðŸ”¸]1. root asks its left subtre: "How many coins do you need/How many coins do you have in excess?"
    int ExcessDeficitOfLeft = ExcessDeficitOf(root->left, total_moves);

    //[ðŸ”¸]2. root asks its right subtree: "How many coins do you need/How many coins do you have in excess?"
    int ExcessDeficitOfRight =  ExcessDeficitOf(root->right, total_moves);

    //[ðŸ”¸]3. number of moves AT & BELOW ROOT will be = |ExcessDeficitOfLeft|+|ExcessDeficitOfRight| [UPDATE GLOBAL total_moves]
    total_moves += abs(ExcessDeficitOfLeft) + abs(ExcessDeficitOfRight);

    //[ðŸ”¸]4. this is what the root will RETURN to its parent ABOVE!
    int ExcessDeficitOfRoot = root->val + (ExcessDeficitOfLeft) + (ExcessDeficitOfRight) - 1;

    return ExcessDeficitOfRoot;
}

int distributeCoins(TreeNode* root) {

    int tot_moves = 0;

    ExcessDeficitOf(root , tot_moves);

    return tot_moves;
}