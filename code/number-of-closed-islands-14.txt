class Solution {
public:
    
    int rowchild[4] = {1,-1,0,0};
    int colchild[4] = {0,0,1,-1};
    
    int row;
    int col;
    
    // recursively get the connected component and check if any element is in the grid border
    bool dfs(int x, int y, vector<vector<int>>&grid, vector<vector<bool>>&visited)
    {
        visited[x][y] = true;
        bool res = true;
        int px,py;
        
        // loop through neighbor node and check if any neighbor is outside border
        // if then we return false, otherwise call DFS for nonvisited land neighbor node 
        for(int k=0;k<4;k++)
        {
            px = x + rowchild[k];
            py = y + colchild[k];
            
            if(px>=0 && px<row && py>=0 && py<col)
            {
                // update result from result of DFS call of neighbor node
                if(grid[px][py]==0 && !visited[px][py])
                    res&=dfs(px,py,grid,visited);
            }
            else res=false; // one enighbor outside border and so component invlaid
        }
        
        return res;
    }
        
    int closedIsland(vector<vector<int>>& grid) {
        
        row = grid.size();
        col = grid[0].size();
        
        // track visited node
        vector<vector<bool>>visited(row,vector<bool>(col,false));
        
        // closed island count
        int c = 0;
        
        // call DFS for nonvisited land node and check if it is a valid conencted component
        // if then we count it as closed island
        for(int i=0;i<row;i++)
        {
            for(int j=0;j<col;j++)
            {
                if(grid[i][j]==0 && !visited[i][j])
                {
                    // closed island only if component has no neighbor outside border
                    if(dfs(i,j,grid,visited))c++;
                }
            }
        }
        
        return c;
    }
};