class Solution {
public:
    bool solve(vector<int> &stones,unordered_map<int,int> &mp,int i,int k,unordered_map<string,int> &dp)
    {
        if(i==stones.size()-1)
            return true;
        if(i>=stones.size())
            return false;
        // check k-1 !=0 
        string key = to_string(i)+"_"+to_string(k);
        if(dp.find(key)!=dp.end())
            return dp[key];
        bool a = false,b = false,c = false;
        if(k-1 !=0 and mp.find(stones[i]+k-1)!=mp.end())
            a =  solve(stones,mp,mp[stones[i]+k-1],k-1,dp);
        if(k!=0 and mp.find(stones[i]+k)!=mp.end())
            b =  solve(stones,mp,mp[stones[i]+k],k,dp);
        if(mp.find(stones[i]+k+1)!=mp.end())
            c =  solve(stones,mp,mp[stones[i]+k+1],k+1,dp);
        if(a or b or c)
            return dp[key]=true;
        return dp[key] = false;
    }
    bool canCross(vector<int>& stones) {
        unordered_map<int,int> mp;
        unordered_map<string,int> dp;
        for(int i =0;i<stones.size();i++)
            mp[stones[i]] = i;
        return solve(stones,mp,0,0,dp);
    }
};