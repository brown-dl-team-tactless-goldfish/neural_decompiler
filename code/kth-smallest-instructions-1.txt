char* kthSmallestPath(int* destination, int destinationSize, int k) {
  const int m = destination[0];
  const int n = destination[1];

  // First compute the total number of paths to all destinations.
  int total[m + 1][n + 1];
  for (int i = 0; i < m + 1; ++i) {
    for (int j = 0; j < n + 1; ++j) {
      if (i == 0 || j == 0) {
        // Only one way to reach a destination in the 0th row or col.
        total[i][j] = 1;
      } else {
        // Number of paths to this destination is the sum of the number of paths
        // to one above and one left.
        total[i][j] = total[i - 1][j] + total[i][j - 1];
      }
    }
  }

  // We will always take exactly m+n steps. The +1 is for the null terminator.
  char* result = malloc(m + n + 1);
  int i = 0, j = 0;
  for (int index = 0; index < m + n; ++index) {
    if (i == m) {
      // Must move right.
      result[index] = 'H';
      continue;
    }

    if (j == n) {
      // Must move down.
      result[index] = 'V';
      continue;
    }

    // Number of ways to get to destination if we move right.
    const int n_right = total[m - i][n - j - 1];

    // All right movements sort before all down movements. If we can move right
    // and still have k way to get to the destination, then that is what we
    // should do.
    //
    // Otherwise, we will move down, thus skipping n_right number of paths (and
    // subtracting that from k).
    if (n_right >= k) {
      ++j;
      result[index] = 'H';
    } else {
      ++i;
      result[index] = 'V';
      k -= n_right;
    }
  }

  result[m + n] = '\0';
  return result;
}