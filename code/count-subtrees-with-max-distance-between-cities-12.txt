class Solution {
public:
	int mx, mxp, cnt; // diameter, farthest point, graph node count
	vector<int> g[17];
	void dfs(int u, int d, int p){ // current node, depth, parent node
		cnt++;
		if(d > mx){
			mx = d;
			mxp = u;
		}
		for(int v: g[u]){
			if(v != p){
				dfs(v, d+1, u);
			}
		}
	}
	vector<int> countSubgraphsForEachDiameter(int n, vector<vector<int>>& edges) {
		vector<int> res(n-1);
		for(int i = 1; i < (1<<n); ++i){ // enum all subset
			if(__builtin_popcount(i) == 1) continue;
			for(int j = 0; j <= n; ++j) g[j].clear();

			int pt = -1; // random pick a point in graph as a start point
			for(auto &e: edges){
				int u = e[0]-1, v = e[1]-1;
				if( ((1<<u)&i) && ((1<<v)&i) ){ // make sure the edge point must be in the mask
					g[u].emplace_back(v);
					g[v].emplace_back(u);
					if(pt == -1) pt = u;
				}
			}
			if(pt == -1) continue;
			
			/**
				Two dfs, one is from a start point find the farthest point.
				Second, from that farthest point. Again find the other farthest point.
				Finally, distance is diameter.
			**/
			
			mx = 0, mxp = -1, cnt = 0;
			dfs(pt, 0, -1);
			mx = 0, cnt = 0;
			dfs(mxp, 0, -1);
			if(cnt == __builtin_popcount(i) && mx > 0){
				res[mx-1]++;
			}
		}

		return res;
	}
};