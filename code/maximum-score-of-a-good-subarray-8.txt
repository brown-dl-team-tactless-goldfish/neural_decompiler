// OJ: https://leetcode.com/contest/weekly-contest-232/problems/maximum-score-of-a-good-subarray/
// Author: github.com/lzl124631x
// Time: O(N)
// Space: O(1)
class Solution {
public:
    int maximumScore(vector<int>& A, int k) {
        int i = k - 1, j = k + 1, N = A.size(), ans = A[k], mn = A[k];  // `i` and `j` point to the next left and right element to extend, respectively. `mn` is the min value within window `[i + 1, j - 1]`.
        for (int len = 2; len <= N; ++len) {
            int lmin = min(mn, i >= 0 ? A[i] : 0); // if extending leftwards, the new min value is lmin
            int rmin = min(mn, j < N ? A[j] : 0); // if extending rightwards, the new min value is rmin
            if (lmin >= rmin) --i; // extending leftwards is as good as or better than extending rightwards.
            else ++j;
            mn = max(lmin, rmin);
            ans = max(ans, mn * len);
        }
        return ans;
    }
};