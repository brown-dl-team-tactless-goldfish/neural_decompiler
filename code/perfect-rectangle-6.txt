public class Solution {
    public bool IsRectangleCover(int[][] rectangles) {
        // Line sweep, similar to skyline problem
        // Event= [x,y1,y2,openClose] (openClose = 1 (Open) or -1 (Close))
        var events = rectangles.Select(x=> new List<int[]>{
            new int[]{x[0],x[1],x[3],1},
            new int[]{x[2],x[1],x[3],-1}
        }).SelectMany(y=>y)
          .GroupBy(z=>z[0])
          .OrderBy(w=>w.Key)
          .Select(v=>v.ToList())
          .ToList();
        
        // Make sure the first and last event create exact same height after merge
        var first = Height(events[0]);
        var last = Height(events.Last());
        if(!SameHeight(first, last) || first.Count!=2){
            return false;
        }
        
        for(var i=1; i<events.Count-1; i++){
            var positiveHeight = Height(events[i].Where(x=>x[3]>0).ToList());
            var negativeHeight = Height(events[i].Where(x=>x[3]<0).ToList());
            if(!SameHeight(positiveHeight, negativeHeight)){
                return false;
            }
        }
        return true;
    }
    
    bool SameHeight(List<int> x, List<int> y){
        return x.Any() && y.Any() && Enumerable.SequenceEqual(x,y);
    }
    
    // Return a list of merged y intervals
    // For instance, [1,3], [3,4] , [5,7],[7,10], [12,13] ==> [1,4], [5,10], [12,13]
    List<int> Height(List<int[]> points){
        var ret = new List<int>();
        if(!points.Any()) return ret;
        points = points.OrderBy(x=>x[1]).ToList();
        Console.WriteLine(string.Join(",", points.Select(x=>$"[{x[0]},{x[1]},{x[2]}]")));
        for(var i=0; i<points.Count; ){
            var j = i+1;
            while(j<points.Count){
                if(points[j][1]==points[j-1][2]){
                    j++;
                }
                else if(points[j][1]<points[j-1][2]){
                    // Overlapped happen, return empty result
                    return new List<int>();
                }
                else{
                    break;
                }
            }
            ret.Add(points[i][1]);
            ret.Add(points[j-1][2]);
            i = j;
        }
        return ret;
    }
}