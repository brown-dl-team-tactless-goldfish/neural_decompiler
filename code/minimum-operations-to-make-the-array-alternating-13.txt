class Solution {
public:
    auto find_max(unordered_map<int, int>& hmap) {
        vector<int> res = {0, 0};
        for (auto& [num, freq] : hmap)  {
            if (freq > res[0]) res[1] = res[0], res[0] = freq;
            else if (freq > res[1]) res[1] = freq;
        }
        return res;
    }
    int minimumOperations(vector<int>& nums) {
        unordered_map<int, int> even = {{0,0}};
        for (int i = 0; i < nums.size(); i += 2) 
            even[nums[i]]++;
        unordered_map<int, int> odd = {{0,0}};
        for (int i = 1; i < nums.size(); i += 2) 
            odd[nums[i]]++;
        auto max1 = find_max(even);
        auto max2 = find_max(odd);
        auto maxel1 = std::max_element(even.begin(), even.end(), 
                                       [](const auto& lhs, const auto&rhs) {
            return lhs.second < rhs.second;
        });
        auto maxel2 = std::max_element(odd.begin(), odd.end(), 
                                       [](const auto& lhs, const auto&rhs) {
            return lhs.second < rhs.second;
        });
        if (maxel1->first != maxel2->first) 
            return nums.size() - max1[0] - max2[0];
        int res1 = nums.size() - max1[0] - max2[1];
        int res2 = nums.size() - max2[0] - max1[1];
        return min(res1, res2);
    }
};