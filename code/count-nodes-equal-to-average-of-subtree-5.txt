/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
int calnode(struct TreeNode* root);
int calsum(struct TreeNode* root);
void process(struct TreeNode* root,int *count);
////////////////////////////////////////
int calnode(struct TreeNode* root)
{
    int leftnodecount=0,rightnodecount=0;
    if(!root)
        return 0;
    else
    {
        leftnodecount=calnode(root->left);
        rightnodecount=calnode(root->right);
        return leftnodecount+rightnodecount+1;
    }
}
int calsum(struct TreeNode* root)
{
    int leftsum=0,rightsum=0;
    if(!root)
        return 0;
    else
    {
        leftsum=calsum(root->left);
        rightsum=calsum(root->right);
        return leftsum+rightsum+root->val;
    }
}
///////////////////////////////////////////
void process(struct TreeNode* root,int *count)
{
    if(root->left)
        process(root->left,count);
    if(root->right)
        process(root->right,count);
    int leftsum=0,rightsum=0;
    int leftnodecount=0,rightnodecount=0;
    leftsum=calsum(root->left);
    rightsum=calsum(root->right);
    leftnodecount=calnode(root->left);
    rightnodecount=calnode(root->right);
    int totalnode=leftnodecount+rightnodecount+1;
    int totalsum=leftsum+rightsum+root->val;
    if(totalsum/totalnode==root->val)
        (*count)++;
}
int averageOfSubtree(struct TreeNode* root)
{
    int count=0;
    if(!root)
        return 0;
    else
    {
        //for the root
        ////////////////////////////////////
        int leftsum=0,rightsum=0;
        int leftnodecount=0,rightnodecount=0;
        leftsum=calsum(root->left);
        rightsum=calsum(root->right);
        leftnodecount=calnode(root->left);
        rightnodecount=calnode(root->right);
        int totalnode=leftnodecount+rightnodecount+1;
        int totalsum=leftsum+rightsum+root->val;
        if(totalsum/totalnode==root->val)
            count++;
        ////////////////////////////////////////////
        if(root->left)
            process(root->left,&count);
        if(root->right)
            process(root->right,&count);
        return count;
    }
}