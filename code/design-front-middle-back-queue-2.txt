struct Node 
{
    int data;
    struct Node * prev;
    struct Node * next;
};

typedef struct 
{
    struct Node * front;
    struct Node * middle;
    struct Node * rear;
    int num_of_nodes;
} FrontMiddleBackQueue;


FrontMiddleBackQueue* frontMiddleBackQueueCreate() 
{
    FrontMiddleBackQueue * obj = (FrontMiddleBackQueue *)malloc(sizeof(FrontMiddleBackQueue));
    obj->front = NULL;
    obj->middle = NULL;
    obj->rear = NULL;
    obj->num_of_nodes = 0;
    return obj;
}

void frontMiddleBackQueuePushFront(FrontMiddleBackQueue* obj, int val) 
{
    struct Node * new_node = (struct Node *)malloc(sizeof(struct Node));
    new_node->data = val;
    new_node->prev = NULL;
    obj->num_of_nodes += 1;
        
    if(obj->front == NULL)  //Queue is Empty
    {        
        new_node->next = NULL;
        obj->front = new_node;
        obj->middle = new_node;
        obj->rear = new_node;
    }
    else
    {
        new_node->next = obj->front;
        obj->front->prev = new_node;
        obj->front = new_node;
        
        //Move the middle
        if(obj->num_of_nodes % 2 == 1) //If odd, move middle to previous node
            obj->middle = obj->middle->prev;
    }

    return;
}

void frontMiddleBackQueuePushMiddle(FrontMiddleBackQueue* obj, int val) 
{
    if(obj->num_of_nodes == 0)
        return frontMiddleBackQueuePushFront(obj, val);
    
    struct Node * new_node = (struct Node *)malloc(sizeof(struct Node));
    new_node->data = val;
      
    if(obj->num_of_nodes == 1)   
    {
        new_node->prev = NULL;
        new_node->next = obj->middle;
        obj->front = new_node;
        obj->middle->prev = new_node;
        
        obj->num_of_nodes += 1;
    }
    else if(obj->num_of_nodes == 2)
    {
        new_node->prev = obj->middle->prev;
        obj->middle->prev->next = new_node;
        new_node->next = obj->middle;
        obj->middle->prev = new_node;
        obj->middle = obj->middle->prev;
        obj->num_of_nodes += 1;
    }
    else
    {
        new_node->prev = obj->middle->prev;
        obj->middle->prev->next = new_node;
        new_node->next = obj->middle;
        obj->middle->prev = new_node;
        obj->num_of_nodes += 1;
        
        if(obj->num_of_nodes % 2 == 1)  //If odd, move middle to prev node
            obj->middle = obj->middle->prev;
    }

    return;
}

void frontMiddleBackQueuePushBack(FrontMiddleBackQueue* obj, int val) 
{
    if(obj->num_of_nodes == 0)  
        return frontMiddleBackQueuePushFront(obj, val);
    
    struct Node * new_node = (struct Node *)malloc(sizeof(struct Node));
    new_node->data = val;
    
    new_node->next = NULL;
    new_node->prev = obj->rear;
    obj->rear->next = new_node;
    obj->rear = new_node;
    obj->num_of_nodes += 1;
    
    if(obj->num_of_nodes % 2 == 0)  //If even, move the middle to next node
        obj->middle = obj->middle->next;

    return;
}

int frontMiddleBackQueuePopFront(FrontMiddleBackQueue* obj) 
{
    int ret_val = -1;
    if(obj->front == NULL)
        return ret_val;

    if(obj->num_of_nodes == 1)
    {
        struct Node * del_node = obj->front;
        obj->front = NULL;
        obj->rear = NULL;
        obj->middle = NULL;
        obj->num_of_nodes -= 1;
        ret_val = del_node->data;

        free(del_node);
    }
    else
    {
        struct Node * del_node = obj->front;
        obj->front = obj->front->next;
        obj->front->prev = NULL;
        obj->num_of_nodes -= 1;
        
        if(obj->num_of_nodes % 2 == 0)  //If even, mode middle forward
            obj->middle = obj->middle->next;
        
        ret_val = del_node->data;
        free(del_node);
        
    }

    return ret_val;
}

int frontMiddleBackQueuePopMiddle(FrontMiddleBackQueue* obj) 
{
    int ret_val = -1;
    if(obj->front == NULL)
        return ret_val;
    
    if(obj->num_of_nodes == 1)
    {
        struct Node * del_node = obj->middle;
        obj->front = NULL;
        obj->middle = NULL;
        obj->rear = NULL;
        obj->num_of_nodes -= 1;
        ret_val = del_node->data;
        free(del_node);
    }
    else
    {
        if(obj->num_of_nodes == 2)
        {
            struct Node * del_node = obj->middle->prev;
            obj->middle = obj->middle;
            obj->front = obj->middle;
            obj->middle->prev = NULL;
            obj->middle->next = NULL;
            obj->num_of_nodes -= 1;
            ret_val = del_node->data;
            free(del_node);
        }
        else
        {
            if(obj->num_of_nodes % 2 == 0)
                obj->middle = obj->middle->prev;
            struct Node * prev_node = obj->middle->prev;
            struct Node * next_node = obj->middle->next;
            struct Node * del_node = obj->middle;
            
            obj->middle->prev->next = obj->middle->next;
            obj->middle->next->prev = obj->middle->prev;
            
            if(obj->num_of_nodes % 2 == 1)  //Odd Nodes, move middle to prev
                obj->middle = next_node;
            else
                obj->middle = next_node;
            obj->num_of_nodes -= 1;
            ret_val = del_node->data;
            free(del_node);
        }
    }
    return ret_val;
}

int frontMiddleBackQueuePopBack(FrontMiddleBackQueue* obj) 
{
    int ret_val = -1;
    if(obj->front == NULL)
        return ret_val;

    if(obj->num_of_nodes == 1)
    {
        struct Node * del_node = obj->rear;
        obj->front = NULL;
        obj->middle = NULL;
        obj->rear = NULL;
        obj->num_of_nodes -= 1;
        ret_val = del_node->data;
        free(del_node);
    }
    else
    {
        struct Node * del_node = obj->rear;
        obj->rear = obj->rear->prev;
        obj->rear->next = NULL;
        obj->num_of_nodes -= 1;
        if(obj->num_of_nodes % 2 == 1)
            obj->middle = obj->middle->prev;
        ret_val = del_node->data;
        free(del_node);
    }
    //print_list(obj);
    return ret_val;
}

void frontMiddleBackQueueFree(FrontMiddleBackQueue* obj) 
{
    while(obj->num_of_nodes != 0)
        frontMiddleBackQueuePopBack(obj);
    free(obj);
}

/**
 * Your FrontMiddleBackQueue struct will be instantiated and called as such:
 * FrontMiddleBackQueue* obj = frontMiddleBackQueueCreate();
 * frontMiddleBackQueuePushFront(obj, val);
 
 * frontMiddleBackQueuePushMiddle(obj, val);
 
 * frontMiddleBackQueuePushBack(obj, val);
 
 * int param_4 = frontMiddleBackQueuePopFront(obj);
 
 * int param_5 = frontMiddleBackQueuePopMiddle(obj);
 
 * int param_6 = frontMiddleBackQueuePopBack(obj);
 
 * frontMiddleBackQueueFree(obj);
*/``