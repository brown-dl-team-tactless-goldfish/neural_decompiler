int timer=0;
bool helper(int a, int b)
{
    return ((tin[a]>=tin[b]) && (tout[a]<=tout[b]));
}
void dfs(int root, vector<int> balak[],vector<int> &nums)
{
    tin[nums[root]]= ++timer;
    for(auto child : balak[root])
        dfs(child,balak,nums);
    
    tout[nums[root]]= ++timer;
}

void dfss(int root, vector<int> balak[], vector<int> &out, vector<int> &nums)
{
    int maxo = -1;
    for(auto child : balak[root])
    {
        dfss(child,balak,out,nums);
        maxo=max(maxo,out[child]);
    }
    
    if(maxo==-1) // leaf
    {
        if(nums[root]!=1)
            out[root]=1;
        else
            out[root]=2;
    }
    else
    {
        int st = maxo;
        while(st<100001)
        {
            if(helper(st,nums[root])==false)
            break;
            st++;
        }
        out[root]=st;
    }
    return ;
}

vector<int> smallestMissingValueSubtree(vector<int>& parents, vector<int>& nums) {
    int n = nums.size();
    vector<int> out(n,1e6);
    
    vector<int> balak[n+1];
    for(int i=1; i<parents.size(); i++)
        balak[parents[i]].push_back(i);
    
    for(int i=0; i<100001; i++)
    {
        tin[i]=0;
        tout[i]=0;
    }
    dfs(0,balak,nums);
    dfss(0,balak,out,nums);
    
    return out;
}