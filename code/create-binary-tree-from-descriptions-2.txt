/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
 //Hash table structure to store the value and corresponding node address
typedef struct value_hash{
    int val;
    struct TreeNode *addr;
    UT_hash_handle hh;
}VALUE;

VALUE *HValueTable = NULL;

struct TreeNode *get_node(int value){
    struct TreeNode *node = NULL;
    VALUE *VItem = NULL;
    HASH_FIND_INT(HValueTable, &value, VItem);
    if(VItem == NULL){//Not present in the Hash Table
        //printf("Node added for %d\n", value);
        //Create a tree node
        node = (struct TreeNode*)malloc(sizeof(struct TreeNode));
        node->val = value;
        node->left = NULL;
        node->right = NULL;
        
        
        //Add the info to Hash table
        VItem = (VALUE*)malloc(sizeof(VALUE));
        VItem->val = value;
        VItem->addr = node;
        
        HASH_ADD_INT(HValueTable, val, VItem);
    }
    else{
        node = VItem->addr;
    }
    return node;
}

struct TreeNode* createBinaryTree(int** descriptions, int descriptionsSize, int* descriptionsColSize){
    HValueTable = NULL;
	//Hash array to store parent for each child
    int *parent_hash = (int*)malloc(sizeof(int) * 100001);
    for(int i = 0; i < 100001; i++){
        parent_hash[i] = i;
    }
       
    for(int i = 0; i < descriptionsSize; i++){
        int parent_val = descriptions[i][0];
        int child_val = descriptions[i][1];
        int is_left = descriptions[i][2];
        
        struct TreeNode *parent = get_node(descriptions[i][0]);
        struct TreeNode *child = get_node(descriptions[i][1]);
        
        if(is_left == 1){
            parent->left = child;
        }
        else{
            parent->right = child;
        }
        
        //Updating child's parent
        parent_hash[child_val] = parent_val;
    }
    
	//Find the root's value
    int root_val = descriptions[0][0];
    while(parent_hash[root_val] != root_val){
        root_val = parent_hash[root_val];
    }
    //Root's address from it's value
    struct TreeNode *root = get_node(root_val);
    
    //Free the Hash table and array
    free(parent_hash);
    VALUE *VItem = NULL, *tmp = NULL;
    HASH_ITER(hh, HValueTable, VItem, tmp){
        HASH_DEL(HValueTable, VItem);
        free(VItem);
    }
    
    return root;
}