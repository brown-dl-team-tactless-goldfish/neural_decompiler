
maintain 2 distance array 
dist1 -> first shortest path
dist2 -> second shortest path.

// no need to use Dijkstra as distance between each node is same , simple bfs would work.

typedef pair<int,int> pi;

class Solution {
public:
    
    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {
        
        vector<vector<int>> adj(n + 1);
        
        for(auto &it : edges){
            int u = it[0] , v = it[1];
            adj[u].push_back(v);
            adj[v].push_back(u);
        }
        
        vector<int> dist1(n + 1 , INT_MAX);
        vector<int> dist2(n + 1 , INT_MAX);
        
        dist1[1] = 0;
        
        queue<pi> q;
        q.push({0,1});
        
        while(q.size()){
            
            auto[tm,src] = q.front();
            q.pop();
         
      // If the signal is red at the vertex wait until the signal gets green.
            
            int val = tm/change;
            
            if(val % 2 != 0)tm = change * (val + 1);
            
            
            for(auto &v : adj[src]){
                
                int path = tm + time;
                
      // first shortest path          
                if(path < dist1[v]){
                    dist2[v] = dist1[v];
                    dist1[v] = path;
                    q.push({path,v});
                }
                
     // second shortest path           
                else if(path > dist1[v] && path < dist2[v]){
                    dist2[v] = path;
                    q.push({path,v});
                }
            }
        }
        
     return dist2[n];
    }
};