class Solution {
public:
    string getKey(map<int,vector<int>> &fc, int idx) {
        string k = "";
        for (auto p : fc) {
            k += "("+to_string(p.first)+"+"+to_string(p.second.size())+"),";
        }
        k += to_string(idx);
        return k;
    }
    
    bool searchFeasible(map<int,vector<int>> &fc, int idx, vector<int> &qu, unordered_set<string> &mem) {
        if (idx == qu.size()) return true;
        
        string k = getKey(fc, idx);
        if (mem.count(k)) return false;
        mem.insert(k);
        
        vector<int> counts;
        for (auto ff : fc) {
            counts.push_back(ff.first);
        }
        
        for (auto ff : counts) {
            if (ff >= qu[idx]) {
                int itemCount = ff;
                int itemId = fc[itemCount].back(); fc[itemCount].pop_back();
                if(fc[itemCount].empty()) fc.erase(itemCount);
                if (itemCount-qu[idx]) fc[itemCount-qu[idx]].push_back(itemId);
                
                if (searchFeasible(fc, idx+1, qu, mem)) return true;

                if (itemCount-qu[idx]) fc[itemCount-qu[idx]].pop_back();
                if (fc[itemCount-qu[idx]].empty()) fc.erase(itemCount-qu[idx]);
                fc[itemCount].push_back(itemId);
            }
        }
        
        return false;
    }
    
    bool canDistribute(vector<int>& nums, vector<int>& quantity) {
        unordered_map<int,int> catalog;
        map<int,vector<int>> freqCount; 
        unordered_set<string> mem;
        for (auto n : nums) {
            ++catalog[n];
        }
        
        for (auto c : catalog) {
            freqCount[c.second].push_back(c.first);
        }
        
        sort(quantity.begin(), quantity.end(), [] (int l, int r) {return l > r;});
        return searchFeasible(freqCount, 0, quantity, mem);
    }
};