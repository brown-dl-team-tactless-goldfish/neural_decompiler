class Solution {
public:
    class myCompactor {
        public:
        bool operator () (const pair<string,int>& a, const pair<string,int>& b) const {
           if (a.second==b.second)
              return a.first.compare(b.first)>0? true: false; 
           else 
              return a.second>b.second? true: false;
        }
    };
    int N; 
    vector<vector<int>> graph;
    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {
        priority_queue<pair<string,int>,vector<pair<string,int>>,myCompactor> heap;
        N = friends.size();  
        graph = friends;  
        int path = 0;
        queue<int> q; 
        bool seen[N] = {false};
        q.push(id); 
        seen[id] = true;
        while (!q.empty() && path<level) {
           int sz = q.size();
           for (int j = 0;j<sz;j++) {
             int node = q.front(); q.pop();
             for (auto child: graph[node]) {
               if (seen[child])
                 continue;
               seen[child] = true;
               q.push(child);
             }
           }
           path++;
        }
        unordered_map<string,int> keep;   
        vector<string>ans;
        while (!q.empty()) {
          int top = q.front(); q.pop();
          for (auto u: watchedVideos[top])
             keep[u]++;
        }
        for (auto pt: keep) 
            heap.push({pt.first,pt.second});
        while (!heap.empty()) {
            ans.push_back(heap.top().first);
            heap.pop();
        }
        return ans;
    }
};