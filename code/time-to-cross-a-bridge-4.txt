enum class Task {
  kLeftToRight,
  kPickOld,
  kRightToLeft,
  kPutNew,
  kWaitLeftToRight,
  kWaitRightToLeft
};

class Worker {
public:
  Worker(int id, std::vector<int>& task_times) : 
    id_(id), 
    task_(Task::kWaitLeftToRight), 
    task_completion_time_(0) {
    for (int i = 0; i < 4; i++) {
      task_times_[i] = task_times[i];
    }
    total_bridge_crossing_cost_ = task_times_[static_cast<int>(Task::kLeftToRight)] 
      + task_times_[static_cast<int>(Task::kRightToLeft)];
  }

  void SetTask(Task t, int current_time) {
    task_ = t;
    if (t == Task::kWaitLeftToRight || t== Task::kWaitRightToLeft) {
      task_completion_time_ = 0;
    } else {
      task_completion_time_ = current_time + task_times_[static_cast<int>(t)];
    }
  }

  int id() {
    return id_;
  }

  Task task() {
    return task_;
  }

  int task_completion_time() {
    return task_completion_time_;
  }

  int total_bridge_crossing_cost() {
    return total_bridge_crossing_cost_;
  }

private:
  int id_;
  Task task_;
  int task_completion_time_;
  int task_times_[4];
  int total_bridge_crossing_cost_;
};

struct BridgeQueueComparator {
  // Returns true iff lhs worker has lower priority on the bridge than rhs.
  bool operator()(Worker* lhs, Worker* rhs) {
    if (lhs->task() == Task::kWaitLeftToRight && rhs->task() != Task::kWaitLeftToRight) {
      return true;
    }
    if (rhs->task() == Task::kWaitLeftToRight && lhs->task() != Task::kWaitLeftToRight) {
      return false;
    }
    if (lhs->total_bridge_crossing_cost() < rhs->total_bridge_crossing_cost()) {
      return true;
    }
    if (rhs->total_bridge_crossing_cost() < lhs->total_bridge_crossing_cost()) {
      return false;
    }
    return lhs->id() < rhs->id();
  }
};

struct TaskCompletionTimeComparator {
  // Returns true iff lhs worker will complete their current task after rhs worker.
  bool operator()(Worker* lhs, Worker* rhs) {
    return lhs->task_completion_time() > rhs->task_completion_time();
  }
};

class Solution {
public:
    int findCrossingTime(int n, int k, vector<vector<int>>& time) {
      std::vector<Worker> workers;
      workers.reserve(time.size());
      for (int i = 0; i < time.size(); i++) {
        workers.push_back(Worker(i, time[i]));
      }

      // priority_queues hold non-owning pointers to Worker objects.
      std::priority_queue<Worker*, std::vector<Worker*>, BridgeQueueComparator> bridge_queue;
      std::priority_queue<Worker*, std::vector<Worker*>, TaskCompletionTimeComparator> busy_workers;
      // It would be slightly better to initialize the heap in a constructor (O(n)), 
      // rather than repeated calls to push() (O(nlogn)), but it's complicated to do 
      // so without creating a copy.
      for (int i = 0; i < time.size(); i++) {
        bridge_queue.push(&workers[i]);
      }

      int t = 0;
      int unclaimed_boxes = n;
      int boxes_on_left = 0;
      bool bridge_busy = false;
      while (true) {
        // Advance all workers that are done with their current task.
        while (!busy_workers.empty() && busy_workers.top()->task_completion_time() == t) {
          Worker* w = busy_workers.top();
          busy_workers.pop();
          switch (w->task()) {
            case Task::kLeftToRight:
              bridge_busy = false;
              w->SetTask(Task::kPickOld, t);
              busy_workers.push(w);
              break;
            case Task::kPickOld:
              w->SetTask(Task::kWaitRightToLeft, t);
              bridge_queue.push(w);
              break;
            case Task::kRightToLeft:
              bridge_busy = false;
              boxes_on_left++;
              // Exit early when the last box makes it to the left bank.
              if (boxes_on_left == n) {
                goto worker_loop_end;
              }
              w->SetTask(Task::kPutNew, t);
              busy_workers.push(w);
              break;
            case Task::kPutNew:
              w->SetTask(Task::kWaitLeftToRight, t);
              bridge_queue.push(w);
            default:
              // Should never happen.
              break;
          }
        }
        // Let the next worker onto the bridge.
        if (!bridge_busy && !bridge_queue.empty()) {
          Worker* w = bridge_queue.top();
          if (w->task() == Task::kWaitRightToLeft) {
            w->SetTask(Task::kRightToLeft, t);
            bridge_busy = true;
            bridge_queue.pop();
            busy_workers.push(w);
          } else if (unclaimed_boxes > 0 && w->task() == Task::kWaitLeftToRight) {
            w->SetTask(Task::kLeftToRight, t);
            unclaimed_boxes--;
            bridge_busy = true;
            bridge_queue.pop();
            busy_workers.push(w);
          }
        }
        t = busy_workers.top()->task_completion_time();
      }
    worker_loop_end:
      return t;
    }
};