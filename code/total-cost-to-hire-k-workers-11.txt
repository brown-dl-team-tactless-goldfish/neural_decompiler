class Solution {
private:
    vector<pair<int,int>> tree;
    vector<int> arr;
    pair<int,int> calc(pair<int,int> left,pair<int,int> right){
        if(left.first <= right.first) return left;
    	return right;
    }

    void build(int node,int st,int en){
        if(st == en){
            tree[node] = {arr[st],st};
        }else{
            int mid = st + (en - st)/2;
            build(node*2,st,mid);
            build(node*2+1,mid+1,en);
            tree[node] = calc(tree[node*2], tree[node*2+1]);
        }
    }

    void update(int node,int st,int en,int pos,int val){
        if(st > pos or en < pos) return;

        if(st == en){
            tree[node].first = val;
        }else{
            int mid = st + (en - st)/2;
            update(node*2,st,mid,pos,val);
            update(node*2+1,mid+1,en,pos,val);
            tree[node] = calc(tree[node*2], tree[node*2+1]);
        }
    }

    pair<int,int> query(int node,int st,int en,int l,int r){
        if(en < l or st > r) return {1e9,-1};

        if(st >= l and en <= r){
            return tree[node];
        }

        int mid = st + (en-st)/2;

        auto left = query(node*2,st,mid,l,r);
        auto right = query(node*2+1,mid+1,en,l,r);

        return calc(left, right);
    }
    
public:
    long long totalCost(vector<int>& c, int k, int cn) {
        int n = c.size();
        arr = c;
        tree.resize(4*n);
        build(1,0,n-1);
        int left = 0, right = 0;
        long long ans = 0;
        while(k--){
            auto op1 = query(1,0,n-1,0,min(n-1,cn-1+left));
            auto op2 = query(1,0,n-1,max(0,n-cn-right),n-1);
            if(op1.first <= op2.first){
                ans += op1.first; left++; update(1,0,n-1,op1.second,1e9);
            }else{
                ans += op2.first; right++; update(1,0,n-1,op2.second,1e9);
            }
        }
        return ans;
    }
};