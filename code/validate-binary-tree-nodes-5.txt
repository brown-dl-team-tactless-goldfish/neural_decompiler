# Time complexity: O(N)
# Space complexity: O(N)


class Solution:
    def validateBinaryTreeNodes(self, n: int, leftChild, rightChild) -> bool:
        print("n = ")

        root = [i for i in range(n)]
        parents = {}
        for i in range(n):
            print("i = ", i)
            if (leftChild[i] >= 0):
                if leftChild[i] not in parents:
                    parents[leftChild[i]] = [i]
                else:
                    parents[leftChild[i]].append(i)

                if (leftChild[i] in root):
                    root.remove(leftChild[i])
            if (rightChild[i] >= 0):
                if rightChild[i] not in parents:
                    parents[rightChild[i]] = [i]
                else:
                    parents[rightChild[i]].append(i)

                if (rightChild[i] in root):
                    root.remove(rightChild[i])

        print("parents = ", parents)
        print("root = ", root)

        if (len(root) != 1):
            return False

        root = root[0]
        print("root = ", root)

        self.visited = set()
        self.res = True

        def helper(curNode):
            if (self.res == False):
                return
            if (curNode in self.visited):
                print("already visted, must be a loop")
                self.res = False
                return

            self.visited.add(curNode)

            if (leftChild[curNode] != -1):
                helper(leftChild[curNode])
            if (rightChild[curNode] != -1):
                helper(rightChild[curNode])

        helper(root)

        print("end self.visite = ", self.visited)

        print("end self.res = ", self.res)

        if (len(self.visited) != n):
            return False

        return self.res