const int           N   = 10 + 3e1;

int     f[N][N][N];
int     g[N][N][N];

class Solution {
public:
    vector<int> earliestAndLatest(int T, int A, int B) {           
        memset(f, 0x3f, sizeof(f));
        memset(g, 0xcf, sizeof(g));
        f[2][1][2] = 1;
        g[2][1][2] = 1;
        
        for (int n = 3; n <= T; n++) {
            for (int i = 1; i <= n; i++) {
                for (int j = i+1; j <= n; j++) {
                    int u = min(i,n+1-i)-1, v = min(j,n+1-j)-1;     // group index : count from 0
                    int l = (i==u+1), r = (j==v+1);                 // on the left side
                    
                    int m = (n+1)/2;
                    
                    if (u == v) {
                        f[n][i][j] = 1;
                        g[n][i][j] = 1;
                    }
                    else if (u < v) {
                        for (int x = 0; x <= u; x++) {
                            for (int y = x+1; y <= v; y++) if (y-x <= v-u) {
                                f[n][i][j] = min(f[n][i][j], f[m][l?x+1:m-(u-x)][r?y+1:m-(v-y)] + 1);
                                g[n][i][j] = max(g[n][i][j], g[m][l?x+1:m-(u-x)][r?y+1:m-(v-y)] + 1);
                            }
                        }
                    }
                    else if (v < u) {
                        for (int y = 0; y <= v; y++) {
                            for (int x = y; x+1 <= u; x++) if (x-y <= u-v-1) {
                                f[n][i][j] = min(f[n][i][j], f[m][l?x+1:m-(u-x)][r?y+1:m-(v-y)] + 1);
                                g[n][i][j] = max(g[n][i][j], g[m][l?x+1:m-(u-x)][r?y+1:m-(v-y)] + 1);
                            }
                        }
                    }
                    
                }
            }
        }
        
                                                    
        if (A > B) swap(A, B);                                                              
        return {f[T][A][B], g[T][A][B]};
    }
};
