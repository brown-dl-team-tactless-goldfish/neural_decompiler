
class Item
{
	public char Char { get; set; }
	public int Count { get; set; }
}

public int Run(string board, string hand)
{
	#region get count dic
	Dictionary<char, int> countDic = new Dictionary<char, int>();

	foreach (var c in hand)
	{
		if (countDic.ContainsKey(c)) countDic[c]++;
		else countDic[c] = 1;
	}
	#endregion

	#region format board
	List<Item> list = new List<Item>();
	Item prev = default;

	foreach (var c in board)
	{
		if (prev != default && prev.Char == c) prev.Count++;
		else list.Add(prev = new Item { Char = c, Count = 1 });
	}
	#endregion

	int res = -1;

	Helper(list, 0, countDic);

	return res;

	#region helper method

	void Helper(List<Item> list, int i, Dictionary<char, int> countDic)
	{
		if (i == list.Count) return;

		var curr = list[i];

		if (countDic.ContainsKey(curr.Char)) // has curr
		{
			if (countDic[curr.Char] + curr.Count >= 3) // can remove
			{
				// clone list
				var clone = new List<Item>(list.Count);

				foreach (var item in list)
					clone.Add(new Item { Char = item.Char, Count = item.Count });

				var cloneDic = new Dictionary<char, int>(countDic);
				cloneDic[curr.Char] -= 3 - curr.Count;// use char
				ReduceList(clone, i, cloneDic);
				if (clone.Count == 0) // list is empty -> win
				{
					if (res == -1) res = hand.Length - cloneDic.Values.Sum();
					else res = Math.Min(res, hand.Length - cloneDic.Values.Sum());
					return;
				}
				Helper(clone, 0, cloneDic);
			}
		}

		// to next char
		Helper(list, i + 1, countDic);

	}

	void ReduceList(List<Item> list, int i, Dictionary<char, int> countDic)
	{
		list.RemoveAt(i);

		if (list.Count == 0) return;

		while (true)
		{
			if (i >= list.Count || i - 1 < 0) return;

			var curr = list[i];
			var prev = list[i - 1];
			if (curr.Char != prev.Char) return;

			prev.Count += curr.Count;
			list.RemoveAt(i--);
			if (prev.Count < 3) return;

			if (prev.Count != 3) // if count > 3 -> you can do {1. remove 3 ele} or {2. remove all ele}
			{
				prev.Count %= 3;
				Helper(list, i, countDic);
			}

			list.RemoveAt(i);

		}

	}

	#endregion

}
