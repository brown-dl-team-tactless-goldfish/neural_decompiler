class Solution {
public:
    int lefts['z'+1]; //the start idx for each letter 
    int rights['z'+1] = {}; //the end idx for each letter 
    
    vector<pair<int, vector<pair<int,int>>>*> dp; // pair<total length of substrs stored in vector, vector<pair<start, end>>>
    
    vector<string> maxNumOfSubstrings(string s) {
        dp.resize(s.size()+1, nullptr);
        
        for (int i = 0; i < dp.size(); i++) //init all total length to -1
            dp[i] = new pair<int, vector<pair<int,int>>>(-1, vector<pair<int,int>>());
        
        dp[s.size()]->first = 0; //the lengh for substr starts from s.size() is zero, ofcourse!
        
        memset(lefts, -1, sizeof(lefts));
        
        for (int i = 0; i < s.size(); i++){
            if (lefts[s[i]] == -1) lefts[s[i]] = i;
            
            rights[s[i]] = i;
        }
        
        int res = dfs(s, 0, 1, lefts[s[0]], rights[s[0]]);
        
        vector<string> ans;
        for (auto& p : dp[res]->second)
            ans.push_back(s.substr(p.first, p.second-p.first));
        
        return ans;
    }
    //l: start idx of this substr
	//r: current idx of this substr
	//minl: min start idx of each letter that presents in [l, r)
	//maxr: max end idx of each letter that presents in [l, r)
    int dfs(string& s, int l, int r, int minl, int maxr){ 
        if (r == s.size()){
            if (minl < l)  //invalid
                return r;
            
            if (dp[l]->second.empty() || (dp[l]->second.size() == 1 && dp[l]->first > r-l)){
                dp[l]->first = r-l;
                if (dp[l]->second.empty())
                    dp[l]->second.push_back(pair<int,int>(l, r));
                else
                    dp[l]->second[0].first = l;
                    dp[l]->second[0].second = r;
            }
            
            return l;
        }
        
        if (dp[l]->first != -1) return l;
        
        int res = dfs(s, r, r+1, lefts[s[r]], rights[s[r]]);
        if (minl < l) { //invalid, early stop here
            dp[l] = dp[res];
            return l;
        }
        
        if (r-1 == maxr){ //meets the maxr, form a valid substr, early stop here
            dp[l]->first = r-l + dp[res]->first;
            dp[l]->second.push_back(pair<int,int>(l, r));
            for (auto& p : dp[res]->second)
                dp[l]->second.push_back(p);
            return l;
        }
        
        auto tmp = dfs(s, l, r+1, min(minl, lefts[s[r]]), max(maxr, rights[s[r]])); //continue to find valid pairs for a substr starts from l
        
        if (dp[res]->second.size() < dp[tmp]->second.size() || (dp[res]->second.size() == dp[tmp]->second.size() && dp[res]->first > dp[tmp]->first))
            dp[l] = dp[tmp];
        else
            dp[l] = dp[res];
        
        return l;
    }
};