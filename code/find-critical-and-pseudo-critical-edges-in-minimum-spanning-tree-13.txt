class UnionFind {
    public:
    vector<int> parents;
    int count = 0;
    UnionFind(int n) {
        parents.resize(n);
        for(int i=0; i < n; ++i) parents[i] = i;
    }
    int find(int i) {
        
        if (i == parents[i])    return i;
        parents[i] = find(parents[i]);
        return parents[i];
    }
    void unite(int i, int j) {
        
        int pi = find(i);
        int pj = find(j);
        if(pi != pj) {
            count++;
            parents[pi] = pj;
        }
        
    }
};

class Solution {
public:
    
    static bool comp(vector<int> a, vector<int> b) {
        return (a[2] < b[2]);
    }
    
    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edge) {
        vector<vector<int>> vec, edges;
        for (int i = 0; i < edge.size(); i++) {
            vector<int> v = edge[i];
            v.push_back(i);
            edges.push_back(v);
        }
        sort(edges.begin(), edges.end(), comp);
        UnionFind uf = UnionFind(n);
        int cost = 0, count = 0;
        for (int i = 0; i < edges.size(); i++) {
            int nd1 = edges[i][0], nd2 = edges[i][1];
            int p1 = uf.find(nd1), p2 = uf.find(nd2);
            if (p1 != p2) {
                uf.unite(nd1, nd2);
                count++;
                cost += edges[i][2];
            }
            if (count == n - 1)  break;
        }
        //cout << cost << endl;
        
        vector<int> critical, pseudo;
        unordered_map<int, bool> crit;
        for (int j = 0; j < edges.size(); j++) {
            vector<vector<int>> ed = edges;
            ed.erase(ed.begin() + j);
            UnionFind uf1 = UnionFind(n);
            int cost1 = 0, count1 = 0;
            for (int i = 0; i < ed.size(); i++) {
                int nd1 = ed[i][0], nd2 = ed[i][1];
                int p1 = uf1.find(nd1), p2 = uf1.find(nd2);
                if (p1 != p2) {
                    uf1.unite(nd1, nd2);
                    count1++;
                    cost1 += ed[i][2];
                }
                if (count1 == n - 1)  break;
            }
            //cout << j << ":" << cost1 << ":" << count1 << endl;
            if (count1 != n - 1 || cost1 > cost)   {
                critical.push_back(edges[j][3]);
                crit[j] = true;
            }
        }
        for (int j = 0; j < edges.size(); j++) {
            vector<vector<int>> ed = edges;
            UnionFind uf1 = UnionFind(n);
            int cost1 = 0, count1 = 1;
            if (crit[j] || edges[j][2] > cost)  continue;
            cost1 += edges[j][2];
            uf1.unite(edges[j][0], edges[j][1]);
            
            for (int i = 0; i < ed.size(); i++) {
                int nd1 = ed[i][0], nd2 = ed[i][1];
                int p1 = uf1.find(nd1), p2 = uf1.find(nd2);
                if (p1 != p2) {
                    uf1.unite(nd1, nd2);
                    count1++;
                    cost1 += ed[i][2];
                }
                if (count1 == n - 1)  break;
            }
            //cout << j << "::" << cost1 << "::" << count1 << endl;
            if (count1 == n - 1 && cost1 == cost)   {
                pseudo.push_back(edges[j][3]);
            }
        }
        vec.push_back(critical);
        vec.push_back(pseudo);
        
        return vec;
    }
};