class Solution {
public:
    vector<int> beautifulArray(int N) {
        // Recursion: first, we can put all even numbers on the left, and all odd numbers on the right.
        // In this case, we only need to make left subarray beautiful, and right subarray beautiful,
        // because any number on the left + any number on the right is odd, which cannot be divided by 2.
        // Then we can recursively get the beautiful subarray on the left and on the right, then map them
        // to the actual number from 1 to N.
        // For even numbers, aka left subarray, left[i] *= 2. E.g. if N = 4, the left subarray will be (1, 2),
        // and we need to multiply 2 for each number.
        // For odd numbers, right[i] = right[i] * 2 - 1. E.g. if N = 5, the right subarray is (1, 3, 2), and 
        // we need to make them as (1, 5, 3).
        if (N == 1)
        {
            return {1};
        }
        
        int evens = N / 2, odds = (N + 1) / 2;
        vector<int> left = beautifulArray(evens);
        vector<int> right = beautifulArray(odds);
        
        for (int i = 0; i < left.size(); ++i)
        {
            left[i] *= 2;
        }
        
        for (int i = 0; i < right.size(); ++i)
        {
            right[i] = right[i] * 2 - 1;
        }
        
        left.insert(left.end(), right.begin(), right.end());
        return left;
    }
};