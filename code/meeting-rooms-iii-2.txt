struct node {
   // avalible time;
    long long x; 
    // node id;
   int y;
    node(int a, int b) {
        x = a;
        y = b;
    }
};
 struct cmp {
  bool operator() (const node& a, const node& b) const {
      if (a.x != b.x) return a.x > b.x;
      return a.y > b.y;
  }  
};
class Solution {
public:
    int mostBooked(int n, vector<vector<int>>& ms) {
        vector<int> cnt(n + 1, 0);
        sort(ms.begin(), ms.end());
        priority_queue<node, vector<node>, cmp> q;
        set<int> mp;
        for (int i = 0; i < n; i++) {
            mp.insert(i);
        }
        for (int i = 0; i < ms.size(); i++) {
            auto& c = ms[i];
            while (!q.empty() && q.top().x <= c[0]) {
                auto p = q.top();
                mp.insert(p.y);
                q.pop();
            }
            if (!mp.empty()) {
                int y = *(mp.begin());
                cnt[y]++;
                mp.erase(mp.begin());
                q.push(node(c[1], y));
                continue;
            }
            
            auto p = q.top();           
            cnt[p.y]++;
            q.pop();
            p.x = (long long)ms[i][1] - (long long)ms[i][0] + max(p.x, (long long)ms[i][0]);
            q.push(p);
        }
        int mx = 0;
        for (int i = 0; i < n; i++) {
            mx = max(mx, cnt[i]);
            //cout << i << "," << cnt[i] << endl;
        }

        for (int i = 0; i < n; i++) {
            if (cnt[i] == mx) return i;
        }
        return 0;
    }
};