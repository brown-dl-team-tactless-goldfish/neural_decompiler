class Solution {
public:
    int maxRepOpt1(string t) {
        
        int n = t.length();
        
        // store freq of chars in vector
        int char_freq[26] = {0};
        for(int i=0;i<n;i++)
            char_freq[t[i]-'a']++;
        
        // max possible length of repeated char substring with one swap
        int result = 1;
        
        // loop through sliding window process for all lowercase char if present in string
        for(char c= 'a'; c<='z'; c++)
        {
            // ignore if such char c is not present in string
            if(char_freq[c-'a']==0)continue;
            
            // no of char c at left of diff char 
            int lc = 0;
            // no of char c at right of diff char 
            int rc = 0;
            
            // count the number of occuerence of diff char in current window
            int mismatch_count = 0;
            
            for(int j=0;j<n;j++)
            {
                // update left substring count
                if(t[j]==c && mismatch_count==0)lc++;
                
                // update right substring count
                else if(t[j]==c && mismatch_count==1)rc++;
                
                // update mismatch count
                else if(t[j]!=c)mismatch_count++;
                
                // update result as LC+RC+1 if char_freq[c] > LC+RC, otherwise LC+RC
                if(char_freq[c-'a']>(lc+rc))result = max(result,lc+rc+1);
                else result = max(result,lc+rc);
                
                // if second mismatch foudn then slide window to the right 
                // as right substring becomes new left substring and mismatch count 1 
                if(mismatch_count>1)
                {
                    lc = rc;
                    rc = 0;
                    mismatch_count = 1;
                }
            }
        }
        
        return result;
    }
};