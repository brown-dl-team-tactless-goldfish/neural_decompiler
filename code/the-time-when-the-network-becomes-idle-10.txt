class Solution {
public:
    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& pat) {
       int n=pat.size();
        int m=edges.size();
      vector<int>g[n];
      for(int i=0;i<m;i++){
        g[edges[i][0]].push_back(edges[i][1]);
         g[edges[i][1]].push_back(edges[i][0]);
      }
        
      vector<int>dist(n,0);
      vector<int>vis(n,0);
      queue<int>q;
      q.push(0);
      vis[0]=1;
      int d=0;
      while(!q.empty()){
        int sz=q.size();
        
        while(sz--){
          int node=q.front();
           dist[node]=d;
          q.pop();
          for(int x: g[node]){
            if(vis[x]==false){
              vis[x]=true;
              q.push(x);
            }
          }
        }
        d++;
      }
      
         int time;
         int mx=INT_MIN;
        for(int i=0;i<n;i++){
          
          if(2*dist[i]<=pat[i]) // no need to send extra signals
             time=2*dist[i];
     
/*number of extra signal send=(2*d[i]-1)/pat[i]
so extra time = no of extra signals* pat[i];
*/
          else
            time=2*dist[i] + (((2*dist[i]-1)/pat[i])*pat[i]);
        
                    mx=max(mx,time+1);

        }
      
      return mx;
    }
};
