public class SORTracker {
    
    private PriorityQueue<string,(int,string)> minHeap; // store locations with large scores
    private PriorityQueue<string,(int,string)> maxHeap; // store locations with small scores
    public int queryNumber = 1;
    
    public SORTracker() {
        
        // For the minHeap, the lexicrographically larger one has less priority if two locations have the same score.
        // e.g., if location 1's score = 1, location 2's score = 2, then location 1 should be the min element
        // e.g., if location 1a's and 1b's score are the same, then location 1b should be the min element
        minHeap = new PriorityQueue<string,(int,string)>(Comparer<(int,string)>.Create((a,b) => a.Item1 == b.Item1? b.Item2.CompareTo(a.Item2) : a.Item1 - b.Item1));
        
        // top element of maxHeap will be the result of each query
        maxHeap = new PriorityQueue<string,(int,string)>(Comparer<(int,string)>.Create((a,b) => a.Item1 == b.Item1? a.Item2.CompareTo(b.Item2) : b.Item1 - a.Item1));
    }
    
    public void Add(string name, int score) {
        
        minHeap.Enqueue(name,(score,name));
        
        // secure a spot in minHeap for the result, which is the max element of the maxHeap
        while(minHeap.Count >= queryNumber)
        {
            minHeap.TryDequeue(out string location, out (int,string) priority);
            maxHeap.Enqueue(location, (priority.Item1, priority.Item2));
        }
    }
    
    public string Get() {
        
        maxHeap.TryDequeue(out string location, out (int,string) priority);
        minHeap.Enqueue(location, (priority.Item1, priority.Item2));
        queryNumber++;
        return location;
    }
}