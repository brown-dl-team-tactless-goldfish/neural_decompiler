#pragma GCC optimize("Ofast","inline","fast-math","unroll-loops","no-stack-protector")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native","f16c")
static const auto fast = []() {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();
class Solution {
public:
    int maxProductPath(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        int mod = 1e9 + 7;
        vector<vector<long long>> maxProduct(n, vector<long long>(m));
        vector<vector<long long>> minProduct(n, vector<long long>(m));
        maxProduct[0][0] = minProduct[0][0] = grid[0][0];
        for (int i = 1; i < n; i++) {
            maxProduct[i][0] = minProduct[i][0] = maxProduct[i - 1][0] * grid[i][0];
        }
        for (int j = 1; j < m; j++) {
            maxProduct[0][j] = minProduct[0][j] = maxProduct[0][j - 1] * grid[0][j];
        }
        for (int i = 1; i < n; i++) {
            for (int j = 1; j < m; j++) {
                long long a = maxProduct[i - 1][j] * grid[i][j];
                long long b = maxProduct[i][j - 1] * grid[i][j];
                long long c = minProduct[i - 1][j] * grid[i][j];
                long long d = minProduct[i][j - 1] * grid[i][j];
                maxProduct[i][j] = max(max(a, b), max(c, d));
                minProduct[i][j] = min(min(a, b), min(c, d));
            }
        }
        return maxProduct[n - 1][m - 1] >= 0 ? maxProduct[n - 1][m - 1] % mod : -1;
    }
};