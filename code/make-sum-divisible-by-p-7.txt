A combination of Subarry Sum equal K and Subarray Sum Divisible by K problem.

First we find the total sum of the array mod P => sumModP
    If sumModP == 0  then total sum is divisible by P and so nothing to remove and return 0
    Otherwise we need to find the shortest subarray which has sum%P == sumModP

Go through the array and calculate the prefix sum and prefix sum mod P => prefixSumModP
	Find in prefixSumModP array if any sum equal sumModP which becomes "Subarray Sum equal K" problem
    We need to find if complement of sumModP for prefixSumModP exists and count its subarray length
    Store the recent index of prefixSumModP in HashMap which we will use to find length of subarray, Base case insert: (0,-1) in HashMap
    So, the complement of sumModP, modComplement = (P + prefixSumModP - sumModP)%P
        We add P cause prefixSumModP can be less than sumModP which makes (prefixSumModP - sumModP) negative
        If modComplement exists then calculate length of the subarry as
        current Index - index of modComeplement : i-prefixSumModTrack[modComplement] and find min length of subarray

If min length is size of array then removal is not possible and return -1
        
Ex: [3, 1, 4, 2], P = 6
    Total sum = 16, sumModP = 16%6 = 4
    Initial HashMap = {0,-1}
    Prefix Sum of given Array = [3, 4, 8, 10]
    PrefixSumModP of given Array = [3, 4, 2, 4]
    i = 0, (6+3-4)%6 = 5 => no compelement found => HashMap insert (3,0)
    i = 1, (6+4-4)%6 = 0 => compelemnt found => minl = min(4,1-(-1)) = 2 => HashMap insert (4,1)
    i = 2, (6+2-4)%6 = 4 => compelemnt found => minl = min(2,2-1) = 1 => HashMap insert (2,2)
    i = 3, (6+4-4)%6 = 0 => compelemnt found => minl = min(1,3-(-1)) = 1 => HashMap insert (4,3)
    So min Length of subarray sum%P = sumModP is 1 which is index 2.
        
Math proof of the complement of sumModP for given prefixSumModP:

We need to find subarray s[i:j] such that (Sum(s) - Sum(s(i:j)))%P == 0
So, Sum(s) - Sum(s(i:j)) = P.x (x is any positive value)
=> Sum(s(i:j)) = Sum(s) - P.x
=> Sum(s(0:i)) - Sum(s(0:j)) = Sum(s) - P.x
=> (Sum(s(0:i)) - Sum(s(0:j)))%P = (Sum(s) - P.x)%P
=> (Sum(s(0:i)) - Sum(s(0:j)))%P = Sum(s)%P
=> (Sum(s(0:i)) - Sum(s(0:j)))%P = sumModP
=> Sum(s(0:j))%P = (Sum(s(0:i))%P - sumModP)%P, this is the modCompelement equation 

Sum(s(0:i))%P is the prefixSumModP and Sum(s(0:j))%P is modCompelemnt stored in HashMap 

class Solution {
public:
    int minSubarray(vector<int>& nums, int p) {
        
        int sumModP = 0;
        
        // Use modular arithmatic to avoid int overflow
        for(int i=0;i<nums.size();i++)
            sumModP = (sumModP + nums[i]) %p;
        
        // total sum mod P is reminder 0 and so nothing to remove and retuen 0
        if(sumModP==0) return 0;
        
        unordered_map<int,int>prefixSumModTrack = {{0, -1}};
        
        int prefixSumModP  = 0;
        int minLen = nums.size();
        int modComplement;
        for(int i=0;i<nums.size();i++)
        {
            // find mod of the prefix sum
            prefixSumModP = (prefixSumModP + nums[i])%p;
            // find complement of sumModP
            modComplement = (p + prefixSumModP-sumModP)%p;
            // If comeplement exsists then count the min length
            if(prefixSumModTrack.count(modComplement))
                minLen = min(minLen,i-prefixSumModTrack[modComplement]);
            
            // update current prefix sum mod with current index
            prefixSumModTrack[prefixSumModP] = i;
        }
        
        // if min length == array size then not possible
        return minLen==nums.size()?-1:minLen;
    }
};