        public int MinimumObstacles(int[][] grid)
        {
            int row = grid.Length;
            int col = grid[0].Length;
            int[][] dp = new int[row][];
            for (int i = 0; i < row; i++)
            {
                dp[i] = new int[col];
                Array.Fill(dp[i], int.MaxValue);
            }
            dp[row - 1][col - 1] = 0;
			
			//dxy hold all neighbors
            int[][] dxy = new int[4][] { new int[] { 1, 0 }, new int[] { -1, 0 }, new int[] { 0, 1 }, new int[] { 0, -1 } };
			
			//init bfs list, search from tail point (m-1,n-1), aka the right-bottom corner
            List<int[]> list = new List<int[]>() { new int[] { row - 1, col - 1 } };
            while (list.Count > 0)
            {
                var next = new List<int[]>();//next loop of BFS
                foreach (var p in list)
                {
                    foreach (var d in dxy)
                    {
                        int r = p[0] + d[0];
                        int c = p[1] + d[1];
						//check invalid all neighbors
                        if (r >= 0 && r < row && c >= 0 && c < col)
                        {
                            int curr = grid[r][c] + dp[p[0]][p[1]];
                            if (curr < dp[r][c])
                            {
							    //if this neighbor can be updated to smaller value, then add (r,c) to next loop of BFS
                                dp[r][c] = curr;
                                next.Add(new int[] { r, c });
                            }
                        }
                    }
                }
                list = next;
            }
            return dp[0][0];
        }
