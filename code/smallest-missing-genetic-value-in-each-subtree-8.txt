#define N 8192
#define S 13
class Solution {
public:
  vector<int>answer;
  vector<vector<int>>g;
  int n;
  
  pair<vector<bitset<N>*>, int> dfs(vector<int> &nums, int id, int i){
    int old_i = i, start = i >> S;
    vector<bitset<N>*> bst(n, NULL);
    
    
    for(int j = 0; j != g[id].size(); j++){
      auto[st, t] = dfs(nums, g[id][j], old_i);
      i = max(i, t);
      
      for(int b = start; b != n; b++){
        if( st[b] == NULL) continue;
        if( bst[b] == NULL) bst[b] = new bitset<N>;
        (*bst[b]) |= (*st[b]);
        
        delete st[b];
      }  
    }
    
    int a = (nums[id]-1) >> S;
    if( bst[a] == NULL ) bst[a] = new bitset<N>;
    (*bst[a]).set( (nums[id]-1) % N, 1);
    
    
    start = i >> S;
    if( bst[start] != NULL)
      if( (*bst[start]).all() ){
        while(++start != n && bst[start] != NULL && (*bst[start]).all()) delete bst[start];
        int b = 0;
        if(start != n && bst[start] != NULL)
          while( (*bst[start]).test(b) == 1) b++;
      
        i = (start<<S) + b;
      }
      else{
        int b = i % N;
        while( (*bst[start]).test(b) == 1) b++, i++;
      }
    
    
    answer[id] = i + 1;
    return {bst, i};
  }
  
  vector<int> smallestMissingValueSubtree(vector<int>& parents, vector<int>& nums) {
    n = nums.size();
    g.resize(n), answer.resize(n);
    
    for(int i = 0; i != n; i++ )
      if(parents[i] != -1) g[parents[i]].push_back(i);
    
    
    n = n / N + 1;
    dfs(nums, 0, 0);
    
    return answer;
  }
};