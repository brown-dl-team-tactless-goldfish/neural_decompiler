class Solution {
public:
    typedef pair<int, int> Point;
    //For points a and b, define a < b if and only if
    // a.first < b.first or else if a.first == b.first then if a.second < b.second.
    inline long ComputeSquareOfDistance(const Point a, const Point b) {
        long d1 = a.first - b.first;
        long d2 = a.second - b.second;
        return d1 * d1 + d2 * d2;
    }
    inline long ComputeAreaOfRectangle(Point a0, Point a1, Point b0, Point b1) {
        long d1 = ComputeSquareOfDistance(a0, a1);
        long d2 = ComputeSquareOfDistance(a0, b0);
        assert(d1 == ComputeSquareOfDistance(b0, b1));
        assert(d2 == ComputeSquareOfDistance(a1, b1));
        return sqrt(d1 * d2);
    }
    //Assumes that a0 <= a1 and b0 <= b1.
    inline bool DoesFormRectaangle(Point a0, Point a1, Point b0, Point b1) {
        long square_of_diagonal1_dist = ComputeSquareOfDistance(a0, b1);
        long square_of_diagonal2_dist = ComputeSquareOfDistance(a1, b0);
        return square_of_diagonal1_dist == square_of_diagonal2_dist;
    }
    inline Point GetVector(Point &p0, Point &p1) {
        if (p0.first > p1.first || p0.first == p1.first && p1.first < p0.first)
            swap(p0, p1);
        return {p1.first - p0.first, p1.second - p0.second};
    }
    struct PointHash {
        size_t operator()(const Point &p) const {
            return hash<int>{}(p.first) ^ (hash<int>{}(p.second));
        }
    };
    void FillInVectorToPointsMap(vector<Point>& points, unordered_multimap<Point, pair<Point*, Point*>, PointHash> &vec_to_points) {
        for (int i = 0; i < points.size(); ++i) {
            for (int j = i + 1; j < points.size(); ++j) {
                Point p0 = points[i], p1 = points[j];
                Point vec = GetVector(p0, p1);
                //Map vec back to the points that created it, where we insert it
                // so that *ptr0 <= *ptr1.
                Point * ptr0 = &(points[i]), * ptr1 = &(points[j]);
                if (p0 != points[i])
                    swap(ptr0, ptr1);
                vec_to_points.insert({vec, make_pair(ptr0, ptr1)});
            }
        }
        return ;
    }
    double minAreaFreeRect(vector<vector<int>>& points) {
        vector<Point> actual_points;
        for (const vector<int> &v : points)
            actual_points.push_back({v[0], v[1]});
        unordered_multimap<Point, pair<Point*, Point*>, PointHash> vec_to_points;
        FillInVectorToPointsMap(actual_points, vec_to_points);
        double min_area = numeric_limits<double>::max();

        while (vec_to_points.size() > 0) {
            auto it_start = vec_to_points.begin();
            Point vec = it_start->first;
            auto range = vec_to_points.equal_range(vec);
            if (distance(range.first, range.second) == 1) { //If vec only has 1 pair of points associated with it then move on
                vec_to_points.erase(it_start);
                continue;
            }
			//We now go through every pair of elements in this range (where each element is a pair of points).
            for (auto it = range.first; it != range.second; ) {
                auto second_it = it;
                ++second_it;
                if (second_it == range.second)
                    break;
                pair<Point *, Point *> a_ptrs = it->second;
                Point a0 = *(a_ptrs.first), a1 = *(a_ptrs.second);
                for (auto it2 = second_it; it2 != range.second; ++it2) {
                    pair<Point *, Point *> b_ptrs = it2->second;
                    Point b0 = *(b_ptrs.first), b1 = *(b_ptrs.second);
                    if (DoesFormRectaangle(a0, a1, b0, b1)) {
                        double area_of_rectangle = ComputeAreaOfRectangle(a0, a1, b0, b1);
                        if (area_of_rectangle < min_area)
                            min_area = area_of_rectangle;
                    }
                }
                it = second_it;
            }
            
            //Erase the points just considered.
            for (auto it = range.first; it != range.second; ) {
                auto next_it = it;
                ++next_it;
                vec_to_points.erase(it);
                it = next_it;
            }
        }
        if (min_area == numeric_limits<double>::max())
            return 0;
        return min_area;
    }
};