class Solution {
public:
    int minimumDifference(vector<int>& nums) {
        auto left = GetCountAndSums(nums, 0, nums.size() / 2);
        auto right = GetCountAndSums(nums, nums.size() / 2, nums.size() - 1);
        const auto kSum = accumulate(nums.begin(), nums.end(), 0);
        int min_diff = abs(kSum - 2 * accumulate(nums.begin(), nums.begin() + nums.size() / 2, 0));
        for (int lc = 0; lc <= nums.size() / 2; ++lc) {
            int rc = nums.size() / 2 - lc;
            if (rc >= right.size()) {
                continue;
            }
            auto li = left[lc].cbegin();
            auto ri = lower_bound(right[rc].cbegin(), right[rc].cend(), kSum / 2 + 1 - *li);
            if (ri == right[rc].cend()) {
                --ri;
            }
            while (li != left[lc].cend()) {
                int sum = *li + * ri;
                int remaining_sum = kSum - sum;
                while (sum > remaining_sum) {
                    min_diff = min(min_diff, abs(sum - remaining_sum));
                    if (ri == right[rc].cbegin()) {
                        break;
                    }
                    --ri;
                    sum = *li + *ri;
                    remaining_sum = kSum - sum;
                }
                if (sum > remaining_sum) {
                    break;
                }
                min_diff = min(min_diff, abs(sum - remaining_sum));
                if (sum == remaining_sum) {
                    return min_diff;
                }
                ++li;
            }
        }
        return min_diff;
    }
private:
    int CountOne(int n) {
        int c = 0;
        while (n) {
            n &= n - 1;
            c++;
        }
        return c;
    }
    vector<vector<int>> GetCountAndSums(const vector<int>& nums, int s, int e) {
        vector<vector<int>> sums(e - s + 1);
        for (int i = 0; i < (1 << (e - s)); ++i) {
            int sum = 0;
            for (int j = 0; j < 15; j++) {
                if ((i >> j) & 1) {
                    sum += nums[s + j];
                }
            }
            sums[CountOne(i)].push_back(sum);
        }
        for (auto& arr : sums) {
            sort(arr.begin(), arr.end());
        }
        return sums;
    }
    
};