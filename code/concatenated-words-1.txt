/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

// Function that sorts words by their size 
int cmp (const void* a, const void* b){
    return strlen(*(char**)b) - strlen(*(char**)a);
}

/*  How to  check if cur word is concatenated from other words?
    First you should check if there is a word in words (argument)
    that is the prefix of the current word your checking upon.
    If you find such word, then you should check if there is
    such word that is the prefix of the rest of the current word
*/
bool concat(char** words, int wordsSize, int curWord, char* cur){
    // If cur word is null or a terminator, it means you found all it's composing words
    if(cur==NULL || cur[0]=='\0') return true;

    // Check if you can find it's composing words
    for(int i = curWord + 1; i<wordsSize; i++){

        // If they start by the same letter, we found a candidate
        if(words[i][0]==cur[0]){
            int j = 1, len=strlen(words[i]);

            /* Check if all chars in both words are equal until
               you reach the end of words[i].
               It won't break even if strlen(words[i]) > strlen(cur)
               because of the terminator of the string '\0'
            */ 
            for(;j<len; j++){
                if(words[i][j]!=cur[j]) break;
            }
            /* If word is a prefix of the cur word, check you you can find 
               all other composing words
            */
            if(j==len){
                if(concat(words, wordsSize, curWord, &cur[len])) return true;
            }
        }
    }
    // If you found no complete concatenation
    return false;
}

char ** findAllConcatenatedWordsInADict(char ** words, int wordsSize, int* returnSize){
    // You need at least 2 words to have one being a concatenated
    if(wordsSize < 2){
        *returnSize = 0;
        return NULL;
    }

    // Sort words by size, in decreasing order
    qsort(words, wordsSize, sizeof(char*), cmp);

    char** ans = calloc(wordsSize, sizeof(char*));
    int ansSize = 0;
    
    // If a word is concatenated, it needs to be at least the size of the smallest word
    int minWordSize = strlen(words[wordsSize-1]);

    // For all candidate words, check if they are concatenated from other words
    for(int i = 0; i < wordsSize; i++){
        if(strlen(words[i])<minWordSize) break;
        if(concat(words, wordsSize, i, words[i])) ans[ansSize++] = words[i];
    }

    *returnSize = ansSize;
    return ans;
}