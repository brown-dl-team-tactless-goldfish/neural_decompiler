class Solution {
public:
    int maximumInvitations(vector<int>& favorite) {
        int n = favorite.size();
        vector<int> ind(n);
        vector<vector<int>> rev(n);
        unordered_map<int, int> pairs;
        for (int i = 0; i < n; ++i) {
            ++ind[favorite[i]];
            rev[favorite[i]].emplace_back(i);
            if (i == favorite[favorite[i]]) {
                pairs[min(i, favorite[i])] = max(i, favorite[i]);
            }
        }
        queue<int> q;
        unordered_set<int> ext;
        for (int i = 0; i < n; ++i) {
            if (ind[i] == 0) {
                q.emplace(i);
            }
        }
        while (!q.empty()) {
            int t = q.front(); q.pop();
            ext.emplace(t);
            if (--ind[favorite[t]] == 0) {
                q.emplace(favorite[t]);
            }
        }
        vector<int> tags(n, 0);
        int circle = 0;
        for (int i = 0; i < n; ++i) {
            if (!ext.count(i)) {
                circle = max(circle, dfs1(i, favorite, tags, 1));
            }
        }
        int chain = 0;
        for (auto [left, right] : pairs) {
            int one = dfs2(rev, left, left, right);
            int two = dfs2(rev, right, right, left);
            chain += one + two;
        }
        return max(circle, chain);
    }

private:
    int dfs1(int i, vector<int>& favorite, vector<int>& tags, int tag) {
        int ans = 0;
        tags[i] = tag;
        if (tags[favorite[i]]) {
            ans = tag - (tags[favorite[i]] - 1);
        } else {
            ans = dfs1(favorite[i], favorite, tags, tag + 1);
        }
        return ans;
    }
    int dfs2(vector<vector<int>>& rev, int curr, int f1, int f2) {
        int ans = 1;
        for (int neighbor : rev[curr]) {
            if (curr != f1 || neighbor != f2) {
                ans = max(ans, 1 + dfs2(rev, neighbor, f1, f2));
            }
        }
        return ans;
    }
};