int minDifficulty(int* jobDifficulty, int jobDifficultySize, int d){
    
    //if d > jobDifficultySize or d == 1 
    
    if (d > jobDifficultySize){
        return -1;
    }
    int ans = 0;
    if (d == 1){
        for (int i = 0 ; i < jobDifficultySize ; i++){
            if (ans < jobDifficulty[i]){
                ans = jobDifficulty[i];
            }
        }
        return ans;
    }
    
    /*
    job_list[day_x][job_y] = difficulty_z
    It means on the [day_x] start with the [job_y] has minimum "difficulty_z"
    So the answer = job_list[0][0] (on the [firstday] start with the [firstjob])
    */
    
    int** job_list = malloc(sizeof(int*)*d);
    for (int i = 0 ; i < d ; i++){
        job_list[i] = malloc(sizeof(int)*jobDifficultySize);
    }
    
    
    /*
    max[job_x][job_y] = z
    It means between [job_x] and[job_y] the maximum difficulty is "z"
    */
    
    int** max = malloc(sizeof(int*)*jobDifficultySize);
    for (int i = 0 ; i < jobDifficultySize ; i++){
        max[i] = malloc(sizeof(int)*jobDifficultySize);
        max[i][i] = jobDifficulty[i];
        for (int j = i+1 ; j < jobDifficultySize ; j++){
            max[i][j] = max[i][j-1] > jobDifficulty[j] ? max[i][j-1] : jobDifficulty[j];
        }
        
    }
    
    
    
    /* 
    (( For convenience, we start counting from day 0  so day_x = d-1 , last_job = jobDifficultySize-1
    
    Bottom to top
    Find the job_list[day_x][day_x ~ jobDifficultySize-1] 
    ((have to finish at least one task every day 0 ~ day_x-1 dont find

    
    job_list[day_x][job_y] 
    It means on the [day_x] start with the [job_y] => on "last_day" start with "job_y"
    Because it is last_day
    It means find the maximum difficulty of "[job_y] ~ [jobDifficultySize-1].
    So job_list[day_x][job_y] = max[job_y][jobDifficultySize-1]
    
    */
    
    int day_x = d-1;
    int last_job = jobDifficultySize-1;
    
    for (int i = last_job ; i >= day_x ; i--){
        job_list[day_x][i] = max[i][last_job];
    }
    
    /*
    Then we find day before day_x 
    day_x--;
    
    Find job_list[day_x][day_x ~ jobDifficultySize-2]
    ((have to finish at least one task every day 0 ~ day_x-1 AND dont find
    
    job_list[day_x][i]
    Start trying 
    {
    If do 1 job a day
    job_list[day_x][i] = max[i][i] + job_list[day_x+1][i+1];
    If do 2 job a day
    job_list[day_x][i] = max[i][i+1] + job_list[day_x+1][i+2];
    If do 3 job a day
    job_list[day_x][i] = max[i][i+2] + job_list[day_x+1][i+3];
    .
    .
    .
    }
    Find the minimum 
    
    (It will be easier to understand if written with a case)
    */
    
    while (day_x > 1){
        day_x--;
        for (int i = last_job-1 ; i >= day_x ; i--){
            job_list[day_x][i] = max[i][i] + job_list[day_x+1][i+1];
            for (int j = i + 1 ; j < last_job ; j++){
                job_list[day_x][i] = job_list[day_x][i] < max[i][j] + job_list[day_x+1][j+1] ?
                                     job_list[day_x][i] : max[i][j] + job_list[day_x+1][j+1];
            }
        }
        last_job--;
    }
    
    
    /*
    If day_x = 0
    We must start with the [job_y(0)]
    */
    
    ans = max[0][0] + job_list[1][1];
    for (int i = 1 ; i < last_job ; i++){
        ans = ans < max[0][i] + job_list[1][i+1] ? ans : max[0][i] + job_list[1][i+1];
    }
    
    // free
	
    for (int i = 0 ; i < d ; i++){
        free(job_list[i]);
    }
    free(job_list);
    for (int i = 0 ; i < jobDifficultySize ; i++){
        free(max[i]);
    }
    free(max);
    
    return ans;
}