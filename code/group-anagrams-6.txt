int IsAnagram(char* str1, char* str2)
{
    char str[100];
    int ii;
    
    if (strlen(str1) != strlen(str2))
        return 0;

    strcpy(str, str2); // in order not to change given array
    for (; *str1; str1++)
    {
        for (ii = 0; str[ii]; ii++)
        {
            if (*str1 == str[ii])
            {
                str[ii] = '*';
                break;
            }
        }
        if (str[ii] == 0)   // no coincidence
            return 0;
    }

    return 1;
}

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
char *** groupAnagrams(char ** strs, int strsSize, int* returnSize, int** returnColumnSizes){
    char*** ret;
    char* word_done;
    int* l_returnColumnSizes;
    int l_returnSize = 0;

    if (strsSize == 0)
    {
        *returnSize = 0;
        *returnColumnSizes = 0;
        return 0;
    }

    ret = (char***)malloc(10000 * sizeof(char**));
    l_returnColumnSizes = (int*)malloc(10000 * sizeof(int));

    word_done = (char*) malloc(strsSize * sizeof(char));
    memset(word_done, 0, strsSize);
    for (int ii = 0; ii < strsSize; ii++)
    {
        if (word_done[ii])
            continue;
        l_returnColumnSizes[l_returnSize] = 1;
        ret[l_returnSize] = (char**)malloc(10000 * sizeof(char*));
        ret[l_returnSize][0] = (char*)malloc((strlen(strs[ii]) + 1) * sizeof(char));
        strcpy(ret[l_returnSize][0], strs[ii]);

        for (int kk = ii + 1; kk < strsSize; kk++)
        {
            if ((word_done[ii] == 0) && IsAnagram(strs[ii], strs[kk]))
            {
                word_done[kk] = 1;
                ret[l_returnSize][l_returnColumnSizes[l_returnSize]] = (char*)malloc((strlen(strs[kk]) + 1) * sizeof(char));
                strcpy(ret[l_returnSize][l_returnColumnSizes[l_returnSize]], strs[kk]);
                l_returnColumnSizes[l_returnSize]++;
            }
        }
        ret[l_returnSize] = (char**)realloc(ret[l_returnSize], l_returnColumnSizes[l_returnSize] * sizeof(char*));
        l_returnSize++;
    }
    free(word_done);

    *returnSize = l_returnSize;
    *returnColumnSizes = (int*)realloc(l_returnColumnSizes, l_returnSize * sizeof(int));
    return (char***)realloc(ret, l_returnSize * sizeof(char**));
}