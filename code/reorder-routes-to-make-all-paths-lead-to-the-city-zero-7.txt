namespace std {
template<typename T1, typename T2>
struct hash<pair<T1, T2>> {
    _GLIBCXX_PURE size_t operator()(const pair<T1, T2>& p) const noexcept {
        return hash<T1>()(p.first) ^ (hash<T2>()(p.second) << 1);
    }
};
}


class Solution {
public:
    int minReorder(int n, const vector<vector<int>>& connections) {
        unordered_set<pair<int, int>> road, need;
        vector<vector<int>> g(n, vector<int>());
        for (auto& c : connections) {
            g[c.front()].push_back(c.back());
            g[c.back()].push_back(c.front());
            road.emplace(c.front(), c.back());
        }
        queue<int> q;
        vector<bool> vi(n, false);
        q.push(0);
        vi[0] = true;
        while (q.size()) {
            int cur = q.front();
            q.pop();
            for (int n : g[cur]) {
                if (vi[n]) continue;
                vi[n] = true;
                need.emplace(n, cur);
                q.push(n);
            }
        }
        need.merge(road);
        return need.size() - road.size() >> 1;
    }
};