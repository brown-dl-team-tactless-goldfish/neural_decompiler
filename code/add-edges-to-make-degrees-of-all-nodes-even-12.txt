class Solution {
public:

    bool hasEdge(set<pair<int,int>> &connected, int node1, int node2){
        if(connected.find({node1, node2}) == connected.end()) return false;            
        else return true;
    }

    bool isPossible(int n, vector<vector<int>>& edges) {
        set<pair<int,int>> connected;
        vector<int> degree(n+1, 0);
        for(auto edge: edges){
            int node1 = edge[0], node2 = edge[1];
            degree[node1]++, degree[node2]++;
            connected.insert({node1, node2});
            connected.insert({node2, node1});
        }

        vector<int> oddDegNodes;
        for(int i=1;i<n+1;i++){
            if(degree[i] % 2 != 0) 
                oddDegNodes.push_back(i);
        }
        
        //cases: 0,2,4
        int oddNodes = oddDegNodes.size();
        if(oddNodes == 0) return true;
        else if(oddNodes == 2){
            int node1 = oddDegNodes[0];
            int node2 = oddDegNodes[1];
            if(!hasEdge(connected, node1, node2)) 
                return true;

            //find a even degree node which is not connected with both of them:
            for(int i=1;i<n+1;i++){
                if(i == node1 or i == node2) continue;
                else if(!hasEdge(connected, i, node1) and !hasEdge(connected, i, node2)) return true;
            }

            return false;
        }
        else if(oddNodes == 4){
            int a = oddDegNodes[0];
            int b = oddDegNodes[1];
            int c = oddDegNodes[2];
            int d = oddDegNodes[3];

            //try connecting all fours with each other in all combinations:
            bool op1 = !hasEdge(connected, a, b) and !hasEdge(connected, c, d);
            bool op2 = !hasEdge(connected, a, c) and !hasEdge(connected, b, d);
            bool op3 = !hasEdge(connected, a, d) and !hasEdge(connected, b, c);

            return op1 or op2 or op3;
        }
        else return false;

        return true;
    }
};