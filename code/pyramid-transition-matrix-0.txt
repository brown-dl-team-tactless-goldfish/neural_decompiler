struct hashMap{
    char value;
    struct hashMap *next;
}hash[26][26];
void addHash(char* str){
    int i=str[0]-'A';
    int j=str[1]-'A';
    if(hash[i][j].value==str[2]){
        return ;
    }else if(hash[i][j].value=='\0'){
        hash[i][j].value=str[2];
    }else{
        struct hashMap *p=&hash[i][j];
        while(p->next&&p->value!=str[2]){
            p=p->next;
        }
        if(p->value==str[2]){return ;}
        struct hashMap *q=(struct hashMap *)malloc(sizeof(struct hashMap));
        q->value=str[2];
        q->next=NULL;
        p->next=q;
    }
}
bool flag;
bool pyramidTransition(char* bottom, char** allowed, int allowedSize) {
    flag=false;
    for(int i=0;i<26;i++){
        for(int j=0;j<26;j++){
            hash[i][j].value='\0';
            hash[i][j].next=NULL;
        }   
    }
    for(int i=0;i<allowedSize;i++){
        addHash(allowed[i]);
    }
    int len=strlen(bottom);
    char *bottomTemp=(char*)malloc(len*sizeof(char));
    int count=0;
    struct hashMap *p=&hash[bottom[0]-'A'][bottom[1]-'A'];
    while(p!=NULL&&p->value!='\0'){
        bottomTemp[count]=p->value;
        function(bottomTemp,count+1,&bottom[1]);
        if(flag){return true;}
        p=p->next;
    }
    return false;
}
void function(char* bottomTemp,int count,char* bottom){
    if(strlen(bottom)<2){
        if(count==1){
            flag=true;
            return ;
        }
        char *temp=(char*)malloc(count*sizeof(char));
        function(temp,0,bottomTemp);
        return ;
    }
    struct hashMap *p=&hash[bottom[0]-'A'][bottom[1]-'A'];
    while(p!=NULL&&p->value!='\0'){
        if(flag){return ;}
        bottomTemp[count]=p->value;
        function(bottomTemp,count+1,&bottom[1]);
        p=p->next;
    }
}