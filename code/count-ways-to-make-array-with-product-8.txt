int P = 1000000000 + 7;
#define N  10005
int seive[N];
int f[N];
int invf[N];

int power(int a, int n){
    int ans = 1;
    while(n > 0){
        if(n%2 == 1){
            n--;
            ans = (a*1LL*ans)%P;
        }
        n /= 2;
        a = (a * 1LL * a)%P;
    }
    return ans;
}

void seive_maker(){
    for(int i = 0 ; i < N; i++) seive[i] = -1;
    seive[0] = seive[1] = 1;

    for(int i = 2 ; i <= int(sqrt(N)); i++){
        if(seive[i] == -1) {
            for(int j = i ; j < N ; j += i){
                if(seive[j] == -1) seive[j] = i;
            }
        }
    }
}

void factorial(){
    f[0] = f[1] = 1;
    for(int i =2; i < N; i++) f[i] = (i * 1LL * f[i-1])%P;
}

void inverse_factorial(){
    for(int i = 0 ; i < N ; i++){
        invf[i] = power(f[i], P-2);
    }
}

int C(int n, int k){
    if(n < k) return 0;
    int ans = f[n];
    ans = (ans* 1LL * invf[k])%P;
    ans = (ans* 1LL * invf[n-k])%P;
    return ans;
}

void preprocess(){
    seive_maker();
    factorial();
    inverse_factorial();
}

class Solution {
public:
    vector<int> waysToFillArray(vector<vector<int>>& queries) {
        preprocess();

        vector<int> ans;
        for( auto query:queries){
            unordered_map<int, int> m;
            int k = query[1];
            int n = query[0];
            while(k > 1){
                int tmp = seive[k];
                k /= tmp;
                if(m.find(tmp) == m.end()) m[tmp] = 1;
                else m[tmp]++;
            }
            
            int val = 1;
            for(auto p:m){
                val = (val *1LL* C(n + p.second -1, p.second))%P;
            }
            ans.push_back(val);
        }
        return ans;
    }
};