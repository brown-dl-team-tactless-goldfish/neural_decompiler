struct Node{
        int sid;
        int endTime;
    };
    
    struct CompareTime{
        bool operator()(const Node & lhs, const Node & rhs){
           return lhs.endTime > rhs.endTime; 
        }
    };
    
    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {
        if(arrival.size() <= k){
            vector<int> ans;
            for(int i=0;i<min((int)arrival.size(), k);i++)
                ans.push_back(i);
            return ans;
        }
        vector<bool> available(k, true);
        priority_queue<Node, vector<Node>, CompareTime> pq;
        unordered_map<int, int> count;
        set<int> availableServers;
        
        for(int i=0;i<k;i++)
            availableServers.insert(i);
        
        int maxCount = -1;
        
        for(int i=0;i<arrival.size();i++){
            while(!pq.empty() && pq.top().endTime <= arrival[i]){
                availableServers.insert(pq.top().sid);
                available[pq.top().sid] = true;
                pq.pop();
            }
            if(available[i%k]){
                count[i%k]++;
                maxCount = max(maxCount, count[i%k]);
                available[i%k] = false;
                availableServers.erase(i%k);
                Node n;
                n.sid = i%k;
                n.endTime = arrival[i] + load[i];
                pq.push(n);
            }
            else if(!available[i%k] && !availableServers.empty()){
                int id = -1;
                auto it = availableServers.lower_bound(i%k);
                auto it2 = availableServers.lower_bound(INT_MAX);
                if(i%k < *it)
                    id = *it;
                if( availableServers.size() > 1 && *it == *it2 && ( i%k > *it)){
                    auto it3 = availableServers.begin();
                    id = *it3;
                }
                else if(availableServers.size() == 1 ){
                    auto it3 = availableServers.begin();
                    id = *it3;
                }
                if(id!= -1 && available[id]){
                    available[id] = false;
                    availableServers.erase(id);
                    count[id]++;
                    maxCount = max(maxCount, count[id]);
                    Node n;
                    n.sid = id;
                    n.endTime = arrival[i]+ load[i];
                    pq.push(n);
                }
            }
        }
        vector<int> ans;
        for(auto it = count.begin(); it!= count.end(); it++)
            if(it->second == maxCount)
                ans.push_back(it->first);
        return ans;
        
    }