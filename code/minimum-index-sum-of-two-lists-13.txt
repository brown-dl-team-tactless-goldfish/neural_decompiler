hash_table* my_hash_table;
char** ret_rest;
int cur_index = -1;
int ret_num = 0;
uint32_t cur_min_value = 0xFFFFFFFF;
int ret;
int value;

char temp[10];


if (list1 == NULL || list2 == NULL)
    return NULL;

// Allocate output list according to the longest favorite list
if(list1Size < list2Size){
    ret_rest = (char**)malloc(sizeof(char*) * list2Size);
    for (int i = 0; i < list2Size; i++)
        ret_rest[i] = NULL;
}
else{
    ret_rest = (char**)malloc(sizeof(char*) * list1Size);
    for (int i = 0; i < list1Size; i++)
        ret_rest[i] = NULL;
}

// Initialize hash table
my_hash_table = init_hash_table(list1Size + list2Size);
if (my_hash_table == NULL)
    return NULL;

//insert list1 to hash table
for (int i = 0; i < list1Size; i++)
{
    my_hash_table->insert(my_hash_table, list1[i], i);
}

// search list2
for(int i=0; i<list2Size; i++)
{
    // check if the favorite resaurant in list2 exists in hash table
    ret = my_hash_table->get_val(my_hash_table, list2[i], &value);
    if(ret != -1)
    {
        value = value + i; // sum of index
        if(value < cur_min_value) // got a smaller sum
        {
            if(cur_index == -1) //output list is empty
            {
                cur_index++;
                ret_rest[cur_index] = strdup(list2[i]);
                ret_num++;
            }
            else
            {   // reset output list directly to save some time
                // TODO: free all allocated spaces
                free(ret_rest[0]);
                ret_rest[0] = strdup(list2[i]);
                cur_index = 0;
                ret_num = 1;
            }
            
            cur_min_value = value;
        }
        else if(value == cur_min_value) //just insert the restaurant in output list
        {
            cur_index++;
            ret_rest[cur_index] = strdup(list2[i]);
            ret_num++;
        }
    }
}

*returnSize = ret_num;
return ret_rest;