typedef struct{
    unsigned int   val; 
    char  str[11];
    int   count;
}Dictory;

unsigned int SDBMHash(char *str)
{
	unsigned int hash = 0;

	while (*str)
	{
		hash = (*str++) + (hash << 6) + (hash << 16) - hash;
	}

	return (hash & 0x7FFFFFFF);
}

int cmpfunc(const void* a, const void* b){
    Dictory A = *(Dictory*)a; 
    Dictory B = *(Dictory*)b;
    if(A.count == B.count)
        return strcmp(B.str, A.str); 
    
    return A.count - B.count;
}

char ** topKFrequent(char ** words, int wordsSize, int k, int* returnSize){
    Dictory* hash = malloc(wordsSize * sizeof(Dictory));
    for(int i = 0; i < wordsSize; i++){
        hash[i].count = 0;   
    }

    for(int i = 0; i < wordsSize; i++){
        unsigned int H = SDBMHash(words[i]);
        if(hash[H%wordsSize].count == 0){
            hash[H%wordsSize].count = 1;
            strcpy(hash[H%wordsSize].str , words[i] ); 
            hash[H%wordsSize].val = H;
        }
        else if(hash[H%wordsSize].val == H){
            hash[H%wordsSize].count++;    
        }
        else{
            int k = (H%wordsSize + 1) % wordsSize;
            bool doneFlag = false;
            while(hash[k].count != 0){
                if(hash[k].val == H){ 
                    hash[k].count++; 
                    doneFlag = true;
                    break;
                }
                k = (k + 1) % wordsSize;
            }
            if(doneFlag == false){
                hash[k].val = H;
                hash[k].count = 1;
                strcpy(hash[k].str , words[i] ); 
            }
        }
    }

    qsort(hash, wordsSize, sizeof(Dictory), cmpfunc);

    char** ans = malloc(k * sizeof(char*));
    for(int i = 0; i < k; i++){
        int len = strlen(hash[wordsSize-1 - i].str );
        ans[i] = malloc( (len + 1) * sizeof(char));
        ans[i][len] = '\0';
        strcpy(ans[i], hash[wordsSize-1 - i].str);
    }
    free(hash);
    *returnSize = k;
    return ans;
}