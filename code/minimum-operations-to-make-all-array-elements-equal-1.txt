int cmp(const void *a, const void *b){ return(*(int*)a - *(int*)b);}
/*
  1 3  6  8
0 1 4 10 18
if(q=5), l = 2, 5 * l - 4 + 18 - 4 - 5*(4 - 2)
*/
long long* minOperations(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize){
    long long* prefixSum = (long long*)calloc(numsSize + 1, sizeof(long long));
    long long* ans = (long long*)calloc(queriesSize, sizeof(long long));
	/* sort nums */
    qsort(nums, numsSize, sizeof(int), cmp);
	/* calculate prefixsum */
    for(int i = 1; i <= numsSize; i++)
        prefixSum[i] = prefixSum[i - 1] + nums[i - 1];
	/* binary search to find out the index in nums that larger than queries[i] */
    for(int i = 0; i < queriesSize; i++){
        /* use binary search to find out the query 's position in the nums */
        if(queries[i] < nums[0])
            ans[i] = prefixSum[numsSize] - (long long)queries[i] * numsSize;
        else if(queries[i] > nums[numsSize - 1])
            ans[i] = (long long)queries[i] * numsSize - prefixSum[numsSize];
        else{
            /* we want to find nums[l] > q[i] */
            int l = 0, r = numsSize - 1, m;
            while(l < r){
                m = l + ((r - l) >> 1);
                if(nums[m] < queries[i])
                    l = m + 1;
                else //if(nums[m] > queries[i])
                    r = m;
            }
            /* int left = queries[i] * l - prefixSum[l] // means nums less than queries
             * int right = prefixSum[numsSize] - prefixSum[l] - queries[i] * (numsSize - l); // means nums laret than queries
             * ans[i] = left + right; */
            ans[i] = (long long)queries[i]*(2 * l - numsSize) + prefixSum[numsSize] - 2 * prefixSum[l];
        }
    }
    *returnSize = queriesSize;
    return ans;
}