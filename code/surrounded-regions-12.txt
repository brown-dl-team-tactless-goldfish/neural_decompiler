void dfs(char **board, int i, int j, int row_sz, int col_sz)
{
    /// No need to go to the depths now
    if('X' == board[i][j])
    {
        return;
    }
    /// Already processed
    if('K' == board[i][j])
    {
    	return;
    }
    board[i][j] = 'K';
    
    /// Traverse the four connected nodes
    if(j-1 > 0)
        dfs(board, i, j-1, row_sz, col_sz);
    if(j+1 < col_sz)
        dfs(board, i, j+1, row_sz, col_sz);
    if(i-1 > 0)
        dfs(board, i-1, j, row_sz, col_sz);
    if(i+1 < row_sz)
        dfs(board, i+1, j, row_sz, col_sz);
}



void solve(char** board, int boardSize, int* boardColSize){
  
    if(NULL == board) return;
    if((boardSize <= 1) || (*boardColSize <= 1)) return;

    int row_sz = boardSize;
    int col_sz = *boardColSize;

    int i,j;
    /// Start traversing through the boundaries
    /// There are a total of four boundaries
    ///i=0, j=0->col_sz
    for(j=0;j<col_sz;j++)
    {
        if(board[0][j] == 'O') dfs(board, 0, j, row_sz, col_sz);
    }
    ///i=0->row_sz, j=col_sz-1
    for(i=0;i<row_sz;i++)
    {
        if(board[i][col_sz - 1] == 'O') 
            dfs(board, i, col_sz - 1, row_sz, col_sz);
    }
    ///i=row_sz-1, j=0->col_sz
    for(j=0;j<col_sz;j++)
    {
        if(board[row_sz-1][j] == 'O')
        	dfs(board, row_sz - 1, j, row_sz, col_sz);
    }
    ///i=0->row_sz, j=0
    for(i=0;i<row_sz;i++)
    {
        if(board[i][0] == 'O') 
            dfs(board, i, 0, row_sz, col_sz);
    }
    
    /// Iterate to replace all 'K' with 'O'
    /// Change all others to 'X'
    for(i=0;i<row_sz;i++)
    {
    	for(j=0;j<col_sz;j++)
    	{
    		if(board[i][j] == 'K') board[i][j] = 'O';
    		else board[i][j] = 'X';
     	}
    }
    
}
