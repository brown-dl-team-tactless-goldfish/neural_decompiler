class Solution
{
private:
    int _good_leaf_node_pairs;
    int _max_distance;
    TreeNode* _root;
    
public:
    int countPairs(TreeNode* root, int max_distance)
    {
        _good_leaf_node_pairs = 0;
        _max_distance = max_distance;
        
        descend(root, nullptr);
        
        return _good_leaf_node_pairs / 2;
    }
    
    void descend(TreeNode* node, TreeNode* sibling, TreeNode* parent)
    {
        TreeNode back(node->val, sibling, parent);
        if (parent == nullptr)
        {
            _root = &back;
        }
        descend(node, &back);
    }
    
    void descend(TreeNode* node, TreeNode* parent)
    {
        bool leaf = true;
        
        TreeNode* left = node->left;
        TreeNode* right = node->right;
        
        if (left)
        {
            descend(left, right, parent);
            leaf = false;
        }
        
        if (right)
        {
            descend(right, left, parent);
            leaf = false;
        }
        
        if (leaf && parent)
        {
            ascend(parent, _max_distance - 1);
        }
    }

    void ascend(TreeNode* node, int distance)
    {
        bool leaf = true;
        
        TreeNode* left = node->left;
        TreeNode* right = node->right;
        
        if (left)
        {
            if (distance > 0)
            {
                ascend(left, distance - 1);
            }
            leaf = false;
        }
        
        if (right)
        {
            if (distance > 0)
            {
                ascend(right, distance - 1);
            }
            leaf = false;
        }
        
        // root node cannot be a leaf when the tree is rotated.
        if (leaf && node != _root)
        {
            _good_leaf_node_pairs += 1;
        }
    }
};