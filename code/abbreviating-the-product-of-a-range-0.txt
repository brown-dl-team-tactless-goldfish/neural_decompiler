#define MAX_CONTIGUOUS 10000000000ULL

char *abbreviateProduct(int left, int right){
    // Max size: #####...#####e####
    char* ret = calloc(19, sizeof(char));
    
    uint64_t product = 0;
    uint32_t top = 0;
    uint32_t bottom = 0;
    // 10000! has 2499 trailing zeros
    uint16_t numZeros = 0;
    
    { // Num zeros
        uint16_t numTwos = 0;
        uint16_t numFives = 0;

        for (uint16_t m = left; m <= right; m++) {
            uint16_t cur = m;
            
            for(; (cur % 2) == 0; cur /= 2, numTwos++);
            for(; (cur % 5) == 0; cur /= 5, numFives++);
        }
        
        numZeros = (numTwos < numFives) ? numTwos : numFives;
    }
    
    { // Bottom 5 digits
        uint16_t numTwos = numZeros;
        uint16_t numFives = numZeros;

        bottom = 1;
        product = 1;
        for (uint16_t m = left; m <= right; m++) {
            uint16_t cur = m;
            
            for(; (cur % 2) == 0 && numTwos  > 0; cur /= 2, numTwos--);
            for(; (cur % 5) == 0 && numFives > 0; cur /= 5, numFives--);
            
            bottom *= cur;
            bottom %= 100000;
            
            if (product < MAX_CONTIGUOUS) {
                product *= cur;
            }
        }
    }
    
    // Top 5 digits
    if (product >= MAX_CONTIGUOUS) { 
        // 'long double' precision is required for all tests to pass.
        long double sum = 0;
        double temp = 0;
        
        for (double m = left; m <= right; m++) {
            sum += log10(m);
        }
        
		// Set sum to fraction part of the double
        sum = modf(sum, &temp);
        top = floor(pow(10.0, 4.0 + sum));
    }
    
    if (product < MAX_CONTIGUOUS) {
        sprintf(ret, "%llue%lu", product, numZeros);
    } else {
        sprintf(ret, "%lu...%05lue%lu", top, bottom, numZeros);
    }
    
    return ret;
}