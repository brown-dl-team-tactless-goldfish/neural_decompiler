class Solution {
public:
    struct pair_hash
{
    template <class T1, class T2>
    std::size_t operator () (std::pair<T1, T2> const &pair) const
    {
        std::size_t h1 = std::hash<T1>()(pair.first);
        std::size_t h2 = std::hash<T2>()(pair.second);
 
        return h1 ^ h2;
    }
};
    int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {
        vector<vector<int>> dirs = { {-1,0}, {0,1}, {1,0}, { 0, -1} };
        
        int x = 0, y = 0;
        int di = 1;
        int ans = 0;
        
        // store obstacles in a hashmap
        unordered_set< pair<int,int> , pair_hash > st;
        for(auto it : obstacles){
            st.insert({it[0],it[1]});
        }
                            
        // traverse the command array
        for(auto it : commands){
            if(it == -1){
                di = (di+1)%4;
            }
            else if(it == -2){
                di = (di+4-1)%4;
            }
            else{
                
                int x_dest = x + dirs[di][0] * it;
                int y_dest = y + dirs[di][1] * it;
                while(x != x_dest || y != y_dest ){
                    x = x + dirs[di][0] * 1;
                    y = y + dirs[di][1] * 1;
                    if(st.find({x,y}) != st.end()){
                          x = x - dirs[di][0] * 1;
                          y = y - dirs[di][1] * 1;
                          break;
                    }
                   
                    
                }
                 ans = max(ans,x*x + y*y);
            }
        }
                            
        return ans;
                            
                            
        
                            
        
    }
};