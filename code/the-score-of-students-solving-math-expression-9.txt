// 2019. The Score of Students Solving Math Expression
class Solution {
    using IntSet = unordered_set<short>;
public:
    int scoreOfStudents(string s, vector<int>& answers) {
        // idea: DP in 2D, bottom-up.
        // the incorrect evaluation order of the expression includes
        // all the differently-structured trees of these k ops and k+1 numbers.
        // let f[i..j] represent the set of possible results of evaluating the sub-expression
        // s[i..j]. then, we have:
        //  a) len1: f[i..i] is { digit(s[i]) }.
        //      e.g. "3", "8"
        //  b) len3: f[i...i+2] is { digit(s[i]) + or * digit(s[i+2] }
        //      e.g. "3*6", "1+9"
        //  c) len5+: f[i...j] is:
        //        `f[i...k-1] op_k f[k+1...j]`,  for k in i+1 to j-1, s[k] is an op.
        //      e.g. "1+2*3", "1*2*3+4*5"
        // note that s[i] and s[j] are digits, where s[k] is an operator.
        // Because the search space is dense, we'll use the Bottom-Up DP.
        const int n = s.size();
        vector<vector<IntSet>> f(n, vector<IntSet>(n)); // only ~1/4 of cells will populate.
        // len1
        for (int i = 0; i < n; i += 2) {
            f[i][i].insert(toNumber(s[i]));
        }
        // len3
        for (int i = 0; i + 2 < n; i += 2) {
            const int j = i + 2;
            char op = s[i + 1];
            int a = toNumber(s[i]);
            int b = toNumber(s[j]);
            f[i][j].insert(op == '*' ? a * b : a + b);
        }
        // len 5, 7, ... the general case:
        // c) len5+: f[i...j] is:
        //  `f[i...k-1] op_k f[k+1...j]`,  for k in i+1 to j-1, s[k] is an op.
        for (int len = 5; len <= n; len += 2) {
            for (int i = 0; i + len - 1 < n; i += 2) {
                const int j = i + len - 1;
                for (int k = i + 1; k <= j - 1; k += 2) { // s[k] is an op
                    combinePossibleResults(f[i][k - 1], f[k + 1][j], s[k], f[i][j]);
                }
            }
        }
        auto possibleResults = std::move(f[0][n - 1]);
        f.clear();
        // print(s, possibleResults);

        const int correctResult = computeCorrectResult(s);
        // cout << "the correct result is " << correctResult << endl;

        int scores = 0;
        for (auto studentAnswer : answers) {
            if (studentAnswer == correctResult) {
                scores += 5;
            } else if (possibleResults.count(studentAnswer)) {
                scores += 2;
            }
        }

        return scores;
    }

    static void
    combinePossibleResults(const IntSet& A, const IntSet& B, char op, IntSet& combined) {
        for (const auto x : A) {
            for (const auto y : B) {
                int res = op == '*' ? x * y : x + y;
                // necessary optimization, otherwise it will Time Limit Exceeded TLE:
                // we can do this, because it's guaranteed that answers[i] <= 1000.
                if (res <= 1000) {
                    combined.insert(res);
                }
            }
        }
    }

    static inline int toNumber(char c) {
        return c - '0';
    }

    static void print(const string& expr, const IntSet& possibleResults) {
        cout << "Possible results for computing `" << expr << "` is: " << endl;
        for (auto x : possibleResults) {
            cout << x << ", ";
        }
        cout << endl;
    }

    static inline int computeCorrectResult(const string& expression) {
        // the current impl. is a simple one.
        // todo: implement the Shunting Yard algorithm, which is general purpose.

        // 3 <= s.length <= 31

        int result = 0;
        // 1*2+3
        // 1+2+3
        // search for `+` op in the expression
        int product = 0;
        int numCountForProduct = 0;
        for (int i = 1; i < expression.size(); i += 2) {
            char op = expression[i];
            if (op == '+') {
                if (numCountForProduct == 0) {
                    // 1+2+3
                    // 1+2*3
                    result += (expression[i - 1] - '0');
                } else {
                    result += product;
                    product = 0;
                    numCountForProduct = 0;
                }
                // if it's the last op, we'll add up the last number
                if (i == expression.size() - 2) {
                    result += (expression[i + 1] - '0');
                }
            } else if (op == '*') {
                if (numCountForProduct == 0) {
                    numCountForProduct += 2;
                    product = (expression[i - 1] - '0') * (expression[i + 1] - '0');
                } else {
                    ++numCountForProduct;
                    product *= (expression[i + 1] - '0');
                }
                // if it's the last op, we'll add up the last product
                if (i == expression.size() - 2) {
                    result += product;
                    product = 0;
                    numCountForProduct = 0;
                }
            } else {
                assert(false);
            }
        }

        return result;
    }
};
