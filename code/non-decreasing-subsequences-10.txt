class Solution {
    vector<vector<int>>result;
    set<vector<int>>st;
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        // sort(nums.begin(),nums.end());
        if(nums.size()<2)
            return {};
        vector<int>v;
        fun(nums,0,v);
        for(auto v:st)
            result.push_back(v);
        return result;
    }
    void fun(vector<int>&nums,int index,vector<int>&v)
    {   
      // cout<<"hello"<<endl;
        if(index==nums.size())
        {if(v.size()>=2)
                st.insert(v);
            return;
        }
        
        if(v.empty()||v.back()<=nums[index])
        {  
            
           // Choose the current element
            // Do pre-calculation
              v.push_back(nums[index]);
              fun(nums,index+1,v);
            // Do post-calculation
              v.pop_back();
          
        
        }
        
       
        
         // Not Choose
            fun(nums,index+1,v);
        
    }
   
};

Time Complexity: O(k*logn), k is all possible increasing subsequence.
Space Complexity: O(n)