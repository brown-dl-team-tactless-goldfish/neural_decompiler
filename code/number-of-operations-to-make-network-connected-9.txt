//use dfs
//adjacency_list
//to connect n nodes you need to have n-1 edges
// if you have number of edges > number of connected components
// if yes then no of connected components is the answer

struct adjacency_list
{
    int key;
    struct adjacency_list *next;
};

struct adjacency_list *new_node(struct adjacency_list *node, int key)
{
    struct adjacency_list *temp = malloc(sizeof(struct adjacency_list));
    temp->key = key;
    temp->next = node;
    return temp;
}

void make_adjacency_list(struct adjacency_list *adjacency_list[], int n, int **connections, int connectionsSize)
{
    for (int i = 0; i < n; i++)
    {
        adjacency_list[i] = NULL;
    }
    for (int i = 0; i < connectionsSize; i++)
    {
         adjacency_list[connections[i][0]] = new_node(adjacency_list[connections[i][0]], connections[i][1]);
        adjacency_list[connections[i][1]] = new_node(adjacency_list[connections[i][1]], connections[i][0]);
        
    }
}


//number of nodes is n
//this implies that minimum number of edges to connect every node will be n-1
//counted the number of edges using dfs
// edges_count is incremented every time a new node is pushed into the stack
//stack is implicit in this case because I am using recursive DFS is used instead of iterative where actual stack is used

void DFS(int i, struct adjacency_list *adjacency_list[], int n, bool visited[])
{
    if (visited[i])
    {
        return;
    }
    visited[i] = true;
    struct adjacency_list *temp ;
    temp = adjacency_list[i];
    while (temp)
    {
        if (!visited[temp->key])
        {
            DFS(temp->key, adjacency_list, n, visited);
        }
        temp = temp->next;
    }
}

int makeConnected(int n, int **connections, int connectionsSize, int *connectionsColSize)
{
    struct adjacency_list *adjacency_list[n];
    make_adjacency_list(adjacency_list, n, connections, connectionsSize);
    

    //Initialising visited to false because initially no node is visited
    bool visited[n];
    for (int i = 0; i < n; i++)
    {
        visited[i] = false;
    }
    //  printf("Edges count : %d\n")
    //each DFS will visit all the nodes connected to the source vertex hence number of dfs calls is the number of connected components
    int connected_comps = 0;
    for (int i = 0; i < n; i++)
    {
        if (!visited[i])
        {
            connected_comps++;

            DFS(i, adjacency_list, n, visited);
        }
    }
    //no of edges is less than minimum no of edges required implies connecting every node is impossible
    // the number of elements in connections is the number of edges in the graph 
    if (connectionsSize < n - 1)
    {
        return -1;
    }
    
    //if connectionSize is > n-1 then it means there are enough edges
    //if there are 'n' connected components then we have to shift n-1 connected components to connect them all
    return connected_comps - 1;
}