class Solution {
public:
    int minimumEffortPath(vector<vector<int>>& heights) {
        int n = heights.size();
        int m = heights[0].size();
        using loc = int;
        
        vector<loc> efforts(n*m, INT_MAX);
        
        auto comp = [&](int loc1, int loc2) {
            return efforts[loc1] > efforts[loc2];
        };
        
        priority_queue<int,vector<int>,decltype(comp)> pq(comp);
    
        
        efforts[0] = 0;        
        pq.push(0);
        
        int xdirs[4] = {-1,0,1,0};
        int ydirs[4] = {0,-1,0,1};
        
        while(!pq.empty()) {
            auto top = pq.top();
            pq.pop();
            int r = top/m;
            int c = top%m;
            
            for(int i = 0; i < 4; ++i){
                int nr = r + xdirs[i];
                int nc = c + ydirs[i];
                
                if(nr >= 0 && nr < n && nc >= 0 && nc < m) {
                    int effort = abs(heights[nr][nc] - heights[r][c]);
                    int maxEffort = max(efforts[r*m + c], effort);
                    int newLoc = nr*m + nc;

                    if(maxEffort < efforts[newLoc]) {
                        efforts[newLoc] = maxEffort;
                        pq.push(newLoc);
                    }    
                }
            }
        }
        
        return efforts[(n - 1)*m + m - 1];
    }
};