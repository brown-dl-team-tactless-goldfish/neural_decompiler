//cheapest path function will be reccursive in nature
//cheapest path function should return the cheapest price required to reach the destination 
int cheapest_path_core(int** path_traveled,int n, int** flights, int flightsSize, int* flightsColSize, int src, int dst, int k){
int min_return  = 50000;
//condition to check if the path_traveled array elemnt is already populated
if(path_traveled[k][src] !=0){return path_traveled[k][src];}
//condtion to check if the source and destination are same meaning we have reached the destination
if(src == dst){return 0;} //inidcating we have reached the destination 
//condtion to check if we have reached to thelas traversal point on the path to reach destination 
if(k == 0){
    //we need to check if we can reach the destiantion at any cost in this condition else return 
    //return we cannot reach destaintion 
    for(int city = 0; city < flightsSize; city ++){
        if(flights[city][0] == src && flights[city][1] == dst){
            return flights[city][2];
        }
    }
    return min_return;   //failure condtion value to return for not finding direct flight 
}
//considering codition where all the above condtions are not meet
//ie path traveled is the first time value to enter into function 
//ie source and destinations are not same 
//ie we have option of more than 0 to hop the city 
for(int city = 0; city < flightsSize; city ++){
    //we wil fist check if the flight orginates from the source in array of flights 
    if(flights[city][0] == src){ 
         //then we will check if the current path reaveld value is set to zero
         if(path_traveled[k-1][flights[city][1]] == 0){
             //reccursive call of the function with updated source value and updated hopping value
             path_traveled[k-1][flights[city][1]] = cheapest_path_core(path_traveled,n,flights,flightsSize,flightsColSize,flights[city][1],dst,k-1);
         }
         //cost of the current flight is added 
         int current_cost =  path_traveled[k-1][flights[city][1]] + flights[city][2];
         if(min_return > current_cost){min_return = current_cost;}
    }
}
return min_return;   //failure condtion value to return for not finding direct flight 
}

int findCheapestPrice(int n, int** flights, int flightsSize, int* flightsColSize, int src, int dst, int k){
    //we will create a na array to trace / hold the values of the route to be taken to reach the destination from source 
    //2 2 diamensional array with memeory allocation for pointer
    int** path_traveled = (int**)malloc(sizeof(int*)*(k+1));
    //elemnts of the array are to be given memeory allocation 
    for(int idx =0; idx < k+1; idx++){
        path_traveled[idx] = (int*)calloc(n+1,sizeof(int));
    }
    //we will now create a function to calculate the cheapest path using the path_traveld_array
    int lowest_cost = cheapest_path_core(path_traveled,n,flights,flightsSize,flightsColSize,src,dst,k);

    //clear the memeory allocation 
    for(int idx =0; idx <  k+1; idx++){
        free(path_traveled[idx]);
    }
    free(path_traveled);
    return lowest_cost >= 50000 ? -1 : lowest_cost;
}