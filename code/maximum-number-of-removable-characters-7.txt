class Solution {
public:
    int maximumRemovals(string s, string p, vector<int>& removable) {
        int remLen = removable.size();
        if (remLen == 0) {
            return 0;
        }
        
        int l = 0, r = remLen, m;
        bool found;
        while (l < r) {
            m = l + (r - l) / 2;
            found = isStillSubSeq(s, p, m, removable);
            if (l == m) {
                break;
            }
            if (found == true) {
                l = m;
            }
            else {
                r = m - 1;
            }
        }
        
        // L is minimum answer
        // Check right side only
        for (int i = l + 1; i <= remLen && isStillSubSeq(s, p, i, removable); i++) {
            l = max(l, i);
        }
        
        return l;
    }
    
    bool isStillSubSeq(string &s, string &p, int k, vector<int> &rem) {
        stack<pair<int, char>> backup;
        for (int i = 0; i < k; i++) {
            backup.push({ rem[i], s[rem[i]] });
            s[rem[i]] = '*';
        }
        // Check if still subsequence
        bool subsec = isPsubsecOfS(s, p);
        // Backtracking
        for (; !backup.empty(); backup.pop()) {
            s[backup.top().first] = backup.top().second;
        }
        return (subsec == true);
    }
    
    bool isPsubsecOfS(string &s, string &p) {
        int pi = 0;
        int si = 0;
        while (pi < p.size() && si < s.size()) {
            if (s[si] == '*') {
                si++;
            }
            else if (s[si] == p[pi]) {
                si++;
                pi++;
            }
            else {
                si++;
            }
        }
        return pi >= p.size();
    }
};