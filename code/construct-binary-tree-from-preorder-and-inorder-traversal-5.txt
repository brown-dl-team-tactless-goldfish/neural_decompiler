struct TreeNode * conTree(int * preorder, int * pre_counter, int * inorder, int root, int left, int right);

struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize){
    if (preorderSize == 0)
        return NULL;
    int root_value = preorder[0];
    int pre_counter = 0;
    int i;
    for (i = 0; i < inorderSize; i++){
        if (root_value == inorder[i])
            break;
    }
    return conTree(preorder, &pre_counter, inorder, i, 0, inorderSize - 1);
}

struct TreeNode * conTree(int * preorder, int * pre_counter, int * inorder, int root, int left, int right){
    if (left >= right){
        struct TreeNode * re = malloc(sizeof(struct TreeNode));
        re->left = NULL;
        re->right = NULL;
        re->val = inorder[right];
        return re;
    }
    struct TreeNode * rootNode = malloc(sizeof(struct TreeNode));
    rootNode->val = inorder[root];
    int left_index, right_index;
    int left_root, right_root;
    int i;
    if (left < root){
        *pre_counter = *pre_counter + 1;
        left_root = preorder[*pre_counter];
        for (i = left; i < root; i++){
            if (inorder[i] == left_root)
                break;
        }
        left_index = i;
        rootNode->left = conTree(preorder, pre_counter, inorder, left_index, left, root - 1);
    }
    else
        rootNode->left = NULL;
    if (right > root){
        *pre_counter = *pre_counter + 1;
        right_root = preorder[*pre_counter];
        for (i = root + 1; i <= right; i++){
            if (inorder[i] == right_root)
                break;
        }
        right_index = i;
        rootNode->right = conTree(preorder, pre_counter, inorder, right_index, root + 1, right);
    }
    else
        rootNode->right = NULL;
    return rootNode;
}