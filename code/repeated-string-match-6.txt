	int repeatedStringMatch(string A, string B) {
        // check whether all characters in B are also in A
        unordered_set<char> mset;
        for (char c : A)
            mset.insert(c);
        for (char c : B)
            if (mset.find(c) == mset.end())
                return -1;
        
        // find the minimum number of times A has to be repeated => R, if number > 1
        // A needs to have suffix that is same with B's prefix
        // A needs to have prefix that is same with B's suffix
        // R.size() = number * A.size()
        // B.size() = A.size() * (number - 2) + len(prefix) + len(suffix) <= R.size() = number * A.size()
        // => number >= B.size() / A.size()
        // B.size() > A.size() * (number - 2) => number < 2 + B.size()/A.size()
        // => B.size() / A.size() <= number < 2 + B.size()/A.size()
        string ss = A;
        int count = 1;
        while (ss.size() < B.size()) {
            ss += A;
            count++;
        }
        if (ss.find(B) != string::npos)
            return count;
        ss += A;
        if (ss.find(B) != string::npos)
            return count + 1;
        return -1;
    }