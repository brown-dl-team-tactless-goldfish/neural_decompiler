    vector<int> avoidFlood(vector<int>& rains) {
        vector<int> ans(rains.size(), -1);
        // hashmap to hold the index of previous rainy days
        std::unordered_map<int, int> previous;
        // Set to store the dry days index
        std::set<int> dryDays;
        
        for (int i = 0; i < rains.size(); i++) {
            if (rains[i] == 0) {
                // No rain this day, a dry day, save it in the
                // set and will use later
                dryDays.insert(i);
                // Store 1, in case if we choose to dry an empty lake
                ans[i] = 1;
            }
            else {
                if (previous.count(rains[i]) > 0) {
                    // The lake was already filled, need to see if there
                    // is any dry lake, after the last filled lake
                    auto it = dryDays.upper_bound(previous[rains[i]]);
                    // If there is no dry days, we can't avoid the flood,
                    // returning empty array
                    if (it == dryDays.end())
                        return {};
                    
                    // empty the lake that was previously filled
                    ans[*it] = rains[i];
                    // Erase the used dry day
                    dryDays.erase(it);
                }
                // store the index of the lake in the hash map
                previous[rains[i]] =  i;
            }
        }
        return ans;       
    }