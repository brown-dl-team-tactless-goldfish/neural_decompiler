using PII = pair<int, int> ;
class Solution {
    
public:
    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {
        int m = students.size() ;
        int n = students[0].size() ;
        const int Target = (1 << m) - 1 ;
        vector<vector<int>>unMatch(m, vector<int>(m)) ;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < m; j++){
                for(int k = 0; k < n; k++){
                    unMatch[i][j] += students[i][k] ^ mentors[j][k] ;
                }
            }    
        }
        vector<int>dp(1 << m, -1) ;
        priority_queue<PII, vector<PII>, greater<>>pq ;  //{notMatch, state}
        pq.push({0, 0}) ;
        
        while(!pq.empty()){
            auto [notMatch, state] = pq.top() ;
            pq.pop() ;
            if(dp[state] != -1)
                continue ;
            dp[state] = notMatch ;
            if(state == Target)
                return m*n - notMatch ;
            
            int j = __builtin_popcount(state) ;
            for(int i = 0; i < m; i++){
                if(((state >> i) & 1 ) == 1)
                    continue ;
                int next = state + (1 << i) ;
                if(dp[next] != -1)
                    continue ;
                pq.push({notMatch + unMatch[i][j], next}) ;
            }
        }
        return -1 ;
    }
};