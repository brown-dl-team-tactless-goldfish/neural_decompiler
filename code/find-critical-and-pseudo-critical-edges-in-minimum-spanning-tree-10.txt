class Solution {
  vector<int> par, sz, anc, w, depth; // par, sz -> used for union find || anc, w, depth -> used for dfs
  vector<vector<pair<int, int>>> adj; // used for dfs
  static bool compare(vector<int>& a, vector<int>& b) { 
    return a[2] < b[2];
  }
  // Union Find logic used from https://cp-algorithms.com/data_structures/disjoint_set_union.html
  int find(int node) { // finds the group to which node belongs to
    if (par[node] == node)
      return node;
    return par[node] = find(par[node]);
  }
  void merge(int a, int b) { // merges two nodes if they are in different groups
    a = find(a);
    b = find(b);
    if (a != b) {
      if (sz[a] < sz[b])
        swap(a, b);
      sz[a] += sz[b];
      par[b] = a;
    }
  } 
  int MST(int n, vector<vector<int>>& edges, int skip = -1) { // finds the MST of the graph with a skipped edge using Kruskal Algorithm
    par = vector<int>(n);
    sz = vector<int>(n, 1);
    anc = vector<int>(n, -1);
    w = vector<int>(n, -1);
    depth = vector<int>(n);
    adj = vector<vector<pair<int, int>>>(n);
    for (int i = 0; i < n; i++) par[i] = i;
    int m = edges.size();
    int cost = 0, links = 0;
    for (int e = 0; e < m; e++) {
      if (e == skip) continue;
      int a = edges[e][0], b = edges[e][1], weight = edges[e][2];
      if (find(a) != find(b)) {
        merge(a, b);
        links++;
        adj[a].push_back({b, weight});
        adj[b].push_back({a, weight});
        cost += weight;
      }
    }
    if (links < n - 1) // In case a tree is not formed, need to return Maximum cost
      return INT_MAX;
    return cost;
  }
  void dfs(int node, int par = -1) { // setting up the MST
    for (auto next : adj[node]) {
      int child = next.first;
      int cost = next.second;
      if (child != par) {
        depth[child] = depth[node] + 1;
        anc[child] = node;
        w[child] = cost;
        dfs(child, node);
      }
    }
  }
  bool checkWaste(int a, int b, int weight) { // Checking if a node is neither critical nor pseudo-critical
    int n1 = a, n2 = b;
    if (depth[n1] < depth[n2])
      swap(n1, n2);
    // always n1 is at higher depth
    int cost = INT_MIN;
    while (depth[n1] > depth[n2])
      cost = max(cost, w[n1]), n1 = anc[n1];
    // n1 and n2 are at same depth
    while (n1 != n2)
      cost = max(cost, w[n1]), cost = max(cost, w[n2]), n2 = anc[n2], n1 = anc[n1];
    return (weight > cost);
  }
public:
  vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {
    int m = edges.size();
    vector<int> type(m);
    for (int e = 0; e < m; e++)
      edges[e].push_back(e);
    sort(edges.begin(), edges.end(), compare);
    int MSTcost = MST(n, edges);

    for (int e = 0; e < m; e++) {
      int cost = MST(n, edges, e);
      int idx = edges[e][3];
      if (cost > MSTcost)
        type[idx] = 1;
    }
    MST(n, edges);
    dfs(0);
    for (int e = 0; e < m; e++) {
      int idx = edges[e][3];
      if (type[idx])
        continue;
      if (checkWaste(edges[e][0], edges[e][1], edges[e][2]))
        type[idx] = 3;
      else
        type[idx] = 2;
    }
    vector<vector<int>> ans(2);
    for (int e = 0; e < m; e++)
      if (type[e] == 1)
        ans[0].push_back(e);
      else if (type[e] == 2)
        ans[1].push_back(e);
    return ans;
  }
};