class Solution {
    // convert a word to bit mask
    int conv2mask(string s) {
        int mask = 0;
        for (char c: s)
            mask |= 1 << (c - 'a');
        return mask;
    }
    
    // generate valid word masks for a puzzle
    vector<int> genPuzzleMask(string s) {
        char f = s[0];
        // sort puzzle characters and deduplicate
        sort(s.begin(), s.end());
        vector<char> chs;
        for (char c: s)
            if (chs.empty() || c != chs.back())
                chs.push_back(c);
        
        // generate using bit manipulation
        int n = chs.size();
        vector<int> gen;
        for (int i = 0; i < (1 << n); i++) {
            int realMask = 0;
            for (int j = 0; j < n; j++) {
                if (i & (1 << j))
                    realMask |= 1 << (chs[j] - 'a');
            }
            // Note the restriction of the first char
            if (realMask & (1 << (f - 'a')))
                gen.push_back(realMask);
        }
        return gen;
    }
    
public:
    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {
        // store the bit masks of words in a map
        map<int, int> valPuz;
        for (string s: words) {
            int mask = conv2mask(s);
            valPuz[mask]++;
        }
        
        // generate and sum up
        vector<int> ans;
        for (string s: puzzles) {
            vector<int> masks = genPuzzleMask(s);
            int b = 0;
            for (int m: masks)
                b += valPuz[m];
            ans.push_back(b);
        }
        return ans;
    }
};