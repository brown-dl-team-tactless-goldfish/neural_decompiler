 public int MinFlips(int[][] mat) {
           int n = mat.Length;
            int m = mat[0].Length;
            Dictionary<string, int> countMap = new Dictionary<string, int>();
            HashSet<string> visitedMap = new HashSet<string>();
            int ans = FindMinFlip(mat, n, m, countMap, visitedMap);
            return ans == int.MaxValue ? -1 : ans;
        }

        public static int FindMinFlip(int[][] mat, int n, int m, Dictionary<string, int> countMap, HashSet<string> visitedMap)
        {
            if (IsZero(mat, n, m))
            {
                return 0;
            }
            StringBuilder builder = new StringBuilder();
            for(int r = 0; r < n; r++)
            {
                for (int c = 0; c < m; c++)
                {
                    builder.Append(Convert.ToString(mat[r][c]));
                }
            }
            string key = builder.ToString();
            // if this key combination is already computed, return from memo
            if (countMap.ContainsKey(key))
            {
                return countMap[key];
            }
            // if this combination is already seen in this recursion tree, return infinity value.
            if (visitedMap.Contains(key))
            {
                return int.MaxValue;
            }
            visitedMap.Add(key);
            int min = int.MaxValue;
            for(int i = 0; i < n; i++)
            {
                for (int j = 0; j < m; j++)
                {
                    // Flip (0, 0)
                    FlipValue(mat, i, j, n, m);
                    // Check if this combination brings down zero, without getting cycles infinite loop.
                    int stepCount = FindMinFlip(mat, n, m, countMap, visitedMap);
                    // Revert it back so that we will try out fliping the other element index and further to recursion.
                    if (stepCount != int.MaxValue)
                    {
                        min = Math.Min(min, 1 + stepCount);
                    }
                    FlipValue(mat, i, j, n, m);
                }
            }
            // When this combination ends, remove the visited map to keep it fresh for other keys.
            visitedMap.Remove(key);
            countMap.Add(key, min);
            return min;
        }

        public static void FlipValue(int[][] mat, int r, int c, int n, int m)
        {
            mat[r][c] ^= 1;
            if (r - 1 >= 0) mat[r - 1][c] ^= 1;
            if (r + 1 < n) mat[r + 1][c] ^= 1;
            if (c - 1 >= 0) mat[r][c-1] ^= 1;
            if (c + 1 < m) mat[r][c + 1] ^= 1;
        }

        private static bool IsZero(int[][] mat, int n, int m)
        {
            for (int r = 0; r < n; r++)
            {
                for (int c = 0; c < m; c++)
                {
                    if (mat[r][c] == 1)
                    {
                        return false;
                    }
                }
            }
            return true;
        }
		```