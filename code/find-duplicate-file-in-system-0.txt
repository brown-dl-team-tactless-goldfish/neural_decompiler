struct list{
    char Address[200];
    char Name[100];
    int App_count;
    int At;
};

char *** findDuplicate(char ** paths, int pathsSize, int* returnSize, int** returnColumnSizes){
    char address[200];
    char name[100];
    
    struct list txt[21000];
    for (int i = 0 ; i < 21000 ; i++){
        txt[i].App_count = 0;
    }

    char*** ans = malloc(sizeof(char**)*1000);
    (*returnColumnSizes) = malloc(sizeof(int)*1000);
    *returnSize = 0;
    
    for (int i = 0 ; i < pathsSize ; i++){
        int now = 0;
        while (paths[i][now] != ' '){
            address[now] = paths[i][now];
            now++;
        }
        int copy = now+1; 
        address[now] = '/';
        //目前位置在' '
        
        while (paths[i][now] != '\0'){    //查看目前是否為結束  這邊需要重複作業
            now++;                        //目前位置在空格後的第一個位置
            int address_count = copy;
            while (paths[i][now] != '('){                   //將位置繼續複製起來
                address[address_count] = paths[i][now];
                address_count++;
                now++;
            }
            address[address_count] = '\0';  //等等複製過去就好了
            address_count++;                //count = 長度 (加上/0)
            
            now++;                          //目前位置在'('後的下一格
            int num = -48;
            int name_count = 0;
            while (paths[i][now] != ')'){                   //將名稱複製起來
                name[name_count] = paths[i][now];
                num += paths[i][now];
                now++;
                name_count++;
            }
            name[name_count] = '\0';     //目前的文件名稱
            //目前位置在')'
            //查看是否有重複的
            num <<= 11;
            num %= 20077;
            while (txt[num].App_count != 0 && strcmp(txt[num].Name, name) != 0){   //如果被用過了 而且 也跟目前不同
                num++;
            }
            if (txt[num].App_count != 0){        //如果是被用過了 
                if (txt[num].App_count == 1){    //目前是第二次 所以要將舊資料加入
                    ans[*returnSize] = malloc(sizeof(char*)*3500);
                    (*returnColumnSizes)[*returnSize] = 1;
                    ans[*returnSize][0] = malloc(sizeof(char)*(strlen(txt[num].Address)+1));
                    strcpy(ans[*returnSize][0],txt[num].Address);
                    txt[num].At = *returnSize;
                    *returnSize += 1;    
                    txt[num].App_count++;
                }
                //將目前資料加入
                ans[txt[num].At][(*returnColumnSizes)[txt[num].At]] = malloc(sizeof(char*)*address_count);
                strcpy(ans[txt[num].At][(*returnColumnSizes)[txt[num].At]],address);
                (*returnColumnSizes)[txt[num].At] += 1;
            } else {                            //目前是第一次 先將資料存起來
                txt[num].App_count++;
                strcpy(txt[num].Address,address);
                strcpy(txt[num].Name,name);
            }
            now++;
        }
    }
    ans = realloc(ans,sizeof(char**)*(*returnSize));
    (*returnColumnSizes) = realloc((*returnColumnSizes),sizeof(int)*(*returnSize));
    for (int i = 0 ; i < *returnSize ; i++){
        ans[i] = realloc(ans[i],sizeof(char*)*((*returnColumnSizes)[i]));
    }
    return ans;
}