class Solution {
public:
    vector<int> recoverArray(vector<int>& nums) {
        int n = nums.size();
		// find all possible k
        unordered_set<long> ks;
        for (int i = 1; i < n; i++) {
            long sum = nums[i]+nums[0];
            if (!(sum&1))
                ks.insert(max(nums[0], nums[i])-(sum>>1));
        }
        sort(nums.begin(), nums.end());
        
		// iterate all possible k and use two pointers to check if it works
        vector<int> ans;
        for (auto k : ks) {
            if (!k) continue;
            
            long k2 = k<<1;
			// find the start position of upper to nums[0]
            int upperi = lower_bound(nums.begin(), nums.end(), nums[0]+k2) - nums.begin();
            if (upperi == n || nums[upperi] != nums[0]+k2) continue; // no such upper
            
            bool used[2000] = {};
            used[0] = used[upperi++] = true;
            ans.push_back(nums[0]+k);
            
            for (int loweri = 1; upperi < n; loweri++) {
                if (used[loweri]) continue;
                
                long upper = nums[loweri]+k2;
                while (upperi < n && (upper > nums[upperi] || used[upperi])) upperi++;
                
                if (upperi == n || upper != nums[upperi]) break;
                    
                used[upperi++] = true;
                ans.push_back(nums[loweri]+k);
            }
            
            if (ans.size() == (n>>1)) break;
            
            ans.clear();
        }
        return ans;
    }
};