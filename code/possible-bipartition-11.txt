class Solution {
public:
    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {
        
        // use bfs

        // create an adjacency list
        vector<vector<int>>adjList(n+1,vector<int>());
        for(auto node:dislikes)
          {
              adjList[node[0]].push_back(node[1]);
              adjList[node[1]].push_back(node[0]);
          }

          // converting this question to be in: is this graph is a bipartite or not ?
           // -1: unvisited
            // 0: blue
            //  1; red
        vector<int>visited(n+1,-1);
        
        for(int i=1;i<=n;i++)
           if(visited[i]==-1)
             if(!bfs(adjList,visited,i))
               return false;

        // return ans
        return true;
         
    }

    bool bfs(vector<vector<int>>&adjList,vector<int>&visited,int node)
    {
        queue<pair<int,int>>q;
        q.push({node,0});
        visited[node]=0;

        while(!q.empty())
        {
            auto it=q.front();
            q.pop();
            int node=it.first;
            int color=it.second;
           cout<<"node:"<<node<<"   "<<"color:"<<color<<endl;

            // traverse over neighbors
            for(auto n:adjList[node])
              {// if this neighbor till not visited
               if(visited[n]==-1)
                 {q.push({n,!color});
                  // mark as visited
                  visited[n]=!color;}
                // else 
                  // it is visited and it have same color as parent have
                 else
                   if(visited[n]==color)
                    return false;
              }
                
        }

        return true;
    }
};