class Solution {
    vector<int> last, dp;
    vector<vector<int>> includes, freq;
    int n;
    string target;
public:
    int minStickers(vector<string>& stickers, string& target) {
        sort(target.begin(), target.end());// sort target
        
        n = target.size();
        this->target = target;
        
        vector<int> reqd(26,0);
        vector<bool> seen(26, 0);
        
        includes = vector<vector<int>>(26);
        last = vector<int>(n, 0);;
        
        last[n-1] = n-1;// last[i] the lastIndex of the ith character in the sorted target
        for (int i = n -1;i>=0;i--) {
            char c = target[i];
            seen[c-'a'] = true;
            reqd[c-'a']++;
            if (i < target.size() -1) {
                if (target[i] != target[i+1]) {
                    last[i] = i;
                } else {
                    last[i] = last[i+1];
                }
            }
        }
        
        int numSeen = 0, numReqd = accumulate(seen.begin(), seen.end(), 0);
        
        fill(seen.begin(), seen.end(), 0); // reuse seen to count the different chars seen in all the stickers
        
        for (auto& s: stickers){
            freq.push_back(vector<int>(26, 0));
            auto& v = freq.back();
            for (auto c: s) {
                v[c-'a']++;
                if (reqd[c-'a'] && !seen[c-'a']) {
                    numSeen++;
                    seen[c-'a'] = true;
                }
                if (includes[c-'a'].empty() || (includes[c-'a'].back() != (freq.size() -1))) { 
                    includes[c-'a'].push_back(freq.size()-1);
                }
            }
        }
        
        if (numSeen < numReqd) return -1;
		
		dp = vector<int>(1<<n, -1); // lazily init dp
        
        return rec((1<<n)-1);
        
    }
    
    int rec(int state) {
        if (state == 0) return 0;
        
        int& ans = dp[state];
        if (ans > -1) return ans;
        
        ans = 1000;
        
        int k = __builtin_ffs(state)-1;//index of the rightmost set bit
        for (auto j: includes[target[k]-'a']) {//use only those words which have this character
            int newState = createState(k, freq[j], state);
            ans = min(ans, 1 + rec(newState));
        }
        
        return ans;
        
    }
    
    // returns the newState after using this word on this state
    int createState(int k, vector<int>& v, int state) {
        for (int p = k;p<target.size() && state > 0;) {
            int lastP = last[p];
            // find the next set bit at or after pth index
            p = max(p, __builtin_ffs(p > 0 ? (state & ~((1<<(p-1))-1)) : state) - 1);
            if (p > lastP) {// if the next set-bit is not in the current bucket, means all the target[p] characters have been filled already in some previous recursion
                continue;
            }
            // width: the remaining target[p] chars to fill
            // setMask: mask with only [p...lastP] bits set
            // mask: isolating the set bits in state[p...lastP]
            // num_set: number of set bits in state[p...lastP] that is number of target[p] chars remaining to be filled
            // minus: min. of num_set and the maximum target[p] available for the v word
            int width = lastP - p +1, setMask = (((1<<width)-1)<<p), mask = state & setMask;
            int num_set = __builtin_popcount(mask), fillBits = min(num_set, v[target[p]-'a']);
            while(fillBits-- > 0) {// unsetting the first fillBits bits in mask
                mask &= (mask - 1);
            }
            state  = (state & ~setMask) | mask;//replacing the state[p...lastP] with mask
            p = last[p] +1;// try the next-different char in target
        }
        return state;
    }
};