class Solution {
public:
    int ways(vector<string>& pizza, int k) {
        int R = pizza.size(), C = pizza[0].size();
        int count[R+1][C+1];
        fill_n(*count, sizeof(count)/sizeof(int), 0);
        for(int i = 1; i <= R; ++i)
            for(int j = 1; j <= C; ++j)
                count[i][j] = count[i][j-1] + count[i-1][j] + (pizza[i-1][j-1] == 'A') - count[i-1][j-1];
        
        if(!count[R][C]) return 0;
        
        auto exist = [&](int r1, int r2, int c1, int c2) {
            return count[r2+1][c2+1] - count[r2+1][c1] - count[r1][c2+1] + count[r1][c1] > 0;
        };
        
        int dp[2][R][C];
        fill_n(**dp, sizeof(dp)/sizeof(int), 0);
        dp[0][0][0] = 1;
        
        for(int c = 0; c < k-1; ++c) {
            
            for(int r1 = 0; r1 < R; ++r1) {
                for(int c1 = 0; c1 < C; ++c1) {
                    
                    if(!dp[0][r1][c1] || !exist(r1, R-1, c1, C-1)) continue;
                    
                    for(int i = c1; i < C-1; ++i)
                        if(exist(r1, R-1, c1, i) && exist(r1, R-1, i+1, C-1))
                            dp[1][r1][i+1] = (dp[1][r1][i+1] + dp[0][r1][c1]) % MOD;

                    for(int i = r1; i < R-1; ++i)
                        if(exist(r1, i, c1, C-1) && exist(i+1, R-1, c1, C-1))
                            dp[1][i+1][c1] = (dp[1][i+1][c1] + dp[0][r1][c1]) % MOD;
                }
            }

            for(int r1 = 0; r1 < R; ++r1) {
                for(int c1 = 0; c1 < C; ++c1) {
                    dp[0][r1][c1] = dp[1][r1][c1];
                    dp[1][r1][c1] = 0;
                }
            }
        }
        
        int res = 0;
        for(int r1 = 0; r1 < R; ++r1) 
            for(int c1 = 0; c1 < C; ++c1)
                res = (res + dp[0][r1][c1]) % MOD;
        
        return res;
    }
    const static int MOD = 1e9+7;
};

auto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();