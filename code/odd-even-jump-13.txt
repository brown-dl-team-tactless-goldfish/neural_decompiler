class Solution {
public:
    int oddEvenJumps(vector<int>& A) {
        int count = 0;
        map<int, vector<int>> vmap;
        for (int i = 0; i < A.size(); i++)  vmap[A[i]].push_back(i);
        unordered_map<int, pair<int, int>> memo;
        for (int i = 0; i < A.size(); i++) {
            map<int, vector<int>> :: iterator itlow, itup;
            int lval = -1, rval = -1;
            itlow = vmap.lower_bound(A[i]);
            itup = vmap.upper_bound(A[i]);
            vector<int> v = itlow->second;
            vector<int> :: iterator it = upper_bound(v.begin(), v.end(), i);
            if (it != v.end()) {
                lval = rval = *it;
            }
            while (lval == -1 && itlow != vmap.begin()) {
                itlow = prev(itlow);
                v = itlow->second;
                it = upper_bound(v.begin(), v.end(), i);
                if (it != v.end()) {
                    lval = *it;
                }
            }
            while (rval == - 1 && itup != vmap.end()) {
                v = itup->second;
                it = upper_bound(v.begin(), v.end(), i);
                if (it != v.end()) {
                    rval = *it;
                }
                itup = next(itup);
            }    
            memo[i] = make_pair(lval, rval);
        }
        for (int i = 0; i < A.size() - 1; i++) {
            list<pair<int, int>> ver;
            ver.push_back(make_pair(i, 0));
            
            while (!ver.empty()) {
                int idx = ver.front().first;
                int st = ver.front().second;
                ver.pop_front();
                if (idx == A.size() - 1) {
                    count++;
                    break;
                }
                //cout << idx << ":" << st << endl;
                //cout << memo[idx].first << "::" << memo[idx].second << endl;
                if ((st % 2 == 0) && memo[idx].second != -1) {
                    ver.push_back(make_pair(memo[idx].second, st + 1));
                } else if ((st % 2) && memo[idx].first != -1){
                    ver.push_back(make_pair(memo[idx].first, st + 1));
                }
            }
        }
        return count + 1;
    }
};