public class Solution {
    public IList<IList<string>> FindLadders(string beginWord, string endWord, IList<string> wordList) {
        
        List<IList<string>> res = new List<IList<string>>();
        if(beginWord.Length != endWord.Length)
            return res;
        
        HashSet<string> wordSet = new HashSet<string>(wordList);
        if(!wordSet.Contains(endWord))
            return res;
        
        Queue<List<string>> queue = new Queue<List<string>>();
        List<string> path = new List<string>(){beginWord};
        queue.Enqueue(path);
        HashSet<string> visited = new HashSet<string>();
        bool found = false;
        
        while(queue.Count > 0)
        {     
            int size = queue.Count;
            for(int i = 0; i < size; i++)
            {
                var currList = queue.Dequeue();
                var curr = currList[currList.Count - 1];
                    
                var arr = curr.ToCharArray();
                for(int j = 0; j < arr.Length; j++)
                {
                    char originalChar = arr[j];
                    for(char c = 'a'; c <= 'z'; c++)
                    {
                        arr[j] = c;
                        string next = new string(arr);
                        if(wordSet.Contains(next))
                        {
                            visited.Add(next);
                            currList.Add(next);
                            
                            if(next == endWord)
                            {
                                found = true;
                                res.Add(new List<string>(currList));
                            }
                            
                            // List is mutable, need to make a copy before enqueue
                            queue.Enqueue(new List<string>(currList));
                            currList.RemoveAt(currList.Count - 1);
                        }
                    }
                    arr[j] = originalChar;
                }
            }
            
            // No need to check words that are already checked to ensure paths are shortest
            foreach(string str in visited)
                wordSet.Remove(str);
            
            // BFS gurantees paths at current level are shortest
            // So no need to continue if any paths are already found
            if(found)
                break;
        }
        
        return res;
    }
}