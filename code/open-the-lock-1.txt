#define Size 10000
char Queue[Size][4] = {0}; //Circular
int front=-1;
int tail=-1;

int is_empty(){
    return (tail == front)?1:0;
}

void show(char *wheel){
    printf("%s\n", wheel);
}
void enqueue(char *wheel){
    front++;
    if(front == Size){ 
        front = 0;
    }
    if(front == tail){
        printf("Queue is full");
    }
    memcpy(&Queue[front][0], wheel, sizeof(char)*4);
    //printf("Enqueue : ");
    //show(wheel);
}

char* dequeue(){
    if(is_empty()==1){
        printf("Nothing to dequeue");
        return NULL;
    } 
    tail++;
    if(tail==Size){
        tail = 0;
    }
    //printf("Dequeue : ");
    //show(&Queue[tail][0]);
    return &Queue[tail][0];
}
int convert_wheels_to_int(char *wheels){
    return (wheels[3]-'0') + (wheels[2]-'0' ) * 10 + (wheels[1]-'0') * 100 + (wheels[0]-'0') * 1000;
}
           
int openLock(char ** deadends, int deadendsSize, char * target){
    
    if(convert_wheels_to_int(target)==0) return 0;
    int visited[Size] = {0};
    int hop[Size] = {0};
    int deadends_int;
    front=-1;
    tail=-1;
    for (int d = 0; d < deadendsSize; d++){
        //printf("First deadend : %s, int deaden : %d \n", deadends[d], convert_wheels_to_int(deadends[d]));
        deadends_int = convert_wheels_to_int(deadends[d]);
        if(deadends_int == 0){
            return -1;
        }else{
            visited[deadends_int] = 1;
        }
    }
    
    int target_int = convert_wheels_to_int(target);
    
    enqueue("0000");
    hop[0] = 0;
    visited[0] = 1;
    
    hop[target_int] = -1;

    int  current_wheel_int;
    char *current_wheel; 
    char neighbor[4];

    while(is_empty()!=1){
        if (hop[target_int] != -1){
            return hop[target_int];
        }
        current_wheel = dequeue();
        current_wheel_int = convert_wheels_to_int(current_wheel);

        //Find the possible neighbors and enqueue
        
        for (int i = 0; i < 4; i++){
            memcpy(&neighbor[0], current_wheel, sizeof(char)*4);
            //INC
            if(neighbor[i]=='9'){
                neighbor[i] = '0';
            }else{
                neighbor[i] = neighbor[i] + 1;
            }
            
            if(visited[convert_wheels_to_int(neighbor)] == 0){
                enqueue(neighbor);
                hop[convert_wheels_to_int(neighbor)] = hop[current_wheel_int] + 1;
                visited[convert_wheels_to_int(neighbor)] = 1;
            }
            
            memcpy(&neighbor[0], current_wheel, sizeof(char)*4);
            //DEC
            if(neighbor[i] == '0'){
                neighbor[i] = '9';
            }else{
                neighbor[i] = neighbor[i] - 1;
            }
            if(visited[convert_wheels_to_int(neighbor)] == 0){
                enqueue(neighbor);
                hop[convert_wheels_to_int(neighbor)] = hop[current_wheel_int] + 1;
                visited[convert_wheels_to_int(neighbor)] = 1;
            }
        }
    }
    return hop[target_int];
}