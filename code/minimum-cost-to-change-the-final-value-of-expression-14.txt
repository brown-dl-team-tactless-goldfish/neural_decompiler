class Solution {
public:
    int minOperationsToFlip(string expression) {
        unordered_map<int, int> mp; 
        stack<int> stk; 
        for (int i = size(expression)-1; i >= 0; --i) {
            if (expression[i] == ')') stk.push(i); 
            else if (expression[i] == '(') mp[stk.top()] = i, stk.pop(); 
        }
        
        function<pair<int, int>(int, int)> fn = [&](int lo, int hi) {
            if (lo == hi) return make_pair(expression[lo]-'0', 1); // single number 
            if (expression[hi] == ')' && lo == mp[hi]) return fn(lo+1, hi-1); // single parenthesis
            int mid = (mp.count(hi) ? mp[hi] : hi) - 1; 
            auto [v, c] = fn(mid+1, hi); 
            auto [vv, cc] = fn(lo, mid-1); 
            int val = 0, chg = 0; 
            if (expression[mid] == '|') {
                val = v | vv; 
                if (v == 1 && vv == 1) chg = 1 + min(c, cc); 
                else if (v == 0 && vv == 0) chg = min(c, cc); 
                else chg = 1; 
            } else {
                val = v & vv; 
                if (v == 1 && vv == 1) chg = min(c, cc); 
                else if (v == 0 && vv == 0) chg = 1 + min(c, cc); 
                else chg = 1; 
            }
            return make_pair(val, chg); 
        };
        
        return fn(0, size(expression)-1).second; 
    }
}; 