public class Solution {
    public bool CanPartitionKSubsets(int[] nums, int k) {
        
        if(nums == null || nums.Length < k)
            return false;
        
        int sum = 0;
        foreach(var num in nums)
            sum += num;
        
        if(sum % k != 0)
            return false;
        
        return backtracking(nums, k, 0, sum/k, 0, new bool[nums.Length]);
    }
    
    private bool backtracking(int[] nums, int k, int startIdx, int targetSum, int currSum, bool[] visited)
    {
	    // k == 1 indicates we already found (k-1) valid subsets, so the remaining unvisited numbers will form the last valid subset. 
        if(k == 1)
            return true;
		// since all the numbers are positive, we can abandom the current candidate solution if currSum > targetSum
        else if(currSum > targetSum)
            return false;
		// find one valid subset, continue to find other valid subsets.
        else if(currSum == targetSum)
            return backtracking(nums, k-1, 0, targetSum, 0, visited);
        
        for(int i = startIdx; i < nums.Length; i++)
        {
            if(!visited[i])
            {
                currSum += nums[i];
                visited[i] = true;
                if(backtracking(nums, k, i+1, targetSum, currSum, visited))
                    return true;
                currSum -= nums[i];
                visited[i] = false;
            }
        }
        
        return false;
    }
}