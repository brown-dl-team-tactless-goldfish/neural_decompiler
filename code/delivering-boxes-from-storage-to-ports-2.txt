const int N = 100010;


class Solution {
    struct Node
    {
        int cnt = 0;
        int lv = 0, rv = 0;
    } tr[N << 2];
    
    
    void pushup(int u)
    {
        Node &_u = tr[u], &l = tr[u << 1], &r = tr[u << 1 | 1]; 
        pushup(_u, l, r);
    }
    
    void pushup(Node& u, Node& l, Node& r) {
        
        
        if (l.rv == r.lv && l.rv != 0)
            u.cnt = l.cnt + r.cnt - 1;        
        else
            u.cnt = l.cnt + r.cnt;
        u.lv = l.lv;
        u.rv = r.rv;
    }
    
    void modify(int u, int l, int r, int x, int v)
    {
        if (l == x && r == x)
        {
            tr[u].cnt = 1;
            tr[u].lv = tr[u].rv = v;
            return;
        }
        
        int mid = (l + r) / 2;
        
        if (x <= mid) modify(u << 1, l, mid, x, v);
        else modify(u << 1 | 1, mid + 1, r, x, v);
        
        pushup(u);
    }
    
    Node query(int u, int l, int r, int L, int R)
    {
        if (L <= l && r <= R) return tr[u];
        
        int mid = (l + r) / 2;
        
        Node nl, nr;
        if (L <= mid) nl = query(u << 1, l, mid, L, R);
        if (R > mid) nr = query(u << 1 | 1, mid + 1, r, L, R);
        
        Node res;
        pushup(res, nl, nr);
        
        return res;
    }

    int f[N];
    
public:
    int boxDelivering(vector<vector<int>>& boxes, int pc, int maB, int maW) {
        
        memset(f, 0x3f, sizeof f);
    
        int n = boxes.size();

        for (int i = 1; i <= n; ++ i)
        {
            modify(1, 1, n, i, boxes[i - 1][0]);
        }

        f[0] = 0;
        deque<int> q;
        q.push_back(0);
        for (int i = 1, j = 1, w = 0, c = 0; i <= n; ++ i)
        {
            w += boxes[i - 1][1], c ++ ;
            while (j <= i && (w > maW || c > maB)) w -= boxes[j - 1][1], c -- , j ++ ;
            while (q.front() < j - 1) q.pop_front();
            int k = q.front();
            f[i] = f[k] + query(1, 1, n, k + 1, i).cnt + 1;
            while (q.size() && i < n && f[q.back()] + query(1, 1, n, q.back() + 1, i + 1).cnt >= f[i] + 1)
                q.pop_back();
            q.push_back(i);
        }
        return f[n];
    }
};


/*

1 3 3 3 2


1 2 1
    
*/