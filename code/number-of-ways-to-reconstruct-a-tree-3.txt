class Solution {
public:
    int checkWays(vector<vector<int>>& pairs) {
        int flags[501][501]{};
        int branch[501]{};    // record which trunk a node belongs to; a trunk is a smooth segment having no branches 
        int branch_number = 1;
        unordered_map<int, vector<int>> m; // neighbor nodes which can be visited upward or downward the tree
        for(auto& t : pairs) {
            m[t[0]].push_back(t[1]);
            m[t[1]].push_back(t[0]);
            flags[t[0]][t[0]] = flags[t[1]][t[1]] = flags[t[0]][t[1]] = flags[t[1]][t[0]] = 1;
        }
		
		// nodes which can visit more nodes along current branch are ancestors of current node
		// ancestor nodes which can visit the same number of nodes belong to the same trunk and they can be reordered.
        auto f = [&m](int i, int j){return m[i].size() > m[j].size();};   
		
        for(auto& t : m) t.second.push_back(t.first);
		
        for(auto& t : m) {
            std::sort(t.second.begin(), t.second.end(), f); // sort ancestors and descendents: ancestors can visit more nodes than descendents
            int finali = -1; // check descendents can visit all ancestors
            for(int i = 0; i < t.second.size(); i++) {
                int cur = t.second[i], pre = i?t.second[i-1]:-1;
                if(m[cur].size() >= t.second.size()) { // cur is ancestor to t.first because it can visit more nodes
                    finali = i; // descendents must have the same ancestors with t.first
                    if(pre < 0)
                    {
                        if(branch[cur] == 0) branch[cur] = branch_number++; // record which trunck current node belong to
                    }
                    else if(m[cur].size() == m[pre].size() && (branch[cur] == 0 || branch[cur] == branch[pre])) branch[cur] = branch[pre]; // same trunk must have same trunk number
                    else if(m[cur].size() == m[pre].size() && branch[cur] != 0 && branch[cur] != branch[pre]) return 0; // same trunk but not same trunk number
                    else if(branch[cur] == 0) branch[cur] = branch_number++; // a new trunk
                    else if(branch[cur] == branch[pre]) return 0; // different descendents but same trunk
                }
                for(int j = 0; j <= finali; j++) { // descendents must have the same ancestors
                    if(flags[cur][t.second[j]] == 0) return 0;
                }
            }
        }
        if(branch_number == m.size() + 1)  return 1; // every node belongs to exactly one trunk
        return 2; // one trunk has 2 or more nodes and they can be reordered
    }
};