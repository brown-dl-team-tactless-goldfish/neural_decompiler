class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& arr)
    {
        const int rows = arr.size();
        const int cols = arr[0].size();
        
        for (int r = 0; r < rows; ++r)
        {
            vector<int> v = arr[r];
            if (r != 0)
            {
                // calculate the minimal sum for each element of the new row
                for (int c = 0; c < cols; ++c)
                    v[c] += arr[r-1][c];
            }
            
            // for each element, we need the minimum element of the row
            // excluding the current one. Executed in two steps
            // left->right and right->left
            int minPrev = v[0];
            arr[r][0] = std::numeric_limits<int>::max();
            for (int c = 1; c < cols; ++c)
            {
                arr[r][c] = minPrev;
                minPrev = std::min(minPrev, v[c]);
            }
            
            minPrev = v[cols-1];
            for (int c = cols - 2; c >= 0; --c)
            {
                arr[r][c] = std::min(arr[r][c], minPrev);
                minPrev = std::min(minPrev, v[c]);
            }
        }
        
        // the minimum of the last row can be calculated in easy way:
        // min(min of all elements excluding 0, min of all elements excluding 1)
        return std::min(arr[rows-1][0], arr[rows-1][1]);
    }
};