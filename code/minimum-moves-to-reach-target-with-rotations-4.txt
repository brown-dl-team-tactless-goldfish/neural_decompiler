
class MinimumMoves {
public:
    MinimumMoves(vector<vector<int>>& grid) 
        :   rows(grid.size()), 
            cols(grid[0].size()), 
            grid(grid),
            visited(rows, vector<vector<bool>>(cols, vector<bool>(2, false))) { }
    
    int compute() {
        int depth = -1;
        queue<Location> qu;
        
        qu.push({0, 0, HORIZONTAL});
        visited[0][0][HORIZONTAL] = true;
        
        while (!qu.empty()) {
            int size = qu.size();
            
            ++depth;
            
            for (int i = 0; i < size; ++i) {
                auto from = qu.front();
                
                if (get<0>(from) == rows - 1 && get<1>(from) == cols - 2) {
                    return depth;
                }
                
                qu.pop();

                // Go right
                scheduleMove(qu, from, RIGHT);
                
                 // Go down
                scheduleMove(qu, from, DOWN);
                
                // Rotate clockwise
                scheduleMove(qu, from, CLOCKWISE);
                
                // Rotate anti-clockwise
                scheduleMove(qu, from, ANTICLOCKWISE); 
            }
        }
        
        return -1;
    }
    
private:
    enum Dir {
        HORIZONTAL = 0,
        VERTICAL
    };
    
    enum Move {
        RIGHT = 0,
        DOWN,
        CLOCKWISE,
        ANTICLOCKWISE
    };
    
    typedef tuple<int, int, Dir> Location;
    
    void scheduleMove(queue<tuple<int, int, Dir>>& qu, const Location& from, Move move) {
        auto [r, c, d] = from;
        
        switch (move) {
            case RIGHT:
                ++c;
                
                if (d == HORIZONTAL) {
                    if (c == cols - 1 || grid[r][c + 1] || visited[r][c][d]) {
                        return;
                    }
                } else {
                    if (c == cols || grid[r][c] || grid[r + 1][c] || visited[r][c][d]) {
                        return;
                    }
                }
                
                break;
                
            case DOWN:
                ++r;
                
                if (d == VERTICAL) { 
                    if (r == rows - 1 || grid[r + 1][c] || visited[r][c][d]) {
                        return;
                    }
                } else {
                    if (r == rows || grid[r][c] || grid[r][c + 1] || visited[r][c][d]) {
                        return;
                    }
                }
                
                break;
                
            case CLOCKWISE:
                if (d == VERTICAL || r == rows - 1 || grid[r + 1][c] || grid[r + 1][c + 1] || visited[r][c][VERTICAL]) {
                    return;
                }
                
                d = VERTICAL;
                
                break;
                
            case ANTICLOCKWISE:
                if (d == HORIZONTAL || c == cols - 1 || grid[r][c + 1] || grid[r + 1][c + 1] || visited[r][c][HORIZONTAL]) {
                    return;
                }
                
                d = HORIZONTAL;
                
                break;    
        }
        
        visited[r][c][d] = true;
        qu.push({r, c, d});
    }
    
    int rows;
    int cols;
    vector<vector<int>>& grid;
    vector<vector<vector<bool>>> visited;
};

class Solution {
public:
    int minimumMoves(vector<vector<int>>& grid) {
        MinimumMoves minimumMovesWrap(grid);
        
        return minimumMovesWrap.compute();
    }
};