// how many 0's and 1's are there in one substring like 00111 or 0001.
// two stacks for 1's and 0's
// there will be no actual push or pop
// top 0 means that stack is empty, which removes unnecessary + operation for the counting.


// char stack
//static char (*stack)[2];
static int stacktop[2];
//static int stacksize;
static char prev = -1; // need to be set explicitly again in the function due to unknown problem regarding local static variable

#define MIN(a, b) ((a<b)?a:b)

int countingMachine(char ch) {
    char t;
    int ret;

    t = ch - '0';
    if(t == prev) {
        ret = 0;
        stacktop[t] = stacktop[t] + 1;
//printf("%d\n", ret);
    } else {
//printf("%d\n", ret);
        ret = MIN(stacktop[0], stacktop[1]);
        stacktop[t] = 1;
    }
//printf("%d\n", ret);

    prev = t;

    return ret;
}

int countBinarySubstrings(char * s){
    int cnt = 0;
    stacktop[0] = 0;
    stacktop[1] = 0;

    prev = -1; // due to unknown problem of static variable initialization
    
    while(*s != '\0') {
        cnt += countingMachine(*s);
        s++;
    }

    // force one additional char into the counting machine instead of null char
    // it should be the opposite char of the last input
    if(*(--s) == '1')
        cnt += countingMachine('0');
    else
        cnt += countingMachine('1');
        
    return cnt;
}