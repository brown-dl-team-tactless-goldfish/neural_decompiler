
// this is very very very small compare to w, so some index may have 0 chance of getting picked!!
// to be reasonable, this should be >= wSize
#define MAX_PICK 100

typedef struct {
    int len;
    int pick[MAX_PICK];
} Solution;


Solution* solutionCreate(int* w, int wSize) {
    double sf;
    int i, j, l, r, sum;
    Solution* obj = calloc(1, sizeof(*obj));        // allocate obj
    
    for(i=sum=0; i<wSize;++i) {                     // find total sum
        sum += w[i];
    }
    obj->len = (sum > MAX_PICK) ? MAX_PICK : sum;         // cap the length
    
    sf = (double)obj->len/(double)sum;              // normalize to fit MAX_PICK
    
    for(i=sum=r=0; i<wSize;++i) {                   // for each element
        l = r;                                      // lower bound takes the value of current upper bound
        sum += w[i];                                // get the running sum
        r = sum * sf;                               // and scale to define upper bound
        for(j=l; j<r;++j) {                         // fill the range with index
            obj->pick[j] = i;                       // each index now fill the range to represent their weight
        }
    }
    return obj;
}

int solutionPickIndex(Solution* obj) {              // instead of maintaining sum and bisection search on each pick
    return obj->pick[random() % obj->len];          // maintaining a map of index to achieve O(1)
}

void solutionFree(Solution* obj) {
    free(obj);
}


/**
 * Your Solution struct will be instantiated and called as such:
 * Solution* obj = solutionCreate(w, wSize);
 * int param_1 = solutionPickIndex(obj);
 
 * solutionFree(obj);
*/