struct stack {
    int size;
    int top;
    int* data;
};

struct stack* new_stack(int size) {
    struct stack* obj = (struct stack*)malloc(sizeof(*obj));

    obj->size = size;
    obj->top = -1;
    obj->data = (int*)malloc(size * sizeof(*obj->data));

    return obj;
}

void free_stack(struct stack* obj) {
    free(obj->data);
    free(obj);
}

bool stack_empty(struct stack* obj) { /*O(1)*/
	return (obj->top == -1);
}

bool stack_full(struct stack* obj) {  /*O(1)*/
	return (obj->top == obj->size - 1);
}

int stack_size(struct stack* obj) {   /*O(1)*/
	return (obj->top + 1);
}

bool pop(struct stack* obj) { /*O(1)*/
	if (stack_empty(obj))
		return false;

	obj->data[obj->top--];
	return true;
}

bool push(struct stack* obj, int val) {   /*O(1)*/
	if (stack_full(obj))
		return false;
	
	obj->data[++obj->top] = val;
	return true;
}

int minOperations(char** logs, int logsSize){
    struct stack* operation = new_stack(10000);
    int i, size;
    
    for(i = 0; i < logsSize; i++){
        if(strcmp(logs[i], "./") != 0){
            if(!strcmp(logs[i], "../"))
                pop(operation);
            else
                push(operation, 1);
        }
    }
    
    size = stack_size(operation);
    free(operation);    
    
    return size;
}