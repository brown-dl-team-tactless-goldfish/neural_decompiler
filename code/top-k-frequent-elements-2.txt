struct hashMap{
    int value;
    int count;
};

int comp(const int* a,const int* b){
    return *a-*b;
}

int compHash(const void* a,const void* b){
    return ((struct hashMap*)b)->count-((struct hashMap*)a)->count;
}
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){
    if(numsSize==0||k==0){
        *returnSize=k;
        return 0;
    }
    if(numsSize<k){
        *returnSize=0;
        return 0;
    }
    if(numsSize==k&&k==1){
        *returnSize=1;
        return nums;
    }
    
    int* ans=calloc(k,sizeof(int));
    struct hashMap hash[numsSize];
    memset(hash,0,sizeof(struct hashMap)*numsSize);
    int i;
    int count=1;
    *returnSize=k;
    qsort(nums,numsSize,sizeof(int),comp);
    
    hash[0].value=nums[0];
    hash[0].count++;
    for(i=1;i<numsSize;i++){
        if(hash[count-1].value==nums[i]){
            hash[count-1].count++;
        }else{
            count++;
            hash[count-1].value=nums[i];
            hash[count-1].count++;
        }
    }
    qsort(hash,count,sizeof(hash[0]),compHash);
    for(i=0;i<k;i++){
        ans[i]=hash[i].value;
    }
    return ans;
}