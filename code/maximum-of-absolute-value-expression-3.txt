#include <stdlib.h>
#define oldcompute(I, J, ARR1, ARR2) ((abs((ARR1[I]) - (ARR1[J]))) \
+ (abs((ARR2[I]) - (ARR2[J])))  + (abs((I) - (J))))

#define COST(A, B, I, ARR1, ARR2) ( (A) * (ARR1[I]) + (B) * (ARR2[I]) + I )
#define MAX( a, b ) ( ( a > b) ? a : b ) 
#define MIN( a, b ) ( ( a < b) ? a : b ) 

int maxAbsValExpr(int* arr1, int arr1Size, int* arr2, int arr2Size){
    int i, n;
    int ans;
    int min, max;
    int res;
    n = arr1Size;
    
    // old compute n^2 too slow
    /*
    for( i = 0; i < n; i++ ) {
        for( j = i; j < n; j++ ) {
            
            res = compute(i,j,arr1,arr2);
            if( res > max ) 
                max = res;
        }
    }
    */
    // so refactor into a cost function where a,b in (-1,1)
    // go through matrix of possible max, skip 0 cause -1 or +1 will always
    // be large
    min = max = COST(-1, -1, 0, arr1, arr2);
    for( i = 1; i < n; i++ ) {
        ans = COST(-1, -1, i, arr1, arr2);
        min = MIN(ans, min);
        max = MAX(ans, max);
    }
    res = max - min;
    
    min = max = COST(-1, 1, 0, arr1, arr2);
    for( i = 1; i < n; i++ ) {
        ans = COST(-1, 1, i, arr1, arr2);
        min = MIN(ans, min);
        max = MAX(ans, max);
    }
    res = MAX(res, max - min);
    
    min = max = COST(1, 1, 0, arr1, arr2);
    for( i = 1; i < n; i++ ) {
        ans = COST(1, 1, i, arr1, arr2);
        min = MIN(ans, min);
        max = MAX(ans, max);
    }
    res = MAX(res, max - min);
    
    min = max = COST(1, -1, 0, arr1, arr2);
    for( i = 1; i < n; i++ ) {
        ans = COST(1, -1, i, arr1, arr2);
        min = MIN(ans, min);
        max = MAX(ans, max);
    }
    res = MAX(res, max - min);
    
    return res;
}