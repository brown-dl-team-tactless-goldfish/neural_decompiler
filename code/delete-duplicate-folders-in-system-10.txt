class Node {
public: 
    bool mark = false; 
    int index = -1; 
    unordered_map<string, Node*> next; 
};

class Solution {
public:
    vector<vector<string>> deleteDuplicateFolder(vector<vector<string>>& paths) {
        sort(paths.begin(), paths.end());
        
        Node* tree = new Node(); 
        for (int i = 0; i < paths.size(); ++i) {
            Node* node = tree; 
            for (auto& x : paths[i]) {
                if (node->next.count(x) == 0) node->next[x] = new Node(); 
                node = node->next[x]; 
            }
            node->index = i; 
        }
        
        unordered_map<string, vector<int>> mp; 
        
        function<string(Node*)> fn = [&](Node* node) -> string {
            if (node->next.size() == 0) return "$"; 
            string ans; 
            for (auto& [k, nn] : node->next) 
                ans += "$" + k + "$" + fn(nn); 
            mp[ans].push_back(node->index); 
            return ans; 
        };
        
        fn(tree); 
        
        unordered_set<int> mark; 
        for (auto& [k, v] : mp) 
            if (v.size() > 1) 
                for (auto& vv : v) mark.insert(vv); 
        
        vector<vector<string>> ans; 
        stack<Node*> stk; 
        stk.push(tree); 
        
        while(stk.size()) {
            Node* node = stk.top(); stk.pop(); 
            if (node->index >= 0) ans.push_back(paths[node->index]); 
            for (auto& [k, nn] : node->next) {
                if (mark.find(nn->index) == mark.end()) 
                    stk.push(nn); 
            }
        }
        return ans; 
    }
};