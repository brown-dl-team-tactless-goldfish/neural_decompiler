class Solution {
public:
    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {
        const int n = amount.size();
        auto g = vector(n, vector<int>());
        for(auto& e:edges){
            g[e[0]].push_back(e[1]);
            g[e[1]].push_back(e[0]);
        }
        
        vector<int> bobTime(n, n+1);
        dfsBob(bob, -1, 0, bobTime, g);
        
        int res = -1e9;
        dfs(0, -1, 0, 0, bobTime, g, amount, res);
        return res;        
    }
    
    //return true if the path go to node 0
    bool dfsBob(int i, int par, int t, vector<int>& bobTime, const vector<vector<int>>& g){
        bool isGoodPath = false;
        if(i == 0) isGoodPath = true;
        for(auto j : g[i]){
            if(j == par) continue;
            if(dfsBob(j, i, t+1, bobTime, g))isGoodPath = true;
        }
        if(isGoodPath) bobTime[i] = t;
        return isGoodPath;
    }
    
    void dfs(int i, int parent, int t, int profit, const vector<int>& bobTime, const vector<vector<int>>& g, 
            const vector<int>& amount, int& maxProfit){
        if(bobTime[i] > t) profit += amount[i];
        else if(bobTime[i] == t) profit += amount[i]/2;
        
        if(g[i].size() == 1 && i != 0){ // leaf
            maxProfit = max(maxProfit, profit);
            return;
        }
        
        for(auto j : g[i])
            if(j != parent) dfs(j, i, t+1, profit, bobTime, g, amount, maxProfit);
    }
};