class Solution {
public:
    int maximumMinutes(vector<vector<int>>& grid) {
        
        queue<pair<int, int>> q;
        int m = grid.size();
        int n = grid[0].size();
        
        for (int i=0; i<m; i++){
            for (int j=0; j<n; j++){
                if (grid[i][j] == 1) q.push({i,j});
            }
        }
        
        //use binary search to find max minutes you can stay
        
        int l = 0; 
        int u = 1e9;
        
        while(l<u){
            int mid = (l+u+1)/2;
            
            if (isValid(grid, q, mid)){
                l = mid;
            }
            else{
                u = mid-1;
            }
        }
        
        if (isValid(grid, q, l)) return l;
        
        return -1;
        
        
        
    }
    
    
    bool isValid(vector<vector<int>> grid, queue<pair<int, int>> q, int t){
        
        evolve(grid, q, t);
        
        return canReach(grid, q);
    }
    
    bool canReach(vector<vector<int>>& grid, queue<pair<int, int>> &fq){
        
        //Multi source BFS, all fire site and you everybody does BFS. Note that You do BFS first and then Fire sites do
        
        if (grid[0][0] == 1) return false;
        
        grid[0][0] = 3;
        
        queue<pair<int, int>> q; //q will store my location. fq will store fire location. q will always do BFS frist, and then fq
        q.push({0,0});
        
        int m = grid.size();
        int n = grid[0].size();
        
        while(!q.empty() || !fq.empty()){
            
            int size = q.size();
            
            while(size > 0){
                
                int r = q.front().first;
                int c = q.front().second;
                
                q.pop();
                
                if (grid[r][c] == 3){
                    addBFSP(r+1, c, grid, q);
                    addBFSP(r-1, c, grid, q);
                    addBFSP(r, c+1, grid, q);
                    addBFSP(r, c-1, grid, q);
                }

                if (grid[m-1][n-1] == 3) return true;
                size--;
            }
            
            size = fq.size();
            
            while(size > 0){
                
                int r = fq.front().first;
                int c = fq.front().second;
                
                fq.pop();
                
                if (grid[r][c] == 1){
                    addBFS(r+1, c, grid, fq);
                    addBFS(r-1, c, grid, fq);
                    addBFS(r, c+1, grid, fq);
                    addBFS(r, c-1, grid, fq);
                }
                
                if (grid[m-1][n-1] == 1) return false;
                size--;
            }
            
            
        }
        
        return false;
        
        
    }
    
    
    void evolve(vector<vector<int>>& grid, queue<pair<int, int>> &q, int t){
        
        //evolves grid for t time when just fire is spreading but you are not moving
        
        while(!q.empty() && t>0){
            
            int size = q.size();
            
            while(size > 0){
                
                int r = q.front().first;
                int c = q.front().second;
                
                q.pop();
                
                addBFS(r+1, c, grid, q);
                addBFS(r-1, c, grid, q);
                addBFS(r, c+1, grid, q);
                addBFS(r, c-1, grid, q);
                
                size--;
            }
            
            t--;
        }
    }
    
    void addBFS(int r, int c, vector<vector<int>>& grid, queue<pair<int, int>> &q){
        
        int m = grid.size();
        int n = grid[0].size();
        
        if (r<0 || r>=m || c<0 || c>=n) return;
        
        if (grid[r][c] == 1 || grid[r][c] == 2) return;
        
        grid[r][c] = 1;
        
        q.push({r,c});
    }
    
    void addBFSP(int r, int c, vector<vector<int>>& grid, queue<pair<int, int>> &q){
        
        int m = grid.size();
        int n = grid[0].size();
        
        if (r<0 || r>=m || c<0 || c>=n) return;
        
        if (grid[r][c] == 1 || grid[r][c] == 2 || grid[r][c] == 3) return;
        
        grid[r][c] = 3;
        
        q.push({r,c});
    }
};