struct node{
    node* next[2];
    bool isValue;
    
    node()
    {
        next[0]=NULL;
        next[1]=NULL;
        isValue=false;
    }
};

class Trie{
    
    private:
        node* root;
    public:
        Trie()
        {
            root=new node();
        }
    
    void insert(int number)
    {
        node* curr=root;
        for(int i=31;i>=0;i--)
        {
            int bit=(number>>i)&1;
            if(curr->next[bit]==NULL)
            {
                curr->next[bit]=new node();
            }
            curr=curr->next[bit];
        }
        curr->isValue=true;
    }
    
    int helper(int num,int limit,int ht,node* curr,int value)
    {
        if(value>limit)
        {
            return -1;
        }
        
        if(ht<0)
        {
            return num^value;
        }
        
        int bit=(num>>ht)&1;
        
        if(curr->next[!bit])
        {
            int ans=helper(num,limit,ht-1,curr->next[!bit],value+((!bit)<<ht));
            if(ans!=-1)
            {
                return ans;
            }
        }
        
        if(curr->next[bit])
        {
            int ans=helper(num,limit,ht-1,curr->next[bit],value+(bit<<ht));
            if(ans!=-1)
            {
                return ans;
            }
        }
        return -1;
    }
    
   int getXor(int number,int limit)
   {
       node* curr=root;
       
       return helper(number,limit,31,curr,0);
   }
};

class Solution {
public:
    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {
        
        int n=nums.size();
        int m=queries.size();
        
        if(m==0)
        {
            return {};
        }
        Trie* obj=new Trie();
        
        for(int num:nums)
        {
            obj->insert(num);
        }
        
        vector<int> ans;
        
        for(vector<int> query:queries)
        {
            int number=query[0];
            int limit=query[1];
            
            ans.push_back(obj->getXor(number,limit));
        }
        return ans;
    }
};