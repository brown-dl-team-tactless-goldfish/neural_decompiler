#define MAX 1000

typedef struct list 
{
	size_t size;
	int value[][MAX];
} list;

int pushBack(list **fubar, int v1, int v2, int v3) 
{
	size_t x = *fubar ? fubar[0]->size : 0;
	size_t y = x + 1;

	if ((x & y) == 0) 
	{
		void *temp = realloc(*fubar, sizeof **fubar
								+ (x + y) * sizeof fubar[0]->value[0]);
		if (!temp) 
			return 1;

		*fubar = temp; 
	}

	fubar[0]->value[x][0] = v1;
	fubar[0]->value[x][1] = v2;
	fubar[0]->value[x][2] = v3;
	fubar[0]->size = y;

	return 0;
}

void swap(int *a, int *b) 
{ 
	int temp = *a; 
	*a = *b; 
	*b = temp; 
} 

int mycomp(int *a, int *b)
{
	if (a[0] != b[0])
		return b[0] - a[0];

	if (a[1] != b[1])
		return b[1] - a[1];

	return b[2] - a[2];
}

void notSoQuicksort(list *v, int first, int last)
{
	int i, j, pivot, temp;

	if (first < last)
	{
		pivot = first;
		i = first;
		j = last;

		while (i < j)
		{
			while (mycomp(v->value[i], v->value[pivot]) > 0 && i < last)
				i++;

			while (mycomp(v->value[j], v->value[pivot]) < 0)
				j--;

			if (i < j)
			{
				swap(&v->value[i][0], &v->value[j][0]);
				swap(&v->value[i][1], &v->value[j][1]);
				swap(&v->value[i][2], &v->value[j][2]);
			}
		}

		swap(&v->value[pivot][0], &v->value[j][0]);
		swap(&v->value[pivot][1], &v->value[j][1]);
		swap(&v->value[pivot][2], &v->value[j][2]);

		notSoQuicksort(v, first, j - 1);
		notSoQuicksort(v, j + 1, last);
	}
}

void inorder(struct TreeNode *root, list **v, int x, int y)
{
	if (!root) 
		return;

	inorder(root->left, v, x - 1, y + 1);
	pushBack(v, x, y, root->val);
	inorder(root->right, v, x + 1, y + 1);
}

int **verticalTraversal(struct TreeNode *root, int *returnSize, int **cSizes)
{
	*returnSize = 0;
	int **res = calloc(MAX, sizeof(int *));
	for (int i = 0; i < MAX; i++)
		res[i] = calloc(MAX, sizeof(int));

	*cSizes = calloc(MAX, sizeof(int));
	list *v = calloc(1, sizeof(list));

	inorder(root, &v, 0, 0);
	notSoQuicksort(v, 0, v->size - 1);

	int prev = INT_MIN;

	for (int i = 0; i < v->size; i++)
	{
		if (v->value[i][0] != prev)
		{
			(*cSizes)[*returnSize] = 1;
			res[*returnSize][(*cSizes)[(*returnSize)] - 1] = v->value[i][2];
			prev = v->value[i][0];
			(*returnSize)++;
		}
		else
		{
			(*cSizes)[(*returnSize) - 1]++;
			res[*returnSize - 1][(*cSizes)[*returnSize - 1] - 1] = v->value[i][2];
		}
	}

	return res;
}