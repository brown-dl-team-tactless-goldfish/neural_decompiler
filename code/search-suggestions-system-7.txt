int* ComparedNumber(char** pFirst, char** pSecond)
{
    short sFirstStrLen = strlen(*pFirst), sSecondStrLen = strlen(*pSecond);

    short sStrLen = sFirstStrLen > sSecondStrLen? sSecondStrLen: sFirstStrLen;
    for(short i=0; i<sStrLen; i++)
    {
        if((*pFirst)[i] != (*pSecond)[i]) return (*pFirst)[i] - (*pSecond)[i];
    }

    return sFirstStrLen - sSecondStrLen;
}

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
char *** suggestedProducts(char ** products, int productsSize, char * searchWord, int* returnSize, int** returnColumnSizes){
    // quicksort by lexicographically
    qsort(products, productsSize, sizeof(char**), ComparedNumber);
/*
    for(short i=0; i<productsSize; i++)
    {
        printf("products[i: %d]: %s\n", i, products[i]);
    }
//*/    
    *returnSize = strlen(searchWord);
    (*returnColumnSizes) = (int*) malloc((*returnSize)*sizeof(int));
    char*** pppcRet = (char***) malloc((*returnSize)*sizeof(char**));

    short sStartIndex = 0, sEndIndex = productsSize;
    for(short i=0; i<(*returnSize); i++)
    {
        // find sStartIndex
        if(sStartIndex >= 0)
        {
            short sTmpEndIndex = sEndIndex;
            while(sStartIndex < sTmpEndIndex)
            {
                short sMiddleIndex = sStartIndex + ((sTmpEndIndex-sStartIndex) >> 1);

                short sMiddleStrLen = strlen(products[sMiddleIndex]);
                if(sMiddleStrLen <= i || products[sMiddleIndex][i] < searchWord[i])
                {
                    sStartIndex = sMiddleIndex + 1;                    
                }
                else if(products[sMiddleIndex][i] == searchWord[i] && (sMiddleIndex == sStartIndex || strlen(products[sMiddleIndex-1]) <= i || products[sMiddleIndex-1][i] < searchWord[i]))
                {
                    sStartIndex = sMiddleIndex;
                    break;
                }
                else if(products[sMiddleIndex][i] >= searchWord[i])
                {
                    sTmpEndIndex = sMiddleIndex;
                    if(products[sMiddleIndex][i] > searchWord[i]) sEndIndex = sTmpEndIndex;
                }
            }

            // no solution
            if(sStartIndex >= sTmpEndIndex) sStartIndex = -1;
        }

        //printf("i: %d, sStartIndex: %d ", i, sStartIndex);

        // find sEndIndex
        if(sStartIndex >= 0)
        {
            for(short j=sStartIndex+1; j<sEndIndex; j++)
            {
                if(products[j][i] > searchWord[i])
                {
                    sEndIndex = j;
                    break;
                }
            }
        }

        //printf("sEndIndex: %d\n", sEndIndex);

        // write data
        if(sStartIndex >= 0)
        {
            char cLen = (sEndIndex-sStartIndex >= 3)? 3: sEndIndex-sStartIndex;

            (*returnColumnSizes)[i] = cLen;
            pppcRet[i] = (char**) malloc(cLen*sizeof(char*));
            for(char j=0; j<cLen; j++) pppcRet[i][j] = products[sStartIndex+j];
        }
        else
        {
            (*returnColumnSizes)[i] = 0;
            pppcRet[i] = NULL;
        }
    }

    return pppcRet;
}