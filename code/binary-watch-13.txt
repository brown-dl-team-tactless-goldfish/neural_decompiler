

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

//static char** h[] = {"01\0", "02\0", "04\0", "08\0"};
//static char** m[] = {"01\0", "02\0", "04\0", "08\0", "16\0", "32\0"};

                //idx   0       1         2      3      4       5        6     7         8     9
static char** hm[] = {"01\0", "02\0", "04\0", "08\0", "01\0", "02\0", "04\0", "08\0", "16\0", "32\0"};

static char** ans;
static int ans_size;
#define ANSSIZE 200 // C (10,5) = 252

void set_ith_bit(int *pint, int i){
    *pint = ( 1 << i ) | *pint;
}

int get_ith_bit(int *pint, int i){
    return ((( 1 << i ) & *pint)>0);
}

void ans_check(int bool_arr){
    int H = 0;
    //H
    for (int i = 0; i <=3; i++){
        if (get_ith_bit(&bool_arr, i) == 1){
            H = H + atoi(hm[i]);
        }
    }
    if (H >= 12){
        return;
    }
    int M = 0;

    //M
    for (int i = 4; i <=9; i++){
        if (get_ith_bit(&bool_arr, i) == 1){
            M = M + atoi(hm[i]);
        }
    }
    if (M >= 60){
        return;
    }

    ans_size++;
    int idx_c = 0;
    if (H > 9){
        ans[ans_size][idx_c] = '1';
        idx_c++;
    }

    if (H==0){
        ans[ans_size][idx_c] = '0';
        idx_c++;
        ans[ans_size][idx_c] = ':';
    } else {
        ans[ans_size][idx_c] = (char)((H%10) + '0');
        idx_c++;
        ans[ans_size][idx_c] = ':';
    }
    idx_c++;

    if (M < 10){
        ans[ans_size][idx_c] = '0';
        idx_c++;
        ans[ans_size][idx_c] = (char)( M + '0');
        idx_c++;
    } else {
        ans[ans_size][idx_c] = (char)((M /10) + '0');
        idx_c++;
        ans[ans_size][idx_c] = (char)( (M % 10) + '0');
        idx_c++;
    }
    ans[ans_size][idx_c] = '\0';
}

void Find_ans(int idx_s, int idx_e, int bool_arr, int num_2_select){
    if (num_2_select == 0) {

        ans_check(bool_arr);
        return;
    }
    for (int i = idx_s; i<= idx_e;i++){
        int temp = bool_arr;
        set_ith_bit(&bool_arr, i);
        Find_ans(i + 1, idx_e, bool_arr, num_2_select-1);
        bool_arr = temp;
    }
}
char ** readBinaryWatch(int turnedOn, int* returnSize){

    if (turnedOn >= 9){
        *returnSize = 0;
        return ans;
    }
    ans = (char**)calloc(ANSSIZE, sizeof(char*));
    ans_size = -1;
    for (int i = 0; i < ANSSIZE; i++){
        ans[i] = (char*)calloc(6, sizeof(char));
    }
    Find_ans(0, 9, 0, turnedOn);
    *returnSize = ans_size + 1;
    return ans;
}