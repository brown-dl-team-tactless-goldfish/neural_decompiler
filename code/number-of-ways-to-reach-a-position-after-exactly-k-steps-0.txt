/*
startPos = 2, endPos = 5, k = 9

min = -1  max =8
>> 1

startPos = 3, endPos = 6, k = 9
min = 0  max = 9

list[place][k] = 當我在place 且剩下 k 步時 到達 endPos 有幾種可能

所以 list[startPos][k] = list[startPos-1][k-1] + list[startPos+1][k-1] 
     list[startPos-1][k-1] = list[(startPos-1)-1][(k-1)-1] + list[(startPos-1)+1][(k-1)-1]...
     依此類推
     

回到例子 因為向右平移 1 (為了不要出現負數)  startPos改成 3  endPos改成6 步數不變
目前得到第一個結論

list[0][6] = 1;
list[1][5] = 1;
list[2][4] = 1;
list[3][3] = 1;
list[4][2] = 1;
list[5][1] = 1;
list[6][0] = 1;
list[7][1] = 1;
list[8][2] = 1;
list[9][3] = 1;

依照此處推可以推論出
list[6][2] = list[5][1] + list[7][1];
list[5][3] = list[4][2] + list[6][2];
list[4][4] = list[3][3] + list[5][3];
list[3][5] = list[2][4] + list[4][4];
list[2][6] = list[1][5] + list[3][5];
list[1][7] = list[0][6] + list[2][6];

list[7][3] = list[6][2] + list[8][2];
list[8][4] = list[7][3] + list[9][3];
(此處可以畫圖 比較好理解)
*/


int numberOfWays(int startPos, int endPos, int k){
    if (endPos < startPos){
        int a = endPos;
        endPos = startPos;
        startPos = a;
    }
    if ((k-endPos+startPos)&1 == 1 || endPos-startPos > k){
        return 0;
    }
    if (endPos-startPos == k){
        return 1;
    }
    
    int min = (startPos+endPos-k)>>1;
    int max = k+1;
    
    endPos -= min;
    startPos -= min;
    int for_free = max;   //返回前要釋放記憶體用的 先複製起來 因為max等等會變動到
    
    int** list = malloc(sizeof(int*)*(max));
    
    for (int i = 0 ; i < max ; i++){
        list[i] = malloc(sizeof(int)*(k+1));
        list[i][abs(endPos-i)] = 1;
    }
    int count = 0;
    min = 0;
    max--;
    
    while (1){
        count++;
        int j = count;
        for (int i = endPos ; i > min ; i--){
            list[i][j+1] = (list[i+1][j] + list[i-1][j]) % 1000000007;
            j++;
        }
        if (j == k){
            break;
        }
        min++;
        
        count++;
        j = count;
        for (int i = endPos+1 ; i < max ; i++){
            list[i][j+1] = (list[i+1][j] + list[i-1][j]) % 1000000007;
            j++;
        }
        if (j == k){
            break;
        }
        max--;
    }
    
    int ans = list[startPos][k];
    
    for (int i = 0 ; i < for_free ; i++){
        free(list[i]);
    }
    free(list);
    return ans;
}