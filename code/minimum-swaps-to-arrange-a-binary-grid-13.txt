int minSwaps(vector<vector<int>>& grid) {
    ListNode root;
    ListNode *cur = &root;
    int n = grid.size();
    for (int i=0; i<n; ++i) {
        int zeroCnt = 0;
        for (int j=n-1; j>=1; j--) {
            if (grid[i][j]!=0) break;
            zeroCnt++;
        }
        cur->next = new ListNode(zeroCnt);
        cur = cur->next;
    }
    cur = root.next;
    int rowIdx = 0;
    int ans = 0;
    while (cur && rowIdx<n) {
        int targetCnt = n - 1 - rowIdx++;
        ListNode* tn = cur;
        ListNode* pre = NULL;
        int swapCnt = 0;
        // greedy to find the nearest available targetCnt
        while (tn && tn->val < targetCnt) {
            pre = tn;
            tn = tn->next;
            swapCnt++;
        }
        // return -1 if no valid found
        if (!tn) return -1;
        // add the swapCnt
        ans += swapCnt;
        // Adjust the list after swap
        // Basically, it could be regarded as the targetCnt node
        // is removed from the original position
        // c     tn
        // 4->3->5->2->1
        // <After sdjacent wap process>
        // tn c
        // 5->4->3->2->1
        if (!pre) {
            cur = cur->next;
        } else {
            pre->next = tn->next;
        }
    }
    return ans;
}