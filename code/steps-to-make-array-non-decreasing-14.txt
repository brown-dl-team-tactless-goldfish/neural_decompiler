class Solution {
public:
  /*
  For every number at i that has a number to the left at j (j < i) such that
    nums[j] > nums[i]
  there can be number in between j and i at some index k (j < k < i) such that
    nums[k] < nums[i]
  because of which i cannot be removed immediately but it will be removed at some  
  point. For that, we would need all ks to be removed in previous steps. So we must 
  find the k that takes the most number of steps to get removed.
  */
  int totalSteps(vector<int>& nums) {
    int maxSteps = 0;
    stack<pair<int, int>> st;
    for (int num : nums) {
      int steps = 0;
      while (!st.empty() && num >= st.top().first) {
        steps = max(steps, st.top().second);
        st.pop();
      }
      if (!st.empty()) {
        steps++;
      }
      maxSteps = max(maxSteps, steps);
      st.push({num, steps});
    }
    return maxSteps;
  }
};