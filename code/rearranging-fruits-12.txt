class Solution {
public:
    
    long long minCost(vector<int>& basket1, vector<int>& basket2) {
        int n = basket1.size();
        
        map<long long ,long long> mp;
        for (int i = 0; i < n; i++) {
            mp[basket1[i]]++;
            mp[basket2[i]]--;
        }
       
        vector<long long> swapNeeded;
        long long minE = begin(mp)->first;
        
        long long totalSwaps = 0;
        for (auto[a,n1] : mp) {
            if (n1 % 2)
                return -1;
            // only possitive fruits freq can be takens as they will have their negative counters parts
            // we need swap only half on other side 
            totalSwaps += max(0LL,n1/2); 
        }
        
        long long result = 0;
        for (auto &p : mp) {
            long long swaps = abs(p.second)/2;
            if (swaps > totalSwaps) {
                swaps = totalSwaps;
            }
            // try swapping with minimumm element which has double cost
            // or just swap the current element itself
            long long cost = swaps*(min(p.first,2*minE));
            result += cost;
            // reduce the total swaps
            totalSwaps -= swaps;
            if (totalSwaps == 0)
                return result;
        }
        
        return result;
        
    }
	}
    
	```