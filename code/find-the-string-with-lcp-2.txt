class Solution {
public:
  vector<int> idxToParent;
  vector<vector<bool>> eligible;
  vector<char> parentToChar;
  vector<unordered_set<int>> different;

  int getParent(int idx) {
    if (idxToParent[idx] == -1) {
      idxToParent[idx] = idx;
    }
    if (idxToParent[idx] == idx) {
      return idx;
    }
    idxToParent[idx] = getParent(idxToParent[idx]);
    return idxToParent[idx];
  }
  
  bool combineParents(int idx1, int idx2) {
    int parentIdx1 = getParent(idx1);
    int parentIdx2 = getParent(idx2);
    for (int i = 0; i < 26; ++i) {
      if (eligible[parentIdx1][i] != eligible[parentIdx2][i]) {
        return false;
      }
    }
    if (different[parentIdx1].find(parentIdx2) != different[parentIdx1].end()) {
      return false;
    }
    if (different[parentIdx2].find(parentIdx1) != different[parentIdx2].end()) {
      return false;
    }
    for (auto it = different[parentIdx2].begin();
        it != different[parentIdx2].end();
        ++it) {
      different[parentIdx1].insert(*it);
    }
    idxToParent[parentIdx2] = parentIdx1;
    return true;
  }
  
  bool tryFilling(int idx, char c) {
    int cIdx = c - 'a';
    int parentIdx = getParent(idx);
    if (!eligible[parentIdx][cIdx]) return false;
    for (auto it = different[parentIdx].begin();
         it != different[parentIdx].end();
         ++it) {
      eligible[getParent(*it)][cIdx] = false;
    }
    parentToChar[parentIdx] = c;
    return true;
  }
  
  string findTheString(vector<vector<int>>& lcp) {
    int n = lcp.size();
    idxToParent = vector<int>(n, -1);
    parentToChar = vector<char>(n, 0);
    eligible = vector<vector<bool>>(n, vector<bool>(26, true));
    different = vector<unordered_set<int>>(n);
    
    for (int i = 0; i < n; ++i) {
      if (lcp[i][i] != (n - i)) return "";
      for (int j = i; j < n; ++j) {
        if (i < n - 1 && j < n - 1) {
          if (lcp[i][j] != 0 && ((lcp[i][j] - lcp[i + 1][j + 1]) != 1)) {
            return "";
          }
        }
        if (lcp[i][j] != lcp[j][i]) return "";
        if (lcp[i][j] > (n - j)) return "";
        if (lcp[i][j] != 0) {
          if (!combineParents(i, j)) return "";
        } else {
          if (i == j) return "";
          different[getParent(i)].insert(getParent(j));
          different[getParent(j)].insert(getParent(i));
        }
      }
    }
    
    for (int i = 0; i < n; ++i) {
      int parentIdx = getParent(i);
      if (parentToChar[parentIdx] != 0) continue;
      bool found = false;
      for (int j = 0; j < 26; ++j) {
        if (tryFilling(i, 'a' + j)) {
          found = true;
          break;
        }
      }
      if (!found) {
        return "";
      }
    }
    string s = "";
    for (int i = 0; i < n; ++i) {
      s += parentToChar[getParent(i)];
    }
    return s;
  }
};