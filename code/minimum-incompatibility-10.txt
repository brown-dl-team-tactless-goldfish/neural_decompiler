class Solution {
public:
    int ans = INT_MAX;
    int minimumIncompatibility(vector<int>& nums, int k) {
        if (k == nums.size()) return 0;
        sort(nums.begin(), nums.end());
        vector<vector<int>> cur(k, vector<int>(3));
        dfs(0, nums, cur, nums.size() / k, 0);
        return ans == INT_MAX ? -1 : ans;
    }
    void dfs(int i, vector<int>& n, vector<vector<int>>& c, int s, int sum){        
            if (i == n.size()) ans = min(ans, sum);
            if (sum >= ans) return;
            set<vector<int>> m;
        for (int y = 0; y < c.size(); ++y){
            if (c[y][1] == n[i] || c[y][2] == s ||
                (c[y][2] == 1 && c[y][0] == n[i]) || m.find(c[y]) != m.end()) continue;
            m.insert(c[y]);
            if (c[y][2] == 0){
                c[y][1] = c[y][0] = n[i], ++c[y][2];
                dfs(i + 1, n, c, s, sum);
                c[y][1] = c[y][2] = c[y][0] = 0;
            }
            else{
                int prev = c[y][1];
                c[y][1] = n[i], ++c[y][2];
                dfs(i + 1, n, c, s, sum - (prev - c[y][0]) + (c[y][1] - c[y][0]));
                c[y][1] = prev, --c[y][2];
            }
        }
    }
};