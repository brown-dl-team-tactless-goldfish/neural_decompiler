class Solution {
public:
    bool isPrintable(vector<vector<int>>& targetGrid) {
        initGraph(targetGrid);
        const int n = g.size();
        vector<int> indegree(n);
        for(auto st:g) for(auto i:st) indegree[i]++;
        queue<int> q;
        for(int i=0;i<n;i++) if(indegree[i] == 0 && !g[i].empty()) q.push(i);
        while(!q.empty()){
            auto i = q.front(); q.pop();
            cout<<i<<endl;
            for(auto j:g[i]){
                if(--indegree[j] == 0) q.push(j);
            }
        }
        return count(indegree.begin(), indegree.end(), 0) == n;
    }
    
    void initGraph(vector<vector<int>>& vv){
        const int n = vv.size(), m = vv[0].size(); 
        g.resize(61);  
        unordered_map<int, Boundry> mp;
        for(int i=0;i<n;i++) for(int j=0;j<m;j++){
            mp[vv[i][j]].update(i, j);
        }
        for(const auto& [color, bond] : mp){
            auto [x1, x2, y1, y2] = bond;
            for(int i=x1;i<=x2;i++) for(int j=y1;j<=y2;j++){
                if(vv[i][j] != color) g[color].insert(vv[i][j]);
            }
        }
    }
    
    struct Boundry{
        void update(int x, int y){
            x1 = min(x, x1);
            x2 = max(x, x2);
            y1 = min(y, y1);
            y2 = max(y, y2);
        }
        
        bool include(int x, int y) const{
            return x>=x1 && x<=x2 && y>=y1 && y<=y2;
        }
        
        int x1 = 100;
        int x2 = -1;
        int y1 = 100;
        int y2 = -1;
    };
    
    vector<unordered_set<int>> g; 
};