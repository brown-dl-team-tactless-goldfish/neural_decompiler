struct SegNode {
    int left_bound, right_bound;
    unsigned long long val0, val1;

    SegNode *left, *right;

    explicit SegNode(int left_bound, int right_bound) : left_bound(left_bound), right_bound(right_bound),
                                                        left(nullptr), right(nullptr), val0(0), val1(0) {}

    void set_val(int val) {
        if (val < 64) {
            val0 |= (((unsigned long long)1) << val);
        } else {
            val1 |= (((unsigned long long)1) << (val - 64));
        }
    }
};

class SegTree {
private:
    SegNode *root;

    SegNode *create_node(int left_bound, int right_bound, const vector<int> &nums) {
        SegNode *ret = new SegNode(left_bound, right_bound);
        if (left_bound == right_bound) {
            ret->set_val(nums[left_bound]);
            return ret;
        }
        int mid = (left_bound + right_bound) / 2;
        ret->left = create_node(left_bound, mid, nums);
        ret->right = create_node(mid + 1, right_bound, nums);
        ret->val0 = ret->left->val0 | ret->right->val0;
        ret->val1 = ret->left->val1 | ret->right->val1;
        return ret;
    }

    void
    search_helper(SegNode *node, int left_bound, int right_bound,
                  unsigned long long &val0, unsigned long long &val1) {
        if (node->left_bound == left_bound && node->right_bound == right_bound) {
            val0 = node->val0;
            val1 = node->val1;
            return;
        }
        int mid = (node->left_bound + node->right_bound) / 2;
        unsigned long long lv0 = 0, lv1 = 0, rv0 = 0, rv1 = 0;
        if (right_bound <= mid) {
            search_helper(node->left, left_bound, right_bound, lv0, lv1);
        } else if (left_bound >= mid + 1) {
            search_helper(node->right, left_bound, right_bound, rv0, rv1);
        } else {
            search_helper(node->left, left_bound, mid, lv0, lv1);
            search_helper(node->right, mid + 1, right_bound, rv0, rv1);
        }
        val0 = lv0 | rv0;
        val1 = lv1 | rv1;
    }

    void release_node(SegNode *node) {
        if (node == nullptr) {
            return;
        }
        release_node(node->left);
        release_node(node->right);
        delete node;
    }

public:
    explicit SegTree(const vector<int> &nums) {
        root = create_node(0, nums.size() - 1, nums);
    }

    void search(int left_bound, int right_bound, unsigned long long &val0, unsigned long long &val1) {
        search_helper(root, left_bound, right_bound, val0, val1);
    }

    ~SegTree() {
        release_node(root);
    }
};

class Solution {
public:
    vector<int> minDifference(vector<int> &nums, vector<vector<int>> &queries) {
        SegTree *st = new SegTree(nums);
        vector<int> ret;
        for (const vector<int> &query : queries) {
            unsigned long long val0 = 0, val1 = 0;
            int prev = -1, ans = INT_MAX;
            st->search(query[0], query[1], val0, val1);
            for (int i = 1; i <= 100; i++) {
                unsigned long long val;
                if (i < 64) {
                    val = ((((unsigned long long)1) << i) & val0);
                } else {
                    val = (((unsigned long long)1) << (i - 64)) & val1;
                }
                if (val != 0) {
                    if (prev != -1) {
                        ans = min(ans, i - prev);
                    }
                    prev = i;
                }
            }
            ret.push_back((ans == INT_MAX) ? -1 : ans);
        }
        delete st;
        return ret;
    }
};