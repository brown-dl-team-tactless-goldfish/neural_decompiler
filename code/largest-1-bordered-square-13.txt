public class Solution {
    public int Largest1BorderedSquare(int[][] grid)
    {
        if (grid == null || grid.Length == 0 || grid[0].Length == 0)
        {
            return 0;
        }
        else
        {
            int rows = grid.Length;
            int cols = grid[0].Length;
            int[] maxVerticalOnesLengths = new int[cols];
            int[,] maxHorizontalOnesLengths = new int[rows, cols];
            int maxVerticalOnesLength, maxHorizontalOnesLength, maxOnesLength;
            int maxArea = 0;
            
            for (int r = 0; r < rows; r++)
            {
                for (int c = 0; c < cols; c++)
                {                    
                    if (grid[r][c] == 0)
                    {
                        maxHorizontalOnesLengths[r, c] = maxVerticalOnesLengths[c] = 0;
                    }
                    else
                    {
                        if (r == 0)
                        {
                            maxVerticalOnesLengths[c] = 1;
                            maxHorizontalOnesLengths[r, c] = c == 0 ? 1 : maxHorizontalOnesLengths[r, c - 1] + 1;
                            maxArea = 1;
                        }
                        else if (c == 0)
                        {
                            maxVerticalOnesLengths[0] += 1;
                            maxHorizontalOnesLengths[r, 0] = 1;
                            maxArea = Math.Max(maxArea, 1);
                        }
                        else
                        {
                            maxVerticalOnesLength = maxVerticalOnesLengths[c] + 1;
                            maxHorizontalOnesLength = maxHorizontalOnesLengths[r, c - 1] + 1;
                            maxOnesLength = Math.Min(maxVerticalOnesLength, maxHorizontalOnesLength);
                            
                            while (maxOnesLength > 1)
                            {
                                if (Math.Min(
                                    maxVerticalOnesLengths[c - maxOnesLength + 1],
                                    maxHorizontalOnesLengths[r - maxOnesLength + 1, c]) >= maxOnesLength)
                                {
                                    break;
                                }
                                else
                                {
                                    maxOnesLength--;
                                }
                            }
                            
                            maxVerticalOnesLengths[c] = maxVerticalOnesLength;
                            maxHorizontalOnesLengths[r, c] = maxHorizontalOnesLength;
                            maxArea = Math.Max(maxArea, maxOnesLength * maxOnesLength);
                        }
                    }
                }
            }
            
            return maxArea;
        }
    }
}