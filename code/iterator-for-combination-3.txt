typedef struct {
    char * characters;
    int cur_comb[15];
    int length, combination_length;
} CombinationIterator;

CombinationIterator * 
combinationIteratorCreate(char * characters, int combination_length) 
{
    CombinationIterator * result = malloc(sizeof(CombinationIterator));
    result->characters = characters;
    result->length = strlen(characters);
    result->combination_length = combination_length;
    result->cur_comb[0] = -1;
    memset(result->cur_comb + 1, 0, 14 * sizeof(char));
    return result;
}

char * 
combinationIteratorNext(CombinationIterator * obj) 
{
    if (obj->cur_comb[0] == -1)
    {
        for (int i = 0; i < obj->combination_length; ++i)
            obj->cur_comb[i] = i;
    }
    else
    {
        int last = obj->combination_length - 1;

        while (last >= 0 && obj->cur_comb[last] == obj->length - obj->combination_length + last)
            --last;

        ++(obj->cur_comb[last]);

        for (int i = last + 1; i < obj->combination_length; ++i) 
            obj->cur_comb[i] = obj->cur_comb[last] + (i - last);
    }
    
    char * result = calloc((obj->combination_length + 1), sizeof(char));
    
    for (int i = 0; i < obj->combination_length; ++i)
        result[i] = obj->characters[obj->cur_comb[i]];
    
    return result;
}

bool 
combinationIteratorHasNext(CombinationIterator * obj)
{    
    if (obj->cur_comb[0] == -1)
        return true;
    
    int last = obj->combination_length - 1;
    
    while (last >= 0 && obj->cur_comb[last] == obj->length - obj->combination_length + last)
        --last;
    
    return last >= 0;
}

void 
combinationIteratorFree(CombinationIterator * obj)
{
    free(obj);
}