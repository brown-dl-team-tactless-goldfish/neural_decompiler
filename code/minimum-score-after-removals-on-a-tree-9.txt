// XOR concepts required
// a ^ 0 = a
// a ^ a = 0

class Solution {
public:
    vector<int> g[1001]; // adjecency list
    int visited[1001];
	// in and out timers to detect subtree element
    int in[1001];
    int out[1001];
    int timer;
    int X[1001];
    void dfs(int u,vector<int>& A, vector<pair<int,int>>& p)
    {
        in[u] = timer++;

        visited[u] = 1;
        // subtree xor
        X[u] = A[u];

        for(auto v: g[u])
        {
            if(visited[v])continue;
            p.push_back({u,v});
            dfs(v,A,p);
            X[u] ^= X[v];
        }

        out[u] = timer++;
    }
    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {
           
           int ans = 1e9;
            timer = 0;
            memset(visited,0,sizeof visited);
           for(int i=0;i<=nums.size();i++)g[i].clear();


           vector<pair<int,int>> v;

           for(auto it: edges)
           {
                int s = it[0];
                int d = it[1];

                g[s].push_back(d);
                g[d].push_back(s);
           }


           dfs(0,nums,v);


           for(int i=0;i<v.size();i++)
           {
                for(int j=i+1;j<v.size();j++)
                {
                    int a = v[i].second;
                    int b = v[j].second;
					// three xors
                    int x,y,z;
                    x = y = 0;
                    z = X[0];


                    // if b lies in subtree of a
                    if(in[b] > in[a] && out[b] < out[a])
                    {
                        x = X[a];
                        y = X[b];
                        x ^= y;
                        z ^= x;
                        z ^= y;
                    }
                    else if(in[a] > in[b] && out[a] < out[b]) // if a lies in subtree of b
                    {
                        swap(a,b);
                        x = X[a];
                        y = X[b];
                        x ^= y;
                        z ^= x;
                        z ^= y;
                    }
                    else // hame mat jodiye hum alag hai :)
                    {
                        x = X[a];
                        y = X[b];
                        z ^= x;
                        z ^= y;
                    }


                    ans = min(ans,max({x,y,z}) - min({x,y,z}));

                }
           }




           return ans;


    }
};