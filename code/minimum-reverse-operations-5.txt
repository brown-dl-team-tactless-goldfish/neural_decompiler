class Solution {
public:
    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {
        unordered_set<int> banned_set(banned.begin(), banned.end());
        vector<int> result(n, -1);
        set<int> positions[2];

        result[p] = 0;
        for (int i = 0; i < n; ++i) {
            if (i != p && banned_set.count(i) == 0) {
                positions[i % 2].insert(i);
            }
        }

        queue<int> q;
        q.push(p);
        while (!q.empty()) {
            int pivot = q.front();
            q.pop();
            auto range = getRange(n, pivot, k);
            int parity = (k % 2 == 0) ? (1 - pivot & 1) : (pivot & 1);
            auto lower = positions[parity].lower_bound(range.first);
            auto upper = positions[parity].upper_bound(range.second);
            for (auto it = lower; it != upper; ++it) {
                result[*it] = result[pivot] + 1;
                q.push(*it);
            }
            positions[parity].erase(lower, upper);
        }

        return result;
    }

private:
    pair<int, int> getRange(int n, int pivot, int k) {
        int left1 = max(0, pivot - k + 1);
        int right1 = left1 + k - 1;
        int right2 = min(n - 1, pivot + k - 1);
        int left2 = right2 - k + 1;
        int left = right1 - (pivot - left1);
        int right = left2 + (right2 - pivot);
        return {left, right};
    }
};