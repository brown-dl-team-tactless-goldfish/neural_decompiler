void DFS(int * nums, int size, int j, int dp[][2], int* max, int* ans){

    dp[j][0] = 1; // There is always atleast 1 subsequence. 

    for (int n = j; n < size; n++){
        if(nums[n] <= nums[j]) continue;
        
        if (dp[n][0] == -1) DFS(nums, size, n, dp, max, ans); // Have we seen n yet?
        
        int t = dp[n][0] + 1; // Temp. for holding current longest subsequence.
        
        if (t > dp[j][0]){ // Is it longer than j's longest subsequence? 
            dp[j][0] = t;
            dp[j][1] = dp[n][1];
        } else if (t == dp[j][0]){ // If it's same as j's longest subsequence,
            dp[j][1] += dp[n][1];  // add it's accumulator to j's accumulator.
        }
    }

    if (dp[j][0] > *max){ // If j's longest subsequence is greater than max's,
        *max = dp[j][0];  // update max and answer variables.
        *ans = dp[j][1];
    } else if (dp[j][0] == *max){ // If j's longest subsequence is same as max,
        *ans += dp[j][1];         // add j's accumulator to the answer variable.
    }
    
    return;
}

int findNumberOfLIS(int* nums, int numsSize){
    if (numsSize == 0) return 0;
    int dp[numsSize + 1][2];
    int max = -1;
    int ans = 0;
    
    for (int n = 0; n < numsSize + 1; n++) {
        dp[n][0] = -1; // Longest subsequence.
        dp[n][1] = 1;  // How many longest subsequences (accumulator).
    }

    for (int n = 0; n < numsSize; n++){
        if (dp[n] > -1) continue;    
        DFS(nums, numsSize, n, dp, &max, &ans);
    }

    return ans; 
}