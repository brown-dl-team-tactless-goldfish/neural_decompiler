static
int imin(int a, int b) {
	return (a < b) ? a : b;
}

static 
void add_move(int** moves, int* moves_size, int* moves_cap, int move) {
	if (*moves_size == *moves_cap) {
		*moves_cap = (*moves_cap) ? *moves_cap * 2 : 1;
		*moves = realloc(*moves, *moves_cap * sizeof(int));
	}
	(*moves)[(*moves_size)++] = move;
}

static
bool expand_out(
		char* stamp, int stamp_len, 
		char* target, int target_len, 
		int** ret_out, int* return_size, int* return_cap, 
		int full_idx, 
		int* prev_end) {
	/* Move left of our full stamp index until we either reach the previous end or the start of target */
	for (int left_idx = full_idx; left_idx > *prev_end; ) {
		int size = imin(left_idx, stamp_len - 1);
		for (; size; --size) {
			int idx = left_idx - size;
			if (0 == memcmp(target + idx, stamp, size)) {
				add_move(ret_out, return_size, return_cap, idx);
				left_idx = idx;
				break;
			}
		}

		if (!size) {
			/* We currently have not found another stamp, but if we have reached the prev_end of the last expansion, then
			   we can try to use a stamp to bridge the two full stamps. This is the only case where we can match the middle
				 of the stamp only. That is, it is possible for the front and back of the stamp to _not_ match. */
			size = left_idx - *prev_end;
			if (size <= stamp_len) {
				for (int offset = 0; offset + size < stamp_len; ++offset) {
					if (0 == memcmp(target + *prev_end, stamp + offset, size)) {
						left_idx = *prev_end - offset;
						add_move(ret_out, return_size, return_cap, left_idx);
						break;
					}
				}
			}

			/* Can't stamp anymore moving left. There will be no solution */
			if (left_idx > *prev_end) {
				return false;
			}
		}
	}

	/* Move right of our full stamp index until we either can't move anymore or reach the right side of target */
	int right_idx = full_idx;
	for (;;) {
    /* maximum size (number of letters) to try and match from the stamp. Normally stamp_len, but will be decreased
       as right edge of target is encountered */
		int size = imin(stamp_len, target_len - (right_idx + stamp_len));
		for (; size; --size) {
			/* We can overwrite the start of the stamp, but must include the entire end. If there is a need to overwrite
			   both sides of the stamp, it can only be done with a full stamp on either side, in which case the step will
				 be added as the next full stamp moves back left. */
			int offset = stamp_len - size;				 
			if (0 == memcmp(target + right_idx + stamp_len, stamp + offset, size)) {
				add_move(ret_out, return_size, return_cap, right_idx + size);
				right_idx += size;
				break;
			}
		}

		/* Eventually we will either reach the end of the target or otherwise won't be able to find any more stamps */
		if (!size) {
			*prev_end = right_idx + stamp_len;
			return true;
		}
	}
}

int* movesToStamp(char * stamp, char * target, int* returnSize) {
	int* ret = NULL;
	*returnSize = 0;
	int cap = 0;

	const int stamp_len = (int) strlen(stamp);
	const int target_len = (int) strlen(target);
	int prev_right_end = 0;

	/* Seach for a full stamp match, from left to right. The target must _finish_ with a full stamp. Thus if we have
	   a full stamp location, we can search backwards for stamps that lead up to the full stamp(s). */
	for (int i = 0; i + stamp_len <= target_len; ) {
		if (0 == memcmp(target + i, stamp, stamp_len)) {
			add_move(&ret, returnSize, &cap, i);
			if (!expand_out(stamp, stamp_len, target, target_len, &ret, returnSize, &cap, i, &prev_right_end)) {
				break;
			}
			i = prev_right_end;
		} else {
			++i;
		}
	}
	
	/* If there is no solution */
	if (prev_right_end < target_len) {
		free(ret);
		*returnSize = 0;
		return NULL;
	}

	/* We added moves from last to first, so we need to reverse before returning result */
	int* first = ret;
	int* last = ret + *returnSize;
	while (first < --last) {
		int tmp = *first;
		*first++ = *last;
		*last = tmp;
	}

	return ret;
}