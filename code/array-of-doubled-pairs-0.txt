int cmpfunc( const void* p1,  const void* p2){
   int* arr1 = *(int**)p1;
   int* arr2 = *(int**)p2; 
  return arr1[0] - arr2[0];
}

int checkItemInArray(int** set, int setSize, int val, int cn){
    int left = 0, right = setSize-1, mid;
    while(left < right){
        mid = left + (right - left)/2;
        if(set[mid][0] == val){
            if(set[mid][1] >= cn){
                set[mid][1] -= cn;
                return mid;
            }
            else
                return -1;
        }
        else if(set[mid][0] > val)
            right = mid -1;
        else 
            left = mid + 1;
    }
    
    if(set[left][0] == val && set[left][1] >= cn){
        set[left][1] -= cn;
        return left;
    }
    else 
        return -1;    
}

bool canReorderDoubled(int* arr, int arrSize){
    //arrSize is odd number, then return NULL
    if(arrSize % 2 == 1){
        return false;
    }
    //O(n), iterate each item, get the set<val, count>
    //>>>>> 
    int* hash = calloc(2e5 + 1, sizeof(int));
    int base = 1e5;
    int** set = malloc(arrSize * sizeof(int*));
    int setSize = 0;
    for(int i = 0; i < arrSize; i++){
        hash[arr[i] + base]++;
        if(hash[ arr[i] + base ] == 1){
            set[setSize] = malloc(2 * sizeof(int));
            set[setSize][0] = arr[i];
            setSize++;
        }
    }
    for(int i = 0; i < setSize; i++){
        set[i][1] = hash[ set[i][0] + base] ;
    }
    free(hash);
    //<<<< end set<val, count>  
    qsort(set, setSize, sizeof(int*), cmpfunc);

    int ptr = 0, post = setSize-1;
    int idx = 0;

    while(idx < arrSize/2 ){
        if(set[ptr][1] == 0){
            for(int i = ptr+1; i < setSize; i++){
                if(set[i][1] > 0){
                    ptr = i;
                    break;
                }                        
            }
        }
        //special case: data is 0, the numbers should be even.
        if(set[ptr][0] == 0){
            if(set[ptr][1] % 2 == 1){
                return false;
            }
            idx += (set[ptr][1]/2);
            set[ptr][1] = 0;  //already checked
            ptr++;
            //next cycle
            continue;
        }        
        //other smallest val
        if(set[ptr][0] < 0){            
            if((set[ptr][0]*(-1))%2  || checkItemInArray(set, setSize, set[ptr][0] / 2, set[ptr][1]) == -1)
                return false;    
        }
        else{
            if( checkItemInArray(set, setSize, set[ptr][0] * 2, set[ptr][1]) == -1)
                return false;               
        }
        idx += set[ptr][1];       
        set[ptr][1] = 0; //already checked
        ptr++;
    }

    return true;
}