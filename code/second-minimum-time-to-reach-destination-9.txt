class Solution {
public:
    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {
        vector<vector<int>> al(n);
        for(auto &e:edges){
            al[e[0]-1].push_back(e[1]-1);
            al[e[1]-1].push_back(e[0]-1);
        }
        int firstTime = -1;
        vector<int> f(n,-1), s(n,-1);
        priority_queue<pair<int,int>> pq;
        pq.push({0,0}); //time, node
        while(!pq.empty()){
            auto [t, u] = pq.top();
            pq.pop();
            t = -t;
            if(u==n-1){
                if(firstTime==-1 || firstTime==t) firstTime = t;
                else return t;
            }
            if(f[u]==t) continue; //another OPTIMUM path to reach u for the first time. Ignore  it since we already cover this case. Without this line, we might think that this is the time needed to reach u for the second time.
            else if(f[u]==-1) f[u] = t;
            else if(s[u]==-1) s[u] = t;
            else continue; // another path (not necessarily optimum) to reach u for the second time. Again, ignore it.
            int turn = t/change;
            if(turn%2) t = (turn+1)*change;
            for(int v:al[u]){
                pq.push({-(t+time), v});
            }
        }
        return -1;
    }
};