int find_right_parenthesis(char* expression, int j) {
    int n = 1;
    while (n > 0){
        if (expression[j] == '}'){
            n--;
        } else if (expression[j] == '{'){
            n++;
        }
        j++;
    }
    return j;
}

int find_end_of_letter(char* expression, int j) {
    while (expression[j] > 96 && expression[j] < 123){
        j++;
    }
    return j;
}

void count_check(char* expression, int* now, int* count, int* list){
    int copy = *now;
    while(expression[*now] != '}'){                                     //最後 now 的位置是 }
        if (expression[*now] == '{'){
            int co = 1;
            int origin = 1;
            while (expression[*now] == '{'){
                *now += 1;
                count_check(expression, now, &co, list);
                *now = find_end_of_letter(expression, *now+1);
                origin = origin*co;
                co = 1;
            }
            *count += origin-1;
            *now -= 1;
        } if (expression[*now] == ','){
            *count += 1;
        }
        *now += 1;
    }
    list[copy] = *count;
}

void count_check_inside (char* expression, int back_start, int* count, int* list){
    *count *= list[back_start];
    back_start = find_right_parenthesis(expression, back_start);
    back_start = find_end_of_letter(expression, back_start);
    if (expression[back_start] == '{'){
        count_check_inside(expression, back_start+1, count, list);
    }
}

int comp(const void** a, const void** b){
    return strcmp(*(char**)a, *(char**)b);
}

void write_in(char* expression, char** ans, int* ans_len, int* original, int* input, int i, int now, int* list){
    int c_original = *original;
    int c_input = *input;
    for (int j = i ; j < now ; j++){
        if (expression[j] == '{'){
            j++;
            int start = j;
            j = find_right_parenthesis(expression, j);
            int back_start = j;
            while (expression[back_start] > 96 && expression[back_start] < 123){
                back_start++;
            }
            int copy_original = *original;
            j--;
            if (expression[back_start] == '{'){
                int repeat = 1;
                count_check_inside(expression, back_start+1, &repeat, list);
                while (repeat > 0){
                    write_in(expression,  ans,  ans_len, original, input, start, j, list);
                    *input += *original;
                    *original = copy_original;
                    repeat--;
                }
            } else {
                write_in(expression,  ans,  ans_len, original, input, start, j, list);
            }
            *original = copy_original*list[start];
            *input = c_input;
        } else if (expression[j] > 96 && expression[j] < 123) {                                   //是數字
            int start = j;
            j++;
            j = find_end_of_letter(expression, j);
            int repeat = 1;
            if (expression[j] == '{'){
                count_check_inside(expression, j+1, &repeat, list);
            }
            while (repeat > 0){
                for (int m = start ; m < j ; m++){
                    for (int k = *input ; k < *original+*input ; k++){
                        ans[k][ans_len[k]] = expression[m];                 
                        ans_len[k]++;
                    }
                }
                *input += *original;
                repeat--;
            }
            *input = c_input;
            j--;
        } else if (expression[j] == ',') {
            *input += *original;
            *original = c_original;
            c_input = *input;
        }
    }
}

char ** braceExpansionII(char * expression, int* returnSize){
    int len = strlen(expression);
    int ans_len[4097] = {0};
    int list[61];
    char** ans = malloc(sizeof(char*)*1);
    ans[0] = malloc(sizeof(char)*60);
    int count = 1;      //這個{}內有幾種可能
    int now = 0;        //目前 expression 檢查到哪個位置
    int i = 0;          //expression 需要從哪邊開始檢查並填入
    int input = 0;      //填入答案的
    int original = 1;   //原本答案已經有幾種可能了

    for (; now < len ; now++){
        if (expression[now] == '{'){
            now++;
            i = now;
            count_check(expression, &now, &count, list);        //檢查{}內有幾種可能  now也會被更改到 這個{}的 } 的位置
            ans = realloc(ans,sizeof(char*)*(count*original));          //將 ans 改成 原本的數量*剛剛檢查到的可能性 的大小
            if (original == 1){
                for (int j = original ; j < count ; j++){                   //設定記憶體空間以存放需要寫入的答案 從原本的大小到變更之後的大小
                    ans[j] = malloc(sizeof(char)*60);
                    strncpy(ans[j],ans[0],ans_len[0]);
                    ans_len[j] = ans_len[0];
                }
            } else {
                int copy;
                for (int j = original ; j < count*original ; j++){          //設定記憶體空間以存放需要寫入的答案 從原本的大小到變更之後的大小
                    ans[j] = malloc(sizeof(char)*60);
                    copy = j % original;
                    strncpy(ans[j],ans[copy],ans_len[copy]);                //複製原本的答案
                    ans_len[j] = ans_len[copy];                             //將每個答案尾巴的位置也複製好
                }
            }
            int copy_original = original;
            write_in(expression,  ans,  ans_len, &copy_original, &input, i, now, list);
        } else {                                                        //遇到{}外面的字母
            for (int k = 0 ; k < original ; k++){       
                ans[k][ans_len[k]] = expression[now];                 
                ans_len[k]++;
            }
        }
        input = 0;                                                      //{}內已經結束 要考慮下一個部分
        original *= count;
        count = 1;
    }
    
    for (int j = 0 ; j < original ; j++){
        ans[j][ans_len[j]] = '\0';
    }
    qsort(ans, original, sizeof(char*), comp);
    i = 1;
    for (; i < original ; i++){
        if (strcmp(ans[i],ans[i-1]) == 0){
            break;
        }
    }
    count = i;
    i++;
    for (; i < original ; i++){
        if (strcmp(ans[i],ans[i-1]) != 0){
            strcpy(ans[count],ans[i]);
            count++;
        }
    }
    *returnSize = count;
    return ans;
}