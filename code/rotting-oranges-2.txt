/// Convert a long array to a 2D array
static void copyToGrid(int ** grid, int rows, int cols, int * tmp){
   int i, j;
   for(i = 0; i < rows; i++){
      for(j = 0; j < cols; j++){
          grid[i][j] = tmp[i * cols + j];
      }
   }
}

/// Convert a 2D array to one dimensional array
static void copyToArray(int * tmp, int rows, int cols, int ** grid){
   int i, j;
   for(i = 0; i < rows; i++){
      for(j = 0; j < cols; j++){
          tmp[i * cols + j] = grid[i][j];
      }
   }
}

int orangesRotting(int** grid, int gridSize, int* gridColSize){
    int colSize = gridColSize[0], i,j;
    // Count the number of fresh oranges
    int total = 0, step = 0;
    for(i = 0; i < gridSize; i++){
       for(j = 0; j < colSize; j++){
          if(grid[i][j] == 1){
             total++;
          }
       }
    }
	// used to store the number of fresh oranges in two consecutive iterations
    int counts[2];
    counts[0] = 0;
    counts[1] = total;
    int * tmp = (int *) malloc(sizeof(int) * gridSize * colSize);
    copyToArray(tmp, gridSize, colSize, grid);
    while ((counts[1] != 0) && (counts[1] != counts[0])){
        for(i = 0; i < gridSize; i++){
           for(j = 0; j < colSize; j++){
		     // If fresh orange
              if(grid[i][j] == 1){
                 if((((i - 1) >= 0) && (grid[i - 1][j] == 2))
                    || (((i + 1) < gridSize) && (grid[i + 1] [j] == 2))
                    || (((j - 1) >= 0) && (grid[i][j - 1] == 2))
                    || (((j + 1) < colSize) && (grid[i][j + 1] == 2))){
					   // Transform it to a rotten orange if one of the neighbor is rotten
                       tmp[i * colSize + j] = 2;
					   // Decrement the number of fresh oranges
                       total--;
                }
          }
       }
       step++;
       counts[0] = counts[1];
       counts[1] = total;
       copyToGrid(grid, gridSize, colSize, tmp);
   }
   free(tmp);
   return (total == 0) ? step : -1;
}