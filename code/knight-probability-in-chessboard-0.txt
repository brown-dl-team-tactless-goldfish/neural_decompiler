void empty_twoDArray(int N, double array[N][N])
{
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            array[i][j] = 0.0;
        }
    }
}

void copy_twoDArray(int N, double dst[N][N], double src[N][N])
{
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            dst[i][j] = src[i][j];
        }
    }
}

double knightProbability(int N, int K, int r, int c){
    int possible_row_diff[8] = {2, 2, -2, -2, 1, 1, -1, -1};
    int possible_col_diff[8] = {1, -1, 1, -1, 2, -2, 2, -2};

    double snapshot[N][N];
    empty_twoDArray(N, snapshot);

    snapshot[r][c] = 1.0;

    for (int i = 0; i < K; i++)
    {
        double current[N][N];
        empty_twoDArray(N, current);
        for (int row_index = 0; row_index < N; row_index++)
        {
            for (int col_index = 0; col_index < N; col_index++)
            {
                // iterate for all possible pairs and filter out related ones
                for (int j = 0; j < 8; j++)
                {
                    int row = row_index + possible_row_diff[j];
                    int col = col_index + possible_col_diff[j];
                    if (row >= 0 && row < N && col >= 0 && col < N)
                    {
                        current[row][col] += snapshot[row_index][col_index] / 8;
                    }
                }
            }
        }

        copy_twoDArray(N, snapshot, current);
    }
    
    double probability = 0.0;
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            probability += snapshot[i][j];
        }
    }

    return probability;
}