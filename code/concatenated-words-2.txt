int cmp(const void* a, const void* b) {
    char* aword = *((char**)a);
    char* bword = *((char**)b);

    return strlen(aword) - strlen(bword);
}

struct Trie
{
    bool end;
    struct Trie *child[26];
};

struct Trie *createNode(bool end)
{
    struct Trie *node = calloc(1, sizeof(struct Trie));

    node->end = end;

    return node;
}

bool dfs(char *word, struct Trie *root, bool build)
{
    bool ret = false;
    struct Trie *curr = root;

    while(*word)
    {
        if(curr->child[*word - 'a'] == NULL)
            break;
        
        curr = curr->child[*word - 'a'];
        
        word++;

        if(curr->end == true)  
            ret |= dfs(word, root, false);
    }

    if(build)
    {
        while(*word)
        {
            curr->child[*word - 'a'] = createNode(false);
            curr = curr->child[*word++ - 'a'];
        }

        curr->end = true;
    }
    else if(curr->end == true && *word == '\0')
            ret = true;        

    return ret;
}
char ** findAllConcatenatedWordsInADict(char ** words, int wordsSize, int* returnSize){

    char **ans = (int**)calloc(wordsSize, sizeof(char*));
    struct Trie *root = createNode(false);

    for(int i = 0; i < wordsSize; i++)
        ans[i] = (char*)calloc(30, sizeof(char));

    *returnSize = 0;

    qsort(words, wordsSize, sizeof(words[0]), cmp);

    for(int i = 0; i < wordsSize; i++)
        if(dfs(words[i], root, true) == true)
            strcpy(ans[(*returnSize)++], words[i]);

    return ans;
}
