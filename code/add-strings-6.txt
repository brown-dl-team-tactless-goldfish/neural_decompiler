char * addStrings(char * num1, char * num2){
    // We need the length of each string in several places
    int len1 = strlen(num1);
    int len2 = strlen(num2);

    // conveneince for storing null byte at end
    char z = '\0';
    
    // constraint
    size_t maxsz = 5101;

    // leave room for possible carry digit and null byte at end of string
    char *res = calloc(maxsz + 1 + 1, sizeof(char));
    if (res == NULL) {
        perror("cannot allocate memory");
        exit(1);
    }
    
    // start result at end of char buffer
    size_t rp = maxsz;
    
    // set pointers to end of each passed in string
    int p1 = len1 - 1;
    int p2 = len2 - 1;
    
    // init carry to '0'
    char carry = '0';
    
    // loop until both strings are exhausted
    while (p1 >= 0 || p2 >= 0) {
        // optimization, use char arithmitic
        char n1 = (p1 >= 0) ? *(num1 + p1--) : '0';
        char n2 = (p2 >= 0) ? *(num2 + p2--) : '0';

        // optimization, set sum to actual char digit
        char sum = (((n1-'0') + (n2-'0') + (carry-'0'))) + '0';

        // optimization, rollover digit use char
        if (sum > '9') {
            carry = '1';
            sum = sum - 10;
        } else {
            carry = '0';
        }
        
        // prepare for storing prior digit in result string
        rp--;

        // actually set string to digit
        *(res + rp) = sum;
    }
    
    // handle carry
    rp--;
    
    // convience pointer to start of result string
    char *f = res + rp;

    // may end up with first digit of '0'
    *f = carry;
    if (carry == '0') {
        f++;
    }
    return f;
}