class Solution {
public:
    struct trie{
        map<string, trie*> ch;
    };
    
    trie* root;
    
    unordered_map<string, vector<pair<trie*,string>>> dup;
    
    vector<vector<string>> ans;
    vector<string> subans;
    
    vector<vector<string>> deleteDuplicateFolder(vector<vector<string>>& paths) {
        root = new trie;
        
        for (auto p : paths){ //1.
            auto node = root;
            for (auto f : p){
                auto it = node->ch.find(f);
                if (it == node->ch.end())
                    it = node->ch.insert(pair<string, trie*>(f, new trie)).first;
                node = it->second;
            }
        }
        
        dfs(root); //2.
        
        for (auto it = dup.begin(); it != dup.end(); it++){ //3.
            if (it->second.size() > 1){
                for (auto& p : it->second)
                    p.first->ch.erase(p.second);
            }
        }
        
        subans.resize(500);
        
        dfs2(root, 0); //4.
        
        return ans;
    }
    
    void dfs2(trie* node, int i){   
        for (auto it = node->ch.begin(); it != node->ch.end(); it++){
            subans[i] = it->first;
            ans.push_back(vector<string>(subans.begin(), subans.begin()+i+1));
            dfs2(it->second, i+1);
        }
    }
    
    string dfs(trie* node){
        string path;
        for (auto it = node->ch.begin(); it != node->ch.end(); it++){
            string tmp = dfs(it->second);
            if (tmp.size())
                dup[tmp].push_back(pair<trie*, string>(node, it->first));
            path += it->first+tmp;
        }
        
        return path;
    }
};