class Solution {
    typedef long long ll;
public:
    vector<int> pathsWithMaxScore(vector<string>& board) {
        unordered_map<int, vector<ll>> dp;
        auto res = helper(0, 0, board, dp);
        if(res[0]< 0) return {0, 0};
        
        return {(int) res[0], (int) res[1]};
    }
    
    vector<ll> helper(int r, int c, vector<string>& board, unordered_map<int, vector<ll>>& dp) {
        ll big = 1e9 + 7;
        vector<ll> res = {};
        if(board[r][c] == 'X') return {INT_MIN, INT_MIN};
        
        int m = board.size(), n = board[0].size();
        if(r == m - 1 && c == n-1) return {0, 1};
        
        if(!dp[r*101 + c].empty()) return dp[r*101 + c];
        
        int cur = board[r][c] == 'E' ? 0 : board[r][c] - '0';
        
        if(r+1 < m) {
            auto p = helper(r+1, c, board, dp);
            res = {p[0]+cur, p[1]};
        }
        
        if(c+1 < n) {
            auto p = helper(r, c+1, board, dp);
            if(res.empty() || p[0] + cur > res[0]) {
                res = {p[0] + cur, p[1]};
            } else if(p[0] + cur == res[0]) {
                res = {p[0] + cur, res[1] + p[1]};
            }
        }
        
        if(r+1 < m && c+1 < n) {
            auto p = helper(r+1, c+1, board, dp);
            if(res.empty() || p[0] + cur > res[0]) {
                res = {p[0] + cur, p[1]};
            } else if(p[0] + cur == res[0]) {
                res = {p[0] + cur, res[1] + p[1]};
            }
        }        
        
        res[1] = res[1] % big;
        dp[r * 101 + c] = res;
        return res;
    }
};