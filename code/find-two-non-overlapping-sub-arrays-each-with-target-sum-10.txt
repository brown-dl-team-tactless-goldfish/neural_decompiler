class Solution {
public:
    int minSumOfLengths(vector<int>& arr, int target) {
        int size=arr.size(),sum=0,ans=INT_MAX;
        unordered_map<int,int>mp;
        // to handle corner cases,you can say it is also one pass,but i am just ignoring it :P
        arr.insert(arr.begin(),0);
        size++;
        // trackmin[i] will give you the minimum length of subarray till i(included) ,whose sum is equals to target
        vector<int>trackmin(size,INT_MAX);
        mp[0]=0;
        for(int i=1;i<size;i++){
           sum+=arr[i];
            // if we find subarray whose sum== target
            if(mp.find(sum-target)!=mp.end()){
                // calculate surrent length
                int curlen=i-mp[sum-target];
                // get previous length from trackmin
                int premin=trackmin[mp[sum-target]];
                if(premin!=INT_MAX)
                    ans=min(ans,curlen+premin);
                // update trackmin[i]
                trackmin[i]=min(curlen,trackmin[i-1]);
            }
            else
               trackmin[i]=trackmin[i-1];
            mp[sum]=i;
        }
        return ans==INT_MAX?-1:ans;
    }
};