typedef struct {
    int n;
    int cur;
    pthread_mutex_t m_zero;
    pthread_mutex_t m_even;
    pthread_mutex_t m_odd;
} ZeroEvenOdd;

ZeroEvenOdd* zeroEvenOddCreate(int n) {
    ZeroEvenOdd* obj = (ZeroEvenOdd*) malloc(sizeof(ZeroEvenOdd));
    obj->n = n;
    obj->cur = 0;
    
    pthread_mutex_init(&obj->m_zero, NULL);
    pthread_mutex_init(&obj->m_even, NULL);
    pthread_mutex_init(&obj->m_odd, NULL);
    
    pthread_mutex_lock(&obj->m_zero);
    pthread_mutex_lock(&obj->m_even);
    pthread_mutex_lock(&obj->m_odd);
    
    return obj;
}

// You may call global function `void printNumber(int x)`
// to output "x", where x is an integer.

void zero(ZeroEvenOdd* obj) {
    
    do {
        printNumber(0);

        if ((obj->cur+1) % 2 == 0)
            pthread_mutex_unlock(&obj->m_even);
        else
            pthread_mutex_unlock(&obj->m_odd);
        
        pthread_mutex_lock(&obj->m_zero);
    } while (obj->cur < obj->n);
    
    obj->cur = obj->n + 1;
    // unlock the last waiter
    pthread_mutex_unlock(&obj->m_even);
    pthread_mutex_unlock(&obj->m_odd);
}

void even(ZeroEvenOdd* obj) {
    while (obj->cur <= obj->n) {
        pthread_mutex_lock(&obj->m_even);
        if (obj->cur == obj->n + 1) {
            pthread_mutex_unlock(&obj->m_even);
            break;
        }
        
        printNumber(++obj->cur);
        pthread_mutex_unlock(&obj->m_zero);
    }
}

void odd(ZeroEvenOdd* obj) {
    while (obj->cur <= obj->n) {
        pthread_mutex_lock(&obj->m_odd);
        if (obj->cur == obj->n + 1) {
            pthread_mutex_unlock(&obj->m_odd);
            break;
        }
        printNumber(++obj->cur);
        pthread_mutex_unlock(&obj->m_zero);
    }
}

void zeroEvenOddFree(ZeroEvenOdd* obj) {
    pthread_mutex_destroy(&obj->m_zero);
    pthread_mutex_destroy(&obj->m_even);
    pthread_mutex_destroy(&obj->m_odd);
    
    free(obj);
}