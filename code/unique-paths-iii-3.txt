// Because m*n <= 20, representing every movement (four possible) as three bits (max size 60 bits) fits in a int64_t, so this is one possibility to encode every path.
// Visited nodes (r, c) can also be a bitmask, left-to-right and top-to-bottom w/ (0, 0) as LSB, then (0, 1), etc.
// Obstacles are placed directly on the "visited" bitmask, because it's easy.
// Put the start node as the sole member in an array to be tested and expanded.
// While the array has members, check the node at the end: Test if the node's neighbors can be visited. If all cells were visited and the node is at the ending, increment x. If not, expand the array with all possible new moves.
// Keep shrinking the array until no nodes remain.

#define  MAX_ALLOC  900
#define  FULL_MASK(nr,nc)  ((1<<(nr*nc))-1)

inline bool can_u(int r, int c, int nr, int nc)  { return r > 0; }
inline bool can_r(int r, int c, int nr, int nc)  { return c < nc - 1; }
inline bool can_d(int r, int c, int nr, int nc)  { return r < nr - 1; }
inline bool can_l(int r, int c, int nr, int nc)  { return c > 0; }

inline uint64_t bit(int r, int c, int nr, int nc)  { return (1<<(r*nc))<<c; }
inline void see(uint64_t *seen_mask, uint64_t seen_bit)  { *seen_mask |= seen_bit; }
inline bool seen(uint64_t seen_mask, uint64_t seen_bit)  { return (seen_mask & seen_bit) == seen_bit; }
inline bool all_visited(uint64_t seen_mask, int nr, int nc)  { return (seen_mask & FULL_MASK(nr,nc)) == FULL_MASK(nr,nc); }

#define  AT_ENDING()  (grid[r][c] == 2)

int uniquePathsIII(int** grid, int gridSize, int* gridColSize) {
    uint64_t visited[MAX_ALLOC];  // visited mask
    uint8_t cr[MAX_ALLOC];
    uint8_t cc[MAX_ALLOC];
    int nr = gridSize;
    int nc = *gridColSize;
    int x = 0;  // Finished path count
    int y = 0;  // Possible path insert index

    visited[0] = 0;

    // Find the start and add obstacles
    for (int r = 0; r < nr; ++r) {
        for (int c = 0; c < nc; ++c) {
            if (grid[r][c] == 1)  { see(&visited[0], bit(r, c, nr, nc)); cr[0] = r; cc[0] = c; }
            if (grid[r][c] == -1) { see(&visited[0], bit(r, c, nr, nc)); }
        }
    }

    int r, c;
    uint64_t mask;
    while (y >= 0) {
        r = cr[y];
        c = cc[y];
        mask = visited[y];

        if (all_visited(mask,nr,nc) && AT_ENDING()) {
            x++;
        } else {
            if (can_l(r,c,nr,nc)&&!seen(mask,bit(r,c-1,nr,nc))) { visited[y]=mask; see(&visited[y], bit(r, c-1, nr, nc)); cr[y]=r;cc[y]=c-1; y++; }
            if (can_d(r,c,nr,nc)&&!seen(mask,bit(r+1,c,nr,nc))) { visited[y]=mask; see(&visited[y], bit(r+1, c, nr, nc)); cr[y]=r+1;cc[y]=c; y++; }
            if (can_r(r,c,nr,nc)&&!seen(mask,bit(r,c+1,nr,nc))) { visited[y]=mask; see(&visited[y], bit(r, c+1, nr, nc)); cr[y]=r;cc[y]=c+1; y++; }
            if (can_u(r,c,nr,nc)&&!seen(mask,bit(r-1,c,nr,nc))) { visited[y]=mask; see(&visited[y], bit(r-1, c, nr, nc)); cr[y]=r-1;cc[y]=c; y++; }
        }
        y--;
    }

    return x;
}