class Solution {
public:
    long long minCost(vector<int>& b1, vector<int>& b2) {
        map<int,int>mp1;
        map<int,int>mp2;
        map<int,int>mp;
        for(auto i : b1) {mp1[i]++;mp[i]++;}
        for(auto i : b2) {mp2[i]++;mp[i]++;}
        for(auto i : mp) {
            if(i.second&1) return -1; // when number of operation is odd then we are able to swap all 
                                      // values with equal frquency 
        }
        vector<vector<long long int>>pa; // store element with number swap opration required to  that 
                                        //  element
        int val = -1; // store minimun value of booth baskets
        for(auto i : mp) {
            if(val == -1) val = i.first;
            int opr = abs(mp1[i.first] - mp2[i.first]);
            if(opr&1) return -1;
            opr /= 2;
            if(opr != 0)pa.push_back({i.first , opr});
        }
        sort(begin(pa) , end(pa));
        long long sum = 0;
        int i=0;
        int j=pa.size()-1;
        int pr = 0;
        int po = 0;
        while(i <= j) {
            int opr1 = pa[i][1];
            int opr2 = pa[j][1];
            // edge case
            if(i == j) {
                opr1 /= 2;
                    sum += (pa[i][0] * opr1);
                break;
            }
            // when we swap 2 element with each other 
            if(min(pa[i][0] , pa[j][0]) < 2*val){if(opr1 >= opr2) {
                pa[i][1] -= opr2;
                sum += (pa[i][0] * opr2);
                j--;
            }
            else {
                pa[j][1] -= opr1;
                sum += (pa[i][0] * opr1);
                i++;
            }}
            // when we swap the elements using minimun value (val) of both baskets
            else {
                sum += ((long long)(opr1+opr2) * val);
                i++;
                j--;
            }
        }
        return sum;
    }
};