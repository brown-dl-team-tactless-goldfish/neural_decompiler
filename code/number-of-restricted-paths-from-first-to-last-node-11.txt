class Solution {
   public:
    int countRestrictedPaths(int n, vector<vector<int>>& edges) {
        const auto graph = [&edges, n] {
            vector<unordered_map<int, int>> graph(n + 1);
            for (auto& e : edges) {
                graph[e[0]][e[1]] = e[2];
                graph[e[1]][e[0]] = e[2];
            }
            return graph;
        }();

        const vector<int> dist = dijkstra(graph);
        vector<int> dp(n, -1);

        return dfs(1, dp, graph, dist);
    }

   private:
    constexpr static int LIMIT = 1'000'000'000 + 7;
    int dfs(int k, vector<int>& dp,
            const vector<unordered_map<int, int>>& graph,
            const vector<int>& dist) {
        const auto n = graph.size() - 1;
        if (k == n) {
            return 1;
        }
        if (dp[k] != -1) {
            return dp[k];
        }

        int cnt = 0;
        for (const auto& e : graph[k]) {
            if (dist[e.first] < dist[k]) {
                cnt += dfs(e.first, dp, graph, dist);
                cnt %= LIMIT;
            }
        }

        return dp[k] = cnt;
    }

    using pii = pair<int, int>;
    vector<int> dijkstra(const vector<unordered_map<int, int>>& graph) {
        const auto n = graph.size() - 1;

        vector<int> dist(n + 1, numeric_limits<int>::max());
        dist[n] = 0;

        auto pq = [n, &dist] {
            priority_queue<pii, vector<pii>, greater<>> pq;
            pq.emplace(dist[n], n);
            return pq;
        }();

        while (!empty(pq)) {
            const auto u = pq.top().second;
            pq.pop();
            for (const auto [v, w] : graph[u]) {
                if (dist[v] > dist[u] + w) {
                    dist[v] = dist[u] + w;
                    pq.emplace(dist[v], v);
                }
            }
        }
        return dist;
    }
};