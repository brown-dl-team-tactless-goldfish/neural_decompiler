
struct cell {
        int x;
        int y;
};

void __enque_adjacent(struct cell *queue, int * front, int x, int y, int **grid)
{
        grid[x][y] = 1;
        ++(*front);
        queue[*front].x = x;
        queue[*front].y = y;        
}

void enque_adjacent(int **grid, int w, int h, int i, int j, struct cell *queue, int *front)
{
        if (i > 0 && j > 0 && !grid[i - 1][j - 1])
                __enque_adjacent(queue, front, i - 1, j - 1, grid);
        if (j > 0 && !grid[i][j - 1])
                __enque_adjacent(queue, front, i, j - 1, grid);
        if (i > 0 && !grid[i - 1][j])
                __enque_adjacent(queue, front, i - 1, j, grid);
        if (i + 1 < h && j > 0 && !grid[i + 1][j - 1])
                __enque_adjacent(queue, front, i + 1, j - 1, grid);
        if (i + 1 < h && !grid[i + 1][j])
                __enque_adjacent(queue, front, i + 1, j, grid);
        if (i + 1 < h && j + 1 < w && !grid[i + 1][j + 1])
                __enque_adjacent(queue, front, i + 1, j + 1, grid);
        if (j + 1 < w && !grid[i][j + 1])
                __enque_adjacent(queue, front, i, j + 1, grid);
        if (i > 0 && j + 1 < w && !grid[i - 1][j + 1])
                __enque_adjacent(queue, front, i - 1, j + 1, grid);
}


int shortestPathBinaryMatrix(int** grid, int gridSize, int* gridColSize)
{
        int w = gridColSize[0];
        int h = w;
        
        if (grid[0][0] || grid[h - 1][w - 1])
                return -1;
        
        int front = -1;
        int rear = -1;
        struct cell *queue = malloc(sizeof(struct cell) * w * h);
        
        int len = 0;
        int tmp_rear, tmp_front;
        ++front;
        queue[front].x = 0;
        queue[front].y = 0;
        grid[0][0] = 1;
        while (rear < front) {
                len++;
                
                tmp_rear = rear;
                tmp_front = front;
                while (tmp_rear < tmp_front) {
                        ++tmp_rear;
                        if (queue[tmp_rear].x == h - 1 && queue[tmp_rear].y == w - 1)
                                return len;
                        else
                                enque_adjacent(grid, w, h, queue[tmp_rear].x, queue[tmp_rear].y , queue, &front);
                }
                rear = tmp_front;
        }
        
        //free queue
        return -1;
}