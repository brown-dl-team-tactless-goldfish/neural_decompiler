/*
    key idea is to think about each element s[i], how many substrings that s[i] can contribute to its appeals.
*/

typedef long long LL;

class Solution {
public:
    long long appealSum(string s) {
        unordered_map<LL, LL> S;
        int n = s.size();
        LL ans = 0;
        for (LL i = 1; i <= n; ++ i)
        {
            int c = s[i - 1] - 'a';
            int last = S[c];
            ans += (i - last) * (n - i + 1);
            S[c] = i;
        }
        return ans;
    }
};