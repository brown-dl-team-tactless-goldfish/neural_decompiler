#define max(a,b) ((a) > (b) ? (a) : (b))
//
//Sort string length
//
int cmpfunc(const void* a, const void* b){
    char* s1 = *(char**)a;
    char* s2 = *(char**)b;
    
    return strlen(s1) - strlen(s2);
}

//
//if s1 is s2's sub sequence string return true
//
bool strcmpEX(char* s1, char* s2){
    int len1 = strlen(s1);
    int len2 = strlen(s2); 
    
    int idx1 = 0, idx2 = 0;
    while(idx1 < len1 && idx2 < len2){
        if(s1[idx1] == s2[idx2]){
            idx1++;
            idx2++;
        }
        else
            idx2++;
    }
    if(idx1 != len1)
        return false;
    else
        return true;

}

//step 1 sort
//step use DP
int longestStrChain(char ** words, int wordsSize){
    qsort(words, wordsSize, sizeof(char*), cmpfunc);
    int* dp = malloc(wordsSize * sizeof(int));
    int i, j, m, n;
    dp[0] = 1;

    for(i = 1; i < wordsSize; i++){
        if(strlen(words[i]) == 1)
           dp[i] = 1;
        else 
           break;
    }
    int LSC = 1;
    for(j = i; j < wordsSize; j++){
        dp[j] = 1;
        for(m = j-1; m >=0; m--){
            if(strlen(words[m]) == strlen(words[j]) ){
                continue;
            }
            if(strlen(words[m]) < (strlen(words[j]) - 1)){
                break;
            }
            if(strcmpEX(words[m], words[j]) == true)
                dp[j] = max(dp[m] + 1, dp[j]);
        }      
        LSC = max(LSC, dp[j]);
    }
    free(dp);
    return LSC;
}