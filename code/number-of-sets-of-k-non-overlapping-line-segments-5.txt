class Solution {
public:
    #define ll long long
    int mod = 1e9 + 7; int n;
    ll dp[1001][1001][2];
    
    
    /* 
        the boolean danda represents that we currently have a stick in hand, and we have to end it somewhere
        if danda is true it simply means that the current position has the responsibility of ending the current stick somewhere
		sorry i tend to use hindi variables at times, kindly bear with me
    
    */
    
    ll f(int i, int k, bool danda) {
        
        if(i == n) return k == 0;
        if(dp[i][k][danda] != -1) return dp[i][k][danda];
        int ans  = 0;
        
        /* 
            if we are currently holding a stick, we have an option to either end it there, or we can ask the next position to decide 
            if we do not end the stick here, the next position now has to take the headache of ending the stick somewhere
            if we end the stick at the current position i, then the next position does not have the responsibility of ending any stick
                
        */
        
        if(danda)  ans = (f(i + 1, k, danda) % mod + f(i, k - 1, !danda) % mod ) % mod;
        
        /*
        
        if we are currently not holding any stick, we can either go to the next position without touching this point, or we can start a new stick at this point (we can start a new stick at this point if and only if k > 0, means there are still sticks remaining to be placed
        */
        else  ans = ((k > 0 ? f(i + 1, k,  true) : 0) % mod + f(i + 1, k, false) % mod) % mod;
        return dp[i][k][danda] = ans % mod;
        
    }
    int numberOfSets(int n, int k) {
        
        // k non overlapping line segements, and each should cover >= 2 points, they do not have to cover all the points
        memset(dp, -1, sizeof(dp));
        this->n = n;
        return f(0, k, false);
    }
};