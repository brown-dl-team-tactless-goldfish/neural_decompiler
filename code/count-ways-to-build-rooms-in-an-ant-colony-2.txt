#define vi vector<int>
#define vvi vector<vi>
#define ll long long

class Solution {
public:
    ll fact[100001];
    ll inv[100001];
    ll mod = 1000000007;
    
    int gr8pow(ll base, ll exp){
        ll res = 1;
        while(exp>0){
            if(exp & 1)
                res = (res * base)%mod;
            exp = exp>>1;
            base = (base * base)%mod;
        }
        return (int) res;
    }
    void precompute(){
        if(fact[0]==1) return;
        
        fact[0] = 1;
        for(int i=1; i<=1e5; i++)
            fact[i] = (fact[i-1]*i)%mod;
        
        inv[100000] = gr8pow(fact[100000], mod-2LL);
        for(int i=1e5-1; i>=0; i--){
            inv[i] = (inv[i+1]*(i+1) )%mod;
        }
    }
    
    int nCr(int n, int r){
        ll res = fact[n];
        res = (res * inv[r])%mod;
        res = (res * inv[n-r])%mod;
        return (int) res;
    }
    
    int dfs(int node, vvi& adj, vi& cnt, vi& dp){
        if(dp[node]!=-1) return dp[node];
        ll res = 1, Total_nodes = 0;
        for(auto &x:adj[node] ){
            int tmp = dfs(x, adj, cnt, dp);
            Total_nodes+= cnt[x];
            
            res = (nCr(Total_nodes, cnt[x]) * res)%mod;
            res = (res * tmp)%mod;
        }
        cnt[node] = (int) Total_nodes + 1; //self add
        return dp[node] = res;
    }
    
    int waysToBuildRooms(vector<int>& prevRoom) {
        precompute();               //be ready with all factorials and combinators
        
        int n = prevRoom.size();
        vvi adj(n);                           //parent se nodes ki trf
        vi cnt(n, 0), dp(n, -1);                         //nodes counting himself in subtree
        for(int i=1; i<n; i++)
            adj[prevRoom[i] ].push_back(i);
        
        return dfs(0, adj, cnt, dp);
    }
};