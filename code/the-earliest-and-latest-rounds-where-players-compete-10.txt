int memo[29][29][29];

class Solution {
public:    
    vector<int> earliestAndLatest(int n, int fi, int se) {
        memset(memo, -1, sizeof(memo));
        int r1 = dfs(n, fi-1, se-1, true);
        
        memset(memo, -1, sizeof(memo));
        int r2 = dfs(n, fi-1, se-1, false);
        
        return {r1 + 1, r2 + 1};
    }
    
    int dfs(int n, int fi, int se, bool find_min) {
        if (fi + se + 1 == n) return 0;
        
        int& res = memo[n][fi][se];
        if (res != -1) return res;
        
		// use to determine if the player is on the left or right
        int lfi = min(fi, n - fi - 1);
        int rfi = max(fi, n - fi - 1);
        int lse = min(se, n - se - 1);
        int rse = max(se, n - se - 1);
        
        int tmp = find_min ? INT_MAX : 0;
        int m = n / 2;
		// enumerate all possibilities
        for (int i = 0; i < pow(2, m); ++i) {
            // simulate
            // calculate decrease in pos
            int dfi = 0, dse = 0;
            for (int j = 0; j < m; ++j) {
                // determine winner from enumeration
                bool rightWin = (((i >> j) & 1) == 1);
                
                // overwrite winner if it's one of the players
                if (j == lfi) rightWin = fi == rfi;
                else if (j == lse) rightWin = se == rse;
                
                if (rightWin) {
                    // right side win
                    remove(j, fi, se, dfi, dse);
                } else {
                    // left side win
                    remove(n - j - 1, fi, se, dfi, dse);
                }
            }
            
            if (find_min) tmp = min(tmp, 1 + dfs(m + n % 2, fi + dfi, se + dse, find_min));
            else tmp = max(tmp, 1 + dfs(m + n % 2, fi + dfi, se + dse, find_min));
        }
        
        return res = tmp;
    }
    
    void remove(int j, int fi, int se, int& dfi, int& dse) {
        if (j < fi) dfi--;
        if (j < se) dse--;
    }
};