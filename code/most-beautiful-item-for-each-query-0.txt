/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int cmp(const void* a, const void* b){
    int* A = *(int**)a ;
    int* B = *(int**)b ;
    if(A[0] == B[0])
        return B[1] - A[1] ;
    return A[0] - B[0] ;
}
int binarySearch(int** set, int n, int val){
    int l = 0, r = n -1 ;
    while(l < r){
        int mid = r - (r-l)/2 ;
        if(set[mid][0] == val)
            return set[mid][1] ;
        else if(set[mid][0] < val)
            l = mid ;
        else
            r = mid - 1;
    }
    if(set[l][0] <= val)
        return set[l][1] ;
    else
        return 0 ;
}
int* maximumBeauty(int** items, int itemsSize, int* itemsColSize, int* queries, int queriesSize, int* returnSize){
    qsort( items, itemsSize, sizeof(int*) , cmp) ;
    int** set = malloc(itemsSize * sizeof(int*)) ;
    int set_cn = 0; 
    set[set_cn] = malloc(2 * sizeof(int)) ;
    set[set_cn][0] = items[0][0] ;
    set[set_cn][1] = items[0][1] ;
    set_cn++;
    for(int i = 1; i < itemsSize; i++){
        if(items[i][0] != items[i-1][0]){
            set[set_cn] = malloc(2 * sizeof(int) ) ;
            set[set_cn][0] = items[i][0] ;
            set[set_cn][1] = items[i][1] ;
            if(set[set_cn][1] < set[set_cn-1][1] )
                set[set_cn][1] = set[set_cn-1][1]  ;
            set_cn++;
        }
    }
    
    int* ans = malloc(queriesSize * sizeof(int)) ;
    for(int i = 0; i < queriesSize; i++){
        ans[i] = binarySearch(set, set_cn, queries[i]) ;
    }
    //free memory 
    for(int i = 0; i < set_cn; i++){
        free(set[i]) ;
    }
    free(set) ;
    *returnSize = queriesSize ;
    return ans ;
}