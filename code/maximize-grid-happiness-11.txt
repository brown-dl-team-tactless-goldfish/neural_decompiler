class Solution {
public:
    int N , M , tot;
    int DP[6][300][7][7];

    vector<int> convert(int mask){
        vector<int> ret(M);
        int c = 0;
        while(c < M){
            int v = mask % 3;
            ret[c] = v;
            mask /= 3;
            ++c;
        }
        reverse(ret.begin() , ret.end());
        return ret;
    }
    
    int max(int a , int b){
        return a >= b ? a : b;
    }
    
    int one[300] , two[300];
    vector<int> cur[300] , pre[300];
    
    int getMaxGridHappiness(int m, int n, int I, int E) {
    // 0 -> empty
    // 1 -> I
    // 2 -> E
        N = m;
        M = n;
        tot = 1;
        for(int i = 1; i <= M; ++i)tot *= 3;
        --tot;
        memset(DP , -1 , sizeof(DP));
        for(int mask = 0; mask <= tot; ++mask){
            cur[mask] = pre[mask] = convert(mask);
            for(int i : cur[mask])one[mask] += i == 1 , two[mask] += i == 2;
        }
        DP[0][0][0][0] = 0;
        for(int i = 0; i < N; ++i){
            for(int mask = 0; mask <= tot; ++mask){
                int ni = one[mask] , ne = two[mask];
                for(int x = ni; x <= I; ++x){
                    for(int y = ne; y <= E; ++y){
                        if(~DP[i][mask][x][y]){
                            for(int nmask = 0; nmask <= tot; ++nmask){
                                int nni = one[nmask] , nne = two[nmask];
                                if(x + nni > I)continue;
                                if(y + nne > E)continue;
                                int sum = 0;
                                for(int p = 0; p < M; ++p){
                                    if(cur[nmask][p] == 1){
                                        sum += 120;
                                        if(p){ // check left
                                            if(cur[nmask][p - 1] == 1)sum -= 60;
                                            if(cur[nmask][p - 1] == 2)sum -= 10;
                                        }
                                        if(pre[mask][p] == 1)sum -= 60;
                                        if(pre[mask][p] == 2)sum -= 10;
                                    }
                                    if(cur[nmask][p] == 2){
                                        sum += 40;
                                        if(p){ //check left
                                            if(cur[nmask][p - 1] == 1)sum -= 10;
                                            if(cur[nmask][p - 1] == 2)sum += 40;
                                        }
                                        if(pre[mask][p] == 1)sum -= 10;
                                        if(pre[mask][p] == 2)sum += 40;
                                    }
                                }
                                DP[i + 1][nmask][x + nni][y + nne] = max(DP[i + 1][nmask][x + nni][y + nne] , DP[i][mask][x][y] + sum);
                            }
                        }
                    }
                }
            }
        }
        int ret = 0;
        for(int mask = 0; mask <= tot; ++mask)
            for(int x = 0; x <= I; ++x)
                for(int y = 0; y <= E; ++y)
                    ret = max(ret , DP[N][mask][x][y]);
        return ret;
    }
};