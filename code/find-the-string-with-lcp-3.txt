class Solution {
public:
    int find(int x,vector<int> &p){
        if(p[x]==x)return x;
        return find(p[x],p);
    }
    void unon(int x,int y,vector<int> &p,vector<int> &sz){
        int a = find(x,p);
        int b = find(y,p);
        if(a==b)return;
        if(sz[a]<sz[b]){
            swap(a,b);
        }
        p[b] = a;
        sz[a] += sz[b];
    }
    string findTheString(vector<vector<int>>& lcp) {
        int i,j,n=lcp.size();
        vector<int> p(n),sz(n);
        for(i = 0; i < n; i++){
            sz[i] = 1;
            p[i] = i;
        }
        for(i = 0; i<n; i++){
            for(j = 0; j < n; j++){
                if(lcp[i][j]==0)continue;
                if(lcp[i][j])unon(i,j,p,sz);//ith and jth char is same if lcp>0 
                if(i==j&&lcp[i][j] !=n-i)return "";
            }
        }
        unordered_set<int> s;//find all possible disticnt char
        for(auto &i: p){
            s.insert(i);
        }
        if(s.size()>26)return "";//if no of possible chars > 26 return "";
        string str = "";
        unordered_map<int,char> mp;
        char c = 'a';
        for(i = 0; i < n; i++){
            if(mp.count(p[i])==0){
                mp[p[i]] = c++;//assign easch parent to disticnt char
            }
            str += mp[p[i]];
        }
        vector<vector<int>> dp(n,vector<int> (n,0));//make a lcp by answer string
        for(i = n-1; i >= 0; i--){
            for(j = n-1; j>=0; j--){
                if(str[i] != str[j])dp[i][j] = 0;
                else{
                    if(i+1<n&&j+1<n){
                        dp[i][j] += dp[i+1][j+1]+1;
                    }else{
                        dp[i][j] = 1;
                    }
                }
            }
        }
        for(i = 0; i < n; i++){
            for(j=  0; j < n; j++){
                if(dp[i][j]!=lcp[i][j])return "";//if not same return "";
            }
        }
        return str;
    }
};