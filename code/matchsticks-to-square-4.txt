/*
- total sum must be divisible by 4 (sides of the square)
- use DP with masking or DFS to check that at least 3 buckets have exactly sum/4
*/

bool dfs(int* arr, int n, bool* visited, int k, int start, long long sum, int target) {
  if (k==1) return true; // don't have to check last bucket
  
  // if current bucket greater than target, failed
  if (sum > target) return false;
  // if exactly filled the bucket, go to the next one
  if (sum==target) return dfs(arr, n, visited, k-1, 0, 0, target);
  
  // bucket not filled yet; go through rest of the arr
  for (int i=start; i<n; ++i) {
    if (!visited[i]) {
      visited[i] = true; // try using arr[i] to fill current bucket
      if (dfs(arr, n, visited, k, i+1, sum+arr[i], target)) return true;
      visited[i] = false; // failed while using arr[i] to fill current bucket
    }
  }
  return false;
}

bool makesquare(int* matchsticks, int matchsticksSize){
  long long sum = 0;
  int max = 0;
  for (int i=0; i<matchsticksSize; ++i) {
    if (matchsticks[i] > max) max = matchsticks[i];
    sum += matchsticks[i];
  }
  if (sum%4 != 0) return false;
  sum >>= 2; // target = sum/4
  // if max > target, cannot insert it in any bucket
  if (max > sum) return false;
  
  bool visited[matchsticksSize];
  for (int i=0; i<matchsticksSize; ++i) visited[i] = false;
  return dfs(matchsticks, matchsticksSize, visited, 4, 0, 0, sum);
}