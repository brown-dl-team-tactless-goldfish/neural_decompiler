class Solution {
public:
    int kSimilarity(string s1, string s2) {
        queue<string> q;
        unordered_set<string> seen;
        q.push(s1);
        seen.insert(s1);

        auto getNxt = [&](string t) {
            vector<string> res;
            for(int i = 0; i < t.size(); i++) {
                if(t[i] != s2[i]) {
                    for(int j = i+1; j < t.size(); j++) {
                        if(t[j] == s2[i]) {
                            string candi = t;
                            swap(candi[i], candi[j]);
                            if(t[i] == s2[j]) return vector<string>{candi};//perfect swap
                            res.push_back(candi);
                        }
                    }
                    return res;
                }
            }
            return res;
        };

        int k = 0;
        while(!q.empty()) {
            for(int sz = q.size(); sz > 0; sz--) {
                auto t = q.front(); q.pop();
                if(t == s2) return k;
                for(auto nxt : getNxt(t)) {
                    if(seen.find(nxt) == seen.end()) {
                        q.push(nxt);
                        seen.insert(nxt);
                    }
                }
            }
            k++;
        }
        return k;
    }
};