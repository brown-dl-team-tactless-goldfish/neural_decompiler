// regular string hashing, but note that here the modulo is given instead of using 
// "unsigned long long" implicitly, and % works differently for unsigned type, thus
// need to use signed type with %.


typedef long long ULL;

const int N = 20010;

class Solution {
    int n, m, P;
    ULL p[N] = {}, h[N] = {};
    
    void init(string& s)
    {
        p[0] = 1;
        for (int i = n - 1, j = 1; i >= 0; -- i, ++ j)
        {
            p[j] = (p[j - 1] * P) % m;
            h[i] = (h[i + 1] * P + s[i] - 'a' + 1) % m;
        }
    }
    
    ULL get(int l, int r)
    {
        return ((h[l] - h[r + 1] * p[r - l + 1]) % m + m) % m;
    }
    
public:
    string subStrHash(string s, int _P, int _m, int k, int hashValue) {
        n = s.size(), m = _m, P = _P;

        init(s);
        
        unordered_map<ULL, int> S;
        for (int i = 0; i + k - 1 < n; ++ i)
        {
            int j = i + k - 1;
            ULL v = get(i, j);
            if (v == hashValue) return s.substr(i, k);
        }
        return "";
    }
};