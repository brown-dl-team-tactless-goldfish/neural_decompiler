// analysis
// if grid[m][n] == -1 and n == leftwall(0); return -1
// if grid[m][n] == 1 and n == rightwall(nCol-1); return -1
// if grid[m][n] == 1 and grid[m][n+1] == -1; return -1
// if grid[m][n] == -1 and grid[m][n-1] == 1; return -1
// check next row until bottom, return n + grid[m][n]
int checkBall(int** grid, int m, int n, const int nRow, const int nCol) {
    if ((grid[m][n] == -1 && n == 0) || (grid[m][n] == 1 && n == nCol - 1)) {
        return -1;
    }
    if ((grid[m][n] == 1 && n < (nCol - 1) && grid[m][n+1] == -1) ||
        (grid[m][n] == -1 && n > 0 && grid[m][n-1] == 1)) {
            return -1;
    }
    if (m == (nRow - 1)) {
        return n + grid[m][n]; // get out
    } else {
        return checkBall(grid, ++m, n + grid[m][n], nRow, nCol);
    }
}

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* findBall(int** grid, int gridSize, int* gridColSize, int* returnSize){
    int *ans = (int *) calloc(*gridColSize, sizeof(int));
    *returnSize = *gridColSize;
    int i = 0;

    do {
        ans[i] = checkBall(grid, 0, i, gridSize, *gridColSize);
    } while (++i < *gridColSize);

    return ans;
}