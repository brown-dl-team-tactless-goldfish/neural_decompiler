long tmp[100001];
void merge(long *arr, int start, int end)
{
        int mid = start + (end - start) / 2;
        int i, j, k;

        i = start;
        j = mid + 1;
        k = start;
        while (i <= mid && j <= end) {
                if (arr[i] < arr[j])
                        tmp[k++] = arr[i++];
                else
                        tmp[k++] = arr[j++];

        }

        while (i <= mid)
                tmp[k++] = arr[i++];

        while (j <= end)
                tmp[k++] = arr[j++];

        for (i = start; i <= end; i++) {
                arr[i] = tmp[i];
        }
}

int merge_count(long *arr, int start, int end, int lower, int upper)
{
        int count = 0;
        if (start >= end)
                return 0;

        int mid = start + (end - start) / 2;
        count += merge_count(arr, start, mid, lower, upper);
        count += merge_count(arr, mid + 1, end, lower, upper);

        int i;
        //[l, r) 表示的范围：范围中的任意一个前缀和节点，减去前半段中的一个节点，差值满足[lower, upper]
        //为什么要执行下面的归并排序？如果前半段是单调递增的，那么为了保持差值满足一定的要求，后半段的l、r值
        //也只能往右移动，也就是说保证了l、r的单调性。避免了前半段i每换一个节点，后半段的l、r都得重新循环一遍。
        //降低了时间复杂度
        int l = mid + 1;
        int r = mid + 1;
        for (i = start; i <= mid; i++) {
                while (l <= end && arr[l] - arr[i] < lower)
                        l++;
                while (r <= end && arr[r] - arr[i] <= upper)
                        r++;
                count += r - l;
        }
        
        merge(arr, start, end);
        return count;
}


int countRangeSum(int* nums, int numsSize, int lower, int upper)
{
        long *prefix_sum = (long *)malloc(sizeof(long) * (numsSize + 1));
        
        //必须要加一个顶部元素‘0’进去：因为每个元素是通过前缀和数组相减得到；如果不插入头部元素，
        //以头部元素开始的区间段就无法被统计到
        prefix_sum[0] = 0;
        int i;
        for (i = 1; i <= numsSize; i++) {
                prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1];
        }

        int count;
        count = merge_count(prefix_sum, 0, numsSize, lower, upper);
        
        free(prefix_sum);
        return count;
}
                                                                   