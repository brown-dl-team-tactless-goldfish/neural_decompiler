int cmp(const void* a, const void* b) {
    return *(const int*) a - *(const int*) b;
}

int** diagonalSort(int** mat, int matSize, int* matColSize, int* returnSize, int** returnColumnSizes) {
    int rSize = matSize, cSize = matColSize[0];
    *returnSize = rSize;
    int** res = (int**) malloc(rSize * sizeof(int*));
    int* tmp = (int*) malloc(cSize * sizeof(int));
    *returnColumnSizes = (int*) malloc(rSize * sizeof(int));
    for(int i = 0; i < rSize; i++) {
        res[i] = (int*) malloc(cSize * sizeof(int));
        (*returnColumnSizes)[i] = cSize;
    }
    res[rSize-1][0] = mat[rSize-1][0];
    res[0][cSize-1] = mat[0][cSize-1];
	
    for(int r = rSize-2; r >= 0; r--) {
        int idx = 0, ridx = r, cidx = 0;
        while(ridx < rSize && cidx < cSize) {
            tmp[idx++] = mat[ridx++][cidx++];
        }
        qsort(tmp, idx, sizeof(int), cmp);
        idx = 0; ridx = r; cidx = 0;
        while(ridx < rSize && cidx < cSize) {
            res[ridx++][cidx++] = tmp[idx++];
        }
    }
	
    for(int c = 1; c < cSize-1; c++) {
        int idx = 0, ridx = 0, cidx = c;
        while(ridx < rSize && cidx < cSize) {
            tmp[idx++] = mat[ridx++][cidx++];
        }
        qsort(tmp, idx, sizeof(int), cmp);
        idx = 0; ridx = 0, cidx = c;
        while(ridx < rSize && cidx < cSize) {
            res[ridx++][cidx++] = tmp[idx++];
        }
    }
    free(tmp);
    return res;
}