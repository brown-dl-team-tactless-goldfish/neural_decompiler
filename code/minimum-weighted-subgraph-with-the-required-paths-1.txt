using LL = long long ;
using PII = pair<LL, LL> ;
class Solution {
    int n ;
public:
    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {
        this->n = n ;
        vector<vector<PII>> forward(n) ;
        vector<vector<PII>> backward(n) ;
        for(auto e : edges){
            int a = e[0], b = e[1], c = e[2] ;
            forward[a].push_back({b, c}) ;
            backward[b].push_back({a, c}) ;
        }
        
        vector<LL> src1ToNode = dijkstra(src1, forward) ;
        vector<LL> str2ToNode = dijkstra(src2, forward) ;
        vector<LL> NodeToDest = dijkstra(dest, backward) ;
        LL ans = LLONG_MAX/3 ;
        for(int i = 0; i < n; i++){
            ans = min(ans, src1ToNode[i] + str2ToNode[i] + NodeToDest[i] ) ;
        }
     
        return (ans >= LLONG_MAX/3) ? -1 : ans ;
    }
    
    vector<LL> dijkstra(int src, vector<vector<PII>> & map)
    {
        vector<LL> dist(n, LLONG_MAX/3) ;
        priority_queue<PII, vector<PII>, greater<>> pq ;
        pq.push({0, src}) ;
        while( !pq.empty() ){
            auto[d, cur] = pq.top() ;
            pq.pop() ;
            if(dist[cur] == LLONG_MAX/3)
                dist[cur] = d ;
            else
                continue ;
            
            for(auto [nxt, weight] : map[cur])
            {
                if(dist[nxt] < LLONG_MAX/3) 
                    continue ;
                pq.push({d + weight, nxt}) ;
            }
        }
        return dist ;
    }
};