class Solution {
public:
    int minPushBox(vector<vector<char>>& grid) {
        const int n = grid.size(), m = grid[0].size();
        State s0;
        int endX=0, endY=0;
        for(int i=0;i<n;i++)for(int j=0;j<m;j++){
            if(grid[i][j] == 'S') s0.px=i,s0.py=j;
            else if(grid[i][j] == 'B') s0.bx=i, s0.by=j;
            else if(grid[i][j] == 'T') endX=i, endY=j;
        }
        priority_queue<State> q;
        q.push(s0);
        vector<bool> visited(20*20*20*20, false);    
        visited[s0.hash()] = true;
        
        while(!q.empty()){
            auto s = q.top(); q.pop();
            for(const auto& neib : getNeighbor(s, grid, n, m)){
                if(visited[neib.hash()]) continue;
                visited[neib.hash()] = true;
                if(neib.bx==endX && neib.by==endY) return neib.step;
                q.push(neib);
            }
        }
        return -1;
    }
    
    struct State{
        int bx = -1;
        int by = -1;
        int px = -1;
        int py = -1;
        int step = 0;
        
        bool operator<(const State& rhs)const {
            if(step != rhs.step) return step > rhs.step;
            return hash() < rhs.hash();
        }
        
        int hash() const{
            return bx*20*20*20 + by*20*20 + px*20 + py;
        }
    };
    
    vector<State> getNeighbor(State s, vector<vector<char>>& grid, int n, int m){
        static const vector<pair<int,int>> dirs = {{0,1},{0,-1},{-1,0},{1,0}};
        static auto isValid = [&](int x, int y){
            return x>=0 && x<n && y>=0 && y<m && grid[x][y] != '#'; };
        
        auto [bx, by, px, py, step] = s;
        
        vector<State> res;
        for(auto [dx, dy] : dirs){
            int px1 = px+dx, py1=py+dy;
            if(isValid(px1, py1) && (px1 != bx || py1 != by)) res.push_back(State{bx, by, px1, py1, step});
        }
        
        State s1;
        if(bx==px && by==py+1){
            s1 = State{bx, by+1, bx, by, step+1};
        }
        else if(bx == px && by==py-1){
            s1 = State{bx, by-1, bx, by, step+1};
        }
        else if(by==py && bx==px+1){
            s1 = State{bx+1, by, bx, by, step+1};
        }
        else if(by==py && bx==px-1){
            s1 = State{bx-1, by, bx, by, step+1};
        }
        if(isValid(s1.bx, s1.by)) res.push_back(s1);
        return res;
    }
};