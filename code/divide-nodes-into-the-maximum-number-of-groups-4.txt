class Solution {
public:
    vector<vector<int>> aj;
    vector<int> group;
    int dist[501][501] = {INT_MAX};
    
    
    void updateDist(int src) {
        for(int i=1; i<=500; i++) 
            dist[src][i] = INT_MAX;
        dist[src][src] = 1;
        
        queue<int> q;
        q.push(src);
        while(!q.empty()) {
            int u = q.front(); q.pop();
            for(int v: aj[u]) {
                if(dist[src][v]>dist[src][u]+1) {
                    dist[src][v] = dist[src][u]+1;
                    q.push(v);
                }
            }
        }
    }
    

    int magnificentSets(int n, vector<vector<int>>& edges) {
        aj.resize(n+1);
        group.resize(n+1, -1);
        for(auto& edge: edges) {
            int a = edge[0], b = edge[1];
            aj[a].push_back(b);
            aj[b].push_back(a);
        }
        
        for(int i=1; i<=n; i++) 
            updateDist(i);
        
        int ret = 0;
        for(int i=1; i<=n; i++) {
            if(group[i]!=-1) continue;
            
            vector<int> visited;
            queue<pair<int,int>> q;
            q.push({i, 0});
            group[i] = 0;
            visited.push_back(i);
            while(!q.empty()) {
                auto [node, g] = q.front(); 
                q.pop();
                for(int nxt: aj[node]) {
                    if(group[nxt]==g) return -1;
                    if(group[nxt]==-1) {
                        q.push({nxt, 1-g});
                        group[nxt] = 1-g;
                        visited.push_back(nxt);
                    }
                }
            }
            
            int maxdist = 0;
            for(auto i: visited) {
                for(auto j: visited) {
                    maxdist = max(maxdist, dist[i][j]);
                }
            }
            ret += maxdist;
        }
        
        
        return ret;
        
    }
};