/**
 * Return an array of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */
#define SIZE 1000
struct HashArray
{
    int key;
    int count;
    struct Array* next;
}Hash[SIZE];
void addHash(int num)
{
    int temp=abs(num%SIZE);
    if(Hash[temp].key==0)
    {
        Hash[temp].key=num;
        Hash[temp].count++;
    }else if(Hash[temp].key==num)
    {
        Hash[temp].count++;     
    }else
    {
        struct HashArray *p=&Hash[temp]; 
        while(p->key!=num&&p->next!=NULL)    
        {p=p->next;}
        if(p->key==num)
        {p->count++;}
        else
        {
            p->next=(struct HashArray*)malloc(sizeof(struct HashArray));
            p=p->next;
            p->key=num;
            p->count=1;
            p->next=NULL;
        }
    }   
}
int* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {   
    if(nums1Size==0||nums2Size==0)
    {
        *returnSize=0;
        return NULL;
    }
    int* result=(int*)malloc(sizeof(int)*1000);
    int count=0;
    int temp=0;
    for(int i=0;i<SIZE;i++)
    {
        Hash[i].key=0;
        Hash[i].count=0;
        Hash[i].next=NULL;
    }
    for(int i=0;i<nums1Size;i++)
    {addHash(nums1[i]);}
    for(int i=0;i<nums2Size;i++)
    {
        temp=abs(nums2[i]%SIZE);
        if(Hash[temp].key==nums2[i]&&Hash[temp].count!=0)
        {
            Hash[temp].count--; 
            result[count]=nums2[i];
            count++;
        }else
        { 
            struct HashArray *p=&Hash[temp]; 
            while(p->key!=nums2[i]&&p->next!=NULL) 
            { p=p->next;}
            if(p->key==nums2[i]&&p->count!=0)
            {
                p->count--;
                result[count]=nums2[i];
                count++;
            }else if(p->next==NULL)
            {continue;}
        }
    }
    *returnSize=count;
    return result;
}