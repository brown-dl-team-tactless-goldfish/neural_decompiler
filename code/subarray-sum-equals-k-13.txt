long tmp[ 20001];
void merge(long *arr, int start, int end)
{
        int mid = start + (end - start) / 2;
        int i, j, k;

        i = start;
        j = mid + 1;
        k = start;
        while (i <= mid && j <= end) {
                if (arr[i] < arr[j])
                        tmp[k++] = arr[i++];
                else
                        tmp[k++] = arr[j++];

        }

        while (i <= mid)
                tmp[k++] = arr[i++];

        while (j <= end)
                tmp[k++] = arr[j++];

        for (i = start; i <= end; i++) {
                arr[i] = tmp[i];
        }
}

int merge_count(long *arr, int start, int end, int k)
{
        int count = 0;
        if (start >= end)
                return 0;

        int mid = start + (end - start) / 2;
        count += merge_count(arr, start, mid, k);
        count += merge_count(arr, mid + 1, end, k);

        int i;
        int l = mid + 1;
        int r = mid + 1;
        for (i = start; i <= mid; i++) {
                while (l <= end && arr[l] - arr[i] < k)
                        l++;
                while (r <= end && arr[r] - arr[i] <= k)
                        r++;
                count += r - l;
        }
        
        merge(arr, start, end);
        return count;
}

int subarraySum(int* nums, int numsSize, int k)
{
        long *prefix_sum = (long *)malloc(sizeof(long) * (numsSize + 1));
        
        prefix_sum[0] = 0;
        int i;
        for (i = 1; i <= numsSize; i++) {
                prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1];
        }

        int count;
        count = merge_count(prefix_sum, 0, numsSize, k);
        
        free(prefix_sum);
        return count;
}