
// Solution: 1

#define rep(i, s, n)  for(int i = s; i < n; i++)
#define rrep(i, n, s) for(int i = n; i >= s; i--)
const int N = 1e5 + 5;
typedef long long ll;

class Solution {
    vector<ll> g[N];
    ll depth[N], ans[N];
    vector<int> price;

    void height(int u, int p) {
        ll mx = price[u];
        for(int v: g[u]) {
            if(v == p) continue;
            height(v, u);
            mx = max(mx, price[u] + depth[v]);
        }
        depth[u] = mx;
    }

    void dfs(int u, int p, ll prnt_max) {
        vector<ll> suffix_max, prefix_max;
        for(int v: g[u]) {
            if(v == p) continue;
            prefix_max.push_back(depth[v]);
            suffix_max.push_back(depth[v]);
        }

        int n = prefix_max.size();
        rep(i, 1, n) prefix_max[i] = max(prefix_max[i], prefix_max[i-1]);
        rrep(i, n-2, 0) suffix_max[i] = max(suffix_max[i], suffix_max[i+1]);

        int i = 0;
        for(int v: g[u]) {
            if(v == p) continue;
            ll left_max = (i == 0) ? 0 : prefix_max[i-1];
            ll right_max = (i == n-1) ? 0 : suffix_max[i+1];
            // in leaf height = 0
            ll parent_max = price[u] + max(prnt_max, max(left_max, right_max));
            dfs(v, u, parent_max);
            i++;
        }

        ans[u] = price[u] + max(prnt_max, n == 0 ? 0 : prefix_max.back());
    }
  
public:
    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& _price) {
        price = _price;
        
        for(auto it: edges) {
            g[it[0]].push_back(it[1]);
            g[it[1]].push_back(it[0]);
        }

        height(0, -1);
        dfs(0, -1, -1);

        ll mx = 0;
        for(int i = 0; i < n; i++) {
            mx = max(mx, ans[i]-price[i]);
        }
        
        return mx;
    }
};



// Solution: 2
// using two max for each node
const int N = 1e5 + 5;
typedef long long ll;

class Solution {
    vector<int> price;
    vector<int> g[N];
    ll mx1[N], mx2[N];
    int child[N];
    // child = child of u through which it has max height

    // calculate mx1 and mx2 for each node
    void dfs1(int u, int p = -1) {
        mx1[u] = price[u];
        mx2[u] = price[u];
        for (auto v : g[u]) {
            if (v == p)continue;
            dfs1(v, u);

            if(mx1[u] < price[u] + mx1[v]) {
                mx2[u] = mx1[u];
                mx1[u] = price[u] + mx1[v];
                child[u] = v;
            }
            else if (mx2[u] < price[u] + mx1[v]) {
                mx2[u] = price[u] + mx1[v];
            }
        }
    }

    // calculate for every node x the maximum length of a path through its parent p
    void dfs2(int u, int p = -1) {
        for (auto v : g[u]) {
            if (v == p) continue;
            if (child[u] == v) {
                if (mx1[v] < price[v] + mx2[u]) {
                    mx2[v] = mx1[v];
                    mx1[v] = price[v] + mx2[u];
                    child[v] = u;
                }
                else {
                    mx2[v] = max(mx2[v], price[v] + mx2[u]);
                }
            }
            else {
                mx2[v] = mx1[v];
                mx1[v] = price[v] + mx1[u];
                child[v] = u;
            }
            dfs2(v, u);
        }
    }
  
public:
    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& _price) {
        price = _price;
        
        for(auto it: edges) {
            g[it[0]].push_back(it[1]);
            g[it[1]].push_back(it[0]);
        }

        dfs1(0, -1);
        dfs2(0, -1);

        ll mx = 0;
        for(int i = 0; i < n; i++) {
            mx = max(mx, mx1[i]-price[i]);
        }
        
        return mx;
    }
};
