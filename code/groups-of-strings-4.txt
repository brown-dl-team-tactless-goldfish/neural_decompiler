class Solution {
public:
    unordered_map<int, unordered_set<int>> G;  // graph G
    
    unordered_map<int, int> cache; // cache all possible nodes
    
    void addNode(const string& s) {
        int mask = 0;
        for(auto& c : s) {
            mask |= (1 << (c - 'a'));
        }
        cache[mask] += 1; // account for duplicate words in vocabulary
    }
    
    bool count[26];  // save time by avoiding dynamic allocation on heap
    
    void addEdge(const string& s) {
        memset(count, 0, sizeof(count));
        int mask = 0;
        for(auto& c : s) {
            count[c - 'a'] = true;
            mask |= (1 << (c - 'a'));
        }
        if(G.count(mask)) return;  // don't process a duplicate word twice
        int self = mask;
        G[mask].insert(mask);
        vector<int> alpha_set, alpha_noset; // lower case letters used / not used in the current word
        for(int i=0; i<26; i++) {
            if(count[i]) { // adding letter 'a' + i
                mask = self - (1 << i);
                if(cache.count(mask)) {
                    G[self].insert(mask);
                }
                alpha_set.push_back(i);
            }
            else { // deleting letter 'a' + i
                mask = self + (1 << i);
                if(cache.count(mask)) {
                    G[self].insert(mask);
                }
                alpha_noset.push_back(i);
            }
        }
        for(auto& i : alpha_set) {
            for(auto& j : alpha_noset) { // adding letter 'a' + j, deleting letter 'a' + i
                mask = self - (1 << i) + (1 << j);
                if(cache.count(mask)) {
                    G[self].insert(mask);
                }
            }
        }
    }
    
    vector<int> groupStrings(vector<string>& words) {
        for(auto& s : words) {
            addNode(s);
        }
        for(auto& s : words) {
            addEdge(s);
        }
        int count = 0, max_sz = 0;
        int tmp, u, v, cur_sz;
        queue<int> q;    // pre-allocating all the variables and data structure required
        for(auto it = G.begin(); it != G.end(); it++) {
            tmp = 0;
            swap(cache[it->first], tmp); // use a swap so that we only need to hash once
            if(tmp) {
                count += 1;
                cur_sz = 0;
                q.push(it->first);
                cur_sz += tmp;    // account for duplicate words in vocabulary
                while(!q.empty()) {
                    u = q.front();
                    q.pop();
                    auto sit = G.find(u);    // use find so that only one hashing is required
                    for(auto tit = sit->second.begin(); tit != sit->second.end(); tit++) {
                        v = *tit;
                        tmp = 0;
                        swap(tmp, cache[v]);
                        if(tmp) {
                            q.push(v);
                            cur_sz += tmp;
                        }
                    }
                }
                max_sz = max(max_sz, cur_sz);
            }
        }
        return vector<int>{count, max_sz};
    }
};