public class Solution {
    
    public class UnionFind
    {
        private int[] parent;
        private int[] rank;
        
        public UnionFind(int n)
        {
            parent = new int[n];
            rank = new int[n];
            for(int i = 0; i < n; i++)
            {
                parent[i] = i;
                rank[i] = 1;
            }
        }
        
        public int Find(int x)
        {
            if(x == parent[x])
                return x;
            
            return parent[x] = Find(parent[x]);
        }
        
        public void Union(int x, int y)
        {
            int px = Find(x);
            int py = Find(y);
            if(px == py)
                return;
            
            if(rank[px] > rank[py])
                parent[py] = px;
            else if(rank[px] < rank[py])
                parent[px] = py;
            else
            {
                parent[px] = py;
                rank[py]++;
            }
        }
        
        public bool IsConnect(int x, int y)
        {
            return Find(x) == Find(y);
        }
    }
    
    public bool ContainsCycle(char[][] grid) {
    
        int m = grid.Length, n = grid[0].Length;
        UnionFind uf = new UnionFind(m * n);
        
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                int curr = i * n + j;
                int up = (i-1) * n + j;
                int left = i * n + j - 1;
                
                if(i > 0 && j > 0 && grid[i][j] == grid[i-1][j] && grid[i][j] == grid[i][j-1] && uf.Find(up) == uf.Find(left))
                    return true;
                
                if(i > 0 && grid[i][j] == grid[i-1][j])
                    uf.Union(curr, up);
                if(j > 0 &&grid[i][j] == grid[i][j-1])
                    uf.Union(curr, left);
            }
        }
        
        return false;
    }
}