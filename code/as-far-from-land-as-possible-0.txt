void dfs(int **grid, int gs, int n, int m, int x, int * p){
    if (grid[n][m] == 0) *p += 1; // Count zeros.
    if (grid[n][m] == 1) x = 1; // x will be incremented by one below, so the next 0 will be 1+1 = 2.
    else if (grid[n][m] != 0 && grid[n][m] <= x) return; // No need to change a cell that is less than or
	                                                     // equal to x.
    grid[n][m] = x;

    if (n > 0    && !(x == 1 && grid[n - 1][m] == 1)) dfs(grid, gs, n - 1, m, x + 1, p);
    if (n < gs-1 && !(x == 1 && grid[n + 1][m] == 1)) dfs(grid, gs, n + 1, m, x + 1, p);
    if (m > 0    && !(x == 1 && grid[n][m - 1] == 1)) dfs(grid, gs, n, m - 1, x + 1, p);
    if (m < gs-1 && !(x == 1 && grid[n][m + 1] == 1)) dfs(grid, gs, n, m + 1, x + 1, p);

    return;
}

int maxDistance(int** grid, int gs, int* gridColSize){
    int p = 0;

    for (int n = 0; n < gs; n++){
        for (int m = 0; m < gs; m++){
            if (grid[n][m] == 0) { // Find first 0.
                dfs(grid, gs, n, m, 101/*<- Start with big number*/, &p);
                break;
            }
        }
    }

    // If p == 0 then all cells are 1's. If p == gs *gs then all cells are 0's.
    if (p == gs * gs || p == 0) return -1; 

    int ans = 0;

    for (int n = 0; n < gs; n++){
        for (int m = 0; m < gs; m++){
            if (grid[n][m] > ans) ans = grid[n][m];
        }
    }

    // All the zero cells that are next to a 1 are set as 2 in the dfs function
    // which will make the answer off by one.
    return ans - 1;
}