class Solution {
public:
    struct Node {
        int mx, my, cx, cy, t;
        
        Node() {}
        
        Node(int mx_, int my_, int cx_, int cy_, int t_) : mx(mx_), my(my_), cx(cx_), cy(cy_), t(t_) {}
    };
    
    bool canMouseWin(vector<string>& grid, int catJump, int mouseJump) {
        int m = grid.size(), n = grid[0].size();
        bool dp[m][n][m][n][2];
        memset(dp, 0, sizeof(dp));
        int mr, mc, cr, cc, fr, fc;
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(grid[i][j] == 'M') {
                    mr = i;
                    mc = j;
                }
                else if(grid[i][j] == 'C') {
                    cr = i;
                    cc = j;
                }
                else if(grid[i][j] == 'F') {
                    fr = i;
                    fc = j;
                }
            }
        }
        queue<Node> q;
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(grid[i][j] != 'F' && grid[i][j] != '#') {
                    dp[fr][fc][i][j][1] = true;
                    q.push(Node(fr, fc, i, j, 1));
                }
            }
        }
        // count number of next nodes for cat
        int cnt[m][n][m][n];
        memset(cnt, 0, sizeof(cnt));
        vector<vector<int>> moves{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        for(int mx = 0; mx < m; mx++) {
            for(int my = 0; my < n; my++) {
                if(grid[mx][my] == '#') continue;
                for(int cx = 0; cx < m; cx++) {
                    for(int cy = 0; cy < n; cy++) {
                        if(grid[cx][cy] == '#') continue;
                        cnt[mx][my][cx][cy] = 1;    // stay in the same position
                        for(auto& dir : moves) {
                            for(int step = 1; step <= catJump; step++) {
                                int r = cx + step * dir[0];
                                int c = cy + step * dir[1];
                                if(r >= 0 && r < m && c >= 0 && c < n) {
                                    if(grid[r][c] != '#') cnt[mx][my][cx][cy] += 1;
                                    else break;  // reach a wall, stop!
                                }
                            }
                        }
                    }
                }
            }
        }
        // percolate (bfs)
        int d = 0;
        while(!q.empty() && d < 1000) {
            d += 1;
            int sz = q.size();
            while(sz-- > 0) {
                auto p = q.front();
                q.pop();
                if(p.t == 1) {
                    if(!(p.mx == fr && p.my == fc)) {
                        if(!dp[p.mx][p.my][p.cx][p.cy][0]) {
                            dp[p.mx][p.my][p.cx][p.cy][0] = true;
                            q.push(Node(p.mx, p.my, p.cx, p.cy, 0));
                        }
                    }
                    for(auto& dir : moves) {
                        for(int step = 1; step <= mouseJump; step++) {
                            int r = p.mx + step * dir[0];
                            int c = p.my + step * dir[1];
                            if(r >= 0 && r < m && c >= 0 && c < n && grid[r][c] != '#'
                              && !(r == p.cx && c == p.cy) && !dp[r][c][p.cx][p.cy][0]) {
                                dp[r][c][p.cx][p.cy][0] = true;
                                q.push(Node(r, c, p.cx, p.cy, 0));
                            }
                            if(r >= 0 && r < m && c >= 0 && c < n && grid[r][c] == '#') break;  // reach a wall, stop!
                        }
                    }
                }
                else {
                    if(--cnt[p.mx][p.my][p.cx][p.cy] == 0) {
                        dp[p.mx][p.my][p.cx][p.cy][1] = true;
                        q.push(Node(p.mx, p.my, p.cx, p.cy, 1));
                    }
                    for(auto& dir : moves) {
                        for(int step = 1; step <= catJump; step++) {
                            int r = p.cx + step * dir[0];
                            int c = p.cy + step * dir[1];
                            if(r >= 0 && r < m && c >= 0 && c < n && grid[r][c] != '#' 
                               && !(r == p.mx && c == p.my) && --cnt[p.mx][p.my][r][c] == 0) {
                                dp[p.mx][p.my][r][c][1] = true;
                                q.push(Node(p.mx, p.my, r, c, 1));
                            }
                            if(r >= 0 && r < m && c >= 0 && c < n && grid[r][c] == '#') break;  // reach a wall, stop!
                        }
                    }
                }
            }
        }
        return dp[mr][mc][cr][cc][0];
    }
};