class Solution {
    void dfs(const vector<vector<int>> &con, const string &colors, const int x, const char c, vector<int> &dp, stack<int>& s) {
        dp[x] = 0;
        for (int y : con[x]) {
            if (dp[y] < 0) {
                dfs(con, colors, y, c, dp, s);
            }
             dp[x] = max(dp[x], dp[y]);
        }
        if (colors[x] == c) {
            ++dp[x];
        }
        s.push(x);
        
    }
public:
    int largestPathValue(string colors, vector<vector<int>>& edges) {
        const int n = colors.size();
        vector<vector<int>> con(n);
        for (const auto& e : edges) {
            if (e[0] == e[1]) {
                return -1;
            }
            con[e[0]].push_back(e[1]);
        }
        int state = 0;
        int r = 0;
        for (char c : colors) {
            const int mask = 1 << (c - 'a');
            if ((state & mask) == 0) {
                vector<int> dp(n, -1);
                stack<int> s;
                for (int i = 0; i < n; ++i) {
                    if (dp[i] < 0) {
                        dfs(con, colors, i, c, dp, s);
                        r = max(r, dp[i]);
                    }
                }
                if (state == 0) {
                    vector<int> ord(n);
                    for (int i = 0; !s.empty(); ++i, s.pop()) {
                        ord[s.top()] = i;
                    }
                    for (const auto& e :edges) {
                        if (ord[e[0]] >= ord[e[1]]) {
                            return -1;
                        }
                    }
                }
                state |= mask;
            }
        }
        return r;
        
    }
};