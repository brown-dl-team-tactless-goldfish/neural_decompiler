using ll = int64_t;
const ll inf = 1e18+5;

template <class X, X (*op)(X, X)>
struct SegTree {
    int N;
    X BASE;
    vector<X> T;
    void build(int v, int tl, int tr, vector<X> &A) {
        // v: tree index, tl/tr: tree bounds
        if (tl == tr) T[v] = A[tl];
        else {
            int mid = (tl + tr) / 2;
            build(v*2, tl, mid, A);
            build(v*2+1, mid+1, tr, A);
            T[v] = op(T[v*2], T[v*2+1]);
        }
    }
    X query(int al, int ar) { return query(al, ar, 1, 0, N-1); }
    X query(int al, int ar, int v, int tl, int tr) {
        // al/ar: arr bounds
        if (al > ar) return BASE;
        if (al == tl && ar == tr) return T[v];
        int mid = (tl + tr) / 2;
        X ql = query(al, min(ar, mid), v*2, tl, mid);
        X qr = query(max(al, mid+1), ar, v*2+1, mid+1, tr);
        return op(ql, qr);
    }
    void update(int i, X val) { update(i, val, 1, 0, N-1); }
    void update(int i, X val, int v, int tl, int tr) {
        // i: arr index, val: new value
        if (tl == tr) T[v] = val;
        else {
            int mid = (tl + tr) / 2;
            if (i <= mid) update(i, val, v*2, tl, mid);
            else update(i, val, v*2+1, mid+1, tr);
            T[v] = op(T[v*2], T[v*2+1]);  // adjust
        }
    }
    void init(vector<X>& a, X base) {
        N = a.size();
        T.assign(4*N, base);
        BASE = base;
        build(1, 0, N-1, a);
    }
};

ll fmax(ll x, ll y) { return max(x,y); }
ll fsum(ll x, ll y) { return   x + y;  }

class BookMyShow {
public:
    int n, m;
    int j = 0;  // MONOTONIC pointer, only advances forward. 
    vector<ll> A;
    SegTree<ll, fmax> mx;
    SegTree<ll, fsum> sum;

    BookMyShow(int n, int m) : n(n), m(m) {
        A.assign(n, m);
        sum.init(A, 0);
        mx.init(A, -inf);
    }

    vector<int> gather(int k, int maxRow) {
        int l = 0, r = maxRow+1;
        while (l < r) {
            int m = (l+r) >> 1;
            int mn = mx.query(0,m);
            if (mn >= k) r = m;
            else l = m+1;
        }
        if (l > maxRow) return {};
        r = m - A[l];
        A[l] -= k;
        sum.update(l, A[l]);
        mx.update(l, A[l]);
        return {l,r};
    }

    bool scatter(ll k, int maxRow) {
        ll s = sum.query(0,maxRow);
        if (s < k) return false;
        while (j < n && k) {
            int dx = min(k, A[j]);
            A[j] -= dx;
            sum.update(j, A[j]);
            mx.update(j, A[j]);
            k -= dx;
            if (!A[j]) ++j;
        }
        return true;
    }
};