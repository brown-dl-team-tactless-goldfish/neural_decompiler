int helper_sort(int** distance, int left, int right)
{
    int pivot = left;
    int temp[2];
    
    while(left < right)
    {
        while((left < right) && (distance[right][0] >= distance[pivot][0]))
            right--;
        while((left < right) && (distance[left][0] <= distance[pivot][0]))
            left++;
        if(left < right)
        {
            temp[0] = distance[left][0];
            temp[1] = distance[left][1];
            distance[left][0] = distance[right][0];
            distance[left][1] = distance[right][1];
            distance[right][0] = temp[0];
            distance[right][1] = temp[1];
        }
    }
    
    if(pivot != left)
    {
        temp[0] = distance[pivot][0];
        temp[1] = distance[pivot][1];
        distance[pivot][0] = distance[left][0];
        distance[pivot][1] = distance[left][1];
        distance[left][0] = temp[0];
        distance[left][1] = temp[1];
    }
    return left;
}

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** kClosest(int** points, int pointsSize, int* pointsColSize, int K, int* returnSize, int** returnColumnSizes){
    int** distance = NULL;
    int i,pos,left,right;
    int** result = NULL;
    
    if((points==NULL) || (pointsSize==0))
    {
        *returnSize = 0;
        return NULL;
    }

    distance = (int**)malloc(pointsSize*sizeof(int*));
    for(i=0;i<pointsSize;i++)
    {
        distance[i] = (int*)malloc(2*sizeof(int));
        distance[i][0] = points[i][0] * points[i][0] + points[i][1] * points[i][1];
        distance[i][1] = i;
    }

    left = 0;
    right = pointsSize-1;
    while(left<=right)
    {
        pos = helper_sort(distance,left,right);
        if(pos > K)
        {
            right = pos - 1;
        }
        else if(pos < K)
        {
            left = pos + 1;
        }
        else
        {
            break;
        }
    }
    
    result = (int**)malloc(K*sizeof(int*));
    (*returnColumnSizes) = (int*)malloc(K*sizeof(int));
    for(i=0;i<K;i++)
    {
        result[i] = (int*)malloc(2*sizeof(int));
        (*returnColumnSizes)[i] = 2;
        pos = distance[i][1];
        result[i][0] = points[pos][0];
        result[i][1] = points[pos][1];
    }    
    
    // free temp memory
    for(i=0;i<pointsSize;i++)
    {
        free(distance[i]);
    }
    free(distance);
    
    *returnSize = K;
    return result;
}