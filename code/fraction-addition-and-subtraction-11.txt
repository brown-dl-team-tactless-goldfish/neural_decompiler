class Solution {
public:
    string fractionAddition(string expression) {
        int nom = 0, denom = 1, size = expression.size();
        for (int i = 0, j = 0; i < size;)
        {
            while (j < size && expression[j] != '/')
            {
                ++j; // find the index of slash '/' so we can get the nominator
            }
            
            int slashInd = j;
            while (j < size && expression[j] != '+' && expression[j] != '-')
            {
                ++j; // find the next '+' or '-' so we can get the denominator
            }
            
            int end = j, curNom = stoi(expression.substr(i, slashInd - i));
            int curDenom = stoi(expression.substr(slashInd + 1, end - slashInd - 1));
            auto sum = addAndNorm(nom, denom, curNom, curDenom); // add the fractions 
            
            nom = sum.first;
            denom = sum.second; // update the latest nominator and denominator
            i = j;
        }
        
        return to_string(nom) + "/" + to_string(denom); // return the result
    }

private:
    pair<int, int> addAndNorm(int nom, int denom, int curNom, int curDenom)
    {
        int sumNom = nom * curDenom + curNom * denom;
        int sumDenom = denom * curDenom; // first get the reducible nominator/denominator
        for (int n = min(abs(sumNom), abs(sumDenom)); n > 1; --n)
        {
            if (sumNom % n == 0 && sumDenom % n == 0)
            {   // find the maximum common factor of the nominator and denominator
                sumNom /= n;
                sumDenom /= n;
                break;
            }
        }
        
        return {sumNom, sumNom == 0 ? 1 : sumDenom}; // return the reduced format
    }
};