class Solution {
public:
    int countCombinations(
        vector<string>& pieces, 
        vector<vector<int>>& positions) {
        std::vector<PieceKind> pieces_kind;
        pred_map_t preds = {
            [](const int dx, const int dy) -> bool {
                return (dx == 0) && (dy == 0);
            },
            [](const int dx, const int dy) -> bool {
                return (dx == 0) || (dy == 0);
            },
            [](const int dx, const int dy) -> bool {
                return (dx == 0) == (dy == 0);
            }            
        };
        
        static constexpr char kQueen[] = "queen";
        static constexpr char kBishop[] = "bishop";
        static constexpr char kRook[] = "rook";        
        
        for (auto &&piece : pieces) {
            if (kQueen == piece) {
                pieces_kind.push_back(QUEEN);                
            } else if (kBishop == piece) {
                pieces_kind.push_back(BISHOP);
            } else if (kRook == piece) {
                pieces_kind.push_back(ROOK);
            } else {
                // panic
            }            
        }
        for (auto &pos : positions) {
            --pos[0];
            --pos[1];
        }
        const int len = pieces.size();
        Context ctx {
            .pieces_kind = pieces_kind,
            .preds = preds,
            .positions = positions,
            .len = len
        };
        std::vector<MoveCfg> move_cfgs;
        build_move_cfgs(ctx, 0, move_cfgs);
        return ctx.seen.size();
    }
private:
    enum PieceKind {
        QUEEN = 0, BISHOP, ROOK, NUM_PIECE_KINDS
    };
    
    static constexpr int MAX_NUM_PIECES = 4;
    static constexpr int MAX_DIM = 8;
    static constexpr int GRID_SIZE = MAX_DIM * MAX_DIM;
    
    using cfg_code_t = std::bitset<GRID_SIZE * MAX_NUM_PIECES>;
    using pred_t = std::function<bool(int, int)>;
    using pred_map_t = std::array<pred_t, NUM_PIECE_KINDS>;
    
    struct Context {
        const std::vector<PieceKind> &pieces_kind;
        const pred_map_t &preds;
        const std::vector<std::vector<int>> &positions;        
        const int len;
        std::unordered_set<cfg_code_t> seen;
    };    
    
    struct MoveCfg {
        int x;
        int y;
        int dx;
        int dy;
        int moves;
        int max_moves;
        
        bool next() {
            if (moves == max_moves) {
                return false;
            }
            if ((x + dx < 0) || (x + dx >= MAX_DIM) ||
                (y + dy < 0) || (y + dy >= MAX_DIM)) {
                return false;
            }
            x += dx;
            y += dy;
            ++moves;
            return true;
        }
    };
        
    void build_move_cfgs(
        Context &ctx,
        const int idx,
        std::vector<MoveCfg> &move_cfgs) const {
        if (idx == ctx.len) {
            maybe_add_final_positions(ctx, move_cfgs);
            return;
        }
        const int x = ctx.positions[idx][0];
        const int y = ctx.positions[idx][1];
        const auto &pred_invalid = ctx.preds[ctx.pieces_kind[idx]];
        for (auto &&cfg : generate_moves(x, y, pred_invalid)) {
            move_cfgs.push_back(cfg);
            build_move_cfgs(ctx, idx + 1, move_cfgs);
            move_cfgs.pop_back();
        }
    }    
                
    bool validate(const std::vector<MoveCfg> &move_cfgs) const {
        std::bitset<GRID_SIZE> seen;
        for (const auto &cfg : move_cfgs) {
            const int pos = cfg.y * MAX_DIM + cfg.x;
            if (seen[pos]) {
                return false;
            }
            seen.set(pos);
        }
        return true;
    }
            
    // Try execute the moves and check if we can 
    // reach the desired final positions.
    void maybe_add_final_positions(
        Context &ctx, 
        std::vector<MoveCfg> move_cfgs) const {
        while (true) {
            bool can_move = false;
            for (auto &cfg : move_cfgs) {
                can_move |= cfg.next();
            }
            if (!can_move) {
                break;
            }
            if (!validate(move_cfgs)) {
                return;
            }
        }
        
        // Check if any piece did not reach the terminal state.
        for (const auto &cfg : move_cfgs) {
            if (cfg.moves != cfg.max_moves) {
                return;
            }
        }
        
        cfg_code_t code;
        int shift = 0;        
        for (const auto &cfg : move_cfgs) {
            const int pos = cfg.y * MAX_DIM + cfg.x;
            code.set(pos + shift);
            shift += GRID_SIZE;
        }        
        if (code.count() == move_cfgs.size()) {
            ctx.seen.insert(code);
        }
    }    
    
    // Create all potential moves for one piece.
    // Invaid step deltas are determined by `pred_invalid`.
    std::vector<MoveCfg> generate_moves(
        const int x, 
        const int y,         
        const pred_t &pred_invalid) const {
        std::vector<MoveCfg> cfgs;
        for (int dx = -1; dx <= 1; ++dx) {
            for (int dy = -1; dy <= 1; ++dy) {
                if (pred_invalid(dx, dy)) {
                    continue;
                }
                int max_moves = MAX_DIM;
                if (dx < 0) {
                    max_moves = std::min(x, max_moves);
                }
                if (dx > 0) {
                    max_moves = std::min(MAX_DIM - 1 - x, max_moves);
                }
                if (dy < 0) {
                    max_moves = std::min(y, max_moves);
                }
                if (dy > 0) {
                    max_moves = std::min(MAX_DIM - 1 - y, max_moves);
                }
                for (; max_moves >= 0; --max_moves) {
                    cfgs.push_back(MoveCfg{
                        .x = x,
                        .y = y,
                        .dx = dx,
                        .dy = dy,
                        .moves = 0,
                        .max_moves = max_moves
                    });
                }
            }
        }
        return cfgs;
    }  
};