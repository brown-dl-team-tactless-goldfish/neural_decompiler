class Solution {
public:
int dp[1001][1001];
    int helper(vector<vector<int>>&books,int shelfWidth,int curr,int currShelfHeight,int currShelfWidth){
        if(curr>=books.size())
            return currShelfHeight;
        
        int&res=dp[curr][currShelfWidth];
        if(res!=-1)
            return res;
        int op1=INT_MAX;
// check if it is possible to peform the first option 
// which is possible only if the current space left is greater than or equal to width of current book
        if(currShelfWidth+books[curr][0]<=shelfWidth){

// go to the next book and while doing so remember to update the maximum height
            op1=helper(books,shelfWidth,curr+1,max(currShelfHeight,books[curr][1]),currShelfWidth+books[curr][0]);
        }

// if we go onto option 2 then we are adding the maximum height of the previous incurred books because that shelf is filled now
        int op2=helper(books,shelfWidth,curr+1,books[curr][1],books[curr][0])+currShelfHeight;

// finally we return the minumum of both the options 
        return res=min(op1,op2);
    }
    int minHeightShelves(vector<vector<int>>& books, int shelfWidth) {
        memset(dp,-1,sizeof dp);
        return helper(books,shelfWidth,0,0,0);
        
    }
};