

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** colorBorder(int** grid, int gridSize, int* gridColSize, int row, int col, int color, int* returnSize, int** returnColumnSizes){
    int m = gridSize;
    int n = *gridColSize;
    *returnSize = m;
    *returnColumnSizes = malloc(m * sizeof(int ));
    for(int i = 0; i < m; i++){
        returnColumnSizes[0][i] = n;
    }
    if(grid[row][col] == color)
        return grid ;
    
    bool** used = malloc(m * sizeof(bool*));
    for(int i = 0; i < m; i++){
        used[i] = calloc(n , sizeof(bool));            
    }
    
    int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}} ;
    
    int** queue = malloc(m * n * sizeof(int*));
    int org = grid[row][col] ;
    int idx = 0;
    queue[idx] = malloc(2 * sizeof(int));
    queue[idx][0] = row;
    queue[idx][1] = col;
    idx++;
    int pos = 0;
      
    used[row][col] = true ;
    grid[row][col] = -1*color ;
    while(pos < idx){
        int x = queue[pos][0];
        int y = queue[pos][1];
        for(int i = 0; i < 4; i++){
            int xx = x + dir[i][0] ;
            int yy = y + dir[i][1] ;
            if(xx < 0 || yy < 0 || xx >= m || yy >= n)
                continue ;
            if(used[xx][yy] || grid[xx][yy] != org)
                continue ;
            used[xx][yy] = true ;
            queue[idx] = malloc(2 * sizeof(int)) ;
            queue[idx][0] = xx ;
            queue[idx][1] = yy ;
            idx++ ;
            grid[xx][yy] = -1 * color ;
        }
        pos++;
    }

    for(int i = 0; i < m; i++){
        for(int j = 0; j < n; j++){
            if(grid[i][j] == -1 * color){
                if(i == 0 || j == 0 || (i == (m-1)) || (j == (n-1)) ){
                    grid[i][j] = color ;
                    continue ;
                }
                for(int k = 0; k < 4; k++){
                    int ii = i + dir[k][0] ;
                    int jj = j + dir[k][1] ;
                    if(used[ii][jj] == false){
                        grid[i][j] = color ;
                        break ;
                    }
                    if(k == 3)
                        grid[i][j] = org ;
                }
            }
        }
    }
    
    for(int i = 0; i < idx; i++)
        free(queue[i]) ;
    free(queue) ;
    for(int i = 0; i < m; i++)
        free(used[i]) ;
    free(used) ;
    return grid;

}