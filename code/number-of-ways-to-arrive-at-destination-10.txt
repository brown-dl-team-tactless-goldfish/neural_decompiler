class Solution {
public:
    const int mod = 1e9+7;
    
    int countPaths(int n, vector<vector<int>>& roads) {
        vector<pair<int,int>> graph[n]; //pair<node,weight>
        for (auto& r : roads){ //build the weighted graph
            graph[r[1]].emplace_back(r[0], r[2]);
            graph[r[0]].emplace_back(r[1], r[2]);
        }
        
        pair<int,long long> vis[n]; //dp: pair<count, shortest time> [node]
        vis[0].first = 1; //start from node 1, count = 1, time = 0;
        for (int i = 1; i < n; i++)
            vis[i].second = LLONG_MAX; //init nodes except node 0 with count = 0, time = max;
        
        auto comp = [](const pair<int, long long>& a, const pair<int, long long>& b){
            return a.second > b.second;   //Dijkstra, min time first 
        };
        //pair<node, time> in pq
        priority_queue<pair<int, long long>, vector<pair<int, long long>>, decltype(comp)> pq(comp);
        
        pq.push({0, 0});
        
        while(pq.size()){
            auto p = pq.top();
            pq.pop();
            
            if (p.second > vis[p.first].second) continue;
            
            for (auto nei : graph[p.first]){
                long long t = p.second + nei.second;
                if (t <= vis[nei.first].second){
                    if (t == vis[nei.first].second){ //do not push neighbor node to pq in this condition, because we already did
                        vis[nei.first].first += vis[p.first].first; 
                        if (vis[nei.first].first >= mod) vis[nei.first].first -= mod;
                    }else{ //better choice for the neighbor node
                        vis[nei.first].first = vis[p.first].first;
                        vis[nei.first].second = t;
                        if (nei.first != n-1) pq.push({nei.first, t}); //push neighbor node to pq unless it's the end node
                    }
                }
            }
        }
        
        return vis[n-1].first;
    }
};