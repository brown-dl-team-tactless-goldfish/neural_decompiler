class Solution {
public:
    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {
        set<int> valid_pos[2];
        for(int i=0;i<n;i++) valid_pos[i&1].insert(i);
        for(int x : banned) {
            valid_pos[0].erase(x);
            valid_pos[1].erase(x);
        }
        deque<pair<int,int>> Q;
        Q.push_back({0,p});
        vector<int> ans(n, -1);
        while(!Q.empty()) {
            pair<int,int> q=Q.front();
            Q.pop_front();
            int pos=q.second;
            int num_moves=q.first;
            if (ans[pos]!=-1) continue;
            // left end is L
            // L >= max(0,pos-k+1)
            // L <= min(pos,n-k)            
            // if left end is L -> 2*L+k-1-pos
            int minL=max(0,pos-k+1);
            int maxL=min(pos,n-k);
                        //printf("pos=%d %d to %d\n",pos,minn,maxx);

            int minn = 2*minL+k-1-pos;
            int maxx = 2*maxL+k-1-pos;
            ans[pos]=num_moves;
            valid_pos[pos&1].erase(pos);
            // pos-k to pos+k
            int parity=(minn&1);
            auto it = valid_pos[parity].lower_bound(minn);
            vector<int> to_remove;
            while(it != valid_pos[parity].end() && *it <= maxx) {
                Q.push_back({num_moves+1,*it});
                to_remove.push_back(*it);
                ++it;
            }
            for(int x : to_remove) valid_pos[parity].erase(x);
        }
        return ans;
    }
};
``