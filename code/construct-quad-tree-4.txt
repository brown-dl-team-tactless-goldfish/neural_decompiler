class Solution {
public:
    Node* construct(vector<vector<int>>& grid) {
        if (grid.empty())
        {
            return nullptr;
        }
        return construct(grid, 0, grid.size() - 1, 0, grid[0].size() - 1);
    }
    
private:
    Node* construct(vector<vector<int>>& grid, int top, int bottom, int left, int right)
    {
        // Recursively define the subtree of each node
        // Base case is single grid (1 cell only)
        // Then check if the cells in subgrid have the same value
        // If not recursively construct the tree
        if (top == bottom)
        {
            return new Node(grid[top][left], 1);
        }
        
        // Check if it is leaf
        bool isLeaf = 1;
        for (int r = top; r <= bottom; ++r)
        {
            for (int c = left; c <= right; ++c)
            {
                if (grid[r][c] != grid[top][left])
                {
                    isLeaf = 0;
                    break;
                }
            }
            if (!isLeaf)
            {
                break;
            }
        }
        
        if (isLeaf)
        {
            return new Node(grid[top][left], 1);
        }
        
        int midRow = top + (bottom - top) / 2, midCol = left + (right - left) / 2;
        Node* topLeft = construct(grid, top, midRow, left, midCol);
        Node* topRight = construct(grid, top, midRow, midCol + 1, right);
        Node* bottomLeft = construct(grid, midRow + 1, bottom, left, midCol);
        Node* bottomRight = construct(grid, midRow + 1, bottom, midCol + 1, right);
        return new Node(0, 0, topLeft, topRight, bottomLeft, bottomRight);
    }
};