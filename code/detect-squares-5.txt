class DetectSquares {
public:
    DetectSquares() {
        
    }
    
    void add(vector<int> point) {
        int key = encodeKey(point[0], point[1]);
        _frequency[key]++;
    }
    
    // for a given point (a, b), check the points in the diagonal, if we can find a point (x, y), 
    // then let's check whether (x, b) and (a, y) are on the map, if so we find a square
    // we use unordered_map to store points, with 10000 * x + y as the key, since x and y are all in the range of [0, 1000]
    int count(vector<int> point) {
        int res = 0;        
        for (auto& item : _frequency) {
            // parse the key
            int y = item.first % 10000;
            int x = item.first / 10000;
            // if the point is the same as the input, ignore it, since they can't form a square
            if (x == point[0] && y == point[1]) {
                continue;
            }
            // if we find a point on the diagonal, add square count
            if (abs(x - point[0]) == abs(y - point[1])) {
                int key1 = encodeKey(x, point[1]);
                int key2 = encodeKey(point[0], y);
                int count1 = 0, count2 = 0;
                if (_frequency.find(key1) != _frequency.end()) {
                    count1 = _frequency[key1];
                }
                if (_frequency.find(key2) != _frequency.end()) {
                    count2 = _frequency[key2];
                }
                res += count1 * count2 * item.second;
            }
        }
        return res;
    }
    
private:
    int encodeKey(int x, int y) {
        return x * 10000 + y;
    }
    
    unordered_map<int, int> _frequency;
};