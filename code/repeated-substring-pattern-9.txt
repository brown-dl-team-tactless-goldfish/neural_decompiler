bool repeatedSubstringPattern(char* s) {
    //[1] get size of s   
    int len_S=0;
    while(s[++len_S]!=0){}
    
    //[2] primefactor search
    int quotient=len_S; 
    for(int prime_i=2; prime_i<=quotient; prime_i++)
    {
        if(quotient%prime_i==0)
        {
            
            // check: if prime_i fits
            int len_sub= len_S/prime_i; 
            int i=0; 
            for(len_sub-=1; ++len_sub<len_S; ++i)
            {
                if(s[len_sub]!=s[i]) break;
            }
            if(len_sub==len_S) return true;
            
            // Make sure NO prime_i in quotient
            while(quotient%prime_i==0)quotient/=prime_i; 
        }
    }
    return false;
}
/*
Complexity: Time= O(k*n).
            Space = O(1)
                - k = prime_factor_numbers of len(S).
                - k <= 6 In this problem. (2*3*5*7*11*13>10000)


[1]:-Without using strlen() might shorten Runtime, wierd.

[2]:-String S can be devided into k parts == S can be devided into PrimeFactor_of(k) parts.
    -example: |abcd|abcd|abcd||abcd|abcd|abcd|  prime(k=6)=2
        
    -We should try all PrimeFactor of (S.size()) only, with no more than 6 attempts when len_S<10000.
*/