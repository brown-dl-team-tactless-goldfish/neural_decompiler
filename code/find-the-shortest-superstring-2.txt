    string shortestSuperstring(vector<string>& A) {
        int N = A.size();
        vector<vector<int>> dp(1<<N, vector<int>(N, -1)), parent(1<<N, vector<int>(N, -1)) , dist(N, vector<int>(N, 0));
        
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                if(i == j) continue;
                for(int k = 0; k < A[i].length(); k++) {
                    if(A[j].find(A[i].substr(k)) == 0) {
                        dist[i][j] = A[i].length()-k;
                        break;
                    }
                }
            }
        }
        
        for(int i = 0; i < N; i++) dp[1<<i][i] = 0;
        
        int last = -1, total = -1;
        for(int mask = 0; mask < (1 << N); mask++) {
            for(int i = 0; i < N; i++) {
                if(((mask >> i)&1) == 0) continue;
                int pmask = mask ^ (1 << i);
                for(int j = 0; j < N; j++) {
                    if((pmask >> j)&1 == 0) continue;
                    
                    if(dp[pmask][j] != -1 && dp[mask][i] < dp[pmask][j] + dist[j][i]) {
                        dp[mask][i] = dp[pmask][j] + dist[j][i];
                        parent[mask][i] = j;
                    }
                }
                
                if(mask == (1 << N)-1 && dp[mask][i] > total) {
                    total = dp[mask][i];
                    last = i;
                }
            }
        }

        int cur = (1 << N)-1;
        vector<int> path;
        while(cur != 0) {
            path.push_back(last);
            int prev = cur ^ (1 << last);
            last = parent[cur][last];
            cur = prev;
        }
        
        reverse(path.begin(), path.end());
        string res = A[path[0]];
        for(int i = 1; i < path.size(); i++) {
            res += A[path[i]].substr(dist[path[i-1]][path[i]]);
        }
        return res;
    }