public class Solution {
    
    private HashSet<int> nodes = new HashSet<int>();
    
    List<int>[] adjList;
    
    private void dfs(int root, (int, int) exclude) {
        nodes.Add(root);
        if (adjList[root] != null)
        foreach (var adj in adjList[root]) {
            if (nodes.Contains(adj)) continue;
            if (root == exclude.Item1 && adj == exclude.Item2) continue;
            dfs(adj, exclude);
        }
    }
    
    public int[] FindRedundantDirectedConnection(int[][] edges) {
        int N = edges.Length;
        
        var parents = new List<int>[N];
        
        adjList = new List<int>[N];
        
        for (int i = 0; i < N; i++) {
            var from = edges[i][0] - 1;
            var to = edges[i][1] - 1;
            if (adjList[from] == null) adjList[from] = new List<int>();
            adjList[from].Add(to);
            if (parents[to] == null) parents[to] = new List<int>();
            parents[to].Add(from);
        }
        
        int? root = null;
        int? dbl = null;
        
        for (int i = 0; i < N; i++) {
            if (parents[i] == null) {
                root = i;
            } else if (parents[i].Count == 2) {
                dbl = i;
            }
        }
        
        if (dbl != null) {
            dfs(root.Value, (parents[dbl.Value].Last(), dbl.Value));
            if (nodes.Count == N) {
                return new int[] { parents[dbl.Value].Last() + 1, dbl.Value + 1 };
            } else {
                return new int[] { parents[dbl.Value].First() + 1, dbl.Value + 1 };
            }
        }
        
        int current = 0;
        
        var visited = new HashSet<int>();
        
        while (!visited.Contains(current)) {
            visited.Add(current);
            current = parents[current][0];
        }

        var visitedEdges = new HashSet<(int, int)>();
        
        var currentEdge = (parents[current][0], current);
        
        while (!visitedEdges.Contains(currentEdge)) {
            visitedEdges.Add(currentEdge);
            currentEdge = (parents[currentEdge.Item1][0], currentEdge.Item1);
        }
        
        for (int i = N - 1; i >= 0; i--) {
            var from = edges[i][0] - 1;
            var to = edges[i][1] - 1;
            if (visitedEdges.Contains((from, to))) return edges[i];
        }
        
        return null;
    }
}