class Solution {
public:
    int minimumIncompatibility(vector<int>& nums, int k) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        int INF = nums.back()*n;
        vector<vector<int>> dp(1<<n, vector<int>(n, INF));
        vector<int> dp_best(1<<n, INF);
        int group_size = n/k;
        
        if(group_size == 1)
            return 0;
        
        dp_best[0] = 0;
        
        int mx = 1<<n;
        for(int i=1; i<mx; i++){
            int n_ones = __builtin_popcount(i), mn, prev;
            
            for(int j=0; j<n; j++){
                if(((1<<j) & i) == 0) continue;
                prev = i^(1<<j);
				
				if(n_ones % group_size == 1) {// first one
                    dp[i][j] = dp_best[prev] - nums[j];
					continue;
				}
				
                mn = INF;
                for(int p=0; p<j && nums[p]!=nums[j]; p++)
                    mn = min(mn, dp[prev][p]);
                
                if(n_ones % group_size == 0) // last one
                    dp[i][j] = mn + nums[j];
                if(n_ones % group_size > 1) // middle ones
                    dp[i][j] = mn;
            }
            
            for(int j=0; j<n; j++)
                dp_best[i] = min(dp_best[i], dp[i][j]);
        }
        
        if(dp_best[(1<<n)-1] >= INF)
            return -1;
        return dp_best[(1<<n)-1];
    }
};