class Solution {
public:
    int findCrossingTime(int n, int k, vector<vector<int>>& t) {
        for(int i=0; i< k; i++){
            t[i].push_back(i);
        }
        sort(t.begin(),t.end(), [](auto &t1, auto &t2){
            int time1 = t1[0] + t1[2];
            int time2 = t2[0] + t2[2];
            if(time1 == time2) return t1[4] > t2[4];
            else return time1 > time2;
        });
        priority_queue<int, vector<int>, greater<int>> l,r,timeline;
        for(int i=0;i<k;i++) l.push(i);
        bool crossing = false;
        // key = time, val = who
        map<int,vector<int>> pick,put;
        map<int,int> toL,toR;
        map<int,int> usedTime;
        timeline.push(0);
        int ans = 0;
        int picking = 0;
        int initialn = n;
        while(n > 0 && !timeline.empty()){
            int time = timeline.top();
            timeline.pop();
            if(usedTime.find(time) != usedTime.end()) continue;
            usedTime[time] ++;
            // cout << time << endl;
            if(pick.find(time) != pick.end()){
                // pick ended
                for(auto &w:pick[time]){
                    r.push(w);
                }
            }
            if(put.find(time) != put.end()){
                // put ended
                for(auto &w:put[time]){
                    l.push(w);
                }
            }
            if(toL.find(time) != toL.end()){
                // toL ended
                int w = toL[time];
                crossing = false;
                put[time + t[w][3]].push_back(w);
                // cout <<　"put"<< time + t[w][3] << endl;
                timeline.push(time + t[w][3]);
                n--;
                ans = time;
            }
            if(toR.find(time) != toR.end()){
                int w = toR[time];
                crossing = false;
                pick[time + t[w][1]].push_back(w);
                // cout <<　"pick" << time + t[w][1] << endl;
                timeline.push(time + t[w][1]);
            }
            if(!crossing){
                // toL
                if(!r.empty()){
                    int w = r.top();
                    r.pop();
                    crossing = true;
                    toL[time + t[w][2]] = w;
                    timeline.push(time + t[w][2]);
                    // cout <<　"toL" << w  << ' ' << time + t[w][2] << endl;
                }
                // toR
                else if(initialn > picking && !l.empty()){
                    int w = l.top();
                    l.pop();
                    crossing = true;
                    toR[time + t[w][0]] = w;
                    timeline.push(time + t[w][0]);
                    // cout <<　"toR" << w << ' '<< time + t[w][0] << endl;
                    picking++;
                }
            }
        }
        return ans;
    }
};