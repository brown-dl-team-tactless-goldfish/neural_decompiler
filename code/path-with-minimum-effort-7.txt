struct node{
    int r, c, cost;
};
class Solution {
    int dir[4][2] {{-1,0},{1,0},{0,-1},{0,1}};
        
    public:
    int minimumEffortPath(vector<vector<int>>& hei) {
        int m = hei.size(), n = hei[0].size();
        auto cmp = [](const node &n1, const node &n2){return n1.cost > n2.cost;};
        priority_queue<node, vector<node>, decltype(cmp)> q(cmp);
        q.push({0, 0, 0});
        
        while(not q.empty()){
            const auto [r, c, cost]= q.top(); q.pop();
            if(hei[r][c] == -1)
                continue;
            if(r == m - 1 and c == n - 1)
                return cost;
            int val = hei[r][c];
            hei[r][c] = -1; //mark visited
            
            for(const auto &off: dir){
                int nr = r + off[0], nc = c + off[1];
                if(nr >= 0 and nr < m and nc >= 0 and nc < n and hei[nr][nc] != -1){
                    q.push({nr,nc,max(cost, abs(hei[nr][nc] - val))});
                }
            } 
        }
        return -1;
    }
};