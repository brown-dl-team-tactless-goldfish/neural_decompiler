class Solution {
public:
    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {
          int n = edges.size()+1;
          vector<vector<int>> graph(n);
          for(vector<int>& edge: edges){
              graph[edge[0]].push_back(edge[1]);
              graph[edge[1]].push_back(edge[0]);
          }

         vector<int> path_bob;
         findPathToBob(path_bob, 0, -1, graph, bob);
         int mid = path_bob.size()/2;
         for(int i=path_bob.size()-1;i>=mid;i--){
              if(i>mid){
                amount[path_bob[i]] = 0;
              }else if(i==mid){
                  if(path_bob.size()%2==0){
                      amount[path_bob[mid]] = 0;
                  }else{
                      amount[path_bob[mid]] = amount[path_bob[mid]]/2;
                  }
              }

         }

        return findMaxProf(graph, 0, -1, amount);
    }
    
    int findMaxProf(vector<vector<int>>& graph, int cur, int parent, vector<int>& amount){
        int res = INT_MIN;

        for(auto& child: graph[cur]){
            if(child != parent){
                int temp = findMaxProf(graph, child, cur, amount);
                temp += amount[cur];
                res = max(temp, res);
            }
        }

        if(res == INT_MIN){
            return amount[cur];
        }

        return res;

    }

    bool findPathToBob(vector<int>& path, int cur_node, int parent, vector<vector<int>>& graph, int bob){
             path.push_back(cur_node);

             if(cur_node == bob){
                 return true;
             }
             

             for(auto& child: graph[cur_node]){
                 if(child != parent){
                     bool check = findPathToBob(path, child, cur_node, graph, bob);
                     if(check){
                         return true;
                     }
                 }
             }
             
             path.pop_back();
             return false;
    }
};