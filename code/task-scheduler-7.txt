class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        int curTime = 0; // current time 
        vector<int> taskFreq(26); // calculate the frequency of each task
        for (char c : tasks)
        {
            ++taskFreq[c - 'A']; // initialize taskFreq array
        }
        
        // Each we execute min(n + 1, 26) number of tasks. 
        // If n + 1 <= 26, that means we can execute n + 1 tasks and we can immediately start next iteration without idle.
        // Otherwise, we have to execute as many tasks as we can, and add the idle time.
        sort(taskFreq.begin(), taskFreq.end(), greater<int>()); 
        while (taskFreq[0] > 0)
        {
            int i = 0;
            while (i < min(n + 1, 26) && taskFreq[i] > 0)
            {
                --taskFreq[i];
                ++curTime, ++i;
            }
            
            curTime += taskFreq[0] > 0 && i < n + 1 ? n + 1 - i : 0;
            sort(taskFreq.begin(), taskFreq.end(), greater<int>());
        }
        
        return curTime;
    }
};