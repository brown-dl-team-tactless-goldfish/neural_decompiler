class Solution {
public:
    const int nax = 1e5 + 1;
    vector<int> tree;
    int size;
    int getMaximum(int root, int left, int right, int l, int r) {
        if (r < left || right < l) return 0;
        if (l >= left && r <= right) {
            return tree[root];
        }
        int mid = (l + r) / 2;
        return max(getMaximum(2 * root + 1, left, right, l, mid), getMaximum(2 * root + 2, left, right, mid + 1, r));
    }
    void update(int pos, int mx) {
        tree[size - 1 + pos] = mx;
        for (int i = (size - 1 + pos - 1) / 2; i > 0; i = (i - 1) / 2) {
            tree[i] = max(tree[2 * i + 1], tree[2 * i + 2]);
        }
        if (size > 1) {
            tree[0] = max(tree[1], tree[2]);
        }
    }
    int lengthOfLIS(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> dp(nax);
        size = 1;
        while (size < nax) {
            size *= 2;
        }
        tree.resize(2 * size - 1);
        for (int i = 0; i < nax; i++) {
            tree[size - 1 + i] = dp[i];
        }
        for (int i = size - 2; i > 0; i = (i - 1) / 2) {
            tree[i] = max(tree[2 * i + 1], tree[2 * i + 2]);
        }
        if (size > 1) {
            tree[0] = max(tree[1], tree[2]);
        }
        int sol = 1;
        for (int i = 0; i < n; i++) {
            int left = max(0, nums[i] - k);
            int right = nums[i] - 1;
            if (left <= right) {
                int mx = getMaximum(0, left, right, 0, size - 1);
                if (mx + 1 > dp[nums[i]]) {
                    dp[nums[i]] = mx + 1;
                    update(nums[i], dp[nums[i]]);
                    sol = max(sol, dp[nums[i]]);
                }
            }
        }
        return sol;
    }
};