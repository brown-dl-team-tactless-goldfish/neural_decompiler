#include <search.h>

typedef struct {
  int sum;
  int count;
} node_s;

// use the sum field as the unique id
int cmp_fn(const void *a, const void *b) {
  node_s *pA = (node_s *)a;
  node_s *pB = (node_s *)b;
  return pA->sum - pB->sum;
}

void walker(const void *nodep, VISIT visit_type_e, int level) {
  node_s *node = *(node_s**)nodep;

  if (visit_type_e == preorder || visit_type_e == leaf) {
    printf("Node sum: %i count: %i visit type: %i level: %i \r\n", node->sum, node->count, visit_type_e, level);
  }
}

// insert into the tree, if the element already contains in the tree
// then simply increment the count
void insertToTree(void **dpRoot, int sum) {
  node_s *pKey = malloc(sizeof(node_s));
  void *dpItemFound = NULL;
  
  pKey->sum = sum;
  dpItemFound = tfind(pKey, dpRoot, cmp_fn);
  if (dpItemFound != NULL) {
    node_s *node = *(node_s**)dpItemFound;
    node->count += 1;
  } else {
    pKey->count = 1;
    tsearch(pKey, dpRoot, cmp_fn);
  }
}

// find the node that has the same sum
// return NULL if no node exists
node_s *findNode(void **pRoot, int sum) {
 node_s key = {.sum=sum, .count=0};
 void *dpItemFound = tfind(&key, pRoot, cmp_fn);
 if (dpItemFound != NULL) {
   node_s *node = *((node_s**) dpItemFound);
   return node;
 }
 return NULL;
}

int subarraySum(int* nums, int numsSize, int k) {
  int count = 0;
  void *pRoot = NULL;
  void *dpItemFound = NULL;
  int cumulative_sum = 0;
  
  // we can always remove the prefix [0, i-1]
  node_s zero_key = {.sum=0, .count=1};
  dpItemFound = tsearch(&zero_key, &pRoot, cmp_fn);
  
  for (int i = 0; i < numsSize; ++i) {
    cumulative_sum += nums[i];
    
    int complement = cumulative_sum - k;
    node_s *node = findNode(&pRoot, complement);
    if (node != NULL) {
      count += node->count;
    }
    
    // Always insert the cumulative sum into the tree
    insertToTree(&pRoot, cumulative_sum);
  }
  
  return count;
}