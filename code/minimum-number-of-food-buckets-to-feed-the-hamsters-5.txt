class Solution {
public:
  
  int countVacant(string s)
  {
    int c = 0;
    
    for(int i = 0;i<s.size();i++)
      if(s[i] == '.') c++;
    
    return c;
  }
  
  int countHouses(string s)
  {
    int c = 0;
    
    for(int i = 0;i<s.size();i++)
      if(s[i] == 'H') c++;
  
    return c;
  }
  
    int minimumBuckets(string street) 
    {
        
      //Edge Case 1:
      if(street.size() == 1){
        
        if(street[0] == 'H')
          return -1;  
                
        else if(street[0] == '.')
          return 0;
        
      }
      
      
      //case 1 When no vacant place is present
      if(countVacant(street) == 0)  return -1;    
        
      //case 2 When no House is present
      if(countHouses(street) == 0)  return 0;
      
      map<int,pair<int,int>> Map;
      
      //--------------------------------------
      for(int i = 0;i<street.size();i++)
      {
        
        if(street[i] == 'H')
        { 
          //cout<<i<<" ";
          
          //Jab House Starting mei ho
          if(i == 0){
            
            if(street[i+1] == 'H')  return -1;
            Map[i] = make_pair(-1,i+1);
                     
          }
          
          //Jab house End mei ho.
          else if(i == street.size() - 1){
            
            if(street[i-1] == 'H')
              return -1;
      
            else
              Map[i] = make_pair(i-1,-1);
            
          }
          
          //Jab house beech mei kahi ho
          else 
          {
            
            if(street[i-1] == 'H' and street[i+1] == 'H')
              return -1;  
            
            else if(street[i-1] == '.' and  street[i+1] == 'H')
              Map[i] = make_pair(i-1,-1);
            
            else if(street[i-1] == 'H' and street[i+1] == '.')
              Map[i] = make_pair(-1,i+1);
      
            else if(street[i-1] == '.' and street[i+1] == '.')
              Map[i] = make_pair(i-1,i+1);
            
          }
          
        }
        
      }
        

        // for(auto i : Map){
        //   cout<<i.first<<endl;
        //   cout<<i.second.first<<" "<<i.second.second<<endl;
        // }
        // cout<<endl;
      
        unordered_map<int,int> f;
        for(auto i : Map){
          
          if(i.second.first >= 0 and i.second.second >= 0){
            f[i.second.first]++;
            f[i.second.second]++;
          } 
          
          else if(i.second.first >=0 and i.second.second == -1){
            f[i.second.first]++;
          }
          
          else if(i.second.first == -1 and i.second.second >=0){
            f[i.second.second]++;
          }
          
        }
        
     
      
        unordered_map <int,int> pos;
        for(auto i : Map){
          
         //cout<<f[i.second.first]<<" "<<f[i.second.second]<<endl;
          
          //Either Left or right.
          if(f[i.second.first] == 1 and f[i.second.second] == 1){
            
            if(pos[i.second.first] == 0) 
            pos[i.second.first]++;
            
          }
          
          else if(f[i.second.first] == 1 and f[i.second.second] == 2){
            
            //cout<<(i.second.second)<<endl;
            if(!pos[i.second.second])
            pos[i.second.second]++;
            
          }
          
          else if(f[i.second.first] == 1 and f[i.second.second] == 0){
            
            if(!pos[i.second.first])
            pos[i.second.first]++;
            //f[i.second.first] -= 1;
          
          }
          
          else if(f[i.second.first] == 0 and f[i.second.second] == 1){
            
            if(!pos[i.second.second])
            pos[i.second.second]++;
            
          }
          else if(f[i.second.first] == 2 and f[i.second.second] == 2){
            
            if(pos[i.second.first]){
              pos[i.second.first]++;
              f[i.second.second] -= 1;
            }
            
            else if(pos[i.second.second])
              pos[i.second.second]++;
              
          }
          else if(f[i.second.first] == 2 and f[i.second.second] == 0){
            
            if(!pos[i.second.first])
              pos[i.second.first]++;
             
          }
          else if(f[i.second.first] == 0 and f[i.second.second] == 2){
            
            if(!pos[i.second.second])
              pos[i.second.second]++;
              
          }
           else if(f[i.second.first] == 2 and f[i.second.second] == 1){
            
            if(!pos[i.second.first])
              pos[i.second.first]++;
              
          }
          
          
        }
      
        for(auto i : pos){
          cout<<i.first<<" "<<i.second<<endl;
        }
      
        return pos.size();
      
    }
};