class Solution {
public:
    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {
        // BFS: start from all water cells, mark their heights as 0.
        // Then for each adjacent cells, mark their heights as 1, aka height of previous cell + 1.
        // Then for the next adjacent cells, mark their heights as 2, and so on, 
        // until we have filled the heights of all the cells.
        int rows = isWater.size(), cols = isWater[0].size();
        vector<vector<int>> heights(rows, vector<int>(cols));
        vector<pair<int, int>> cur; // cells at current level, starting from the waters
        vector<pair<int, int>> dirs{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 4 directions
        
        for (int i = 0; i < rows; ++i)
        {
            for (int j = 0; j < cols; ++j)
            {
                if (isWater[i][j])
                {
                    cur.push_back({i, j}); // initialize current cells as waters
                }
            }
        }
        
        while (!cur.empty())
        {
            vector<pair<int, int>> next; // next level
            for (const auto& pair : cur)
            {
                for (const auto& dir : dirs)
                {
                    int r = pair.first + dir.first, c = pair.second + dir.second; // row and col 
                    if (r >= 0 && r < rows && c >= 0 && c < cols && heights[r][c] == 0 && !isWater[r][c])
                    {
                        heights[r][c] = heights[pair.first][pair.second] + 1; // adjacent cell's height = current height + 1
                        next.push_back({r, c}); // add adjacent cells
                    }
                }
            }
            
            cur = next; // traverse next level
        }
        
        return heights;
    }
};