/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */

typedef struct group {
    int *elems;    
    int max_size;
    int size;
}group;

int** groupThePeople(int* groupSizes, int groupSizesSize, int* returnSize, int** returnColumnSizes){
    int max_grp_size=500,i,j,k,grp_count=0;
    
    max_grp_size=0;
    for(i =0; i < groupSizesSize;i++)
        if(groupSizes[i] > max_grp_size)
            max_grp_size = groupSizes[i];
 

    int *counts = calloc(sizeof(int), (max_grp_size+1) );            /*counts[i] : How many users requested a group of size i*/
    group **groups = malloc(sizeof(group *) * (max_grp_size+1) );    /*groups[i] : array of arrays of groups, each group being of size i*/

    /*count group-requests*/
    for(i =0; i < groupSizesSize;i++) {
        if(counts [ groupSizes[i]] % groupSizes[i] == 0)
            grp_count++;
        counts[ groupSizes[i] ] += 1;
    }
    
    /*allocate all the groups*/
    for(i =1; i < max_grp_size+1; i++){                             /*For possible group size*/
        groups[i] = malloc( sizeof(group) * (counts[i]/i) );
        int *shared = malloc(sizeof(int) * counts[i]);              /*Say we have three groups of size 3.. This allocates 9 integers, to save running time at the risk of malloc failing.*/
        for(j=0; j < (counts[i]/i) ;j++) {
            groups[i][j].max_size = i;
            groups[i][j].size = 0;
            groups[i][j].elems = (shared+j*i);                      /*Can instead malloc an array of size (counts[i]/i) here. Less likely that malloc fails, but costs more time*/
        }
    }
    
    /*Populate the allocated group arrays*/
    for(i =0;i < groupSizesSize;i++) {
        for(j=0; j < ( counts[ groupSizes[i] ]/(groupSizes[i]) ) ; j ++) {
            group *grps = &groups[ groupSizes[i] ][j];
            if( grps->size < grps->max_size) {
                grps->elems[ grps->size ] = i;
                grps->size += 1;
                break;
            }
        }
    }

    /*Allocate the returned results array*/
    *returnSize = grp_count;
    int **return_arr = malloc(sizeof(int *)* grp_count);
    *returnColumnSizes = malloc(sizeof(int) * grp_count);
    
    /*Populate the result array with pointers to the previously populated group-arrays*/
    k=0;
    for(i=1; i <= max_grp_size;i++) {
        for(j=0; j < (counts[ i ]/i);j++) {
            return_arr[k] = groups[i][j].elems;
            (*returnColumnSizes)[k] = i;
            k+=1;
        }
    }
    
    /*Housekeeping*/
    for(i=1; i <= max_grp_size;i++)
        free( groups[i] );
    free(groups);
    free(counts);

    return return_arr;
}