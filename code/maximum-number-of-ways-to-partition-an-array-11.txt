class Solution {
public:
    int waysToPartition(vector<int>& nums, int k) {
        int n = nums.size(), cnt=0;
        
        vector<long> prefix(n, 0), pivot(n, 0);
        for (int i=0; i<n; i++) 
            prefix[i] = (i==0)?nums[0]:prefix[i-1]+nums[i];
        
        for (int i=1; i<n; i++) {
            pivot[i] = prefix.back()-prefix[i-1] - prefix[i-1];
            if (pivot[i]==0) cnt++;   // if no change, the count of pivots.
        }
        
		// consider one number may change to k 
        unordered_map<long, int> bag; //bag of (pivot balance -> cnt);
        vector<int> counts(n,0);               // the count of partitions when k replace nums[j], j=0..n-1.
        
        for (int j=1; j<n; j++) {   //inc at j, impact on right balance of pivots [1,j].
            bag[pivot[j]]++;        // right balance to offset.
            long delta = nums[j]-k; // nums[j]-k, offset on the right 
            counts[j]+=bag[nums[j]-k];
        }
        
        bag.clear();  
        
        for (int j=n-2; j>=0; j--) { //inc at j, inc on left balance of pivots [j+1, n-1].
            bag[pivot[j+1]]++;       //right balance to offset.
            long delta = k-nums[j];  //k-nums[j], add up on the left
            counts[j]+=bag[delta];
        }
        
        return max(cnt,*max_element(counts.begin(), counts.end() ) );
    }
};