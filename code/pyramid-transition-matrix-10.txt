class Solution {
public:
    map<string,vector<string>> m; // map to store given allowed strings
    map<string,bool> dp; // dp to store visited strings
    bool dfs(string bot){
		// passing bottom to dfs
		// if bot length is 2 then we are at final stage
        if(bot.length() == 2){
            if(m.find(bot) != m.end() && m[bot].size() > 0) return 1;
            return 0;
        }
        // if we have visited this given string before so return previous result
        if(dp.find(bot) != dp.end()) return dp[bot];
        // set to store newly generated strings
        set<string> nBot;
        for(auto x: m[bot.substr(0,2)]){
            nBot.insert(x);
        }
        // have to create all strings and call for every one
        for(int i=1;i<bot.length()-1;i++){
            set<string> s2;
            for(auto x: m[bot.substr(i,2)]){
                for(auto y: nBot){
                    s2.insert(y + x);
                }
            }
            nBot.clear();
            nBot = s2;
        }
        // calling dfs for all generated strings
        for(auto x: nBot){
            if(dfs(x)) return dp[x] = true;
        }
        return dp[bot] = false;
    }
    
    // we only have A B C D E F
    bool pyramidTransition(string bt, vector<string>& all) {
        int n = bt.length();
        set<string> s;
        for(auto x: all){
            m[x.substr(0,2)].push_back(x.substr(2,1));
        }
        return dfs(bt);
    }
};