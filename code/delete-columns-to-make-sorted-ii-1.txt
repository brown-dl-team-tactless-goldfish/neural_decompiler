class Solution {
public:
    struct data {
        int start;
        int end;
        int row;
        data(int s, int e, int r) : start(s), end(e), row(r) {}
    };
    int minDeletionSize(const vector<string>& A) {
        if (A.size() == 1) return 0;
        vector<string> t(A.front().size(), string(A.size(), ' '));
        for (int r = 0; r < A.size(); ++r) {
            for (int c = 0; c < A.front().size(); c++) {
                t[c][r] = A[r][c];
            }
        }
        unordered_set<int> removed;
        queue<data> q;
        q.emplace(0, t.front().size(), 0);
        while (q.size()) {
            data d = q.front();
            q.pop();
            if (d.row == t.size()) break;
            if (removed.count(d.row)) {
                q.emplace(d.start, d.end, d.row + 1);
                continue;
            }
            if (!is_sorted(t[d.row].begin() + d.start, t[d.row].begin() + d.end)) {
                removed.insert(d.row);
                q.emplace(d.start, d.end, d.row + 1);
            } else {
                int p = d.start + 1;
                while (p < d.end) {
                    if (t[d.row][p - 1] != t[d.row][p]) {
                        ++p;
                        continue;
                    } else {
                        int s = p - 1;
                        while (t[d.row][s] == t[d.row][p] && p < d.end) ++p;
                        if (p - s > 1) q.emplace(s, p, d.row + 1);
                    }
                }
            }

        }
        return removed.size();
    }
};