static int compare(const void* v, const void* z)
{
    const int* a = *(const int**)v;
    const int* b = *(const int**)z;
    
    if (a[0] < b[0]) return -1;
    else if (a[0] > b[0]) return 1;
    else if (a[1] < b[1]) return -1;
    else if (a[1] > b[1]) return 1;
    else if (a[2] > b[2]) return -1;
    else if (a[2] < b[2]) return 1;
    else return 0;
}

static int getNextStart(int** events, int lastEndTime, int start, int end)
{
    while (start <= end) {
        const int mid = (start + end) / 2;
        
        if (events[mid][0] <= lastEndTime) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }
    
    return start;
}

static int getMax(int *dp, int** events, int* nextEvents, int start, int size, int k)
{
    const int dpIdx = (k - 1)*size + start;

    if (k == 0 || start >= size) {
        return 0;
    } else if (dp[dpIdx] == -1) {
        int max = 0;

        for (int i = start; i < size; i++) {
            int temp = events[i][2] + getMax(dp, events, nextEvents, nextEvents[i], size, k - 1);
            if (temp > max) {
                max = temp;
            }
        }
        
        dp[dpIdx] = max;
    }
    
    return dp[dpIdx];
}

int maxValue(int** events, int eventsSize, int* eventsColSize, int k){
    int nextEvent[eventsSize];
    int dp[k * eventsSize];

    qsort(events, eventsSize, sizeof(int*), compare);
    
    for (int i = 0; i < eventsSize; i++) {
        nextEvent[i] = getNextStart(events, events[i][1], i + 1, eventsSize - 1);
    }
    
    memset(dp, 0xFF, sizeof(dp));
    return getMax(dp, events, nextEvent, 0, eventsSize, k);
}