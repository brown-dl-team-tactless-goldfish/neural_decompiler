class Solution {
    unordered_map<int, int> left, right, top, buttom;
    
    // For any 2 colors, their boundaries might overlap. If the overlap area contain 2 colors. Then this is invalid. 
    // Otherwise, the only color in the overlap area is the color printed later. Now we have a directed graph relative order of painting between 2 colors.
    bool valid(vector<vector<int>>& grid, int x, int y, unordered_map<int, vector<int>>& g) {

        int t = max(top[x], top[y]);
        int b = min(buttom[x], buttom[y]);
        int l = max(left[x], left[y]);
        int r = min(right[x], right[y]);

        bool findX = false, findY = false;
        for(int i=t; i<=b; ++i) {
            for(int j=l; j<=r; ++j) {
                if(grid[i][j] == x) findX = true;
                if(grid[i][j] == y) findY = true;
            }
        }
        
        if(findX && findY) return false;
        if(findX) g[x].push_back(y);
        if(findY) g[y].push_back(x);    
        return true;
    }
public:
    bool isPrintable(vector<vector<int>>& grid) {
        left.clear();
        right.clear();
        top.clear();
        buttom.clear();
        
        int m = grid.size(), n = grid[0].size();
        
        // Get the boundaries of each color. {left, right, top, buttom}. The boundaries means for that color, we need to print at least the area from [left, top] to [right, buttom].
        for(int i=0; i<m; i++) {
            for(int j=0; j<n; j++) {
                int val = grid[i][j];
                if(left.find(val) != left.end()) left[val] = min(left[val], j);
                else left[val] = j;
                if(right.find(val) != right.end()) right[val] = max(right[val], j);
                else right[val] = j;
                if(top.find(val) != top.end()) top[val] = min(top[val], i);
                else top[val] = i;
                if(buttom.find(val) != buttom.end()) buttom[val] = max(buttom[val], i);
                else buttom[val] = i;
            }
        }
        
        unordered_map<int, vector<int>> g;
        vector<int> colors;
        for(auto it1 = left.begin(); it1 != left.end(); ++it1) {
            colors.push_back(it1->first);
            for(auto it2 = left.begin(); it2 != left.end(); ++it2) {
                if(it1->first >= it2->first) continue;
                if(!valid(grid, it1->first, it2->first, g)) return false;
            }
        }
        
        // Check if the graph has cycle. If it does, then there is no valid order to paint colors.
        unordered_set<int> visited;
        for(auto c : colors) {
            visited.clear();
            if(hasCycle(c, g, visited)) return false;
        }
        
        return true;
    }
    
    
    bool hasCycle(int cur, unordered_map<int, vector<int>>& g, unordered_set<int>& visited) {
        if(visited.count(cur)) return true;
        
        if(g.find(cur) == g.end()) {
            return false;
        }
        
        visited.insert(cur);
        for(auto nxt : g[cur]) {
            if(hasCycle(nxt, g, visited)) return true;
        }
        visited.erase(cur);
        return false;
    }
};