/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
/*
*   Approach - Create a hashtable and make the index as the node count
*            - After each insertion check if thats adding up to 0 with prev val or sum (if yes, make those entries as stale/invalid)
*            - Remove all the stale entry nodes from the linkedlist
*/
struct HashNode
{
    bool valid;
    int data;
    struct ListNode * addr;
};

struct HashNode hashtable[1000];

struct ListNode* removeZeroSumSublists(struct ListNode* head)
{
    struct ListNode * trav = head;
    int index = 0;
    
    int hash_index = 0;
    
    while(trav)
    {
        int cur_sum = 0;
        
        //Insert the entry in hashtable
        hashtable[hash_index].data = trav->val;
        hashtable[hash_index].addr = trav;
        hashtable[hash_index].valid = true;
        
        //If current is 0, then make it false
        if(trav->val == 0)
            hashtable[hash_index].valid = false;
        
        //Check if the inserted entry is similar to negative sum of previous enteries
        int i;
        for(i=hash_index-1; i>=0; i--)
        {
            if(hashtable[i].valid == true)
            {
                cur_sum += hashtable[i].data;
            
                if(cur_sum == -1*(trav->val))
                {
                    int j;
                    for(j=i; j<=hash_index; j++)
                    {
                        hashtable[j].valid = false;
                    }
                    break;
                }
            }
        }
        
        hash_index++;
        trav = trav->next;
    }
    
    struct ListNode * prev = NULL;
    trav = head;
    
    hash_index = 0;
    while(trav)
    {
        if(hashtable[hash_index].valid == false)
        {
            //Delete the nodes
            if(prev == NULL)
            {
                struct ListNode * del_node = trav;
                trav = trav->next;
                free(del_node);
                head = trav;
            }
            else
            {
                struct ListNode * del_node = trav;
                trav = trav->next;
                prev->next = trav;
                free(del_node);
            }
        }
        else
        {
            prev = trav;
            trav = trav->next;
        }
        hash_index++;
    }
    return head;
    
}