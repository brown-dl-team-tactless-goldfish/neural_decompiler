class Solution {
public:
    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {
        
        //we need to maintain the nums1 in sorted order
        //for every ele in nums2 get the next greater ele in nums1;
        
        multiset<int> s(nums1.begin(),nums1.end());
        
        for(int i=0;i<nums2.size();i++)
        {
            //if the last element in set is greater than current element
            //then we can be sure to get a upper bound
            //if not we place the first element (smallest element) 
             auto it= *s.rbegin()>nums2[i] ? s.upper_bound(nums2[i]) : s.begin();
            nums1[i]= *it;
            s.erase(it);
        }
        return nums1;
        
    }
};