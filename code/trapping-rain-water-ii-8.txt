/*
the idea is to apply the bucket principal:
1. a bucket is composed of bars to hold water
2. the hight of the water the bucket can hold must equal to the lowest bar of the bucket
example: for a matrix:
[[12,13,1,12],
 [13,4,13,12],
 [13,8,10,12],
 [12,13,12,12],
 [13,13,13,13]]

the ans is 14

the trick is to find the smallest bar to hold water for any given square,

note in the above example, the square at position (1,1) can hold 8 water,
this is computed by the lowest height of the 4 bars surrounding it:
top bar of (1,1) is 13, left bar is 13, right bar is 13, bottom bar is 12 (not 13),

the bottom bar is 12 not 13 because the bottom bar of (1,1) is determined by the lowest bars
of its surroundings. And the lowest right bar for position (2,1), the position
directly below (1,1), is 12, which determined the bottom bar of (1,1) to be 12.

algorithm:
1. the elements on the 4 sides of the matrix can be considered at tentative bars for the bucket
2. maintain a priority queue (min heap) and extract the smallest value (bar) in a loop
3. we also maintain the max value M extracted for the height of the lowest bar
4. while extracting the smallest value, we also visit all the surrounding squares (left, right, up, down)
5. if a visited square has height H smaller than M, then water can be trapped at this square at amount (M-H)
5. this is bc M must be the lowest bar amoung other bars to trap water for this square, since we always visit the lowest element first with the min heap
6. add the water up to get the total amount of water that could be trapped

*/
//T(n) = O(m*n), bc each node will be put in and extracted out from the heap only once
//S(n) = O(m*n)
class Solution {
public:
    int trapRainWater(vector<vector<int>>& heightMap) {
        if(heightMap.empty()){return 0;}
        //step 1:
        priority_queue<pip, vector<pip>, comp> minHeap;

        int m = heightMap.size();
        int n = heightMap[0].size();
        
        vector<vector<bool>> visited(m, vector<bool>(n,false));//record the visited nodes
        
        for(int r = 0; r < m; r++){
            minHeap.push({heightMap[r][0],{r,0}});
            minHeap.push({heightMap[r][n-1],{r,n-1}});
            visited[r][0] = true;
            visited[r][n-1] = true;
        }
        for(int c = 1; c < n-1; c++){
            minHeap.push({heightMap[0][c],{0,c}});
            minHeap.push({heightMap[m-1][c],{m-1,c}});
            visited[0][c] = true;
            visited[m-1][c] = true;
        }
        //steps 2-6:
        int Max = minHeap.top().first;//update when a larger bar is extracted
        int res = 0;//add or update when a visited square has height lower than Max
        
        static vector<vector<int>> directions = {{0,1},{0,-1},{1,0},{-1,0}};
        
        while(!minHeap.empty()){
            auto u = minHeap.top();
            minHeap.pop();
            int u_h = u.first;
            int u_r = u.second.first;
            int u_c = u.second.second;
            Max = max(Max, u_h);
            for(auto d : directions){
                int x = u_r + d[0];
                int y = u_c + d[1];
                if(x>0 && x<m && y>0 && y<n && !visited[x][y]){
                    visited[x][y] = true;
                    if(heightMap[x][y] < Max){
                        res += Max - heightMap[x][y];
                    }
                    minHeap.push({heightMap[x][y],{x,y}});
                }
            }
        }
        return res;
    }
private:
    using pip = pair<int,pair<int,int>>;
    struct comp{
        bool operator()(const pip& a, const pip& b)const{
            return a.first > b.first;
        }
    };
};