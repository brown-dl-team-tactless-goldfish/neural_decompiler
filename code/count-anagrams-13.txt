class Solution {
public:
	int mod=1e9+7;
	int fact[100002];

	int modmul(int a,int b){    //  function to multiply two very large numbers 
		return((long long)(a%mod)*(b%mod))%mod;
	}

	int binExpo(int a,int b){    // function to calculate modular multiplicative inverse ( b ^ -1 ) % mod
		int ans = 1;
		while( b > 0 ){
			if( b & 1 ) ans = modmul( ans, a ); 
			a = modmul( a, a);
			b = b / 2;
		}
		return ans;
	}

	int modmulinv(int a){              // ( a/b ) % mod  ! = ( a % mod ) / ( b % mod )
		return binExpo(a,mod-2);       // ( a/b ) % mod  =  a * ( b ^ -1 ) % mod  
	}              // if mod is prime then   ( b ^ -1 ) % mod = ( b ^ mod-2 )      and    a * ( b ^ -1 ) % mod  =  a * ( b ^ mod-2 )

	void getfact() {    // function to track all the factorial of nums from 0 to 100000
		fact[0]=1;
		for(int i=1;i<=100001;i++){
			fact[i]=modmul(fact[i-1],i);
		}
	}

	int ways( string s ){    // function that returns no of permutations possible for a word 
		map< char, int > map;
		for( char ch : s ){
			map[ch]++;
		}
		int p = fact[s.size()];
		int q = 1;
		for( auto k : map ){
			q = modmul( q, fact[k.second] );
		}
		return modmul(p, modmulinv(q));
	}

	int countAnagrams(string s) {
		getfact();
		stringstream ss(s);
		string word; 
		int ans=1;
		while (ss >> word){
			ans=modmul(ans,ways(word));
		}
		return ans;
	} 
};