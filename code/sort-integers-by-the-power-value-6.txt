class Solution {
public:
    int dp[1000000], c=0; // dp for memoization, c for temporary answers
    int solve(int x) 
    {
        if(x<2) // base case
            return dp[x];
        c++; // one step added
        if(dp[x]) // returning precomputed value
            return dp[x];
        else if(x%2==0) // even case
            return dp[x] = solve(x/2);
        else
            return dp[x] = solve((3*x)+1); // odd case
    }
    int getKth(int lo, int hi, int k) 
    {
        memset(dp, 0, sizeof(dp)); // initialized with 0
        priority_queue <pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; // min heap
        for(int i=lo; i<=hi; i++) // solve for each i in range low to high
        {
            solve(i);
            pq.push({c, i}); // push {step count, i} as a pair, min heap will sort by first element that is c
            c=0; // reset c for new i
        }
        int res=0;
        while(k--) // get kth smallest from min heap
        {
            res = pq.top().second;
            pq.pop();
        }
        return res; // and return it
    }
};