class Solution {
public:
    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& price, vector<int>& start, int k) {
        int n = grid.size(), m = grid[0].size();
        
        vector<vector<int>> dist(n, vector<int>(m, -1)), vis(n, vector<int>(m));
        
        queue<pair<int, int>> q;
        q.push({start[0], start[1]});
        vis[start[0]][start[1]] = 1;
        dist[start[0]][start[1]] = 0;
        
        int level = 1, size = 0;
        
        // BFS for computing distance matrix
        while(1){
            size = q.size();
            
            if(size == 0) break;
            
            while(size --){
                auto t = q.front(); q.pop();
                
                int i = t.first, j = t.second;
                
                if(i + 1 < n && vis[i + 1][j] == 0 && grid[i + 1][j]){
                    vis[i + 1][j] = 1;
                    dist[i + 1][j] = level;
                    q.push({i + 1, j});
                }
                
                if(j + 1 < m && vis[i][j + 1] == 0 && grid[i][j + 1]){
                    vis[i][j + 1] = 1;
                    dist[i][j + 1] = level;
                    q.push({i, j + 1});
                }
                
                
                if(i && vis[i - 1][j] == 0 && grid[i - 1][j]){
                    vis[i - 1][j] = 1;
                    dist[i - 1][j] = level;
                    q.push({i - 1, j});
                }
                
                if(j && vis[i][j - 1] == 0 && grid[i][j - 1]){
                    vis[i][j - 1] = 1;
                    dist[i][j - 1] = level;
                    q.push({i, j - 1});
                }
            }
            
            level += 1;
        }
        
        // Adding everything into some array
        vector<vector<int>> arr, ans;
        for(int i = 0; i < n; i ++){
            for(int j = 0; j < m; j ++){
                if(dist[i][j] != -1 && grid[i][j] >= price[0] && grid[i][j] <= price[1] && grid[i][j]){
                    arr.push_back({dist[i][j], grid[i][j], i, j});
                }
            }
        }
        
        // Sort the array according to the conditions
        sort(arr.begin(), arr.end(), [](vector<int> &a, vector<int> &b){
            if(a[0] != b[0]) return a[0] < b[0];
            if(a[1] != b[1]) return a[1] < b[1];
            if(a[2] != b[2]) return a[2] < b[2];
            
            return a[3] < b[3];
        });
        
        for(int i = 0; i < arr.size() && i < k; i ++){
            // cout<<arr[i][0]<<" "<<arr[i][1]<<" "<<arr[i][2]<<" "<<arr[i][3]<<"\n";
            
            ans.push_back({arr[i][2], arr[i][3]});
        }
        
        return ans;
    }
};