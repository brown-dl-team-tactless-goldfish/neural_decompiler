public class Solution {
    class TwoNums : IComparable {
        public IList<int> Nums;

        int IComparable.CompareTo(object obj) {
            var second = (TwoNums)obj;
            return Nums[0] + Nums[1] - (second.Nums[0] + second.Nums[1]);
        }
    }
    public IList<IList<int>> KSmallestPairs(int[] nums1, int[] nums2, int k) {
        var result = new List<IList<int>>();

        if (nums1.Length == 0 || nums2.Length == 0) return result;

        int total = nums1.Length * nums2.Length;

        k = k > total ? total : k;

        var maxHeap = new Heap<TwoNums>(HeapType.Max, k);

        for (int i = 0; i < nums1.Length; i++) {
            for (int j = 0; j < nums2.Length; j++) {
                var sum = nums1[i] + nums2[j];

                if (maxHeap.Count < k) {
                    var twoNums = new TwoNums() {
                        Nums = new List<int>() { nums1[i], nums2[j] }
                    };
                    maxHeap.Push(twoNums);

                } else if (maxHeap.Any()) {
                    var pre = maxHeap.Peek();

                    if (sum < pre.Nums[0] + pre.Nums[1]) {
                        var twoNums = new TwoNums() {
                            Nums = new int[] { nums1[i], nums2[j] }
                        };
                        maxHeap.Push(twoNums);
                        maxHeap.Pop();
                    }
                }
            }
        }

        while (maxHeap.Any()) {
            var key = maxHeap.Pop();

            result.Add(key.Nums);
        }
        result.Reverse();
        return result;
    }

    public enum HeapType { Max, Min }
    public class Heap<KeyT> where KeyT : IComparable {
        private HeapType _type;
        private int _count;
        private KeyT[] _heap;

        public Heap(HeapType heapType, int initalCapacity) {
            if (initalCapacity <= 0) throw new ArgumentOutOfRangeException("Capacity should be greater than 0.");
            _heap = new KeyT[initalCapacity + 1];

            _type = heapType;
        }

        public bool Any() {
            return _count != 0;
        }

        public void Push(KeyT key) {
            if (_count + 1 >= _heap.Length) {
                // Double the length of the array
                var newHeap = new KeyT[_count * 2 + 1];
                _heap.CopyTo(newHeap, 0);

                _heap = newHeap;
            }

            _heap[++_count] = key;
            Swim(_count);
        }

        public KeyT Pop() {
            KeyT max = _heap[1];
            Exchange(1, _count--);
            Sink(1);
            _heap[_count + 1] = default(KeyT);
            return max;
        }

        public KeyT Peek() => _heap[1];

        public int Count => _count;

        // Swim to the top (larger than one or both) of its children's
        private void Swim(int k) {
            // parent of node at k is at k / 2;
            while (k > 1 && LessOrMore(k / 2, k)) {
                Exchange(k, k / 2);
                k = k / 2;
            }
        }

        private void Sink(int k) {
            while (2 * k <= _count) {
                int j = 2 * k;
                if (j < _count && LessOrMore(j, j + 1)) j++;

                if (!LessOrMore(k, j)) break;

                Exchange(k, j);
                k = j;
            }
        }

        private bool LessOrMore(int i, int j) {
            if (_type == HeapType.Max) return _heap[i].CompareTo(_heap[j]) < 0;    // Less
            else return _heap[i].CompareTo(_heap[j]) > 0;    // More
        }

        private void Exchange(int i, int j) {
            var temp = _heap[i];
            _heap[i] = _heap[j];
            _heap[j] = temp;
        }
    }
}