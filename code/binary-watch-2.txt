/**
 * Return an array of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */
int count_one_bits(int num){
    int count = 0;
    while(num){
        count += (num&1);
        num = num>>1;
    }
    return count;
}
char** readBinaryWatch(int num, int* returnSize) {
    int bincount[60];
    
    int idx = 0;
    while(idx < 60){
        bincount[idx] = count_one_bits(idx);
        idx++;
    }
    
    int hr = 0, min = 0, pos = 0, HH = 12, MM = 60;
    int total_size = (HH*MM*sizeof(char*));         // array of pointers, hence times 8
    char **answer = malloc(total_size);
    while(hr < HH){
        min = 0;
        while(min < MM){
            if ((bincount[hr] + bincount[min]) == num){
                
                answer[pos] = (char*)malloc(6);     // alloc a string and put it in the answer
                sprintf(answer[pos], "%d:%02d", hr, min);                
                pos++;
            }
            min++;
        }
        hr++;
    }
    *returnSize = pos;  // number of elements and not the total size of the array !
    return answer;
}