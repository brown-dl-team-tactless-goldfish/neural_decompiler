class Solution {
public:
    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {
        vector< set <int> > ed(edges.size() + 1); 
        int del_leave;
        set<int>::iterator parent; 
        vector<int> del; 
        int edgesCnt=edges.size()*2, delCnt=0;
        
        for (auto edge : edges){
            ed[edge[0]].insert(edge[1]);
            ed[edge[1]].insert(edge[0]);
        }

        auto deleteNodes = [&] (auto self, int firstStep) -> void {
            while (del.size()) {
                del_leave = del[del.size() - 1]; 
                parent = ed[del_leave].begin(); 
                ed[*parent].erase(del_leave); 
                del.pop_back(); 
                if (firstStep && ed[*parent].size() == 1 && coins[*parent] == 0) { // parent has become a leaf?
                    del.push_back(*parent); 
                    coins[*parent] = -1; 
                }
                ed[del_leave].clear();                 
                delCnt += 2; 
            }
        }; 

        for (int k = 0; k < 3; k++) { //  k = 0 removing leaves with no coins, k = 1 and k = 2 removing leaves twice 
            for (int i = 0; i < ed.size(); i++) 
                if (ed[i].size() == 1 && (k> 0 || coins[i] == 0)) {del.push_back(i);  coins[i] = -1;}
                deleteNodes(deleteNodes, k == 0);
        }    
        
        return max(0,edgesCnt - delCnt); 
    }
};