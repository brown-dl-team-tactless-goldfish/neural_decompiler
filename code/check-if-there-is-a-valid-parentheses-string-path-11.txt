#define vvvi vector<vector<vector<int>>>
#define vvc vector<vector<char>> 

class Solution {
public:
    
    bool f(int i, int j, int close, vvc &grid, vvvi &dp) {
        if(i < 0 || j < 0 || close < 0) return 0;
        
        // What did u encounter at current cell? 
        // Rem: Traversing right to left in a potential Valid VPS
        if(grid[i][j] == ')') close++;
        else close--;
        
        if(i == 0 and j == 0) {
            // Top-Left cell
            return (close == 0);
        }
        
        if(close < 0) return 0;
        
        if(dp[i][j][close] != -1) return dp[i][j][close];
        
        // Move up(i-1, j) or move left(i, j-1)
        // Now u should move up or left only when u are still satisfying vps
        
        return dp[i][j][close] = (f(i-1, j, close, grid, dp) || f(i, j-1, close, grid, dp));
    }
    
    
    // Idea is while moving left or right, go only where u can make a valid path
    // Check validity while choosing.
    bool hasValidPath(vector<vector<char>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vvvi dp(m, vector<vector<int>> (n, vector<int> (201, -1)));
        
        // I am starting from bottom-right cell meaning back of a possible vps
        // So, I should encounter closing brackets from end )
        
        return f(m-1, n-1, 0, grid, dp);
    }
};