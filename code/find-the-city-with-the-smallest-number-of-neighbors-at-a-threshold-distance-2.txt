int findTheCity(int n, int** edges, int edgesSize, int* edgesColSize, int distanceThreshold){

    int a, i, j, k;
    int path_table[n][n];
    int city_num[n], min_city;
    int visited[n], dist[n];

    for(i=0; i<n; i++)
        for(j=0; j<n; j++)
            path_table[i][j] = -1;

    for(i=0; i<n; i++) {
        visited[i] = 0;
        dist[i] = 100000;
        city_num[i] = 0;
    }

    for(i=0; i<edgesSize; i++) {

        //We don't have to consider the distance which is longer than threshold
        if(edges[i][2] > distanceThreshold)
            continue;

        path_table[edges[i][0]][edges[i][1]] = edges[i][2];
        path_table[edges[i][1]][edges[i][0]] = edges[i][2];
    }

    //Each city will be the start point and do the Dijkstra algorithm
    for(a=0; a<n; a++) {
        
        dist[a] = 0;

        for(i=0; i<n; i++) {

            k = -1;

            for(j=0; j<n; j++)
                if(!visited[j] && (k == -1 || dist[j] < dist[k]))
                    k = j;
    
            //If the smallest distance is shorter than threshold, then not to continuously find
            if(dist[k] > distanceThreshold)
                break;
    
            visited[k] = 1;
    
            for(j=0; j<n; j++)
                if(path_table[k][j] != -1 && dist[k] + path_table[k][j] < dist[j] && 
                   dist[k] + path_table[k][j] <= distanceThreshold)
                    dist[j] = dist[k] + path_table[k][j];
        }

        //Record the number of available city for each city
        for(i=0; i<n; i++)
            if(dist[i] != 100000 && dist[i] != 0)
                city_num[a]++;

        //Reset the visited city and distance
        for(i=0; i<n; i++) {
            visited[i] = 0;
            dist[i] = 100000;
        }
    }

    min_city = 0;
    for(i=0; i<n; i++)
        if(city_num[i] <= city_num[min_city])
            min_city = i;

    return min_city;
}