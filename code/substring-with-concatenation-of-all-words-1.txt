int* findSubstring(char* s, char** words, int wordsSize, int *returnSize)
{
  struct tnode *root = NULL, *head = NULL, *node = NULL;;
  int wlen, slen, i, j, tw = 0, wsize, s_end, arr_off = 0;
  int *ret_arr = NULL;
  struct mstack m = {NULL};
  struct tnode **m_arr = NULL;
  struct tnode dummy;
 
  /* Maintain Sanity */
  *returnSize = 0;
  if (!s || !words || !wordsSize || !returnSize)
    return NULL;
 
  /* Calculate the input array size */
  wlen = strlen(words[0]);
  slen = strlen(s);
 
  /* Initialize variables */
  wsize = wlen * wordsSize;
  s_end = slen - wsize;
 
  /* Initialize dummy to zero */
  dummy.count = dummy.tcount = 0;
 
  /* Allocate a trie for the array */
  if (s_end >= 0)
  {
    /* Allocate memory for simple allocator */
    if (!m_stack_alloc(&m, SEGMENT_COUNT, SEGMENT_SIZE))
      goto subs_exit;
 
    /* Memoization Array */
    m_arr = calloc(slen, sizeof(struct tnode *));
    if (!m_arr)
      goto subs_exit;
 
    /* Create trie */
    root = create_trie(words, wordsSize, &m);
    if (!root)
      goto subs_exit;
  }
 
  /* Loop as long as there is a possibility for a match */
  for (i = 0; i <= s_end; ++i)
  {
    /* Loop checking whether the substring at this location is a
      concatenation of the words */
    for (j = i; j <= slen - wlen; j += wlen)
    {
      char c = s[j + wlen];
      struct tnode *tn = m_arr[j];
 
      /* If there is no hit, then search the trie */
      if (!tn)
      {
        /* Create a NULL terminating condition */
        s[j + wlen] = '\0';
 
        /* If the word is not found then, set the value to
           dummy */
        if ((tn = search(root, &s[j])) == NULL)
          tn = &dummy;
 
        /* Replace the character */
        s[j + wlen] = c;
 
        /* Assign the pointer to the memoization array */
        m_arr[j] = tn;
      }
 
      /* If it's not found, then break */
      if (!tn->count)
        break;
 
      /* Decrement the count */
      --tn->count;
 
      /* Initiate the linked list head */
      if (!head)
        node = head = tn;
 
      /* Add the new node only if it's not already a part of the
        list */
      else if ((!tn->next) && (node != tn))
      {
        node->next = tn;
        node = tn;
      }
 
      /* Increment the hit count */
      tw++;
 
      /* If all the words were found, then break*/
      if (tw == wordsSize)
      {
        /* Make the necessary dynamic allocation */
        if ((!ret_arr) && ((ret_arr = malloc(sizeof(int) * slen)) == NULL))
          goto subs_exit;
 
        /* Save the offset, increment the index and break */
        ret_arr[arr_off] = i;
        arr_off++;
        break;
      }
    }
 
    /* Reset the list */
    if (head)
    {
      reset_list(head);
      head = NULL;
      tw = 0;
    }
  }
 
 /* Free the trie, memoization array, assign the return size */
subs_exit:
  m_stack_free(&m);
  if (m_arr)
  free(m_arr);
  *returnSize = arr_off;
  return ret_arr;
}