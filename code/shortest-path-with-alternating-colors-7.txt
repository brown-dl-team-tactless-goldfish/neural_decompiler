class Solution {
public:
    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {
        
        // create adjacency list
          // for red
           vector<vector<int>>adjR(n,vector<int>());
           for(auto edge:redEdges)
            adjR[edge[0]].push_back(edge[1]);
           
           // for blue
           vector<vector<int>>adjB(n,vector<int>());
           for(auto edge:blueEdges)
            adjB[edge[0]].push_back(edge[1]);

        // not need of priority queue because we have same weight
        queue<pair<int,pair<int,int>>>q;
        q.push({0,{0,-1}});
         // 0: for red
          // 1: for blue
        
        // to store min path          // dist, r, b
        vector<vector<int>>dist(n,{INT_MAX,0,0});
        dist[0][0]=0;
       
       while(!q.empty())
       {
           auto it=q.front();
           q.pop();
           int node=it.first;
           int wgt=it.second.first;
           int color=it.second.second;

        //    cout<<"node:"<<node<<"   wgt:"<<wgt<<"   color:"<<color<<endl;

           // red edge neighbor nodes
           if(!dist[node][1]&&color!=0)
           for(auto n:adjR[node])
           {   
               dist[n][0]=min(dist[n][0],wgt+1);
                 q.push({n,{wgt+1,0}});
               // mark red edge from node 0 as visited
               dist[node][1]=1;     
           }

          // blue edge neighbor nodes
          if(!dist[node][2]&&color!=1)
           for(auto n:adjB[node])
           {  
               dist[n][0]=min(dist[n][0],wgt+1);
                 q.push({n,{wgt+1,1}});
               // mark red edge from node 0 as visited
               dist[node][2]=1;     
           }

       }
    
    // update distance value for node which have not reachable
    vector<int>ans;
      for(auto &d:dist)
         if(d[0]!=INT_MAX)
          ans.push_back(d[0]);
         else
          ans.push_back(-1);

        // return ans
        return ans;
    }
};