public class Solution {
    
private class Heap<T>
{
    private readonly IList<T> _data;
    private readonly IComparer<T> _comparer;

    public int Count => _data.Count;
    public T Peek => _data[0];

    public Heap(IList<T> inputs, IComparer<T> comparer = null)
    {
        _comparer = comparer ?? Comparer<T>.Default;
        _data = inputs;
        for (int i = Count / 2; i >= 0; i--)
        {
            SiftDown(i);
        }
    }

    public Heap(IEnumerable<T> inputs, IComparer<T> comparer = null) : this(inputs.ToList(), comparer)
    {
    }

    private void Swap(int i, int j)
    {
        var tmp = _data[i];
        _data[i] = _data[j];
        _data[j] = tmp;
    }

    public void Clear()
    {
	    _data.Clear();
    }

	private void SiftDown(int i)
    {
        while (2 * i + 1 < _data.Count)
        {
            int left = 2 * i + 1;
            int right = 2 * i + 2;
            int j = left;

            if (right < _data.Count && _comparer.Compare(_data[right], _data[left]) < 0)
            {
                j = right;
            }

            if (_comparer.Compare(_data[i], _data[j]) <= 0)
            {
                break;
            }

            Swap(i, j);
            i = j;
        }
    }

    private void SiftUp(int i)
    {
        while(_comparer.Compare(_data[i], _data[(i - 1) / 2]) < 0)
        {
            Swap(i, (i - 1) / 2);
            i = (i - 1) / 2;
        }
    }

    public T Pop()
    {
        T top = Peek;
        _data[0] = _data.Last();
        _data.RemoveAt(Count - 1);
        SiftDown(0);
        return top;
    }

    public void Push(T value)
    {
        _data.Add(value);
        SiftUp(Count - 1);
    }
}
    
    
			private class ExitComparer : IComparer<int>
			{
				private readonly int[][] _intervals;

				public ExitComparer(int[][] intervals)
				{
					_intervals = intervals;
				}

				public int Compare(int x, int y)
				{
					var cmp = _intervals[x][1].CompareTo(_intervals[y][1]);
					if (cmp == 0)
					{
						return x.CompareTo(y);
					}

					return cmp;
				}
			}

			private class LengthComparer : IComparer<int>
			{
				private readonly int[][] _intervals;

				public LengthComparer(int[][] intervals)
				{
					_intervals = intervals;
				}

				public int Compare(int x, int y)
				{
					var l1 = _intervals[x][1] - _intervals[x][0] + 1;
					var l2 = _intervals[y][1] - _intervals[y][0] + 1;
					var cmp = l1.CompareTo(l2);
					if (cmp == 0)
					{
						cmp = x.CompareTo(y);
					}

					return cmp;
				}
			}

    
    
    public int[] MinInterval(int[][] intervals, int[] queries) {
        Array.Sort(intervals, (i1, i2) => i1[0].CompareTo(i2[0]));
				(int q, int idx)[] qdata = new (int q, int idx)[queries.Length];
				for (var i = 0; i < queries.Length; i++)
				{
					qdata[i] = (queries[i], i);
				}
				Array.Sort(qdata, (q1, q2) =>
				{
					var cmp = q1.q.CompareTo(q2.q);
					if (cmp == 0)
					{
						cmp = q1.idx.CompareTo(q2.idx);
					}

					return cmp;
				});

				int[] res = new int[queries.Length];
				Heap<int> opened = new Heap<int>(new List<int>(), new ExitComparer(intervals));
				SortedSet<int> minLengthSet = new SortedSet<int>(new LengthComparer(intervals));
				int intervalOpenIdx = 0;

				for (var i = 0; i < qdata.Length; i++)
				{
					var curr = qdata[i];
					while (intervalOpenIdx != intervals.Length && intervals[intervalOpenIdx][0] <= curr.q)
					{
						opened.Push(intervalOpenIdx);
						minLengthSet.Add(intervalOpenIdx);
                        intervalOpenIdx++;
					}

					while (opened.Count > 0 && intervals[opened.Peek][1] < curr.q)
					{
						minLengthSet.Remove(opened.Peek);
						opened.Pop();
					}

					if (minLengthSet.Count != 0)
					{
						var min = minLengthSet.Min;
						res[curr.idx] = intervals[min][1] - intervals[min][0] + 1;
					}
					else
					{
						res[curr.idx] = -1;
					}
				}

				return res;
    }
}