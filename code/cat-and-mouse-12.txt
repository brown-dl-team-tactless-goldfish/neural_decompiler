class Solution {
public:
    struct node // turn => who bring the game to this state,turn=0 => mouse else cat 
    {
       int x,y,turn ;  
    };
    // 0-M , 1-C
    int N=51 ;
    int catMouseGame(vector<vector<int>>& graph) {
        queue<node>q ;
        node noob ;
        int n=graph.size() ;
        
        
        int vis[n][n][2],deg[n][n][2] ;
        
        for(int i=0;i<n;i++) for(int j=0;j<n;j++) for(int k=0;k<2;k++) 
        { vis[i][j][k]=-1 ;
          if(k==1) deg[i][j][k]=graph[i].size(); // mouse can go anywhere
          else // cat can not go to 0
          { 
              deg[i][j][k]=graph[j].size() ;
              int f=0 ;
              
              for(int l:graph[j])
              {
                  if(l==0) f=1 ;
              }
              
              if(f)
              deg[i][j][k]-- ;
          }
        }
        
        
        
        
        for(int i=1;i<n;i++)
        {
            noob.x=0 ;
            noob.y=i ;
            noob.turn=0 ;
            
            vis[noob.x][noob.y][noob.turn]=1 ; // mouse wins if mouse enters 0 
            
            q.push(noob) ;
            
            noob.x=i ;
            noob.y=i ;
            noob.turn=1 ;
            
            vis[noob.x][noob.y][noob.turn]=2 ; // cat wins if cat reaches the position of mouse
            q.push(noob) ;
            
            noob.x=i ;
            noob.y=i ;
            noob.turn=0 ;
            
            vis[noob.x][noob.y][noob.turn]=2 ; // cat wins if mose reahes the position of cat 
            q.push(noob) ;
        }
        
        node req ; req.x=1 ; req.y=2 ; req.turn=1 ;
        node nxt ;
        
      
        
        while(!q.empty())
        {
            noob=q.front() ; q.pop() ;
            
            if(noob.x==req.x&&noob.y==req.y&&noob.turn==req.turn) break ;
            
            if(noob.turn==0)
            {
                for(int j:graph[noob.x])
                {
                    nxt.x=j ;
                    nxt.y=noob.y ;
                    nxt.turn=1 ;
                    
                    if(vis[nxt.x][nxt.y][nxt.turn]==-1)
                    {
                           if(vis[noob.x][noob.y][noob.turn]==1)
                         {
                              vis[nxt.x][nxt.y][nxt.turn]=1 ;
                               q.push(nxt) ;
                        }
                        else
                        {
                            deg[nxt.x][nxt.y][nxt.turn]-- ;
                           if(deg[nxt.x][nxt.y][nxt.turn]==0)
                           {
                               vis[nxt.x][nxt.y][nxt.turn]=2 ;
                               q.push(nxt) ;
                           }
                        }
                    }
                    
    
                }
            }
            else
            {
                for(int j:graph[noob.y])
                {
                    nxt.x=noob.x ;
                    nxt.y=j ;
                    nxt.turn=0 ;
                    
                   if(vis[nxt.x][nxt.y][nxt.turn]==-1&&nxt.y!=0)
                    {
                         if(vis[noob.x][noob.y][noob.turn]==2)
                        {
                        vis[nxt.x][nxt.y][nxt.turn]=2 ;
                        q.push(nxt) ;
                        }
                       else
                       {
                           deg[nxt.x][nxt.y][nxt.turn]-- ;
                           if(deg[nxt.x][nxt.y][nxt.turn]==0)
                           {
                               vis[nxt.x][nxt.y][nxt.turn]=1 ;
                               q.push(nxt) ;
                           }
                       }
                    }
                    
                    
                }
            }
            
            
        }
        
        
        if(vis[1][2][1]==-1) return 0 ;
        
        else return vis[1][2][1] ;
        
    }
};