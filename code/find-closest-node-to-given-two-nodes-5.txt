/*
Algorithm
    1. DFS from node1. At each node save distance from node1 in dist[i].
    2. Repeat #1 for node2. At each node save max (dist[i], dist_from_node2) dist[i].
       Track min of this value in result.
    3. Return the corresponding node as result_node.
*/

// global pointer to edges.
int* E;
// Number of edges.
int N;
// Array to hold distance values
int* dist;
// Array of visited flag
unsigned char* visited;
// Resulting distance.
int result;
// Node value corresponding to the resulting distance.
int result_node;

void dfs1 (int node, int depth)
{
    // Recursion base case already handled by caller.
    dist[node] = depth;
    visited[node] = 1;
    if (E[node] < 0)
        return;
    if (!visited[E[node]])
        dfs1 (E[node], depth+1);
}

void dfs2 (int node, int depth)
{
    // Recursion base case already handled by caller.

    if (dist[node] >= 0)
    {
        dist[node] = depth > dist[node] ? depth: dist[node];
        if (result > dist[node])
        {
            result= dist[node];
            result_node = node;
        }
        else if (result == dist[node])
        {
            if (node < result_node)
            {
                result_node = node;
            }
        }
        
    }
    visited[node] = 1;
    if (E[node] < 0)
        return;

    if (!visited[E[node]])
        dfs2 (E[node], depth+1);
}

int closestMeetingNode(int* edges, int edgesSize, int node1, int node2)
{

    int i, j;
    result = 999999999;
    result_node = -1;
    
    E= edges;
    N= edgesSize;
    visited = (unsigned char*) malloc (sizeof(unsigned char) * N);
    dist = (int*) malloc (sizeof(int) * N);

    /* Memset visited and dist structures */
    memset (visited, 0, sizeof(char) * N);
    memset (dist, -1, sizeof(int) * N);

    /* First DFS to calculate distances to nodes from node1 */
    dfs1 (node1, 0);

    /* Second DFS from node 2 to calculate the max of distances from node1 & node2 */
    memset (visited, 0, sizeof(char) * N);
    dfs2 (node2, 0);

    /* Release memory */
    free (visited);
    free (dist);
    return (result_node);

}