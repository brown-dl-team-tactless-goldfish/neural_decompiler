class Solution {
    const int inf = 1234567890;
    int getf(vector<int>& f, int x) {
        return f[x] == x ? x : (f[x] = getf(f, f[x]));
    }
    
    void make(vector<int> &f, vector<int> &num) {
        const int n = f.size();
        for (int i = 0; i < n; ++i) {
            f[i] = i;
            num[i] = 1;
        }
    }

    int mst(const vector<vector<int>>& edges, const vector<int> &ind, const int nume, vector<int> &f, vector<int>& num, int p) {
        int e = 0, w = 0;
        for (int i = 0; e < nume && i < ind.size(); ++i) {
            const int x = ind[i];
            if (x == p) continue;
            int xx = getf(f, edges[x][0]);
            int yy = getf(f, edges[x][1]);
            if (xx == yy) continue;
            ++e;
            if (num[xx] < num[yy]) {
                f[xx] = yy;
                num[yy] += num[xx];
            } else {
                f[yy] = xx;
                num[xx] += num[yy];
            }
            w += edges[x][2];
        }
        return e == nume ? w : inf;
    }
    
public:
    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {
        const int m = edges.size();
        vector<int> ind(m);
        for (int i = 0; i < m; ++i) {
            ind[i] = i;
        }
        sort(ind.begin(), ind.end(), [&](const int &x, const int &y) {
            return edges[x][2] < edges[y][2];
        });
        vector<int> f(n), num(n);
        make(f, num);
        const int w = mst(edges, ind, n - 1, f, num, -1);
        vector<vector<int>> r(2);
        for (int i = 0; i < m; ++i) {
            make(f, num);
            const int x = ind[i];
            const int may1 = mst(edges, ind, n - 1, f, num, x);
            if (may1 > w) {
                r[0].push_back(x);
            } else {
                make(f, num);
                f[edges[x][0]] = f[edges[x][1]];
                num[edges[x][1]] = 2;
                const int may2 = mst(edges, ind, n - 2, f, num, x) + edges[x][2];
                if (may2 == w) r[1].push_back(x);  
            }
        }
        return r;
    }
};