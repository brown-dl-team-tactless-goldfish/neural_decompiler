func longestCommonSubpath(n int, paths [][]int) int {
    degrees := make([]int, n)
    psm := map[int][]int{}

    for _, p := range paths{
        showedc := make([]bool, n)
        showedp := map[int]int{}
        for j, c := range p {
            if !showedc[c] {
                degrees[c]++
                showedc[c] = true
            }
            if j > 0 {
                mask := p[j-1]|(c<<20) //edge (p[j-1], p[j)
                if k := showedp[mask]; k == len(psm[mask]){
                    psm[mask] = append(psm[mask], 1)
                }else{
                    psm[mask][k]++
                }
                showedp[mask]++
            }
        }
    }
    
    ans := 100001
    
    for _, p := range paths{
        res := 0
        showedp := map[int]int{}
        for l, r := 0, 0; r < len(p); r++ {
            if degrees[p[r]] != len(paths){ //not all paths contain city p[r]
                l = r+1 
            }else{
                if l == r {
                    if res == 0 {res = 1}
                }else{
                    mask := p[r-1]|(p[r]<<20)
                    if psm[mask][showedp[mask]] == len(paths){ //all paths contain edge (p[r-1], p[r])
                        if r-l+1 > res {res = r-l+1}
                        showedp[mask]++ //edge used counter
                    }else{
                        l = r //all paths contain city p[r]
                    }
                }
            }
        }
        if res < ans {ans = res} //iterate all paths, ans = min(max res of each path) to avoid bug.
    }
    
    if ans == 100001 {return 0}
    
    return ans
}