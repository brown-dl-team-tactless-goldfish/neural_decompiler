class Solution {
public:
  int findCrossingTime(int n, int k, vector<vector<int>>& time) {
    // Worker is a struct used to represent the workers.
    vector<Worker> workers;
    
    // leftPq: for workers waiting on the left bank.
    // rightPq: for workers waiting on the right bank.
    priority_queue<Worker> leftPq, rightPq;
    
    for (int i = 0; i < k; ++i) {
      workers.push_back(Worker(i, time[i][0], time[i][1], time[i][2], time[i][3]));
      leftPq.push(*(--workers.end()));
    }
    
    // A timeline of {wTime, wIdx, action}
    // action: {0: put down, 1: bridge crossed L->R, 2: picked up, 3: bridge crossed R->L}
    priority_queue<tuple<int, int, int>> timePq;
    bool bridgeInUse = false;
    int maxT = 0;
    
    int moved = 0, picked = 0;
    while (moved < n) {
      // The current time in the simulation.
      int curT = 0;
      
      while (!timePq.empty()) {
        auto [wTime, wIdx, action] = timePq.top();
        auto w = workers[wIdx];
        wTime *= -1;
        if (curT == 0) {
          curT = wTime;
        } else if (wTime > curT) {
          break;
        }
        
        timePq.pop();
        if (action == 0) {
          // One block has been successfully moved.
          moved++;
          // Enqueue on left side of the bridge.
          leftPq.push(workers[wIdx]);
        } else if (action == 1) {
          // Bridge freed up.
          bridgeInUse = false;
          // Enqueue for picking up
          timePq.push({-(curT + w.pO), wIdx, 2});
          // Although, it hasn't been picked yet but tests don't pass otherwise :(
          picked++;
        } else if (action == 2) {
          // Enqueue on right side of the bridge.
          rightPq.push(workers[wIdx]);
        } else if (action == 3) {
          // Lazy way to record the last time a worker reaches the left bank.
          maxT = max(maxT, curT);
          // Bridge freed up.
          bridgeInUse = false;
          // Enqueue for putting down in the new warehouse.
          timePq.push({-(curT + w.pN), wIdx, 0});
        }
      }
      
      // Use the bridge only if it is free.
      if (!bridgeInUse) {
        if (!rightPq.empty()) {
          auto w = rightPq.top(); rightPq.pop();
          timePq.push({-(curT + w.r2L), w.idx, 3});
          bridgeInUse = true;
        } else if (!leftPq.empty() && (picked < n)) {
          auto w = leftPq.top(); leftPq.pop();
          timePq.push({-(curT + w.l2R), w.idx, 1});
          bridgeInUse = true;
        }
      }
    }
    
    return maxT;
  }
  
  struct Worker {
    // idx: Index in the array.
    // l2R: Time to go from left -> right.
    // pO: Time to pick up from old warehous.
    // r2L: Time to go from right -> left.
    // pN: Time to put down in new warehouse.
    int idx, l2R, pO, r2L, pN;
    Worker(int idx, int l2R, int pO, int r2L, int pN) :
    idx(idx), l2R(l2R), pO(pO), r2L(r2L), pN(pN) {}
    
    // Comparator for comparing efficiency in the max-heap PQ.
    bool operator<(const Worker& other) const {
      if (this == &other) return false;
      if ((l2R + r2L) == (other.l2R + other.r2L)) return idx < other.idx;
      return  (l2R + r2L) < (other.l2R + other.r2L);
    }
  };
};