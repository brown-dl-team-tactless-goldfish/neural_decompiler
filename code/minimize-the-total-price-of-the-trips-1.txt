class Solution {
public:
    const int INF = 1e9 + 7;
    pair<int, int> dfs(int v, vector<vector<int>>& edge, vector<int>& count, vector<int>& price, int p) {
        pair<int, int> sol;
        for (int u : edge[v]) {
            if (u != p) {
                pair<int, int> d = dfs(u, edge, count, price, v);
                sol.first += d.second;
                sol.second += min(d.second, d.first);
            }
        }
        sol.first += count[v] * price[v] / 2;
        sol.second += count[v] * price[v];
        return sol;
    }
    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {
        vector<vector<int>> edge(n);
        for (const vector<int>& v : edges) {
            edge[v[0]].push_back(v[1]);
            edge[v[1]].push_back(v[0]);
        }
        vector<int> parent(n);
        vector<int> depth(n);
        parent[0] = 0;
        vector<int> que;
        que.push_back(0);
        depth[0] = 1;
        for (int i = 0; i < (int) que.size(); i++) {
            int v = que[i];
            for (int u : edge[v]) {
                if (depth[u] == 0) {
                    depth[u] = depth[v] + 1;
                    parent[u] = v;
                    que.push_back(u);
                }
            }
        }
        vector<int> count(n);
        for (const vector<int>& vec : trips) {
            int u = vec[0];
            int v = vec[1];
            if (depth[u] > depth[v]) swap(u, v);
            while (depth[v] > depth[u] && v != u) {
                ++count[v];
                v = parent[v];
            }
            while (u != v) {
                ++count[u];
                ++count[v];
                u = parent[u];
                v = parent[v];
            }
            ++count[u];
        }
        pair<int, int> sol =  dfs(0, edge, count, price, -1);
        return min(sol.first, sol.second);
    }
};