#define SIZE 1000   
struct HashArray
{
    int key;
    int count;
    struct HashArray* next;
}Hash[SIZE];       
void addHash(int num)    
{
    int temp=abs(num%SIZE);     
    if(Hash[temp].key==0)
    {
        Hash[temp].key=num;
        Hash[temp].count++;
    }else if(Hash[temp].key==num)
    {
        Hash[temp].count++;     
    }else
    {
        struct HashArray *p=&Hash[temp]; 
        while(p->key!=num&&p->next!=NULL)    
        {p=p->next;}
        if(p->key==num)
        {p->count++;}
        else
        {
            p->next=(struct HashArray*)malloc(sizeof(struct HashArray));
            p=p->next;
            p->key=num;
            p->count=1;
            p->next=NULL;
        }
    }   
}
int leastBricks(int** wall, int wallRowSize, int *wallColSizes) {
    int maxCount=0;
    int sum=0;
    struct HashArray *p;
    for(int i=0;i<SIZE;i++){
        Hash[i].key=0;
        Hash[i].count=0;
        Hash[i].next=NULL;
    }
    for(int i=0;i<wallRowSize;i++){
        sum=0;
        for(int j=0;j<wallColSizes[i]-1;j++){
            sum=sum+wall[i][j];
            addHash(sum);
        }
    }
    for(int i=0;i<SIZE;i++){
        if(Hash[i].count!=0)
        {  
            if(maxCount<Hash[i].count){
                maxCount=Hash[i].count;
            }
            if(Hash[i].next!=NULL){
                p=&Hash[i];
                while(p->next!=NULL)    
                {
                    p=p->next;
                    if(maxCount<p->count){
                        maxCount=p->count;
                    }
                }
            }  
        }
    }
    return wallRowSize-maxCount;
}