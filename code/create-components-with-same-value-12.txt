class Solution {
public:
    int dfs(int v, int target, vector<int> &temp, vector<int>& nums, vector<vector<int>>& adj)
    {
        temp[v] = nums[v];                             //step 1
        
        for(auto u: adj[v])                            //step 2
        {
            if(temp[u])                                //already visited 
                continue;
            
            temp[v] += dfs(u, target, temp, nums, adj);
            
            if(temp[v] > target)                       //step 3
                return 1e6;                            
        }
        if(temp[v] == target)                          //step 4
            return 0;
        return temp[v];                                //step 5
    }
    
    int componentValue(vector<int>& nums, vector<vector<int>>& edges) 
    {
        int n = nums.size();
        vector<vector<int>> adj(n);                    //adjacency list, making graph
        for(auto e: edges)
        {
            adj[e[0]].push_back(e[1]);
            adj[e[1]].push_back(e[0]);
        }
        
        int sum = 0;                                   //sum of all nodes
        for(auto i: nums)
            sum += i;
        
        for(int i=n; i>1; i--)                         //components = i, edges to be removed = i-1, we see if we can divide the graph into more than 1 component
        {
            if(sum % i != 0)                           //not possible to divide graph into equal components
                continue;
            
            vector<int> temp(n, 0);
            if(dfs(0, sum/i, temp, nums, adj) == 0)    //0 = curr node, sum/i = target sum for each component
                return i-1;
        }
        return 0;
    }
};