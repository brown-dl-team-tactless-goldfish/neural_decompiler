#define ABS(a) ((a)>=0?(a):-(a))

// Reformat regex string
// ab*c(four bytes) -> a (-b) c (three bytes) 
// ASCII <= 127
int removeStars(signed char *s)
{
    int c = 0;
    for(int i=0; s[i]; i++) {
        if(s[i]=='*')
            s[c-1] = -s[c-1];
        else
            s[c++] = s[i];
    }
    s[c] = '\0';
    return c;
}

bool isMatch(char* s, char* p_) {
    int p_len = removeStars((signed char *)p_);
    int s_len = strlen(s);
    
    // We cannot promise char is signed on every machine.
    signed char *p = (signed char *)p_;
    
    char dp[1024][1024] = {0};

    for(int x = s_len; x>=0; x--) {
        for(int y = p_len; y>=0; y--) {
            if(s[x]=='\0' && p[y]=='\0') {
                // isMatch("", "") is always true
                dp[y][x] = 1;
                continue;
            }
            // this is a very ordinary dp solution. see https://discuss.leetcode.com/topic/50274/4ms-c-solution-with-explanation
            // note that p[y] < 0 means this token has *
            char right = ((s[x] == ABS(p[y]) || ABS(p[y]) == '.') && p[y] < 0) ? dp[y][x+1]: 0;
            char bottom_right = (s[x] == ABS(p[y]) || ABS(p[y]) == '.') ? dp[y+1][x+1]: 0;
            char bottom = (p[y] < 0)? dp[y+1][x]: 0;
            dp[y][x] = right | bottom_right | bottom;
        }
    }
    return dp[0][0];
}