class Solution {
public:
    int numSubarrayBoundedMax_wrong_DP_TLE(vector<int>& nums, int left, int right) {
        int n=nums.size();
        int mat[n],ctr=0;
        memset(mat,0,sizeof(mat));
        for (int i=n-1; i>=0; --i) {
            for (int j=i; j<n; ++j) {
               mat[j]=i==j? nums[i]: max({mat[j-1],mat[j],nums[i]});
               ctr+=mat[j]<=right && mat[j]>=left;
            }
        }
        return ctr;
    }
    int numSubarrayBoundedMax_O_n_1(vector<int>& nums, int left, int right) {
        int ctr=0,tot=0;
        int target=right;
        auto lambda=[&](int x) { tot+=ctr=x<=target?ctr+1:0; };
        for_each(begin(nums),end(nums),lambda);
        int rright=tot;
        ctr=tot=0, target=left-1;
        for_each(begin(nums),end(nums),lambda);
        return  rright-tot;
    }
    
    int numSubarrayBoundedMax(vector<int>& nums, int left, int right) {
        int res=0;
        //BUG pre=0, wrong
        for (int i=0,dp=0, pre=-1; i<nums.size(); ++i) {
            int n=nums[i];
            //this digit can resurrect previous digits that <left
            // BUG 1: dp+=i-pre : dp here is new subarray created which ends at i
            if (n>=left && n<=right) dp=i-pre, res+=dp;
            else if (n>right) dp=0, pre=i;
            else  res+=dp; // n<left, this digit can not be independent, relies on previous dp to create number of dp new subarrays (appending)
        }
        return res;
    }
};