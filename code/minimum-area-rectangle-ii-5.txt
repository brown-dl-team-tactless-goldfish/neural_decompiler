class Point{
public:
    double x, y;
    
    Point(double x, double y){
        this->x = x;
        this->y = y;
    }
    
    double dist(Point *point){
        double value_one = point->x - this->x;
        double value_two = point->y - this->y;
        
        return sqrt(pow(value_one, 2) + pow(value_two, 2));
    }
    
    Point *center(Point *point){
        double x_center = (point->x + this->x) / 2;
        double y_center = (point->y + this->y) / 2;
        
        Point *centerPoint = new Point(x_center, y_center);
        return centerPoint;
    }
};


typedef unordered_map<string, vector<pair<Point*, Point*>>> diagDT;
class Solution {
private:
    string key(string distance, string centerXY){
        return distance + " -> " + centerXY;
    }
    
    void fillDiagonalValues(vector<vector<int>> &points, diagDT &diagonals){
        for(int i = 0; i < points.size(); i++){
            Point *point_one = new Point(points.at(i).at(0), points.at(i).at(1));
            
            for(int j = i + 1; j < points.size(); j++){
                Point *point_two = new Point(points.at(j).at(0), points.at(j).at(1));
                           
                Point *center   = point_one->center(point_two);
                string distance = to_string(point_one->dist(point_two));
                string centerXY = to_string(center->x) + ", " + to_string(center->y);
                
                diagonals[key(distance, centerXY)].push_back({point_one, point_two});
            }
        }
    }
    
public:
    double minAreaFreeRect(vector<vector<int>>& points) {
        diagDT diagonals;
        fillDiagonalValues(points, diagonals);
        
        double minArea = INT_MAX;
        for(auto iter = diagonals.begin(); iter != diagonals.end(); iter++){
           
            vector<pair<Point*, Point*>> diagonalPoints = iter->second;
            for(int i = 0; i < diagonalPoints.size(); i++){
                Point *point_one = diagonalPoints.at(i).first;
                Point *point_two = diagonalPoints.at(i).second;
                
                for(int j = i + 1; j < diagonalPoints.size(); j++){
                    Point *point_three = diagonalPoints.at(j).first;
                    
                    double length = point_one->dist(point_three);
                    double width  = point_two->dist(point_three);
                    minArea = min(minArea, (length * width));
                }
            }
        }
        
        return minArea != double(INT_MAX) ? minArea : 0;
    }
};