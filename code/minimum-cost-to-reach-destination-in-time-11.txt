vector<vector<int>> adj[1001];
    
    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {
        int V=passingFees.size();
        int E=edges.size();
        vector<int> cost(V,INT_MAX);
        vector<int> time(V,INT_MAX);
      
        
        for(auto e: edges){
            adj[e[0]].push_back({e[1],e[2],passingFees[e[1]]});
            adj[e[1]].push_back({e[0],e[2],passingFees[e[0]]});
        }
        cost[0] = passingFees[0];
        time[0]=0;
        int ans=dijkstra(0,V-1,maxTime,cost,time);
        if (ans==INT_MAX)
            return -1;
        return ans;
    }
    int dijkstra(int src,int dst,int maxTime,vector<int> &cost,vector<int> &time){
        
        
        priority_queue<vector<int>,vector<vector<int>>, greater<vector<int>>> minh;
        minh.push({cost[src],time[src],src});
        
        while(!minh.empty()){
            vector<int> temp=minh.top();
            minh.pop();
            
            int c=temp[0];
            int t=temp[1];
            int v=temp[2];
            
            for(auto X: adj[v]){
                if(t+X[1] <= maxTime){
                    if(cost[X[0]] > c + X[2]){
                        cost[X[0]]=c+X[2];
                        
                        time[X[0]]= t+ X[1];
                        minh.push({cost[X[0]],time[X[0]],X[0]});
                    }
                     if(time[X[0]]> t+ X[1]){
                        time[X[0]]=t+X[1];
                        minh.push({c+X[2],time[X[0]],X[0]});
                    }
                    
                }
            }
            
        }

return cost[dst];
}