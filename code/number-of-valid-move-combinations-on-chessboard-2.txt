class Solution {
public:
    vector<int> type = {0,0,0,0};
    vector<long long> Pow;
    vector<vector<vector<int>>> pos;
    map<long long,int> cache;
	
	//Gets all possible combinations
    void Get(int type, int x, int y){
	
        vector<vector<int>> res;
        res.push_back({x,y});
        for(int i=1; i<=8; ++i){
            for(int j=1; j<=8; ++j){
                int dx = i-x, dy = j-y;
                if(i==x && j==y) continue;
                
                if(type==0 && (dx==0 || dy==0)) res.push_back({i,j}); // horizontal or vertical move
                else if(type==1 && (abs(dx) == abs(dy) || dx==0 || dy==0)) res.push_back({i,j});  
                else if(type==2 && (abs(dx) == abs(dy))) res.push_back({i,j}); //diagonal move
                
            }
        }
        pos.push_back(res);
        return;
    }
    
	
	
	//detect collision between two pieces
    int collision(int t1, vector<int> from1, vector<int>to1, int t2, vector<int>from2, vector<int>to2){
        long long hash = t1*Pow[0] + from1[0]*Pow[1] + from1[1]*Pow[2]
            + to1[0]*Pow[3] + to1[1]*Pow[4] + t2*Pow[5] + from2[0]*Pow[6] + from2[1]*Pow[7]
            + to2[0]*Pow[8] + to2[1]*Pow[9]; 
        
        if(cache.count(hash)) return cache[hash];
        else if(to1 == to2)  return cache[hash] = 1;
        
        
		//direction of movement
        int x1 = to1[0]-from1[0], y1 = to1[1]-from1[1], x2 = to2[0]-from2[0], y2 = to2[1]-from2[1];
        x1 = x1==0 ? 0 : x1/abs(x1);
        y1 = y1==0 ? 0 : y1/abs(y1);
        x2 = x2==0 ? 0 : x2/abs(x2);
        y2 = y2==0 ? 0 : y2/abs(y2);        
        
        while(from1!=to1 || from2!=to2){
            if(from1 == from2) return cache[hash] = 1;
            if(from1!=to1){ from1[0] += x1; from1[1] += y1;}
            if(from2!=to2){ from2[0] += x2; from2[1] += y2;}
        }
        
        return cache[hash] = 0;
    }
	
	
	// Main caller function
    int countCombinations(vector<string>& p, vector<vector<int>>& loc) {
        int n = p.size(), res = 1;
        cache.clear();
        Pow.resize(10,1);
        for(int i=1; i<10; ++i) Pow[i] *= Pow[i-1]*10;
        
        
        //Get All combinations
        for(int i=0; i<n; ++i){
            int x = loc[i][0], y = loc[i][1];
            if(p[i]=="rook") type[i] = 0;  else if(p[i]=="queen") type[i] = 1;  else type[i] = 2;
            Get(type[i],x,y);
            res *= pos[i].size(); //counting total combination
        }
        
        if(n==1) return res;
		
		
		//removing invalid combinations now
        vector<int> ind(n);
        while(1){
		
		//iterating all pairs
            for(int i=0; i<n; ++i){
                int flag = 0;
                for(int j=i+1; j<n;++j){
					//checking collision
                    if(collision(
                        type[i],
                        loc[i],
                        pos[i][ind[i]],
                        type[j],
                        loc[j],
                        pos[j][ind[j]]
                     ))
                        
                       { res--; flag = 1; break;}
                }
                if(flag) break;
            }
            
			//getting next combination, iterating the indexes
            int flag = 0;
            for(int i=n-1; i>=0; --i){
                if(ind[i]<pos[i].size()-1) {ind[i]++; break;}
                else { flag++; ind[i] = 0;}
            }
            if(flag == n) break;

        }
        return res;       
    }
};