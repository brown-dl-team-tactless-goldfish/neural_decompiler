class Solution {
 public:
  struct Node { int val, cost; };
  Node ParseClause(const char*& expr) {
    char c = *expr++;
    if (c != '(') return {c - '0', 1};
    Node node = ParseExpression(expr);
    ++expr;
    return node;
  }

  Node ParseExpression(const char*& expr) {
    Node left = ParseClause(expr);
    while (*expr && *expr != ')') {
      char op = *expr++;
      Node right = ParseClause(expr);
      left = {(op == '&') ? (left.val & right.val) : (left.val | right.val),
              (left.val != right.val) ? 1
                                      : std::min(left.cost, right.cost) +
                                            ((left.val == 0) ^ (op == '|'))};
    };
    return left;
  }

  int minOperationsToFlip(const string& expression) {
    const char* expr = expression.c_str();
    Node node = ParseExpression(expr);
    return node.cost;
  }
};