int rec(int pl,int mask,int cur,int t,int mx,unordered_map<int,int> &mp){
    if(cur>=t){
        return 1-pl;    //  (1-pl) has already won
    }
    if(mp.find(mask)!=mp.end()) return mp[mask];
    for(int i=mx-1;i>=0;i--){
        if((mask&(1<<i))==0){
            //  put this number
            int z=rec(1-pl,mask|(1<<i),cur+i+1,t,mx,mp);
            if(z==pl){
                mp[mask]=z;
                //  current player can win
                return z;
            }
        }
    }
    mp[mask]=1-pl;
    //  current player 'pl' can't win
    return 1-pl;
}

class Solution {
public:
    bool canIWin(int mx, int t) {
        unordered_map<int,int> mp;
        if(((mx*(mx+1))/2)<t) return false;
        if(mx>=t) return true;
        int mask=0;
        return !rec(0,mask,0,t,mx,mp);
    }
};