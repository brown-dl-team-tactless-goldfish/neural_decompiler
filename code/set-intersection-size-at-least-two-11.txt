class Solution {
public:
    /*
        greedy:
        
        1. sort by right end
        2. assign points in order
        
          |------oo|
                     -------|
                  
        for the next interval we have 3 cases:
        
            |----------| cover two points before
                  |---------| cover only one point (add one point to the end of interval)
                     |--------| cover no point (add two points to the end of interval)
                     
        keep track the index of the last two points assigned
    */
    int intersectionSizeTwo(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), [](const vector<int>& lhs, const vector<int>& rhs) {
            // why lhs[0] > rhs[0] when lhs[1] == rhs[1], since if we solve the case for lhs[0] is maximum, those with left
            // end less than lhs[0] will be solved. We do not need to check if right end is covered when assigning a new point
            if (lhs[1] == rhs[1]) return lhs[0] > rhs[0];
            return lhs[1] < rhs[1];
        });
        
        int res = 0, first = -1, second = -1;
        for (auto interval : intervals) {
            int left = interval[0], right = interval[1];
            if (left > first) {
                res += 2;
                first = right, second = right - 1;
            } else if (left > second) {
                res += 1;
                if (right > first) {
                    second = first, first = right;
                } else {
                    second = right;
                }
            }
        }
        
        return res;
    }
};