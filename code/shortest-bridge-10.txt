public class Solution {
    public int ShortestBridge(int[][] A) {
        if (A == null || A.Length == 0)
            return 0;
        
        int result = Int32.MaxValue,
            i = 0,
            j = 0;
        int[] dx = new int[] { 0, 0, 1, -1 },
              dy = new int[] { 1, -1, 0, 0 };
        Queue<int[]> q1 = new Queue<int[]>();
        Queue<Tuple<int[], int>> q2 = new Queue<Tuple<int[], int>>();
        bool[,] visited = new bool[A.Length, A[0].Length];
        
        for (i = 0; i < A.Length; i++)
        {
            for (j = 0; j < A[0].Length; j++)
                if (A[i][j] == 1)
                    break;
            
            if (j < A[0].Length && A[i][j] == 1)
                break;
        }
        
        A[i][j] = 2;
        q1.Enqueue(new int[] { i, j });
                    
        while (q1.Count > 0)
        {
            int[] cur = q1.Dequeue();
                        
            for (int k = 0; k < 4; k++)
            {
                int newX = cur[0] + dx[k],
                    newY = cur[1] + dy[k];
                            
                if (newX > -1 && newX < A.Length && newY > -1 && newY < A[0].Length && !visited[newX, newY])
                {
                    visited[newX, newY] = true;
                                
                    if (A[newX][newY] == 1)
                    {
                        A[newX][newY] = 2;
                        q1.Enqueue(new int[] { newX, newY });
                    }
                    else if (A[newX][newY] == 0)
                        q2.Enqueue(new Tuple<int[], int>(new int[] { newX, newY }, 1));
                }
            }
        }
        
        while (q2.Count > 0)
        {
            var cur = q2.Dequeue();
            
            for (int k = 0; k < 4; k++)
            {
                int newX = cur.Item1[0] + dx[k],
                    newY = cur.Item1[1] + dy[k];
                
                if (newX > -1 && newX < A.Length && newY > -1 && newY < A[0].Length && !visited[newX, newY])
                {
                    visited[newX, newY] = true;
                    
                    if (A[newX][newY] == 1)
                        result = Math.Min(result, cur.Item2);
                    else if (A[newX][newY] == 0)
                        q2.Enqueue(new Tuple<int[], int> (new int[] { newX, newY }, cur.Item2 + 1));
                }
            }
        }
        
        return result;
    }
}