typedef long long int ll;
typedef vector<vector<pair<ll, int>>> VVP;
typedef vector<ll> VL;
typedef vector<VL> VVL;

class Solution {
public:
    ll dijkstra(VVP graph, int change){
        int n = graph.size();
        multiset<pair<ll, int>> pq;
        VVL dis(n);
        pq.insert({0, 0});
        
        while(!pq.empty()){
            ll node = pq.begin()->second, weight = pq.begin() -> first;
            pq.erase(pq.begin());
            
            if((int)dis[node].size() == 0) dis[node].push_back(weight);
            else if((int)dis[node].size() == 1 && dis[node][0] != weight) dis[node].push_back(weight);
            else continue;
            
            bool signal = false;
            int time=-1;
            if((weight / change) % 2 == 0){
                signal = true;
            }
            else{
                time = change*((weight/change) + 1);
            }
            
            for(auto z: graph[node]){
                if((int)dis[z.first].size() < 2){
                    //check if signal is green on the parent node;
                    if(signal){
                        pq.insert({weight + z.second, z.first});
                    }
                    else{
                        pq.insert({time + z.second, z.first});
                    }
                }
            }
        }
        return dis[n-1][1];
    }
    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {
        VVP graph(n);
        for(int i=0;i<(int)edges.size();i++){
            graph[edges[i][0]-1].push_back({edges[i][1]-1, time});
            graph[edges[i][1]-1].push_back({edges[i][0]-1, time});
        }
        return dijkstra(graph, change);
    }
};