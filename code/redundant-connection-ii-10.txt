public class Solution {
    public int[] FindRedundantDirectedConnection(int[][] edges)
        {
            int numNodes = edges.Length;
            int edgeRemoved = -1;
            int edgeMakesCycle = -1;

            var parent = new int[numNodes + 1];

            for (int i = 0; i < numNodes; i++)
            {
                int parentId = edges[i][0];
                int childId  = edges[i][1];

                if (parent[childId] != 0)
                {
                    /* Assume we removed the second edge. */
                    edgeRemoved = i;
                    break;
                }
                else
                    parent[childId] = parentId;
            }

            var unionFind = new UnionFind(numNodes);
            for (int i = 0; i < numNodes; i++)
            {
                if (i == edgeRemoved)
                {
                    continue;
                }

                int u = edges[i][0];
                int v = edges[i][1];

                if (!unionFind.Union(u, v))
                {
                    edgeMakesCycle = i;
                    break;
                }
            }

            /* Handle with the cyclic problem only. */
            if (edgeRemoved == -1)
            {
                return edges[edgeMakesCycle];
            }

            /* Handle with the cyclic problem when we remove the wrong edge. */
            if (edgeMakesCycle != -1)
            {
                int v = edges[edgeRemoved][1];
                int u = parent[v];
                return new int[] { u, v };
            }

            /* CHandle with the cyclic problem when we remove the right edge. */
            return edges[edgeRemoved];    
        }

        /// <summary>
        /// code review March 29, 2019
        /// </summary>
        internal class UnionFind
        {
            private int[] parent;
            private int[] rank;

            public UnionFind(int n)
            {
                parent = new int[n + 1];
                rank = new int[n + 1];
                for (int i = 1; i < n + 1; i++)
                {
                    parent[i] = i;
                    rank[i] = 1;
                }
            }

            private int find(int x)
            {
                if (parent[x] == x)
                    return x;
                return parent[x] = find(parent[x]);
            }

            public bool Union(int x, int y)
            {
                int rootX = find(x);
                int rootY = find(y);

                if (rootX == rootY)
                    return false;
                if (rank[rootX] < rank[rootY])
                {
                    parent[rootX] = rootY;
                    rank[rootY] += rank[rootX];
                }
                else
                {
                    parent[rootY] = rootX;
                    rank[rootX] += rank[rootY];
                }

                return true;
            }
        }
}