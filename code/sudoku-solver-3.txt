#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <stdbool.h>

static int8_t   row[9][10] = {0};
static int8_t   col[9][10] = {0};
static int8_t   square[9][10] = {0};


static inline int
__get_squnum(int x, int y) {
    x /= 3;
    x *= 3;
    y /= 3;

    return x + y;
}

#define __fit_num(num, x, y) ({                             \
    bool __res = false;                                     \
    int  __squnum = __get_squnum((x), (y));                 \
    if(row[(x)][(num)] == 0 && col[(y)][(num)] == 0 &&      \
       square[__squnum][(num)] == 0) {                      \
        board[x][y] = '0' + num;                            \
        row[(x)][(num)] = 1;                                \
        col[(y)][(num)] = 1;                                \
        square[__squnum][(num)] = 1;                        \
        __res = true;                                       \
    }                                                       \
    __res;                                                  \
})

#define __rm_num(x, y)                                  \
do {                                                    \
    char __ch = board[(x)][(y)];                        \
    int  __squnum = __get_squnum((x), (y));             \
    if(__ch != '.') {                                   \
        int __num = __ch - '0';                         \
        board[(x)][(y)] = '.';                          \
        row[(x)][__num] = 0;                            \
        col[(y)][__num] = 0;                            \
        square[__squnum][(num)] = 0;                    \
    }                                                   \
} while(0)

#define __get_nextxy(nextx, nexty, n)                   \
do {                                                    \
    (nextx) = -1;                                       \
    (nexty) = -1;                                       \
    for(int __i = 0; __i < (n); __i++) {                \
        for(int __j = 0; __j < (n); __j++) {            \
            if(board[__i][__j] == '.') {                \
                (nextx) = __i;                          \
                (nexty) = __j;                          \
                __i = (n);                              \
                __j = (n);                              \
            }                                           \
        }                                               \
    }                                                   \
} while(0)

static bool
__do_solveSudoku(char **board, int n, int x, int y)
{
    int nextx, nexty;
    for(int num = 1; num <= 9; num++) {
        if(__fit_num(num, x, y)) {
            __get_nextxy(nextx, nexty, n);
            if(nextx != -1 && nexty != -1) {
                if(!__do_solveSudoku(board, n, nextx, nexty)) {
                    __rm_num(x, y);
                } else {
                    return true;
                }
            } else {
                return true;
            }
        }
    }
    return false;
}

void 
solveSudoku(char** board, int boardSize, int* boardColSize)
{
    char    ch;
    int     n = boardSize;
    int     x, y, squnum;
    bzero(col, sizeof(int8_t) * 90);
    bzero(row, sizeof(int8_t) * 90);
    bzero(square, sizeof(int8_t) * 90);
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            ch = board[i][j];
            if(ch == '.')
                continue;
            ch -= '0';
            squnum = __get_squnum(i, j);
            assert(!row[i][ch]);
            assert(!col[j][ch]);
            assert(!square[squnum][ch]);
            row[i][ch] = 1;
            col[j][ch] = 1;
            square[squnum][ch] = 1;
        }
    }

    __get_nextxy(x, y, n);
    if(x != -1 && y != -1) 
        __do_solveSudoku(board, n, x, y);
}