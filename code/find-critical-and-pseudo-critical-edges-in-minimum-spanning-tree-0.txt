class Solution {
public:
    int find(const vector<int>& a, int i){
        if(i == a[i]){
            return i;
        }
        return find(a,a[i]);
    }
    
    void init(vector<int>& a){
        for(int i = 0;i<a.size();i++){
            a[i] = i; 
        }
    }
    void f(vector<int>& sets, vector<vector<int>>& edges,const vector<pair<int,int>>& weights, vector<int>& tree, int& sum){
        for(int i = 0;i<weights.size();i++){
            int j = weights[i].second;
            auto& e = edges[j];
            int u = e[0];
            int v = e[1];
            int u_ = find(sets,u);
            int v_ = find(sets,v);
            if(u_ != v_){
                tree.push_back(j);
                sum += edges[j][2];
                sets[u_] = sets[v_];
                if(tree.size() == sets.size()-1){
                    break;
                }
            }
        }
    }
    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {
        vector<int> sets(n);
        init(sets);
        vector<pair<int,int>> weights; 
        for(int i = 0;i<edges.size();i++){
            weights.push_back({edges[i][2],i});
        }
        sort(weights.begin(),weights.end());
        vector<int> tree;
        int base = 0;
        f(sets,edges,weights,tree,base);
        vector<int> critical; 
        vector<int> non_critical; 
        for(int i = 0;i<edges.size();i++){
            init(sets);
            tree.clear();
            int sum = 0; 
            int u = edges[i][0];
            int v = edges[i][1];
            edges[i][1] = u; 
            f(sets,edges,weights,tree,sum);
            edges[i][1] = v;
            if(tree.size()!=n-1){
                critical.push_back(i);
            } else {
                if(sum>base){
                    critical.push_back(i);
                } else {
                    tree.clear();
                    init(sets);
                    sets[u] = v;
                    sum = edges[i][2];
                    tree.push_back(i);
                    f(sets,edges,weights,tree,sum);
                    if(sum == base){
                        non_critical.push_back(i);
                    }
                }
            }
        }
        return {critical,non_critical};
    }
};