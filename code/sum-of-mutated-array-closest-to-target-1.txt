int cmpfunc(const void* a, const void* b){
    return *(int*)a - *(int*)b;
}

int findBestValue(int* arr, int arrSize, int target){
    int n = arrSize; 
    qsort(arr, n, sizeof(int), cmpfunc);
    long long*  preSum = malloc(n * sizeof(long long));
    preSum[0] = arr[0];
    for(int i = 1; i < n; i++){
        preSum[i] = preSum[i-1] + arr[i];
    }
    //special case >>>
    if(preSum[n-1] == target)
        return arr[n-1];
    
    if(preSum[0]*n > target){
        int a = target/n;
        if(abs(target - a*n) <= abs(target - (a+1)*n))
            return a;
        else
            return a+1;
    }

    if(preSum[n-1] < target)
        return arr[n-1];
    //<<<<
    
    int left = 0, right = n-1;
    int mid, sum ;
    while(left < right){
        mid = left + (right - left)/2;
        sum = preSum[mid] + (n-mid-1) * arr[mid];
        if(sum == target)
            return arr[mid];
        if(sum < target)
            left = mid + 1;
        else
            right = mid;
    }
    
    sum = preSum[left] + (n-left-1) * arr[left];
    if(sum == target || left == 0)
        return arr[left];
    
    int L = arr[left-1], R = arr[left];
    int M;
    
    while(L < R){        
        M = L + (R-L)/2;        
        sum = preSum[left-1] + M*(n-left);
        //printf("L = %d, R=%d, M=%d, sum=%d ", L, R, M, sum);
        if(sum == target)
            return M;
        if(sum < target)
            L = M + 1;
        else
            R = M;
    }
    
    int sum1 = preSum[left-1] + L*(n-left);
    int sum2 = preSum[left-1] + (L-1)*(n-left);
    if( abs(target - sum2)  <=  abs(target - sum1) )
        return L-1;
    else
        return L;
}