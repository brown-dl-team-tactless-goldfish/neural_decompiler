class LockingTree {
public:
    struct treeNode{
        treeNode* parent = nullptr;
        vector<treeNode*> chs;
        int locked = 0;
    };
    
    treeNode* root = nullptr;
    unordered_map<int, treeNode*> nodes;
    
    LockingTree(vector<int>& parent) {
        nodes[0] = root = new treeNode;
         
        for (int i = 1; i < parent.size(); i++){
            auto pnode = nodes[parent[i]];
            if (!pnode) pnode = nodes[parent[i]] = new treeNode;
            
            auto node = nodes[i];
            if (!node) node = nodes[i] = new treeNode;
            
            node->parent = pnode;
            pnode->chs.push_back(node);
        }
    }
    
    bool lock(int num, int user) {
        auto node = nodes[num];
        if (node->locked) return false;
        
        node->locked = user;
        return true;
    }
    
    bool unlock(int num, int user) {
        auto node = nodes[num];
        if (node->locked != user) return false;
        
        node->locked = 0;
        return true;
    }
    
    bool upgrade(int num, int user) {
        auto node = nodes[num];
        if (node->locked) return false;
        
        for (auto pnode = nodes[num]->parent; pnode; pnode = pnode->parent)
            if (pnode->locked) return false;
        
        if (!dfs(node)) return false;
        
        node->locked = user;
        return true;
    }
    
    int dfs(treeNode* node){
        int res = node->locked > 0;
        if (res) node->locked = 0;
        
        for (auto ch : node->chs)
            res += dfs(ch);
        
        return res;
    }
};