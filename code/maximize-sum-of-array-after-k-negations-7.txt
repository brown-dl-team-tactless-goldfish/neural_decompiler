int largestSumAfterKNegations(int* A, int ASize, int K) {
    int total[201] = {0};
    int *totalP = total+100;
    int t = 0;
    for(int i = 0; i < ASize;++i){
        int n= A[i];
        ++totalP[n];
        t += n;
    }
    int j = 200;
    for(int i = 0; i < 100;++i,j = j - 2){//反转负数部分需要添加两倍的值
        int n = total[i]; 
        if(K >= n){
            K -= n;
            t += j*n;
        }else{
            t += j*K;
            K = 0;
            break;
        }
    }
    if(K%2 == 1){//说明有多余的反转数，所以需要反转一个最小值
        for(int i = 0;i <= 100;++i){
            if(total[i+100] > 0 || total[100-i] > 0){
                t = t-2*i;
                break;
            }
        }
    }
    return t;
}