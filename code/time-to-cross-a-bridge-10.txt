using State = array<int, 3>; 
// first element is finish time of action.
// second one is worker index.
// third one is action indicator, where 
// 'r' is putting box and gettign ready to cross bridge on right side, 
// 'l' is picking up box and getting ready to cross bridge on left side,
// 'm' is crossing the bridge from left side to right side, 
// 's' is crossing the bridge from right side to left side.

class Solution {
public:
    int findCrossingTime(int n, int k, vector<vector<int>>& time) {
        priority_queue<array<int, 2>> bwql, bwqr; // bwql stands for bridge_waiting_queue_on_leftside    
        priority_queue<State, vector<State>, greater<State>> tq;
        int tm = 0;
        for(int i = 0; i < k; i++) {
            bwql.push({time[i][0] + time[i][2], i});       
        } 
        int n_arrival_left = n;
        int ans = 0;
        int b_locked = 0; // bridge is blocked or not
        for(; n > 0;) {
            if (tq.size() > 0) {
                tm = tq.top()[0];
                for(; tq.size() > 0 and tq.top()[0] <= tm;) {
                    State s = tq.top(); tq.pop();
                    if (s[2] == (int) 'l') {
                        bwql.push({time[s[1]][0] + time[s[1]][2], s[1]});
                    } else if (s[2] == (int) 'r') {
                        bwqr.push({time[s[1]][0] + time[s[1]][2], s[1]});
                    } else if (s[2] == (int) 'm') {
                        b_locked = 0;
                        tq.push({s[0] + time[s[1]][1], s[1], 'r'}); 
                    } else if (s[2] == (int) 's') {
                        b_locked = 0;
                        tq.push({s[0] + time[s[1]][3], s[1], 'l'});
                        if (n > 0) ans = s[0];
                        n -= 1;
                    }
                }
            }
            
            if (!b_locked) { // if bridge is not used
                if (bwqr.size() > 0) {
                    auto c = bwqr.top(); bwqr.pop();
                    tq.push({tm + time[c[1]][2], c[1], 's'});
                    b_locked = 1;
                } else {
                    if (bwql.size() > 0 and n_arrival_left > 0) {
                        n_arrival_left -= 1;
                        auto c = bwql.top(); bwql.pop();
                        tq.push({tm + time[c[1]][0], c[1], 'm'});
                        b_locked = 1;
                    } 
                }
            } 
        }
        return ans;
    }
};