public class Solution {
    Dictionary<int, IList<IList<string>>> cache = new Dictionary<int, IList<IList<string>>>();
    
    public IList<string> WordBreak(string s, IList<string> wordDict) {
        // form the trie
		var trie = new Trie();
        foreach(var word in wordDict) {
            var node = trie;
            for(var i = 0; i < word.Length; i++) {
                var c = word[i];
                if (node.children[c - 'a'] == null) {
                    node.children[c - 'a'] = new Trie { val = c };
                }
                node = node.children[c - 'a'];
            }
            node.end = true;
            node.word = word;
        }
        
        var result = Helper(s, trie, 0);
        return result.Select(x => string.Join(" ", x)).ToList();
    }

    private IList<IList<string>> Helper(string s, Trie trie, int startIdx) {
        if (cache.ContainsKey(startIdx)) return cache[startIdx];   // use memoisation to avoid redundant recursion
        
        var index = startIdx;
        IList<IList<string>> backet = new List<IList<string>>();
        var node = trie.children[s[index] - 'a'];
        while (node != null) {
            if (node.end) {
                if (index == s.Length - 1) {
                    backet.Add(new List<string>{ node.word });
                }
                else {
                    var result = Helper(s, trie, index+1);
                    foreach(var item in result) {
                        var x = new List<string>();  // super important here, do not modify (add `node.word` into) item directly, it is referencing the value stored into cache, modify it will modify the cache. So we create a new list x here
                        x.Add(node.word);
                        x.AddRange(item);
                        backet.Add(x);
                    }
                }
            }
            index++;
            if (index >= s.Length) break;
            node = node.children[s[index] - 'a'];
        }
        
        cache[startIdx] = backet;
        return backet;
    }

    class Trie {
        public bool end;
        public string word;
        public char val;
        public Trie[] children;
        public Trie() {
            children = new Trie[26];
        }
    }
}