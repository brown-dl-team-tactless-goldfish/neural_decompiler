typedef struct Pair_
{
    int i;
    int j;
} Pair;

int mat_get_dis(int **B, int i, int j, int r, int c, int round)
{
    int k = -1, d = -1;

    if (B[i][j] >= 0) {
        return B[i][j];
    }

    /* dis: up */
    if (i > 0 && B[i - 1][j] >= 0) {
        k = B[i - 1][j];

        if (d < 0) {
            d = k;
        }
        else if (d >= 0 && d > k) {
            d = k;
        }
    }

    /* dis: down */
    if (i < r - 1  && B[i + 1][j] >= 0) {
        k = B[i + 1][j];

        if (d < 0) {
            d = k;
        }
        else if (d >= 0 && d > k) {
            d = k;
        }
    }

    /* dis: left */
    if (j > 0 && B[i][j - 1] >= 0) {
        k = B[i][j - 1];

        if (d < 0) {
            d = k;
        }
        else if (d >= 0 && d > k) {
            d = k;
        }
    }

    /* dis: right */
    if (j < c - 1 && B[i][j + 1] >= 0) {
        k = B[i][j + 1];

        if (d < 0) {
            d = k;
        }
        else if (d >= 0 && d > k) {
            d = k;
        }
    }

    if (d >= 0) {
        if (d <= round) {
            B[i][j] = 1 + d;
        }
        else {
            d = -1;
        }
    }

    return d;
}

int** updateMatrix(int **A, int r, int c, int **columnSizes, int* returnSize)
{
    int **B;
    int i, j;
    Pair *td; /* to be determined */
    int s, m, d, round;

    assert(A != NULL);
    assert(r > 0);
    assert(c > 0);

    *returnSize = r;
    *columnSizes = malloc(sizeof(int) * r);
    for (i = 0; i < r; i++) (*columnSizes)[i] = c;
    
    B = malloc(sizeof(*B) * r);
    assert(B != NULL);

    for (i = 0; i < r; i++) {
        B[i] = malloc(sizeof(int) * c);
        assert(B[i] != NULL);
    }

    /* aux mem */
    td = malloc(sizeof(*td) * r * c);

    s = 0;
    for (i = 0; i < r; i++) {
        for (j = 0; j < c; j++) {
            if (A[i][j] == 0) {
                B[i][j] = 0;
            }
            else {
                B[i][j] = -1;

                td[s].i = i;
                td[s].j = j;

                s++;
            }
        }
    }

    /* breadth first search */
    round = 0;
    while (s > 0) {
        m = 0;
        for (i = 0; i < s; i++) {
            d = mat_get_dis(B, td[i].i, td[i].j, r, c, round);

            if (d < 0) {
                td[m].i =  td[i].i;
                td[m].j =  td[i].j;
                m++;
            }
        }

        s = m;
        round += 1;
    }

    free(td);

    return B;
}