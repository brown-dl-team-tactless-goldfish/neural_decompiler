public class Solution {
	int ans;
	Dictionary<string, int> freq;

	public int CountSubstrings(string s, string t) {
		ans = 0;
		freq = new Dictionary<string, int>();
		Trie root = new Trie();

		for(int i = 0; i < t.Length; i++) {
			for(int j = i; j < t.Length; j++) {
				string str = t.Substring(i, j - i + 1);

				if(!freq.ContainsKey(str))
					freq[str] = 0;

				freq[str]++;

				Insert(root, str, 0);
			}
		}

		for(int i = 0; i < s.Length; i++) {
			for(int j = i; j < s.Length; j++) {
				Match(root, s.Substring(i, j - i + 1), 0, "", 0);
			}
		}

		return ans;
	}

	public Trie Insert(Trie root, string str, int idx) {
		if(idx == str.Length) {
			root.isEnd = true;
			return root;
		}

		if(root.next[str[idx] - 'a'] == null)
			root.next[str[idx] - 'a'] = new Trie();

		root.next[str[idx] - 'a'] = Insert(root.next[str[idx] - 'a'], str, idx + 1);
		return root;
	}

	public void Match(Trie root, string str, int idx, string word, int count) {
		if(idx == str.Length || count > 1) {
			if(count == 1)
				ans += freq[word];

			return;
		}

		for(int i = 0; i < 26; i++) {
			if(root.next[i] != null)
			{
				if(i == (str[idx] - 'a'))
					Match(root.next[i], str, idx + 1, word + (char)(i + 'a'), count);
				else
					Match(root.next[i], str, idx + 1, word + (char)(i + 'a'), count + 1);
			}
		}
	}
}

public class Trie{
	public bool isEnd;
	public Trie[] next;

	public Trie() {
		isEnd = false;
		next = new Trie[26];
	}
}