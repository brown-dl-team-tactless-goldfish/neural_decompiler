class Solution {
public:
    struct Pos{
        int r, c;
        Pos(int rr, int cc) : r(rr), c(cc) {}
    };
    int swimInWater(vector<vector<int>>& grid) {
        auto cmp = [&](auto& p1, auto& p2) { return grid[p1.r][p1.c] > grid[p2.r][p2.c]; };
        priority_queue<Pos, vector<Pos>, decltype(cmp)> q(cmp);
        q.emplace(0, 0);
        int res = 0, n = grid.size();
        vector<vector<bool>> visited(n, vector<bool>(n, false));
        visited[0][0] = true;
        int dir[] = {-1, 0, 1, 0, -1};
        while (!q.empty()) {
            int r = q.top().r, c = q.top().c;
            q.pop();
            res = max(res, grid[r][c]);
            if (r == n - 1 && c == n - 1) return res;
            for (int i = 0, j = 1; i < 4; i++, j++) {
                int rr = r + dir[i], cc = c + dir[j];
                if (rr < 0 || cc < 0 || rr == n || cc == n || visited[rr][cc]) continue;
                visited[rr][cc] = true;
                q.emplace(rr, cc);
            }
        }
        return res;
    }
};