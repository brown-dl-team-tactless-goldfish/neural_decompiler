class Solution {
public:
    int minOperationsToFlip(string expression) {
        std::stack<CompositeExpr> expr_stack;
        expr_stack.emplace();
        for (char ch : expression) {
            switch (ch) {
                case '(':
                    expr_stack.emplace();
                    break;
                case ')': 
                    {
                        std::shared_ptr<Expr> ptr = std::make_shared<CompositeExpr>(expr_stack.top());
                        expr_stack.pop();
                        expr_stack.top().vals.push_back(ptr);
                    }                        
                    break;
                case '0':
                    expr_stack.top().vals.push_back(
                        std::make_shared<FalseExpr>()
                    );
                    break;
                case '1':
                    expr_stack.top().vals.push_back(
                        std::make_shared<TrueExpr>()
                    );
                    break;
                case '|':
                    expr_stack.top().ops.push_back(Op::OR);                
                    break;                    
                case '&':
                    expr_stack.top().ops.push_back(Op::AND);
                    break;
            }
        }
        return expr_stack.top().cost();
    }
private:
    enum Op {
        AND = 0, OR
    };
    struct Expr {
        virtual int cost() = 0;            
        virtual bool eval() = 0;
    };
    
    struct TrueExpr : public Expr {        
        virtual int cost() {
            return 1;
        }        
        virtual bool eval() {
            return true;
        }
    };   
    
    struct FalseExpr : public Expr {        
        virtual int cost() {
            return 1;
        }        
        virtual bool eval() {
            return false;
        }
    };   
    
    struct CompositeExpr : public Expr {
        std::vector<Op> ops;
        std::vector<std::shared_ptr<Expr>> vals;
        
        virtual bool eval() {
            init();
            return eval_result;
        }
        
        virtual int cost() {   
            init();
            std::vector<std::vector<int>> tbl(ops.size() + 1, std::vector<int>(2, 0));
            tbl[0][records[0].val] = 0;
            tbl[0][1 - records[0].val] = records[0].cost;
            for (int i = 1; i <= ops.size(); ++i) {
                const auto curr_op = ops[i - 1];
                const auto curr_val = records[i].val;
                const auto curr_cost = records[i].cost;
                
                int neg_cost = INT_MAX;
                neg_cost = std::min(neg_cost,
                    (Op::AND != curr_op) + ((false != curr_val) ? curr_cost : 0) + 
                        std::min(tbl[i - 1][true], tbl[i - 1][false]));
                neg_cost = std::min(neg_cost,
                    (Op::OR != curr_op) + ((false != curr_val) ? curr_cost : 0) +
                        tbl[i - 1][false]);
                neg_cost = std::min(neg_cost,
                    (Op::AND != curr_op) + ((true != curr_val) ? curr_cost : 0) + 
                        tbl[i - 1][false]);
                tbl[i][false] = neg_cost;
                
                int pos_cost = INT_MAX;
                pos_cost = std::min(pos_cost,
                    (Op::AND != curr_op) + ((true != curr_val) ? curr_cost : 0) + 
                        tbl[i - 1][true]);
                pos_cost = std::min(pos_cost, 
                    (Op::OR != curr_op) + ((true != curr_val) ? curr_cost : 0) +
                        std::min(tbl[i - 1][true], tbl[i - 1][false]));
                pos_cost = std::min(pos_cost,
                    (Op::OR != curr_op) + ((false != curr_val) ? curr_cost : 0) + 
                        tbl[i - 1][true]);
                tbl[i][true] = pos_cost;
            }
            return tbl.back()[!eval_result];
        }
                
    private:
        struct Record {
            bool val;
            int cost;
        };    
            
        std::vector<Record> records;
        bool eval_result;
        bool init_done = false;
        
        void init() {
            if (init_done) {
                return;
            }
            for (const auto &val : vals) {
                records.push_back(
                    Record{.val = val->eval(), .cost = val->cost()}
                );
            }                        
            bool target = records.front().val;
            for (int i = 0; i < ops.size(); ++i) {
                switch (ops[i]) {
                    case Op::AND:
                        target &= records[i + 1].val;
                        break;
                    case Op::OR:
                        target |= records[i + 1].val;
                        break;
                }
            }
            eval_result = target;
            init_done = true;
        }
        
    };
};