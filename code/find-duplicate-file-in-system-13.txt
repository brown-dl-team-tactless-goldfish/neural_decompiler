/*
 * 609. Find Duplicate File in System
 *
 * Given a list paths of directory info, including the directory path, 
 * and all the files with contents in this directory, return all the 
 * duplicate files in the file system in terms of their paths. You may 
 * return the answer in any order.
 * 
 * A group of duplicate files consists of at least two files that have 
 * the same content.
 * 
 * A single directory info string in the input list has the following format:
 * 
 * "root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... 
 * fn.txt(fn_content)"
 * It means there are n files (f1.txt, f2.txt ... fn.txt) with content 
 * (f1_content, f2_content ... fn_content) respectively in the directory 
 * "root/d1/d2/.../dm". Note that n >= 1 and m >= 0. If m = 0, it means the 
 * directory is just the root directory.
 * 
 * The output is a list of groups of duplicate file paths. For each group, 
 * it contains all the file paths of the files that have the same content. 
 * A file path is a string that has the following format:
 * 
 * "directory_path/file_name.txt"
 *  
 * 
 * Example 1:
 *  Input: paths = ["root/a 1.txt(abcd) 2.txt(efgh)","root/c 
 *                  3.txt(abcd)","root/c/d 4.txt(efgh)","root 4.txt(efgh)"]
 *  Output: [["root/a/2.txt","root/c/d/4.txt","root/4.txt"],
 *           ["root/a/1.txt","root/c/3.txt"]]
 *
 * Example 2:
 *  Input: paths = ["root/a 1.txt(abcd) 2.txt(efgh)",
 *                  "root/c 3.txt(abcd)","root/c/d 4.txt(efgh)"]
 *  Output: [["root/a/2.txt","root/c/d/4.txt"],
 *           ["root/a/1.txt","root/c/3.txt"]]
 *  
 * Constraints:
 * 
 * 1 <= paths.length <= 2 * 10^4
 * 1 <= paths[i].length <= 3000
 * 1 <= sum(paths[i].length) <= 5 * 10^5
 * paths[i] consist of English letters, digits, '/', '.', '(', ')', and ' '.
 * You may assume no files or directories share the same name 
 * in the same directory.
 * You may assume each given directory info represents a unique 
 * directory. A single blank space separates the directory path 
 * and file info.
 */
 
/*
 * Algorithm:
 *  Trie?
 *      Using file content as index, store the file path and name in the Trie.
 *      Traverse the Trie, copy the file name to the answer buffer?
 *
 *              a
 *                  b
 *                      c
 *                          d   -> root/a/1.txt
 *                              -> root/c/3.txt
 *  (1) Scan the paths, extract the path and file names and content of files.
 *  (2) Store file information to Trie (file content as index)
 *  (3) Traverse the Trie (or store the pointers in another buffer), 
 *      if a termination node contains more than 1 file, copy the file names 
 *      to answer buffer.
 */
 
typedef struct file_info {
    char *folder;           /* File folder name */
    char *name;             /* File name */
    struct file_info *next; /* Next file */
} FILE_INFO;
 
typedef struct node {
    bool is_end;
    struct node *next[128];
    FILE_INFO *file_list;   /* File list for storing the information of files have same content */ 
    int file_cnt;
} NODE;

NODE trie;

int trie_init()
{
    memset((void *)&trie, 0, sizeof(trie));
    return 0;
}

int trie_insert(char *folder, char *file, char *content)
{
    int key;
    NODE *curr;
    FILE_INFO *new_file;

    curr = &trie;

    /* Using file content as index */
    while (*content != ')') {

        key = *content;
        
        if (curr->next[key] == NULL) {
            curr->next[key] = (NODE *)calloc(1, sizeof(NODE));
        }

        curr = curr->next[key];
    
        content++;
    }

    curr->is_end = true;
    
    /* Add file information to corresponding linkin list */
    new_file = (FILE_INFO *)malloc(sizeof(FILE_INFO));
    new_file->folder = folder;
    new_file->name = file;
    new_file->next = curr->file_list;
    curr->file_list = new_file;
    curr->file_cnt++;
    
    return 0;
}

int trie_dump_dup(NODE *node, char ***ans, int grp, int **col)
{
    FILE_INFO *file;
    NODE *next;

    int idx = 0;
    int len;
    
    for (int i = 0; i < 128; i++) {
    
        next = node->next[i];
        
        if (next != NULL) {

            if (next->is_end) {

                /* Check if there are files have same content */
                if (next->file_cnt >= 2) {
                    file = next->file_list;
                    
                    idx = 0;
                    
                    ans[grp] = (char **)malloc(sizeof(char **) * next->file_cnt);

                    while (file) {

                        len = strlen(file->folder) + strlen(file->name) + 1 + 1;
                        
                        ans[grp][idx] = (char *)malloc(sizeof(char) * len);
                        strcpy(ans[grp][idx], file->folder);
                        strcat(ans[grp][idx], "/");
                        strcat(ans[grp][idx], file->name);
                        
                        idx++;
                        file = file->next;
                    }
                    
                    (*col)[grp] = next->file_cnt;
                    
                    grp++;
                }
            }
            
            grp = trie_dump_dup(next, ans, grp, col);
        }
    }

    return grp;
}

int trie_release(NODE *trie)
{
    FILE_INFO *file, *del;

    if (trie) {
        for (int i = 0; i < 128; i++) {
            if (trie->next[i]) {
            
                file = trie->next[i]->file_list;
                
                while (file) {
                    del = file;
                    file = file->next;
                    free(del);
                }
            
                trie_release(trie->next[i]);
                free(trie->next[i]);
            }
        }
    }

    return 0;
}

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
char *** findDuplicate(char ** paths, int pathsSize, int* returnSize, int** returnColumnSizes){

    /*
     * Input:
     *  **paths, string array contains folder, file names and contents of files
     *  pathsSize, number of strings in given array
     */
     
    char *s;
    char *tok;
    char *folder;
    char *file_name;
    char *file_content;
    char ***ans = (char **)malloc(sizeof(char **) * 10000);
    
    *returnColumnSizes = (int *)calloc(1, sizeof(int) * 10000);
    *returnSize = 0;
    
    trie_init();
       
    for (int i = 0; i < pathsSize; i++) {
    
        s = paths[i];
        
        /* Extract the folder name */
        tok = strtok(s, " ");
        folder = tok;
        
        if (folder) {
            
            /* Extract information of files */
            tok = strtok(NULL, " ");
        
            while (tok) {
            
                /* Extract file name and content */
                file_name = tok;
                file_content = file_name;
                
                while (*file_content != '(') {
                    file_content++;
                }
                
                *file_content = 0;
                file_content++;

                trie_insert(folder, file_name, file_content);

                tok = strtok(NULL, " ");
            }
        }
    
    }
    
    *returnSize = trie_dump_dup(&trie, ans, 0, returnColumnSizes);

    if (*returnSize == 0) {
        free(*returnColumnSizes);
        *returnColumnSizes = NULL;
        free(ans);
        ans = NULL;
    }
    
    /* Release Trie */
    for (int i = 0; i < 128; i++) {
        trie_release(trie.next[i]);
    }

    /*
     * Output:
     *  returnSize, row number of returned array
     *  returnColumnSizes, column number of returned array
     *  return all the duplicate files in the file system in 
     *  terms of their paths
     */

    return ans;
}