
void swap(int *a, int *b){
    int t = *a;
    *a = *b;
    *b = t;
}

static int *maxheap;
static int hsize;

void sink(int h_idx){
    int child = h_idx * 2 + 1;
    while (1){
        if (child < hsize){
            if (child + 1 < hsize && maxheap[child + 1] > maxheap[child]){
                child = child + 1;
            }
            if (maxheap[h_idx] < maxheap[child]){
                swap(&maxheap[h_idx], &maxheap[child]);
                h_idx = child;
                child = h_idx * 2 + 1;
            } else {
                return;
            }
        } else {
            return;
        }
    }

}

int kthSmallest(int** matrix, int matrixSize, int* matrixColSize, int k){
    hsize = k;
    maxheap = calloc(hsize, sizeof(int));
    int heap_idx = k-1;
    int break_i, break_j;
    int ret;
    //Fetch data
    for (int i = 0; i < matrixSize && heap_idx>=0; i++){
        for (int j = 0; j < *matrixColSize && heap_idx>=0; j++ ){
            if (heap_idx>=0){
                maxheap[heap_idx] = matrix[i][j];
                if (heap_idx==0){
                    break_i = i;
                    break_j = j;
                }
                heap_idx--;
            }
        }
    }

    //Heapify
    for (heap_idx = k/2; heap_idx >= 0; heap_idx--){
        sink(heap_idx);
    }


    for (break_j++; break_j < *matrixColSize; break_j++){
         if (matrix[break_i][break_j] < maxheap[0]){
            maxheap[0] = matrix[break_i][break_j] ;
            sink(0);
        } else { // matrix[i][j] >= maxheap[0]   && matrix[i][j +1 ] > matrix[i][j ]
            break;
        }
    }

    for (int i = break_i + 1; i<matrixSize;i++){
        for(int j = 0; j<*matrixColSize;j++){
            if (matrix[i][j] < maxheap[0]){
                maxheap[0] = matrix[i][j] ;
                sink(0);
            } else {
                if( j == 0){ // // matrix[i][0] >= maxheap[0]   && matrix[i + 1][0] > matrix[i][0]
                    goto END;
                } else { // matrix[i][j] >= maxheap[0]   && matrix[i][j +1 ] > matrix[i][j]
                    break;
                }

            }
        }
    }
END:
    ret = maxheap[0];
    free(maxheap);
    return ret;
}
