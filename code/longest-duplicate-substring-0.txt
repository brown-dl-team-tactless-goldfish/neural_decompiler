struct list{
    int key;
    struct list* next;
    struct list *last;
};

struct list *getnode(int key) {
    struct list *node = (struct list *)malloc(sizeof(struct list));
    node->key = key;
    node->next = 0;
    return node;
}

void add2hash(struct list *hash[], int index, int key) {
    if(hash[index] == 0) {
        hash[index] = getnode(key);
        hash[index]->last = hash[index];
        return;
    }
    
    struct list *last = hash[index]->last;
    last->next = getnode(key);
    last = last->next;
    hash[index]->last = last;
 
    return;
}

void remhash(struct list *hash[], int index, int key) {
    if(hash[index]) {
        struct list *tmp = hash[index];
        hash[index] = hash[index]->next;
        free(tmp);
    }
    return;
}

void freelist(struct list *hash[]) {
    for(int i = 0; i < 26; i++) {
        struct list *node = hash[i];
        while(node) {
            struct list *tmp = node;
            node = node->next;
            free(tmp);
        }
     }
}

void printlist(struct list *hash[]) {
    for(int i = 0; i < 26; i++) {
        struct list *node = hash[i];
        printf("\nlist char = %c and pos: ", i + 'a');
        while(node) {
            printf("%d ", node->key);
            node = node->next;
        }
        printf("\n");
     }
}

char * longestDupSubstring(char * s){
    char *p = s;
    int n = 0;
    struct list *hash[26] = {0};
    while(*p) {
        add2hash(hash, *p - 'a', n);
        n++;
        p++;
    }
    int max = 0;
    int mi = 0;
   // printlist(hash);
    for(int si = 0; si < n; si++) {
        /*Already max found no furhter scan required*/
        if(n - si < max)
            break;
        remhash(hash, s[si] - 'a', si);
        struct list *node = hash[s[si] - 'a'];
        int di = 0;
        int j = 0;
        while(node) {
            int di = node->key;
            /* with this match index max duplicate not possible */
            if(n - di < max)
                break;
            node = node->next;
            j = 0;
            while(s[si + j] == s[di + j])
                j++;    
            if(max < j) {
                max = j;
                mi = si;
            }
        }
        if(max + di + j >= n) 
            break;
        if(max >= (n - si)/2 )
            break;
    }
    freelist(hash);
    s[mi + max] = '\0';
    return &s[mi];
}