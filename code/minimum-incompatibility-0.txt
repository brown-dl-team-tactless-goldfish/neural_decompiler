class Solution {
    int n ;
    int k ;
    vector<bool>visited ;
    int ret = INT_MAX ;
    
    void dfs(vector<int>&nums, int cur, int count, int low, int high, int sum){
        if(count == n/k){
            int i = 0;  
            while(i < n && visited[i])
                i++ ;
            if(i == n){
                ret = min(ret , sum + high - low) ;
                return ;
            }
            else{
                visited[i] = true ;
                dfs(nums, i, 1, nums[i], nums[i], sum + high - low) ;
                visited[i] = false ;
            }
        }
        else{
            int last = -1 ;
            for(int i = cur+1; i < n; i++){
                if(visited[i])
                    continue ;
                if(nums[i] == nums[cur])
                    continue ;
                if(nums[i] == last)
                    continue ;
                visited[i] = true ;
                dfs(nums, i, count+1, low, nums[i], sum) ;
                last = nums[i] ;
                visited[i] = false ;
            }
        }
    }
public:
    int minimumIncompatibility(vector<int>& nums, int k) {
        this->n = nums.size() ;
        this->k = k ;
        visited.resize(n) ;
        sort(nums.begin(), nums.end() ) ;
        int cn = 1 ;
        
        for(int i = 1; i < n; i++){
            if(nums[i] == nums[i-1]){
                cn++ ;
                if(cn > k)
                    return -1 ;
            }
            else
                cn = 1 ;
        }
        if(cn > k)
            return -1 ;
        visited[0] = true ;
        dfs(nums, 0, 1, nums[0], nums[0], 0) ;
        return ret ;
    }
};