public class Solution {
    public int[][] ValidArrangement(int[][] pairs) {
        Dictionary<int, Stack<int>> adj = new Dictionary<int, Stack<int>>();
        Dictionary<int, int> id = new Dictionary<int, int>();
        Dictionary<int, int> od = new Dictionary<int, int>();
        for (int i = 0; i < pairs.Length; ++i) {
            if (!adj.ContainsKey(pairs[i][0])) {
                adj.Add(pairs[i][0], new Stack<int>());
                adj[pairs[i][0]].Push(pairs[i][1]);
            } else {
                adj[pairs[i][0]].Push(pairs[i][1]);
            }
            
            if (!id.ContainsKey(pairs[i][1])) {
                id.Add(pairs[i][1], 1);
            } else {
                id[pairs[i][1]]++;
            }
            
            if (!od.ContainsKey(pairs[i][0])) {
                od.Add(pairs[i][0], 1);
            } else {
                od[pairs[i][0]]++;
            }
        }
        
        int s = pairs[0][0];
        foreach (int[] pair in pairs) {
            if (id.GetValueOrDefault(pair[0], 0) - od.GetValueOrDefault(pair[0], 0) == -1) {
                s = pair[0];
                break;
            }
        }
        
        List<int[]> p = new List<int[]>();
        Traverse(adj, s, p);
        
        int[][] r = new int[pairs.Length][];
        for (int i = 0, j = pairs.Length - 1; j >= 0; i++, j--) {
            r[i] = new int[2] { p[j][1], p[j][0] };
        }
        
        return r;
    }
    
    public void Traverse(Dictionary<int, Stack<int>> adj, int n, List<int[]> p) {
        Stack<int> nn = adj.GetValueOrDefault<int, Stack<int>>(n, new Stack<int>());
        
        while (nn.Count > 0) {
            int nx = nn.Pop();
            Traverse(adj, nx, p);
            p.Add(new int[2] { nx, n });
        }
    }
}