class Solution {
private:
    int Father[100001] ;
    int FindFather(int x){
        if(x != Father[x])
            return FindFather(Father[x]) ;
        return x ;
    }
    
    void Union(int x, int y){
        x = FindFather(x) ;
        y = FindFather(y) ;
        if(x < y)
            Father[y] = x ;
        else
            Father[x] = y ;
    }
public:
    int minimumHammingDistance(vector<int>& source, vector<int>& target, vector<vector<int>>& allowedSwaps) {
        int n = source.size() ;
        int ret = 0 ;
        for(int i = 0; i <= 100000; i++)
            Father[i] = i ;
        
        for(auto& v : allowedSwaps)
            Union(v[0], v[1]) ;
        
        unordered_map<int, vector<int>>Map ;
        for(int i = 0; i < n; i++)
            Map[FindFather(i)].push_back(i) ;
            
        for(auto& m : Map)
        {
            multiset<int>Set ;
            for(auto x : m.second)
                Set.insert(source[x]) ;
            for(auto x : m.second)
            {
                auto it =  Set.find(target[x]) ;
                if(it != Set.end())
                    Set.erase(it ) ;
            }
            ret += Set.size() ;
        }    
        
        return ret ;
    }
};