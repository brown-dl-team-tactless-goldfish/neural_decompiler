int cmp(char *str1, char *str2)
{
    int str1_len = strlen(str1);
    int str2_len = strlen(str2);
    int i = 0;
    int j = 0;
    
    // find ' '
    while (i < str1_len)
    {
        if (str1[i] == ' ') {
            i = i + 1;
            break;
        }
        i++;
    }
    
    // find ' '
    while (j < str2_len)
    {
        if (str2[j] == ' ') {
            j = j + 1;
            break;
        }
        j++;
    }
    
    // swap digit and letter
    if (str1[i] <= 0x39 && str2[j] > 0x39) {
        //one of logs is digit-log
        return -1;
    }
    else if (str1[i] <= 0x39 && str2[j] <= 0x39) {
        // both logs are digit-log
        return 1;
    }
    else if (str1[i] > 0x39 && str2[j] <= 0x39) {
        return 1;
    }
    
    // handle letter
    while (i < str1_len && j < str2_len)
    {
       // printf("%c | %c \n", str1[j], str2[j]);
        if (str1[i] > str2[j])
        {
            return -1;
        } 
        else if (str1[i] == str2[j])
        {
            i++;
            j++;
        }
        else
        {
            return 1;
        }
    }
    
    if (i < str1_len)
        return -1;
    
    if (j < str2_len)
        return 1;
    
    // sort them lexicographically by their identifiers.
    i = 0;
    j = 0;
    while (str1[i] != ' ' && str2[j] != ' ')
    {
        if (str1[i] > str2[j])
        {
            return -1;
        } 
        else if (str1[i] == str2[j])
        {
            i++;
            j++;
        }
        else
        {
            return 1;
        }
    }
    return 0;
}

void merge(char **arr, int start, int mid, int end)
{
    int nL = mid - start + 1;
    int nR = end - mid;
    
    char **L = (char **)malloc(sizeof(char *) * nL);
    char **R = (char **)malloc(sizeof(char *) * nR);
    
    int i = 0;
    int j = 0;
    int k = start;
        
    for (i = 0; i< nL; i++) {
        L[i] = malloc(strlen(arr[start + i]) + 1);
        strcpy(L[i], arr[start + i]);
    }
    
    for (i = 0; i< nR; i++) {
        R[i] = malloc(strlen(arr[mid + i + 1]) + 1);
        strcpy(R[i], arr[mid + i + 1]);
    }
    i = 0;
    
    while (i < nL && j < nR)
    {
        // comparator
        int r = cmp(L[i], R[j]);
        if (r > 0)
        {
            arr[k++] = L[i++];
        }  
        else if (r == 0) 
        {
            i++;
            j++;
        }
        else 
        {
            arr[k++] = R[j++];
        } 
    }
    
    while (i < nL)
        arr[k++] = L[i++];
    
    while (j < nR)
        arr[k++] = R[j++];
    
    return;
}


void merge_sort(char **arr, int start, int end)
{
    if (start >= end)
        return;

    int mid = (start + end) / 2;
    
    merge_sort(arr, start, mid);
    merge_sort(arr, mid + 1, end);

    merge(arr, start, mid, end);
}


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char ** reorderLogFiles(char ** logs, int logsSize, int* returnSize){

    merge_sort(logs, 0, logsSize - 1);
    
    *returnSize = logsSize;
    return logs;
}