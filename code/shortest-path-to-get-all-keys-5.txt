    public class Solution
    {
        private static readonly (int di, int dj)[] _directions = { (0,1), (1,0), (0,-1), (-1,0)};

        public int ShortestPathAllKeys(string[] grid)
        {
            checked
            {
                int n = grid.Length;
                int m = grid[0].Length;

                IList<char> keys = new List<char>(6);
                int start = -1;

                for (int i = 0; i < n; i++)
                {
                    for (int j = 0; j < m; j++)
                    {
                        if (grid[i][j] >= 'a' && grid[i][j] <= 'z')
                        {
                            keys.Add(grid[i][j]);
                            continue;
                        }

                        if (grid[i][j] == '@')
                        {
                            start = i * m + j;
                        }
                    }
                }

                int maxKeysMask = (int) Math.Pow(2, keys.Count);
                bool[,] visited = new bool[n * m, maxKeysMask];
                Queue<(int pos, int mask)> bfs = new Queue<(int pos, int mask)>();
                bfs.Enqueue((start, 0));
                visited[start, 0] = true;
                int res = 0;

                while (bfs.Count != 0)
                {
                    int count = bfs.Count;

                    for (int c = 0; c < count; c++)
                    {
                        var curr = bfs.Dequeue();
                        if (curr.mask == maxKeysMask - 1)
                        {
                            return res;
                        }

                        int i = curr.pos / m;
                        int j = curr.pos % m;

                        foreach (var dir in _directions)
                        {
                            int newI = i + dir.di;
                            int newJ = j + dir.dj;
                            int newLinear = newI * m + newJ;

                            if (newI >= 0 && newJ >= 0 && newI < n && newJ < m && grid[newI][newJ] != '#')
                            {
                                int mask = curr.mask;

                                if (grid[newI][newJ] >= 'a' && grid[newI][newJ] <= 'z')
                                {
                                    var idx = keys.IndexOf(grid[newI][newJ]);
                                    mask |= (1 << idx);
                                }

                                if (visited[newLinear, mask])
                                {
                                    continue;
                                }

                                if (grid[newI][newJ] >= 'A' && grid[newI][newJ] <= 'Z')
                                {
                                    var idx = keys.IndexOf((char)(grid[newI][newJ] - ('A' - 'a')));
                                    if (idx < 0 || (mask & (1 << idx)) == 0)
                                    {
                                        continue;
                                    }
                                }

                                visited[newLinear, mask] = true;
                                bfs.Enqueue((newLinear, mask));
                            }
                        }
                    }

                    res++;
                }


                return -1;
            }
        }
    }