class StockPrice {
public:
    StockPrice() {
        latestTime = 0;
        currentValue = 0;
    }
    
    void update(int timestamp, int price) {
        // if we have newer or the same latest timestamp, update the current one
        if (timestamp >= latestTime) {
            latestTime = timestamp;
            currentValue = price;
        }
        // if we have new time key, insert it
        if (timeLine.find(timestamp) == timeLine.end()) {
            timeLine[timestamp] = price;
        } else {
            // otherwise remove the previous key and value and insert the new one
            int oldPrice = timeLine[timestamp];
            timeLine[timestamp] = price;
            frequency[oldPrice]--;
            if (frequency[oldPrice] == 0) {
                frequency.erase(oldPrice);
            }
        }
        frequency[price]++;
    }
    
    int current() {
        return currentValue;
    }
    
    int maximum() {
        return prev(frequency.end())->first;
    }
    
    int minimum() {
        return frequency.begin()->first;
    }
    
private:
    // latestTime record the most recent time stamp
    // currentValue record the most recent value
    int latestTime;
    int currentValue;
    unordered_map<int, int> timeLine;
    map<int, int> frequency;
};