class Solution {
public:
    string toBinary(int c){
        string ans="";
        while(c!=0){
            if(c%2==1)
                ans.push_back('1');
            else
                ans.push_back('0');
            c/=2;
        }
        reverse(ans.begin(),ans.end());
        return ans;
    }
    int longestSubsequence(string s, int k) {
        
        string ans=toBinary(k); 
        if(ans.size()>=s.size())//If the length of our given 'k' in binary is greater than the given binary string then longest subsequence is equal to the length of the given string
            return s.size();      
       
        int i=s.length()-ans.length();//to find a substring which iis smaller than our 'k' (in binary) we are using the slidng window technique and moving in a reverse order of our binary string 's'
        while(i>=0){
            string tmp=s.substr(i,ans.length());
            if(tmp<=ans)//given substring is smaller             
                break;            
            i--;
        }
        if(i==-1)///If no substring is found then longest subsequence is the length of binary representation of 'k'
            return ans.length()-1;
       int start=ans.length();
        //We are now moving from the beginning of the string 's' and as soon as we encounter a '0' we increment our 'start' to calculate the longest subsequence
       for(int  j=0;j<i;j++) 
           if(s[j]=='0')
               start++;
        cout<<ans;
        return (start);            
    }
};