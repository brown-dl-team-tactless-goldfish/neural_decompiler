class UnionFind {
    vector<int> parent, rank; 
public: 
    UnionFind(int n) {
        parent.resize(n); 
        iota(parent.begin(), parent.end(), 0); 
        rank = vector<int>(n, 1); 
    }
    
    int find(int p) {
        if (p != parent[p]) 
            parent[p] = find(parent[p]); 
        return parent[p]; 
    }
    
    bool connect(int p, int q) {
        int prt = find(p), qrt = find(q); 
        if (prt == qrt) return false; 
        if (rank[prt] > rank[qrt]) swap(prt, qrt); 
        parent[prt] = qrt; 
        rank[qrt] += rank[prt]; 
        return true; 
    }
};


class Solution {
public:
    bool gcdSort(vector<int>& nums) {
        int m = *max_element(nums.begin(), nums.end()); 
        UnionFind* uf = new UnionFind(1+m); 
        
        unordered_set<int> seen(nums.begin(), nums.end()); 
        
        vector<bool> sieve(1+m, true); 
        sieve[0] = sieve[1] = false; 
        for (int i = 2; i <= m/2; ++i) 
            if (sieve[i]) 
                for (int ii = i*2; ii <= m; ii += i) {
                    sieve[ii] = false; 
                    if (seen.count(ii)) uf->connect(i, ii); 
                }
        
        bool ans = true; 
        vector<int> copy(nums); 
        sort(copy.begin(), copy.end()); 
        for (int i = 0; i < nums.size(); ++i) 
            if (uf->find(nums[i]) != uf->find(copy[i])) {
                ans = false; 
                break; 
            }
        delete uf; 
        return ans; 
    }
};