class Solution {
public:
    
    
    long dfs( vector<vector<pair<int,int>>>&  graph,vector<int>& dist,int node,vector<long>& dp){
        
        if(node==graph.size()-1) return 1;
        
        if(dp[node]!=-1) return dp[node];
        
         long ans=0;
        
        for(auto [nei,len] : graph[node]){
            
            if(dist[nei]<dist[node]){
                ans=ans+dfs(graph,dist,nei,dp);
                ans=ans%1000000007;
            }
            
        }
        return dp[node]=ans;
          
    }
    
    
    int countRestrictedPaths(int n, vector<vector<int>>& edges) {

        
        vector<vector<pair<int,int>>>  graph(n);
        
        for(auto &v : edges){
            graph[v[0]-1].push_back({v[1]-1,v[2]});
            graph[v[1]-1].push_back({v[0]-1,v[2]});
        }
        
        
        
        vector<int> dist(n,INT_MAX);   
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;
        pq.push({0,n-1});
        dist[n-1]=0;  
        
        while(!pq.empty()){
            
            auto [d,node]=pq.top(); pq.pop();
            
            for(auto [nei,len]:graph[node]){
                  
                if( dist[nei]> d+len ){
                    dist[nei]= d+len;
                    pq.push({dist[nei],nei});
                 }
             }
         }
        
         vector<long>  dp(n,-1);
        
         return dfs(graph,dist,0,dp);
        
        return 0;
        
        
    }
};