class Solution {
    const int dirs[5] = {-1, 0, 1, 0, -1};          // allowed directions to move to 
public:
    vector<int> findPeakGrid(vector<vector<int>>& mat) {
        int m = mat.size(), n = mat[0].size();
        
        auto isValid = [&] (vector<int> &pos) -> bool {     // is pos(r,c) a valid position to look at
            int r = pos[0], c = pos[1];
            return r >= 0 && c >= 0 && r < m && c < n;
        };
        
        auto getNum = [&] (vector<int> &pos) -> int {       // get number at mat[r][c] 
            return mat[pos[0]][pos[1]];
        };
        
        vector<int> curPos({0, 0});
        
        while (true) {
            int max(getNum(curPos));
            vector<int> maxPos(curPos);
            for (int i = 1; i < 5; i++) {
                vector<int> nextPos({curPos[0] + dirs[i-1], curPos[1] + dirs[i]}); // get neighboring max candidate
                if (isValid(nextPos) && (getNum(nextPos) > getNum(maxPos))) {   // check if it is greater than current maxPos
                    maxPos = nextPos;
                    max = getNum(maxPos);
                }
            }
            if (curPos == maxPos)   // only true for a peak position
                return maxPos;
            curPos = maxPos;
        }
        return {-1, -1};
    }
};