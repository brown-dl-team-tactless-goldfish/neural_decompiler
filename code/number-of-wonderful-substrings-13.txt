using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _1915_number_of_wonderful_substrings
{
    class Program
    {
        static void Main(string[] args)
        {
            var result = WonderfulSubstrings("aabb");
        }        
        
        /// <summary>
        /// study code
        /// https://leetcode.com/problems/number-of-wonderful-substrings/discuss/1299523/C%2B%2B-Bit-Vector-%2B-Prefix-Parities-(Similar-to-Prefix-Sums)
        /// </summary>
        /// <param name="word"></param>
        /// <returns></returns>
        public static long WonderfulSubstrings(string word)
        {         
            // using an integer with 10 bits to represent a - j's count in odd or even count 
            // key - integer with 10 bits, value - how many prefix substrings have the key value
            var map = new Dictionary<int, int>();

            // caught by online judge, failed test case: "aba", should return 4, but 1
            map.Add(0, 1);

		    int running = 0;
            long result = 0;

            foreach(var w in word) 
            {
			    // Update the running parity
                running ^= 1 << (int)(w - 'a');                

                for (char c = 'a'; c <= 'j'; c++)
                {
                    var keyOneDiff = running ^ (1 << (c - 'a'));
                    if (map.ContainsKey(keyOneDiff))
                    {
                        // exclusive or ^
                        result += map[keyOneDiff];
                    }                    
                }
				
			    // Add counts of substrings with all characters with even counts.
			    // As seen in observation we need count of prefix parities with same parities as current running parity.
                if (!map.ContainsKey(running))
                {
                    map.Add(running, 0);
                }

                result += map[running];
			
			    // Update the counts for next future iterations.
                map[running]++;
            }

            return result;
        }
    }
}