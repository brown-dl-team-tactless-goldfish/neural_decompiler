/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* findDiagonalOrder(int** mat, int matSize, int* matColSize, int* returnSize)
{
    //0,0||0,1||0,2 
    //1,0||1,1||1,2
    //2,0||2,1||2,2
    //even values of r+c go up and right [-1,+1]
    //end of even diagonals increment c or r when c is out of bounds
    //odd values of r+c go down and left [+1,-1]
    //end of odd diagonals increment r or c when r is out of bounds
    int rSize = matSize;
    int cSize = matColSize[0];
    int r = 0;//row index
    int c = 0;//column index
    *returnSize = rSize * cSize;
    int *ret = malloc(sizeof(int) * rSize * cSize);
    //fill return array
    for(int i = 0; i < *returnSize; i++)
    {   //add value
        ret[i] = mat[r][c];
        //in the case of an even diagonal
        if((r+c) % 2 == 0)
        {   //check to see if we can increment diagonal
            if(r - 1 >= 0 && c + 1 < cSize)
            {
                r--;
                c++;
            }//if we can't go further along diagonal, go to next column if possible
            else if(c + 1 < cSize)
                c++;
            else//otherwise go to next row
                r++;
        }
        else//in the case of an odd diagonal
        {
            if(c - 1 >= 0 && r + 1 < rSize)
            {
                c--;
                r++;
            }//if we can't go further along diagonal, go to next row
            else if(r + 1 < rSize)
                r++;
            else//otherwise go to next column
                c++;
        }
    }
    return ret;
}