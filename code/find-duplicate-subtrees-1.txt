/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Return an array of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */
#define n 4000
int memory_size=5;

typedef struct element{
    int value;
    int done;
    int num_node;
    struct TreeNode* sr;
}element;

typedef struct HashTable{
    element pos[n];
    element neg[n];
}HashTable;

bool check(struct TreeNode* a,struct TreeNode* b,bool *ck){
    if(*ck){
        if(!a&&b||!b&&a){
        *ck=false;
        return false;
        }
        
        if(!a&&!b)
        return true;
    
        check(a->left,b->left,ck);
        check(a->right,b->right,ck);
    
        if(a->val!=b->val)
           *ck=false;
            
    }
    else{
        return false;
    }
    
    if(*ck)
    return true;
    
    return false;
}

void insertHashTable(HashTable *h,int key,int value,struct TreeNode* root,struct TreeNode **ans,int* ans_size,int node){
    int d=2;
    bool ck=true;
    if(key<0){
        key=~(key-1);
        
        if(h->neg[key].value==INT_MAX){
            h->neg[key].value=value;
            h->neg[key].sr=root;
            h->neg[key].num_node=node;
            return;
        }
        if(h->neg[key].value==value&&h->neg[key].num_node==node&&check(root,h->neg[key].sr,&ck)){
            if(h->neg[key].done)
                return;
            h->neg[key].done=1;
            ans[(*ans_size)++]=root;
            return;
        }
        
        int st=key;
        
        key++;
        
        while(st!=key){
            ck=true;
            
            if(h->neg[key].value==INT_MAX){
                h->neg[key].value=value;
                h->neg[key].num_node=node;
                h->neg[key].sr=root;
                return;
            }
            if(h->neg[key].value==value&&h->neg[key].num_node==node&&check(root,h->neg[key].sr,&ck)){
                if(h->neg[key].done)
                    return;
                h->neg[key].done=1;
                ans[(*ans_size)++]=root;
                return;
            }
            
            key=(key+d*d)%n;
            d++;
        }
        
    }
    else{
        if(h->pos[key].value==INT_MAX){
            h->pos[key].value=value;
            h->pos[key].sr=root;
            h->pos[key].num_node=node;
            return;
        }
        if(h->pos[key].value==value&&h->pos[key].num_node==node&&check(root,h->pos[key].sr,&ck)){
            if(h->pos[key].done)
                return;
            h->pos[key].done=1;
            ans[(*ans_size)++]=root;
            return;
        }
        
        int st=key;
        
        key++;
        
        while(st!=key){
             ck=true;
            
            if(h->pos[key].value==INT_MAX){
                h->pos[key].value=value;
                h->pos[key].sr=root;
                h->pos[key].num_node=node;
                return;
            }
            if(h->pos[key].value==value&&h->pos[key].num_node==node&&check(root,h->pos[key].sr,&ck)){
                if(h->pos[key].done)
                    return;
                h->pos[key].done=1;
                ans[(*ans_size)++]=root;
                return;
            }
            
            key=(key+d*d)%n;
            d++;
        }
    }
}

int Traverse(struct TreeNode* root,HashTable *h,struct TreeNode ***ans,int* ans_size){
    if(!root)
        return 0;
    
    int l=Traverse(root->left,h,ans,ans_size);
    int r=Traverse(root->right,h,ans,ans_size);
    
    
    insertHashTable(h,root->val%n,root->val,root,(*ans),ans_size,l+r+1);
    if((*ans_size)>=memory_size){
        (*ans)=(struct TreeNode**)realloc((*ans),sizeof(struct TreeNode*)*(memory_size*2));
        memory_size*=2;
    }
    
    return l+r+1;
    
}

struct TreeNode** findDuplicateSubtrees(struct TreeNode* root, int* returnSize) {
    struct TreeNode** ans=(struct TreeNode**)malloc(sizeof(struct TreeNode*)*memory_size);
    int i,ans_size=0;
    HashTable *h=(HashTable*)malloc(sizeof(HashTable));
    
    for(i=0;i<n;i++){
        h->pos[i].value=INT_MAX;
        h->pos[i].num_node=0;
        h->neg[i].value=INT_MAX;
        h->neg[i].num_node=0;
        h->pos[i].done=0;
        h->neg[i].done=0;
    }
    
    Traverse(root,h,&ans,&ans_size);
    (*returnSize)=ans_size;
    return ans;
}