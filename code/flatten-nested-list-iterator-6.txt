// time: O(n) for constructor, O(1) for next() and hasNext()
// space: O(n)

struct NestedIterator {
  int cur, listLen;
  int* list;
};

void FlattenList(struct NestedInteger** nestedList, int nestedListSize, struct NestedIterator *result) {
  for (int i = 0; i < nestedListSize; i++) {
    if (NestedIntegerIsInteger(nestedList[i]))
      result->list[result->listLen++] = NestedIntegerGetInteger(nestedList[i]);
    else
      FlattenList(NestedIntegerGetList(nestedList[i]), NestedIntegerGetListSize(nestedList[i]), result);
  }
}

struct NestedIterator *nestedIterCreate(struct NestedInteger** nestedList, int nestedListSize) {
  struct NestedIterator *result = (struct NestedIterator *) malloc(sizeof(struct NestedIterator));
  result->cur = 0;
  result->listLen = 0;
  result->list = (int*) malloc(sizeof(int) * 20000);
  
  FlattenList(nestedList, nestedListSize, result);
  return result;
}

bool nestedIterHasNext(struct NestedIterator *iter) {
  return iter->cur < iter->listLen;
}

int nestedIterNext(struct NestedIterator *iter) {
  return iter->list[iter->cur++];
}

/** Deallocates memory previously allocated for the iterator */
void nestedIterFree(struct NestedIterator *iter) {
  free(iter->list);
  free(iter);
}