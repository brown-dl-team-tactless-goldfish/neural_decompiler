
class Solution {
    
    const int dirs[5] = {-1, 0, 1, 0, -1};
    
public:
    
    bool canMouseWin(vector<string>& grid, int cj, int mj) {
        
        int m = grid.size(), n = grid[0].size();
// [cx, cy, mx, my, turn, 
//   {
//       # of cat-win neighbors,
//	     # of mouse-win neighbors,
//       final state{0(unclear), 1(mouce win), 2(cat win)}
//    }
//  ]
        int states[9][9][9][9][2][3]{}; 
        int rs[2][9][9]{}; // number of reachable cells from current location for cat and mouse within catjump and mousejump
        
        vector<int> x(2), y(2), z(2);
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(grid[i][j] == '#') continue;
                if(grid[i][j] == 'C') x = {i, j};
                if(grid[i][j] == 'M') y = {i, j};
                if(grid[i][j] == 'F') z = {i, j};
                rs[0][i][j] = rs[1][i][j] = 1;
                for(int k = 0; k < 4; k++) {
                    for(int len = 1; len <= max(cj, mj); len++) {
                        int xx = i + len * dirs[k];
                        int yy = j + len * dirs[k + 1];
                        if(xx < 0 || xx >= m || yy < 0 || yy >= n || grid[xx][yy] == '#') break;
                        if(len <= cj) rs[0][i][j]++;
                        if(len <= mj) rs[1][i][j]++;
                    }
                }
            }
        }

		// bfs: a state will be added to the queue under 2 conditions:
		// 1. it has a neighbor which can help to achieve its goal
		// 2. all neighbors achieve opposite goal
        queue<vector<int>> knowns;
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(grid[i][j] != '#') {
                    if(i != z[0] || j != z[1]) {
                        knowns.push({i, j, z[0], z[1], 0});
                        knowns.push({i, j, z[0], z[1], 1});
                        knowns.push({z[0], z[1], i, j, 0});
                        knowns.push({z[0], z[1], i, j, 1});
                        knowns.push({i, j, i, j, 0});
                        knowns.push({i, j, i, j, 1});

                        states[i][j][z[0]][z[1]][0][2] = 1;
                        states[i][j][z[0]][z[1]][1][2] = 1;
                        states[z[0]][z[1]][i][j][0][2] = 2;
                        states[z[0]][z[1]][i][j][1][2] = 2;
                        states[i][j][i][j][0][2] = 2;
                        states[i][j][i][j][1][2] = 2;
                    }
                }
            }
        }
        
        int finals;
        while(!knowns.empty()) {
            auto h = knowns.front();
            knowns.pop();
			// update neighbor states and if possible, add new elements into the BFS queue
            if(h[4]) {
                for(int i = 0; i < 4; i++) {
                    for(int len = 0; len <= cj; len++) {
                        if(!len && i) continue;
                        int xx = h[0] + dirs[i] * len;
                        int yy = h[1] + dirs[i + 1] * len;
                        if(xx < 0 || xx >= m || yy < 0 || yy >= n || grid[xx][yy] == '#') break;
                        
                        finals = states[xx][yy][h[2]][h[3]][1 - h[4]][2];
                        if(finals) continue;
                        finals = states[h[0]][h[1]][h[2]][h[3]][h[4]][2];
                        
                        if(finals == 2 || ++states[xx][yy][h[2]][h[3]][1 - h[4]][2 - finals] == rs[0][xx][yy]) {
                            states[xx][yy][h[2]][h[3]][1 - h[4]][2] = finals;
                            knowns.push({xx, yy, h[2], h[3], 1 - h[4]});
                        }
                    }
                }
            }else{
                for(int i = 0; i < 4; i++) {
                    for(int len = 1; len <= mj; len++) {
                        if(!len && i) continue;
                        int xx = h[2] + dirs[i] * len;
                        int yy = h[3] + dirs[i + 1] * len;
                        if(xx < 0 || xx >= m || yy < 0 || yy >= n || grid[xx][yy] == '#') break;
                        
                        finals = states[h[0]][h[1]][xx][yy][1 - h[4]][2];
                        if(finals) continue;
                        finals = states[h[0]][h[1]][h[2]][h[3]][h[4]][2];
                        
                        if(finals == 1 || ++states[h[0]][h[1]][xx][yy][1 - h[4]][2 - finals] == rs[1][xx][yy]) {
                            states[h[0]][h[1]][xx][yy][1 - h[4]][2] = finals;
                            knowns.push({h[0], h[1], xx, yy, 1 - h[4]});
                        }
                    }
                }
            }
        }
        
        finals = states[x[0]][x[1]][y[0]][y[1]][1][2];
        return finals == 1;
    }
};