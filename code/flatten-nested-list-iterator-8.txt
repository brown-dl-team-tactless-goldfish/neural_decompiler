struct NestedIteratorNode {
  struct NestedInteger** start;
  struct NestedInteger** end;
};

struct NestedIterator {
  struct NestedIteratorNode* stack;
  struct NestedIteratorNode* top;
  size_t cap;
};

struct NestedIterator *nestedIterCreate(struct NestedInteger** nestedList, int nestedListSize) {
  struct NestedIterator* ret = (struct NestedIterator*) malloc(sizeof(struct NestedIterator));
  if (nestedListSize) {
    ret->stack = (struct NestedIteratorNode*) malloc(sizeof(struct NestedIteratorNode));
    ret->top = ret->stack;
    ret->top->start = nestedList;
    ret->top->end = nestedList + nestedListSize;
    ret->cap = 1;
  } else {
    ret->stack = NULL;
    ret->top = NULL;
    ret->cap = 0;
  }
  return ret;
}

/* HasNext involves reading to the next integer value if there is one and waiting for IterNext to be called */
bool nestedIterHasNext(struct NestedIterator *iter) {
  while (iter->top) {
    /* Keep going deeper into nested lists until an integer is found */
    while (iter->top->start < iter->top->end && !NestedIntegerIsInteger(*iter->top->start)) {
      size_t stack_size = (iter->top - iter->stack) + 1;
      if (stack_size == iter->cap) {
        iter->cap = (iter->cap) ? iter->cap * 2 : 1;
        iter->stack = (struct NestedIteratorNode*) realloc(iter->stack, sizeof(struct NestedIteratorNode) * iter->cap);
      }
      struct NestedIteratorNode* prev_node = &iter->stack[stack_size - 1];
      iter->top = &iter->stack[stack_size];
      iter->top->start = NestedIntegerGetList(*prev_node->start);
      iter->top->end = iter->top->start + NestedIntegerGetListSize(*prev_node->start++);
    }
    if (iter->top->start < iter->top->end) /* Found a next integer */ {
      return true;
    } else if (--iter->top < iter->stack) /* Completely finished iterating */ {
      iter->top = NULL;
    }
  }
  return false;
}

int nestedIterNext(struct NestedIterator *iter) {
  return NestedIntegerGetInteger(*iter->top->start++);
}

void nestedIterFree(struct NestedIterator *iter) {
  free(iter->stack);
  free(iter);
}