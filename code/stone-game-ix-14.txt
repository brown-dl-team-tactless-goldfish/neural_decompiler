class Solution {
public:
    bool stoneGameIX(vector<int>& stones) {
        // Alice will take the only stone. Bob wins. 
        if (stones.size() == 1) {
            return false;
        }
        
        // Collect a histogram of stone values modulo 3.
        std::array<int, 3> histo;
        histo.fill(0);
        for (int val : stones) {
            ++histo[val % 3];
        }
        
        // Anything Alice picks is divisible by 3. Bob wins.
        if ((histo[1] == 0) && (histo[2] == 0)) {
            return false;
        }
        
        // Picking a value divisible by 3 will shift the state 
        // (i.e. current remainder) to the opponent. As a result,
        // an even number of those would not have any effect. 
        if (histo[0] % 2 == 0) {
            // Alice will pick a value with a smaller number of occurrences. 
            // Without loss of generality, assume it is 2. 
            // Eventually the players will move the game into a state where
            // there are one or more of 1s and the state is 2, with Bob playing next move.
            // In this case, he would have to choose 1 and lose the game. 
            return (histo[1] > 0) && (histo[2] > 0);
            
            // Notice that the situation above only works when we have stones with both values.
            // Otherwise, the game will end up in the situation where 
            // the current state is 2 and there are one or more 2s, with Bob playing next move.
            // If there is only one stone left, Bob wins by removing it.
            // If there are more stones, Bob removes the 2 and the game state becomes 1.
            // Alice loses by removing the next stone. 
        }
        
        // When the number of stones with value divisible by 3 is odd, 
        // the game state will shift back to Alice. 
        // Assume one kind of stone has more than two counts than the other, 
        // without loss of generality, say it is 1. The game will eventually 
        // be in a state of 1 and there are at least two stones left with 
        // the same modulo 3 value (i.e. 1), with Alice playing next. 
        // Alice removes 1, transitioning the state into 2, and hand it over to Bob.
        // There are still at least one stone with value 1, and Bob loses by removing it. 
        return std::abs(histo[1] - histo[2]) > 2;
    }
};