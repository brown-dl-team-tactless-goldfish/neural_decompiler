typedef struct {
    int n;
} ZeroEvenOdd;

pthread_mutex_t m0,m1,m2;
int counter=0;
ZeroEvenOdd* zeroEvenOddCreate(int n) {
    ZeroEvenOdd* obj = (ZeroEvenOdd*) malloc(sizeof(ZeroEvenOdd));
    obj->n = n;
    pthread_mutex_init(&m0,NULL);
    pthread_mutex_init(&m1,NULL);
    pthread_mutex_init(&m2,NULL);
    pthread_mutex_lock(&m1);
    pthread_mutex_lock(&m2);
    return obj;
}
void lk_release(int index, ZeroEvenOdd* obj){
    if(counter<=obj->n) {
        if(index==0) {
            pthread_mutex_lock(&m0);          
            if(counter%2) {
                pthread_mutex_unlock(&m2);
            } else {
                pthread_mutex_unlock(&m1);
            }
        } else if (index == 1) {
            pthread_mutex_lock(&m1);
            pthread_mutex_unlock(&m0);
        } else {
            pthread_mutex_lock(&m2);
            pthread_mutex_unlock(&m0);
        }
    } 
}
// You may call global function `void printNumber(int x)`
// to output "x", where x is an integer.

void zero(ZeroEvenOdd* obj) {
   while(counter<obj->n) {
       pthread_mutex_lock(&m0);
       if(counter<obj->n){
           printNumber(0);
       }
       pthread_mutex_unlock(&m0);
       lk_release(0,obj);
   }
}

void even(ZeroEvenOdd* obj) {
   while(counter<obj->n) {
       pthread_mutex_lock(&m2);
       if(counter<obj->n){
           counter++;
           printNumber(counter);
       }
       pthread_mutex_unlock(&m2);
       lk_release(2,obj);
   }
}

void odd(ZeroEvenOdd* obj) {
    while(counter<obj->n) {
       pthread_mutex_lock(&m1);
       if(counter<obj->n){
           counter++;
           printNumber(counter);
       }
       pthread_mutex_unlock(&m1);
       lk_release(1,obj);
   }
}

void zeroEvenOddFree(ZeroEvenOdd* obj) {
    counter=0;
}