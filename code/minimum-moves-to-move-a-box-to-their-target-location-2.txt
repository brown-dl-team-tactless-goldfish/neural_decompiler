class Solution {
public:
    int minPushBox(vector<vector<char>>& grid) {
	    // remember three coords, and retore them to not '#' it is road not wall
        int row = grid.size(), col = grid.front().size();
        pair<int, int> t, b, s;
        for (int r = 0; r < row; ++r) {
            for (int c = 0; c < col; ++c) {
                if (grid[r][c] == 'T') {
                    t = make_pair(r, c);
                    grid[r][c] = '.';
                }
                if (grid[r][c] == 'B') {
                    b = make_pair(r, c);
                    grid[r][c] = '.';
                }
                if (grid[r][c] == 'S')  {
                    s = make_pair(r, c);
                    grid[r][c] = '.';
                }
            }
        }
        priority_queue<pair<int, int>, vector<pair<int,int>>, greater<pair<int,int>>> q;
        unordered_set<int> vi;
		// step is pushes, and key contains two coords
        q.emplace(0, b.first * 1000000 + b.second * 10000 + s.first * 100 + s.second);
        vi.emplace(b.first * 1000000 + b.second * 10000 + s.first * 100 + s.second);

		// just helper function to get cell
        auto g = [&](int r, int c) {
            if (r < 0 || r >= row || c < 0 || c >= col) return '#';
            return grid[r][c];
        };

		// if keeper possible moves
        auto check = [&](int step, int br, int bc, int r, int c) {
            if (g(r, c) != '.') return;
            if (br == r && bc == c) return;
            int key = br * 1000000 + bc * 10000 + r * 100 + c;
            if (vi.count(key)) return;
            vi.emplace(key);
            q.emplace(step, key);
        };

		// if push is possible, we need +1 on steps if possible
        auto push = [&](int step, int br, int bc, int r, int c) {
            int key = -1;
            if (make_pair(r + 1, c) == make_pair(br, bc) && g(r + 2, c) == '.') {
                key = (br + 1) * 1000000 + bc * 10000 + (r + 1)  * 100 + c;
            } else if (make_pair(r - 1, c) == make_pair(br, bc) && g(r - 2, c) == '.') {
                key = (br - 1) * 1000000 + bc * 10000 + (r - 1) * 100 + c;
            } else if (make_pair(r, c + 1) == make_pair(br, bc) && g(r, c + 2) == '.') {
                key = br * 1000000 + (bc + 1) * 10000 + r * 100 + c + 1;
            } else if (make_pair(r, c - 1) == make_pair(br, bc) && g(r, c - 2) == '.') {
                key = br * 1000000 + (bc - 1) * 10000 + r * 100 + c - 1;
            }
            if (key == -1) return;
            if (vi.count(key)) return;
            vi.emplace(key);
            q.emplace(step + 1, key);
        };
		// here is just simple bfs
        while (q.size()) {
            int step = q.top().first;
            int cbr = q.top().second / 1000000 % 100;
            int cbc = q.top().second / 10000 % 100;
            int csr = q.top().second / 100 % 100;
            int csc = q.top().second / 1 % 100;
            q.pop();
            if (cbr == t.first && cbc == t.second) return step;
            check(step, cbr, cbc, csr + 1, csc);
            check(step, cbr, cbc, csr, csc + 1);
            check(step, cbr, cbc, csr - 1, csc);
            check(step, cbr, cbc, csr, csc - 1);
            push(step, cbr, cbc, csr, csc);
        }
        return -1;
    }
};