class Solution {
public:

    int dp[13][13];
    
    
    // LCS used to get the length of the LPS
    int LCS(int i, int j, string &s, string &t, int &l)
    {
        if(i==l || j==l)return 0;
        
        if(dp[i][j]!=-1)return dp[i][j];
        
        if(s[i]==t[j])
        {
            dp[i][j] = 1 + LCS(i+1,j+1,s,t,l);
        }
        else
        {
            dp[i][j] = max(LCS(i,j+1,s,t,l),LCS(i+1,j,s,t,l));            
        }
        
        return dp[i][j];
    }
    
    int maxProduct(string s) {
        
        vector<int>rdp(4096,-1);
        
        int sl = s.length();
        int maxp = INT_MIN;
        int p = 1<<sl;
        int tmask = p-1;
        int mask;
        
        // loop for all possible mask from 1 to 2^sl
        for(int k=1;k<p;k++)
        {
            mask = k;
            
            // get mask string and anti mask string 
            string ns = "";
            string nt = "";
            for(int i=0;i<sl;i++)
            {
                if(((mask>>i)&1)==0)ns+=s[i];
                else nt += s[i];
            }
            
            int spl,tpl;
            int ls = ns.length();
            bool lpalindrom = true;
            
            // check if mask string is palindrom
            for(int i=0;i<ls/2;i++)
            {
                if(ns[i]!=ns[ls-1-i])
                {
                    lpalindrom = false;
                    break;
                }
            }
                        
            // get mask string PLS length
            spl = lpalindrom ? ls : 0;
            
            // check anti mask string only if spl > 0
            if(spl>0)
            {
                // if not LPS already not calculated then get the LPS of anti mask string 
                if(rdp[tmask^mask]==-1)
                {
                    int lt = nt.length();
                    string rnt = nt;
                    reverse(rnt.begin(),rnt.end());

                    memset(dp,-1,sizeof(dp));

                    tpl = LCS(0,0,nt,rnt,lt);    
                    rdp[tmask^mask] = tpl;
                }
                else tpl = rdp[tmask^mask];

                // get max product of mask string and anti mask string LPS
                maxp = max(maxp,spl * tpl);                
            }
        }
        
        return maxp;
    }
};