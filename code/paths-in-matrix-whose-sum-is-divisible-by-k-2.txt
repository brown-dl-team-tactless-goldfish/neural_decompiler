class Solution {
public:
    int numberOfPaths(vector<vector<int>>& grid, int k) {
        int r = grid.size();
        int c = grid[0].size();
        // create array to store all k modules at each i,j
        vector<vector<vector<int>>> dp(r,vector<vector<int>>(c,vector<int>(k,0)));
        
        queue<pair<int,int>> q;
        q.push({0,0});
        int s = grid[0][0]%k;
        dp[0][0][s] = 1;
        vector<vector<int>> visited(r,vector<int>(c,0));
        vector<vector<int>> dir = {{0,1},{1,0}};
        int mod = 1e9 + 7;
        
        while (!q.empty()){
            int sz = q.size();
            for (int i = 0; i < sz; i++) {
                auto [x,y] = q.front();
                q.pop();
                
                // check for right and down
                for (int d = 0; d < dir.size(); d++) {
                    int nx = x+ dir[d][0]; int ny = y + dir[d][1];
                    // if next index goes beyond last row or last column
                    if ( nx == r ||  ny == c)
                        continue;
                    // take modulo of current number
                    int m = grid[nx][ny] % k;
                    // add it to all possible modulo's,
                    // move frequencey of old modulo to new modulo
                    for (int j = 0; j < k; j++) {
                        // getting new modulo after adding current number
                        int nm = (m + j)%k;
                        // move frequency from old modulo to new modulo
                        dp[nx][ny][nm] = (dp[nx][ny][nm] + dp[x][y][j])%mod;
                    }
                    // use visited matrix to make sure particular point in the grid
                    // is added only once in the queue.
                    if (!visited[nx][ny]) {
                        q.push({nx,ny});
                        visited[nx][ny] = 1;
                    }
                }  
            }
        }
        return (dp[r-1][c-1][0]%mod);
    }
};