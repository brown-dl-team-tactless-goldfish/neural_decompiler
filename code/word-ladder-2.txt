class Solution {
public:
    static unordered_map<string, vector<string>> buildCombos(string beginWord, vector<string>& wordList)
    {
        unordered_map<string, vector<string>> comboDict;
        for (const string& word : wordList)
            for (const string& combo : getCombos(word))
                comboDict[combo].emplace_back(word);
        
        for (const string& combo : getCombos(beginWord))
            comboDict[combo].emplace_back(beginWord);
        
        return comboDict;
    }
    
    static vector<string> getCombos(string word)
    {
        vector<string> combos(word.size(), word);
        int pos = 0;
        for (string& combo : combos)
            combo[pos++] = '*';
        return combos;
    }
    static int shortestPathLength(queue<pair<string, int>>& bfs, unordered_map<string, vector<string>>& combos, string endWord)
    {
        unordered_set<string> visited;
        while (not bfs.empty())
        {
            auto [word, level] = bfs.front(); bfs.pop();
            if (visited.count(word)) continue;
            if (word == endWord) return level;
            
            visited.emplace(word);
            for (string combo : getCombos(word))
                for (string neighbor : combos[combo])
                    bfs.emplace(make_pair(neighbor, level + 1));
        }
        return 0;
    }
    
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        unordered_map<string, vector<string>> combos = buildCombos(beginWord, wordList);
        std::queue<pair<string, int>> bfs;
        bfs.emplace(make_pair(beginWord, 1));
        return shortestPathLength(bfs, combos, endWord);
    }
};