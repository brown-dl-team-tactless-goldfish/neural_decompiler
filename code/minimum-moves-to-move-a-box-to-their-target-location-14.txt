class Solution {
public:
    int find(vector<int>& a, int i) {
        if(a[i] == i) {
            return i;
        }
        return a[i] = find(a, a[i]);
    }
    
    void merge(vector<int>& a, vector<int>& r, int i, int j) {
        int i_ = find(a,i);
        int j_ = find(a,j);
        if(i_ == j_) {
            return; 
        }
        if(r[i_] > r[j_]) {
            a[j_] = i_;
        } else {
            a[i_] = j_; 
            if(r[i_] == r[j_]) {
                r[j_]++;
            }
        }
    }
    
    bool same(vector<int>& a, int i, int j) {
        return find(a,i) == find(a,j);
    }
    
    typedef pair<int,pair<int,int>> pipii;
    const int INF = INT_MAX / 2; 
    int minPushBox(vector<vector<char>>& grid) {
        const int m = grid.size();
        const int n = grid[0].size();
        vector<vector<int>> dp(m*n,vector<int>(m*n, INF));
        int p = -1; 
        int b = -1; 
        int target = -1; 
        for(int i = 0;i<m;i++) {
            for(int j = 0;j<n;j++) {
                if(grid[i][j] == 'S') {
                    p = i * n + j; 
                    grid[i][j] = '.';
                } else if(grid[i][j] == 'B') {
                    b = i * n + j;
                    grid[i][j] = '.';
                } else if(grid[i][j] == 'T') {
                    target = i * n + j; 
                    grid[i][j] = '.';
                }
            }
        }
        priority_queue<pipii,vector<pipii>,greater<pipii>> q; 
        q.push({0,{p,b}});
        while(q.size()) {
            auto value = q.top();
            q.pop();
            int w = value.first; 
            p = value.second.first; 
            b = value.second.second; 
            if(b == target) {
                return w; 
            }
            if(dp[b][p] <= w) {
                continue; 
            }
            dp[b][p] = w;
            int x = b/n; 
            int y = b%n; 
            grid[x][y] = '#';
            vector<int> a(m*n);
            vector<int> rank(m*n);
            for(int i = 0;i<a.size();i++) {
                a[i] = i; 
            }
            for(int i = 0;i<m;i++) {
                for(int j = 0;j<n;j++) {
                    if(grid[i][j] != '.') {
                        continue; 
                    } 
                    int t = i * n + j; 
                    if(i+1<m && grid[i+1][j] == '.') {
                        merge(a,rank,t,t+n);
                    }
                    if(j+1<n && grid[i][j+1] == '.') {
                        merge(a,rank,t,t+1);
                    }
                }
            }
            int p_x = p / n; 
            int p_y = p % n; 
            if(x+1<m && x - 1>=0 && same(a,b-n,p) && grid[x+1][y] == '.') {
                q.push({w+1,{b,b+n}});
            }
            if(x-1>=0 && x + 1 < m && same(a,p,b+n) && grid[x-1][y] == '.') {
                q.push({w+1,{b,b-n}});
            }
            if(y+1<n && y-1>=0 && same(a,p,b-1) && grid[x][y+1] == '.') {
                q.push({w+1,{b,b+1}});
            }
            if(y-1>=0 && y + 1 < n && same(a,p,b+1) && grid[x][y-1] == '.') {
                q.push({w+1,{b,b-1}});
            }
            grid[x][y] = '.';
        }
        return -1; 
    }
};