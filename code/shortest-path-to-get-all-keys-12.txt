class Solution {
public:
    struct Move{
        int r;
        int c;
        int keys;
        int moves;
        Move(int r, int c, int k,int m):r(r),c(c),keys(k),moves(m){}
        Move(const Move &other):
            r(other.r),c(other.c),keys(other.keys),moves(other.moves){}
        
        string toString(){
            return to_string(r) + "," + to_string(c) + "," + to_string(keys);
        }
    };
    
    unordered_set<string> visited;
    int shortestPathAllKeys(vector<string>& grid) {
        deque<Move> q;
        bool found = false;
        int numOfLocks = 0;
        for(int i = 0; i < grid.size() && !found; ++i){
            for(int j = 0; j < grid[0].size() && !found; ++j){
                if(grid[i][j] == '@'){
                    q.emplace_back(i,j,0,0);
                    visited.insert(q.back().toString());
                }else if(grid[i][j] >= 'a' && grid[i][j] <= 'f'){
                    numOfLocks++;
                }
            }
        }
                
        static int rs[4] = {-1,0,1,0};
        static int cs[4] = {0,-1,0,1};
        
        while(!q.empty()){
            auto currMove = q.front();
            q.pop_front();
            
            if(currMove.keys == ((1<<(numOfLocks)) - 1)){
                return currMove.moves;
            }
            
            int keys = currMove.keys;
            int moves = currMove.moves;
                        
            for(int i = 0; i < 4; ++i){
                int nr = rs[i] + currMove.r;
                int nc = cs[i] + currMove.c;
                
                if(nr >= 0 && nc >= 0 && nr < grid.size() && nc < grid[0].size()){
                    if(grid[nr][nc] == '.' || grid[nr][nc] == '@'){
                        Move newMove(nr,nc,keys,moves + 1);
                        auto str = newMove.toString();
                        if(visited.find(str) == visited.end()){
                            q.emplace_back(newMove);
                            visited.insert(str);
                        }                        
                    }else if(grid[nr][nc] >= 'a' && grid[nr][nc] <= 'f'){
                        Move newMove(nr,nc, (keys | (1 << (grid[nr][nc] - 'a'))),moves + 1);
                        auto str = newMove.toString();
                        if(visited.find(str) == visited.end()){
                            q.emplace_back(newMove);
                            visited.insert(str);
                        }
                    }else if(grid[nr][nc] >= 'A' && grid[nr][nc] <= 'F'){
                       Move newMove(nr,nc, keys,moves + 1);
                       auto str = newMove.toString();
                       if(visited.find(str) == visited.end() && ((keys >> (grid[nr][nc] - 'A')) & 1)){
                           q.emplace_back(newMove);
                           visited.insert(str);
                       }
                    }   
                }
            }        
        }
        
        return -1;
    }
};

