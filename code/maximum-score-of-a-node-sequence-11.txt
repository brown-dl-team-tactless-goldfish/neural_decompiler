class Solution {
public:
    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {
        int n = scores.size();
        // keep track of map: node id -> the largest 3 edges
        vector<vector<array<int, 2>>> another(n);
        for (auto& e : edges) {
            int u = e[0], v = e[1];
            another[u].push_back({scores[v], v});
            another[v].push_back({scores[u], u});
        }
        for (int i = 0; i < n; i++) {
            if (another[i].size() <= 3) continue;
            nth_element(another[i].begin(), another[i].begin() + 3, another[i].end(), [](const array<int, 2>& a, const array<int, 2>& b) {
                return a[0] > b[0];
            });
			another[i].resize(3);
        }
        // consider each edge
        int ans = -1e9;
        for (auto& e : edges) {
            int u = e[0], v = e[1];
            int cur_ans = -1e9;
            for (int i = 0; i < another[u].size(); i++) {
                int uu = another[u][i][1];
                if (uu == v) continue;
                for (int j = 0; j < another[v].size(); j++) {
                    int vv = another[v][j][1];
                    if (vv == u || vv == uu) continue;
                    cur_ans = max(cur_ans, scores[u] + scores[v] + scores[uu] + scores[vv]);
                }
            }
            ans = max(ans, cur_ans);
        }
        return max(ans, -1);
    }
};