class Solution {
public:
    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {
        map<int, pair<char, int>> cache;   // map from "start position" to "<char, length>"
        map<int, int> len_cnt;   // map from length to count
        int slow = 0, fast;
        int n = s.size(), k = queryCharacters.size();
        while(slow < n) {
            fast = slow + 1;
            while(fast < n && s[fast] == s[slow]) fast++;
            cache[slow] = pair<char, int>{s[slow], fast - slow};
            len_cnt[fast - slow] += 1;
            slow = fast;
        }
        vector<int> ans(k);
        for(int i = 0; i < k; i++) {
            int j = queryIndices[i];
            char c = queryCharacters[i];
            auto cit = --cache.upper_bound(j);
            if(cit->second.first == c) {
                if(i > 0) ans[i] = ans[i-1];
                else {
                    auto it = --len_cnt.end();
                    ans[i] = it->first;
                }
            }
            else {
                int x = cit->first;
                int len = cit->second.second;
                len_cnt[len] -= 1;
                if(len_cnt[len] == 0) len_cnt.erase(len);
				
				/*
				case 1: the substring to be updated has only one character,
				in this case, it can merge with substrings on both sides.
				*/
                if(len == 1) {   
                    vector<int> to_del;
                    to_del.push_back(x);
                    int start = x;
                    if(cit != cache.begin()) {
                        auto pit = --cit;
                        cit++;
                        if(pit->second.first == c) {   // merge to left
                            start = pit->first;
                            to_del.push_back(start);
                            int ll = pit->second.second;
                            len += ll;
                            len_cnt[ll] -= 1;
                            if(len_cnt[ll] == 0) len_cnt.erase(ll);
                        }
                    }
                    auto nit = ++cit;
                    cit--;
                    if(nit != cache.end() && nit->second.first == c) {    // merge to right
                        to_del.push_back(nit->first);
                        int lr = nit->second.second;
                        len += lr;
                        len_cnt[lr] -= 1;
                        if(len_cnt[lr] == 0) len_cnt.erase(lr);
                    }
                    len_cnt[len] += 1;
                    for(auto& elem : to_del) cache.erase(elem);
                    cache[start] = pair<char, int>{c, len};
                }
				/*
				case 2: substring to be updated has multiple characters, and we need to update the first character,
				in this case, new character can merge with substring to its left
				*/
                else if(j == x) {
                    bool ishead = (cit == cache.begin());
                    auto pit = cit;
                    if(!ishead) pit--;
                    if(ishead || pit->second.first != c) {
                        len_cnt[1] += 1;
                        len_cnt[len - 1] += 1;
                        char old = cit->second.first;
                        cache.erase(cit);
                        cache[x] = pair<char, int>{c, 1};
                        cache[x + 1] = pair<char, int>{old, len - 1};
                    }
                    else {    // merge to left
                        int plen = pit->second.second++;
                        len_cnt[plen] -= 1;
                        if(len_cnt[plen] == 0) len_cnt.erase(plen);
                        len_cnt[plen + 1] += 1;
                        len_cnt[len - 1] += 1;
                        char old = cit->second.first;
                        cache.erase(cit);
                        cache[x + 1] = pair<char, int>{old, len - 1};
                    }
                }
				/*
				case 3: substring to be updated has multiple characters, and we need to update the last character,
				in this case, new character can merge with substring to its right
				*/
                else if(j == x + len -1) {
                    auto nit = ++cit;
                    cit--;
                    if(nit == cache.end() || nit->second.first != c) {
                        len_cnt[1] += 1;
                        len_cnt[len - 1] += 1;
                        cit->second.second -= 1;
                        cache[j] = pair<char, int>{c, 1};
                    }
                    else {  // merge to right
                        int nlen = nit->second.second++;
                        if(--len_cnt[nlen] == 0) len_cnt.erase(nlen);
                        len_cnt[nlen + 1] += 1;
                        len_cnt[len - 1] += 1;
                        cit->second.second -= 1;
                        cache.erase(nit);
                        cache[j] = pair<char, int>{c, nlen + 1};
                    }
                }
				/*
				case 4: the character to be updated is in the middle of substring,
				in this case, we split the original substring into three new substrings;
				*/
                else {
                    int ll = j - x;
                    int lr = len - ll - 1;
                    char old = cit->second.first;
                    len_cnt[1] += 1;
                    len_cnt[ll] += 1;
                    len_cnt[lr] += 1;
                    cache[x].second = ll;
                    cache[j] = pair<char, int>{c, 1};
                    cache[j+1] = pair<char, int>{old, lr};
                }
				// finally, we query the length of the longest substring
                auto it = --len_cnt.end();
                ans[i] = it->first;
            }
        }
        return ans;
    }
};