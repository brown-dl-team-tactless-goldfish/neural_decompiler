class Solution {
public:
    class myCompactor {
      public:    
        bool operator () (const vector<int>& a, const vector<int>& b) const {
          return a[0]<b[0]? true: false;    
        }  
    };
    
    int largestValsFromLabels(vector<int>& values, vector<int>& labels, int num_wanted, int use_limit) {
      int n = labels.size(), ans = 0, l = 0;      
      priority_queue<vector<int>,vector<vector<int>>,myCompactor> pq;
      unordered_map<int,int> count;
      for (int i = 0; i<n;i++) {
        pq.push({values[i],labels[i]});    
      }  
      while (l<num_wanted && !pq.empty()) {
        vector<int> top = pq.top(); pq.pop();
        int label = top[1]; 
        count[label]++;
        if (count[label]<=use_limit) { 
          ans+=top[0]; l++;    // only increment when value is valid 
        }
      }
      return ans;
    }
};