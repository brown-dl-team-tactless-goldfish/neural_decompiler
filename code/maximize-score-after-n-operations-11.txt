class Solution {
public:
    int maxScore(vector<int>& nums) {
        int n = nums.size() / 2;
        int limit = 1 << (2 * n);
        
        vector<int> dp(limit, -1);
        int ans = helper(nums, n, limit - 1, dp);
        return ans;
    }
    
    int helper(vector<int>& nums, int cur, int mask, vector<int>& dp) {
        if(mask == 0) {
            return 0;
        }
        
        if(dp[mask] != -1) return dp[mask];
        
        int len = nums.size();
        int res = 0;
        
        // Pick index i, and j. If mask contains both bit i and bit j. Then we can try select nums[i] and nums[j].
        for(int i=0; i<len; i++) {
            for(int j=i+1; j<len; j++) {
                if((mask & (1 << i)) && (mask & (1 << j))) {
                    int rem = mask - (1 << i) - (1 << j);
                    res = max(res, cur * gcd(nums[i], nums[j]) + helper(nums, cur-1, rem, dp));
                }
            }
        }
        
        dp[mask] = res;
        return res;
    }
};