class Solution:
    def longestNiceSubstring(self, s: str) -> str:
        self.res = []
        n = len(s)

        # for b

        def helper(curS):
            print("curS = ", curS)

            n = len(curS)
            if (n < 2):
                return
            maps = {}
            for c in curS:
                if (c.lower() not in maps):
                    maps[c.lower()] = [0, 0]

                if (c.islower()):
                    maps[c.lower()][0] = 1
                else:
                    maps[c.lower()][1] = 1

            print("maps = ", maps)

            flag = True
            break_data_deliter = ""
            for k, v in maps.items():
                # print ("k = ", k, " v = ", v)
                if (sum(v) < 2):
                    flag = False
                    if (v[0] == 1):
                        break_data_deliter += k.lower()
                    else:
                        break_data_deliter += k.upper()
                # print ("flag = ", flag)
            print("break_data_deliter = ", break_data_deliter)

            if (break_data_deliter == ""):
                self.res.append([len(curS), n - s.index(curS), curS])
                return

            import re
            candidates = re.split("[" + break_data_deliter + "]", curS)
            candidates.sort(key=len, reverse=True)
            print("candidates = ", candidates)
            print("")

            for c in candidates:
                if (len(c) >= 2):
                    helper(c)

        helper(s)
        self.res.sort(reverse=True)
        print("self.res = ", self.res)

        if (self.res == []):
            return ""
        else:
            return self.res[0][2]