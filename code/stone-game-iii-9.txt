class Solution {
public:
    string stoneGameIII(vector<int>& stoneValue) {
     
        vector<vector<int>> memo(stoneValue.size(), vector<int>(2, -1));
        int Alice_score = minmax(stoneValue, 0, true, memo);

        int total = accumulate(begin(stoneValue), end(stoneValue), 0);
        if (total == (Alice_score * 2)) {
            return "Tie";
        } else if (total - Alice_score < Alice_score) {
            return "Alice";
        } else {
            return "Bob";
        }
    }
    
    int minmax(const vector<int>& stone_value, int idx, bool alice_turn, vector<vector<int>>& memo) {
        
        if (idx >= stone_value.size()) {
            return 0;
        }
        
        if (memo[idx][alice_turn] != -1) {
            return memo[idx][alice_turn];
        }
        
        int score = alice_turn ? std::numeric_limits<int>::min() : std::numeric_limits<int>::max();
        if (alice_turn) {
            
            int sum_of_stones = 0;
            for (int i = idx; i < idx + 3 && i < stone_value.size(); ++i) {
                
                sum_of_stones += stone_value[i];
                score = max(score, sum_of_stones + minmax(stone_value, i + 1, !alice_turn, memo));
            }
            
        } else {
            
            for (int i = idx; i < idx + 3 && i < stone_value.size(); ++i) {
                // Bob wants to play optimally, so he also wants to maximize his score,
                // which is equivalent to minimize Alice next step score.
                // Essentially we are getting and returning alice score.
                score = min(score, minmax(stone_value, i + 1, !alice_turn, memo));
            }
        }
        
        memo[idx][alice_turn] = score;
        
        return score;
    }
};