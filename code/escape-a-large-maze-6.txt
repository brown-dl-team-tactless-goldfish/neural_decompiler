class Solution {
public:
    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {
        set<int> sx, sy;
        for (vector<int>& b : blocked) sx.insert(b[0]), sy.insert(b[1]);
        sx.insert(source[0]), sy.insert(source[1]);
        sx.insert(target[0]), sy.insert(target[1]);
        int n = -1, m = -1, last = -1;
        unordered_map<int, int> xm, ym;
        for (auto it = sx.begin(); it != sx.end(); it++)
        {
            if (*it == last + 1) n++;
            else n += 2;
            xm[*it] = n;
            last = *it;
        }
        if (last != 999999) n++;
        n++;
        last = -1;
        for (auto it = sy.begin(); it != sy.end(); it++)
        {
            if (*it == last + 1) m++;
            else m += 2;
            ym[*it] = m;
            last = *it;
        }
        if (last != 999999) m++;
        m++;
        vector<vector<bool>> v(n, vector<bool>(m, true));
        vector<vector<bool>> vis(n, vector<bool>(m, false));
        for (vector<int>& b : blocked) v[xm[b[0]]][ym[b[1]]] = false;
        int x = xm[source[0]], y = ym[source[1]];
        int tx = xm[target[0]], ty = ym[target[1]];
        queue<int> que;
        que.push(x << 16 | y);
        vis[x][y] = true;
        vector<vector<int>> dirs = {{1,0},{0,1},{-1,0},{0,-1}};
        while (!que.empty())
        {
            int p = que.front(), q = p & 0xFFFF;
            p >>= 16;
            que.pop();
            for (vector<int>& d : dirs)
            {
                int tmpp = p + d[0], tmpq = q + d[1];
                if (tmpp < 0 || tmpp >= n || tmpq < 0 || tmpq >= m || !v[tmpp][tmpq] || vis[tmpp][tmpq]) continue;
                if (tmpp == tx && tmpq == ty) return true;
                vis[tmpp][tmpq] = true;
                que.push(tmpp << 16 | tmpq);
            }
        }
        return false;
    }
};