typedef struct {
    struct TreeNode *p;
    int layer;
} Item1;

struct TreeNode* addOneRow(struct TreeNode* root, int val, int depth){
    if (depth == 1) {
        struct TreeNode *p = (struct TreeNode *)malloc(sizeof(struct TreeNode));
        p->val = val;
        p->left = root;
        p->right = NULL;
        return p;
    }
    
    Item1 p[10001] = {0};
    p[0].p = root;
    p[0].layer = 0;
    int head = 0, tail = 1;
    
    while (head < tail) {
        if (p[head].p->left) {
            p[tail].p = p[head].p->left;
            p[tail].layer = p[head].layer + 1;
            tail++;
        }
        if (p[head].p->right) {
            p[tail].p = p[head].p->right;
            p[tail].layer = p[head].layer + 1;
            tail++;
        }
        head++;
    }
    
    for (int i=0; i<tail; i++) {
        if (p[i].layer == depth-2) {
            struct TreeNode *p1 = NULL;
            if (p[tail-1].layer == p[i].layer) {
                p1 = (struct TreeNode *)malloc(sizeof(struct TreeNode));
                memset(p1, 0, sizeof(struct TreeNode));
                p1->val = val;
                p1->left = NULL;
                p1->right = NULL;
                
                p[i].p->left = p1;
                
                p1 = (struct TreeNode *)malloc(sizeof(struct TreeNode));
                memset(p1, 0, sizeof(struct TreeNode));
                p1->val = val;
                p1->left = NULL;
                p1->right = NULL;
                
                p[i].p->right = p1;
                
                continue;
            }

            p1 = (struct TreeNode *)malloc(sizeof(struct TreeNode));
            memset(p1, 0, sizeof(struct TreeNode));
            p1->val = val;
            p1->right = NULL;
            p1->left = p[i].p->left;
            
            p[i].p->left = p1;
            
            p1 = (struct TreeNode *)malloc(sizeof(struct TreeNode));
            memset(p1, 0, sizeof(struct TreeNode));
            p1->val = val;
            p1->left = NULL;
            p1->right = p[i].p->right;
            
            p[i].p->right = p1;
        }
    }
    
    return root;
}