/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int cmp(void* a,void* b){
    return *(int*)a-*(int*)b;
}
void func(int* nums, int numsSize,int* map,int* lens,int pre_index){
    if(numsSize==1||map[0]!=0){
        return;
    }
    for(int i=1;i<numsSize;i++){
        if(nums[i]%nums[0]==0){
            if(map[i]==0){
                func(&nums[i], numsSize-i,&map[i],&lens[i],pre_index+i);
            }
            if(lens[0]<lens[i]+1){
                map[0]=i+pre_index;
                lens[0]=lens[i]+1;
            }
        }
    }
}
int* largestDivisibleSubset(int* nums, int numsSize, int* returnSize){
     *returnSize=0;
    if(numsSize==0){
        return NULL;
    }
    qsort(nums,numsSize,sizeof(nums[0]),cmp);
    int* map=(int*)calloc(numsSize,sizeof(int));
    int* lens=(int*)calloc(numsSize,sizeof(int));
    int* ret=(int*)calloc(numsSize,sizeof(int));
    for(int i=0;i<numsSize-1;i++){
        if(map[i]!=0){
            continue;
        }
        func(&nums[i], numsSize-i,&map[i],&lens[i],i);
    }
    int index=0;
    for(int i=1;i<numsSize;i++){
        if(lens[i]>lens[index]){
            index=i;
        }
    }
    while(map[index]!=0){
        ret[(*returnSize)++]=nums[index];
        index=map[index];
    }
    ret[(*returnSize)++]=nums[index];
    return ret;
}