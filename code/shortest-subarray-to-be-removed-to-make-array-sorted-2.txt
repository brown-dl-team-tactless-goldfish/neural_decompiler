int findLengthOfShortestSubarray(int* arr, int arrSize){
    int *lp = arr,              /* left -> beginning element */
        *rp = lp + arrSize - 1, /* right -> last element */
        *ep = lp + arrSize,     /* points to end of array */ 
        r = 0;                  /* result */
    
    /* 1. Keep sliding rp from right to left checking non-decreasing order */
    while(rp > lp && *(rp - 1) <= *rp) rp--; if (rp == lp) return 0; /* full ascending order */

    /* rp points to a point from where it is non-decreasing till the end */
    r = rp - lp;

    /* We need to play from the left now ... */
    do {
        /* When we did 1, we may have overdone it towards left. So now, 
         * in order to move lp ahead in non-decreating order, we may 
         * need to adjust rp to the right until *lp <= *rp.
         */
        while (rp < ep && *lp > *rp) rp++;
        
        /* We need to record the minimum distance between lp and rp 
         * while keeping the rest elements in non-decreasing order
         */
        int d = rp - lp - 1; if (r > d) r = d;
        
        /* Move left pointer if we can maintain non-decreasing order 
         * by including the next element
         */
    } while (++lp < ep && *(lp - 1) <= *lp);
    
    /* Return the minimum distance recorded */
    return r; 
}