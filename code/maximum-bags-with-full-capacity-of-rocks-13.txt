class Solution:
    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:
        # combine the input arrays
        crs = list(zip(capacity, rocks))
        # sort the bags by number of rocks left to fill each bag
        crs.sort(key=lambda cr: cr[0] - cr[1])
        # keep track of the number of bags we have filled so far
        filled = 0
        # iterate bags, starting from those closest to filled
        for c, r in crs:
            # if we have enough rocks to fill this bag...
            if additionalRocks >= c - r:
                # then substract from the number of additional
                # rocks the number of rocks needed to fill this
                # bag
                additionalRocks -= c - r
                # increment the number of filled bags
                filled += 1
            else:
                # optimization - we can stop checking for bags
                # to fill prematurely once we find one bag that
                # we don't have enough rocks to fill with,
                # because since the bags are sorted all bags
                # after this one will need at least as many
                # rocks to fill them anyway
                break
        return filled