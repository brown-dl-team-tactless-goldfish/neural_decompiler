
class Solution {
public:
	vector<vector<bool>> visMat;

	int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, { -1, 0}};
	bool isValid(int i, int j, vector<vector<int>> &grid) {

		return (i >= 0 && j >= 0 && i < grid.size() && j < grid[0].size());
	}

	vector<int> parent;
	vector<int> low;
	vector<int> disc;
	vector<bool> vis;
	vector<bool> ap;


	void dfs(vector<vector<int>> &grid, int i, int j) {

		visMat[i][j] = true;
		for (auto d : dirs) {
			int ni = i + d[0];
			int nj = j + d[1];

			if (isValid(ni, nj, grid) && !visMat[ni][nj] && grid[ni][nj] == 1) {dfs(grid, ni, nj);}
		}
	}


	int time = 0;
	void dfsArticulation(vector<set<int>> &graph, int u) {

		// cout << "At " << u << " ";

		low[u] = disc[u] = ++time;
		vis[u] = true;
		int dfsCount = 0;

		for (int v : graph[u]) {

			if (v == parent[u]) continue;

			else if (vis[v]) low[u] = min(low[u], disc[v]);

			else {
				dfsCount++;
				parent[v] = u;
				dfsArticulation(graph, v);
				low[u] = min(low[u], low[v]);

				if (parent[u] == -1) {

					if (dfsCount > 1) {
						if (low[v] >= disc[u]) {
							ap[u] = true;
						}
					}
				}

				else  {
					if (low[v] >= disc[u]) ap[u] = true;
				}

			}
		}


	}


	int minDays(vector<vector<int>>& grid) {
		int rows = grid.size();
		int cols = grid[0].size();
		int comps = 0;
		int onesCount = 0;

		visMat.resize(rows, vector<bool> (cols, false));

		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < cols; j++) {
				onesCount += grid[i][j];
				if (grid[i][j] == 1 && !visMat[i][j]) {
					dfs(grid, i, j);
					comps++;
				}
			}
		}
		if (onesCount == 1) return 1;
		// cout << "Comps : " << comps << '\n';
		if (comps > 1) return 0;


		vector<set<int>> graph(rows * cols + 1);
		parent.resize(rows * cols + 1);
		low.resize(rows * cols + 1);
		disc.resize(rows * cols + 1);
		vis.resize(rows * cols + 1, false);
		ap.resize(rows * cols + 1, false);

		int src = -1;
		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < cols; j++) {

				if (grid[i][j] == 0) continue;


				if (src == -1) src = cols * i + j;

				for (auto d : dirs) {

					int ni = i + d[0];
					int nj = j + d[1];

					if (isValid(ni, nj, grid) && grid[ni][nj] == 1) {

						graph[cols * i + j].insert(cols * ni + nj);
						graph[cols * ni + nj].insert(cols * i + j);
					}
				}

			}
		}


		parent[src] = -1;
		int artiPoints = 0;
		dfsArticulation(graph, src);


		for (int i = 0; i < ap.size(); i++) {
			if (ap[i]) return 1;

		}

		return 2;

	}
};