#include <stdlib.h>

#define HASH_TABLE_MAX_NUM (1 << 7)
#if defined linux
#define offsetof(TYPE, MEMBER) ( (size_t) &((TYPE *)0)->MEMBER )
#define container_of(ptr, type, member) ({ \
    const __typeof__(((type *)(0))->member) *__mptr = (ptr); \
    (type *) ((char *)__mptr - offsetof(type, member)); })
#endif
#if defined WIN32
#include <Windows.h>
#define container_of(ptr, type, member) CONTAINING_RECORD(ptr, type, member)
#endif

struct hlist_node {
    struct hlist_node *next;
    struct hlist_node **pprev;
    char *key;
};

struct hlist_head {
    struct hlist_node *first;
};

struct list_node {
    struct list_node *next;
    struct list_node **pprev;
    struct list_head *head;
};

struct list_head {
    struct list_head *next;
    struct list_head *prev;
    struct list_node *first;
    int val;
};

struct data_node {
    struct hlist_node hn;
    struct list_node ln;
};

typedef struct {
    struct hlist_head *hash_table;
    struct list_head *list;
    int number;
} AllOne;

struct hlist_head *create_hash_table()
{
    struct hlist_head *table = (struct hlist_head *)malloc(sizeof(*table) * HASH_TABLE_MAX_NUM);
    int i;

    for (i = 0; i < HASH_TABLE_MAX_NUM; i++)
    {
        table[i].first = NULL;
    }

    return table;
}

struct list_head *create_list()
{
    struct list_head *list = (struct list_head *)malloc(sizeof(*list));
    list->next = list->prev = list;

    return list;
}

/** Initialize your data structure here. */
AllOne* allOneCreate() {
    AllOne *obj = (AllOne *)malloc(sizeof(*obj));
    obj->hash_table = create_hash_table();
    obj->list = create_list();
    obj->number = 0;

    return obj;
}

int get_hash_key(char *key)
{
    int hash_key = 0;

    while(*key)
    {
        hash_key = (hash_key + *key) % HASH_TABLE_MAX_NUM;
        key++;
    }

    return hash_key;
}

struct hlist_node *find_hash_node(struct hlist_head *hash_table, char* key)
{
    int hash_key = get_hash_key(key);
    struct hlist_node *hn = hash_table[hash_key].first;

    while (hn && strcmp(hn->key, key)) hn++;

    return hn;
}

struct data_node *get_data_from_list_node(struct list_node *ln)
{
    struct data_node *data = container_of(ln, struct data_node, ln);
    return data;
}

struct list_node *get_list_node_from_hash_node(struct hlist_node *hn)
{
    struct data_node *data = container_of(hn, struct data_node, hn);
    struct list_node *ln = &data->ln;
    return ln;
}

struct hlist_node *get_hash_node_from_list_node(struct list_node *ln)
{
    struct data_node *data = get_data_from_list_node(ln);
    struct hlist_node *hn = &data->hn;
    return hn;
}

void set_hash_key(struct hlist_node *hn, char *key)
{
    hn->key = key;
}

void add_hash_node(struct hlist_head *hash_table, struct hlist_node *hn)
{
    int hash_key = get_hash_key(hn->key);
    struct hlist_node **pprev = &hash_table[hash_key].first;
    hn->next = *pprev;
    hn->pprev = pprev;
    *hn->pprev = hn;
    if (hn->next) hn->next->pprev = &hn->next;
}

void remove_hash_node(struct hlist_node *hn)
{
    *hn->pprev = hn->next;
    if (hn->next) hn->next->pprev = hn->pprev;
}

struct list_head *create_list_head(int val)
{
    struct list_head *lh = (struct list_head *)malloc(sizeof(*lh));
    lh->val = val;
    lh->first = NULL;
    return lh;
}

void add_list_head(struct list_head *prev, struct list_head *lh)
{
    lh->next = prev->next;
    lh->prev = prev;
    lh->next->prev = lh->prev->next = lh;
}

void add_list_node(struct list_head *lh, struct list_node *ln)
{
    ln->next = lh->first;
    ln->pprev = &lh->first;
    *ln->pprev = ln;
    if (ln->next) ln->next->pprev = &ln->next;
    ln->head = lh;
}

void remove_list_node(struct list_node *ln)
{
    *ln->pprev = ln->next;
    if (ln->next) ln->next->pprev = ln->pprev;
}

void add_data(AllOne* obj, char* key)
{
    struct list_head *list = obj->list;
    struct list_head *lh = list->next;
    struct data_node *data = (struct data_node *)malloc(sizeof(*data));
    struct hlist_node *hn = &data->hn;
    struct list_node *ln = &data->ln;

    set_hash_key(hn, key);
    add_hash_node(obj->hash_table, hn);

    if(lh == list || lh->val != 1)
    {
        lh = create_list_head(1);
        add_list_head(list->next, lh);
    }

    add_list_node(lh, ln);
}

void destroy_data(struct data_node *data)
{
    free(data);
}

/** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */
void allOneInc(AllOne* obj, char* key) {
    struct hlist_node *hn = find_hash_node(obj->hash_table, key);
    struct list_head *lh;
    struct list_head *next_lh;
    struct list_node *ln;

    if(hn)
    {
        ln = get_list_node_from_hash_node(hn);
        lh = ln->head;
        next_lh = lh->next;
        remove_list_node(ln);

        if (next_lh == obj->list || next_lh->val != lh->val + 1)
        {
            next_lh = create_list_head(lh->val + 1);
            add_list_head(lh, next_lh);
        }

        add_list_node(next_lh, ln);
    }
    else
    {
        add_data(obj, key);
        obj->number++;
    }
}

/** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */
void allOneDec(AllOne* obj, char* key) {
    struct hlist_node *hn = find_hash_node(obj->hash_table, key);
    struct list_head *lh;
    struct list_head *prev_lh;
    struct list_node *ln;

    if (hn)
    {
        ln = get_list_node_from_hash_node(hn);
        lh = ln->head;
        remove_list_node(ln);

        if (lh->val == 1) 
        {
            remove_hash_node(hn);
            destroy_data(get_data_from_list_node(ln));
            obj->number--;

            return;
        }

        prev_lh = lh->prev;

        if (prev_lh == obj->list || prev_lh->val != lh->val - 1)
        {
            prev_lh = create_list_head(lh->val - 1);
            add_list_head(lh->prev, prev_lh);
        }

        add_list_node(prev_lh, ln);
    }
}

void remove_list_head(struct list_head *lh)
{
    lh->next->prev = lh->prev;
    lh->prev->next = lh->next;
}

void destroy_list_head(struct list_head *lh)
{
    free(lh);
}

/** Returns one of the keys with maximal value. */
char* allOneGetMaxKey(AllOne* obj) {
    struct list_head *lh;
    struct list_head *prev_lh;
    if (obj->number == 0) return "";

    lh = obj->list->prev;
    
    while(lh->first == NULL)
    {
        prev_lh = lh->prev;
        remove_list_head(lh);
        destroy_list_head(lh);
        lh = prev_lh;
    }

    return get_hash_node_from_list_node(lh->first)->key;
}

/** Returns one of the keys with Minimal value. */
char* allOneGetMinKey(AllOne* obj) {
    struct list_head *lh;
    struct list_head *next_lh;
    if (obj->number == 0) return "";

    lh = obj->list->next;

    while (lh->first == NULL)
    {
        next_lh = lh->next;
        remove_list_head(lh);
        destroy_list_head(lh);
        lh = next_lh;
    }

    return get_hash_node_from_list_node(lh->first)->key;
}

void allOneFree(AllOne* obj) {
    struct list_head *list = obj->list;
    struct list_head *lh;
    struct list_head *next_lh;
    struct list_node *ln;
    struct list_node *next_ln;

    list->prev->next = NULL;
    lh = list->next;

    while (lh)
    {
        ln = lh->first;

        while(ln)
        {
            next_ln = ln->next;
            destroy_data(get_data_from_list_node(ln));
            ln = next_ln;
        }

        next_lh = lh->next;
        destroy_list_head(lh);
        lh = next_lh;
    }

    free(obj->list);
    free(obj->hash_table);
    free(obj);
}

/**
* Your AllOne struct will be instantiated and called as such:
* struct AllOne* obj = allOneCreate();
* allOneInc(obj, key);
* allOneDec(obj, key);
* char* param_3 = allOneGetMaxKey(obj);
* char* param_4 = allOneGetMinKey(obj);
* allOneFree(obj);
*/