int numSpecialEquivGroups(char** A, int ASize) {
    const int slen    = strlen(A[0]);
    const int elen    = 26;
    const int mxshift = 64 + 1 - 4;

    char     entries[1001][elen];   // entry table (26KB)
    uint64_t sigs[1000];            // entry signature table (8KB)
    int32_t  nexts[1000];           // entry next table (4KB)
    int32_t  backs[1000];           // entry back table (4KB)
    int32_t  hashes[256];           // hash table (1KB)
    
    int      siz = 0;
    
    // Init hash table
    memset(hashes, 0xff, 256*sizeof(int32_t));

    for (int i = 0; i < ASize; ++i) {
        char*    tmp  = entries[siz];
        uint64_t sig  = 0;
        uint8_t  hash = 0;
        
        // Construct tmp entry and entry sig
        memset(tmp, 0x00, elen);
        
        for (int j = 0; j < slen; j += 2) {
            int k = A[i][j] - 'a';
            tmp[k] += 0x01;
            sig    |= 0x01 << k;
        }

        for (int j = 1; j < slen; j += 2) {
            int k = A[i][j] - 'a';
            tmp[k] += 0x10;
            sig    |= 0x01 << (k + elen);
        }
        
        for (int j = 0, shift = elen*2; shift < mxshift && j < slen; ++j) {
            if (tmp[j]) {
                sig   |= tmp[2] << shift;
                shift += 4;
            }
        }
        
        // Construct hash
        for (int j = 0; j < elen; ++j) {
            int rotate = j & 0x1f;
            unsigned char msk = (tmp[j] << (rotate)) |
                                (tmp[j] >> (8 - rotate));
            hash ^= msk;
        }
        
        // Find entry in hash, sig, and entry tables
        bool found = false;
        for (int e = hashes[hash]; found == false && e != -1; e = nexts[e]) {
            found = sigs[e]                       == sig &&
                    memcmp(entries[e], tmp, elen) == 0;
        }

        // Insert hash, sig, and entry, if not found
        if (found == false) {
            sigs[siz] = sig;
            
            if (hashes[hash] == -1) hashes[hash]       = siz;
            else                    nexts[backs[hash]] = siz;

            backs[hash] = siz;
            nexts[siz]  = -1;
            
            ++siz;            
        }
    }

    return siz;    
}