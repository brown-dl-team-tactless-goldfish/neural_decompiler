class Node{
    unordered_map<string,Node*> m;
    bool end = false;
public:
    void set(string &s,Node* node){
        m[s] = node;
    }
    Node* getNode(string &s){
        return m[s];
    }
    bool isContainsPath(string &s){
        return m[s] != nullptr;
    }
    void setEnd(){
        end = true;
    }
    bool isEnd(){
        return end;
    }
};
class Trie{
    Node *root = new Node();
    public:
    void insert(vector<string> &str){
        Node* node = root;
        for(string &s:str){
            if(!node->isContainsPath(s)){
                node->set(s,new Node());
            }
            node = node->getNode(s);
        }
        node->setEnd();
    }
    string get(vector<string> &str){
        string ans;
        Node* node = root;
        for(string &s:str){
            ans += "/" + s;
            if(node->isEnd()) return "";
            node = node->getNode(s);
        }
        return ans;
    }
};
class Solution {
public:
    vector<string> removeSubfolders(vector<string>& folder) {
        Trie trie;
        vector<vector<string>> str;
        for(string &s:folder){
            string temp;
            s += "/";
            str.push_back({});
            for(char &c:s){
                if(c != '/') temp += c;
                else if(temp.size() > 0) {
                    str.back().push_back(temp);
                    temp = "";
                }
            }
            trie.insert(str.back());
        }
        vector<string> ans;
        for(auto v:str){
            string s = trie.get(v);
            if(s.size() > 0) ans.push_back(s);
        }
        return ans;
    }
};