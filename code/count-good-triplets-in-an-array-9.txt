class Solution {
private:
    int tree[400004];
public:
    void update(int low, int high, int parent, int val){
        if(low>val || high<val){
            return;
        }
        if(low==val && high==val){
            tree[parent]=1;
            return;
        }
        int mid=(low+high)/2;
        update(low,mid,2*parent+1,val);
        update(mid+1,high,2*parent+2,val);
        tree[parent]=tree[2*parent+1]+tree[2*parent+2];
    }
    
    int findMinCount(int low, int high, int parent, int lowerR, int higherR){
        if(low>higherR || high<lowerR){
            return 0;
        }
        if(low>=lowerR && high<=higherR){
            return tree[parent];
        }
        int mid=(low+high)/2;
        return findMinCount(low,mid,2*parent+1,lowerR,higherR)+findMinCount(mid+1,high,2*parent+2,lowerR,higherR);
    }
    
    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {
        memset(tree,0,sizeof(tree));
        int n=nums1.size();
        unordered_map<int,int> mpp;
        for(int i=0;i<n;i++){
            mpp[nums1[i]]=i;
            nums1[i]=i;
        }
        for(int i=0;i<n;i++){
            nums2[i]=mpp[nums2[i]];  // by doing this we will just need to work on nums2 and ignore 1 as it is sorted. Remember, we are not considering elements, but the indexes anyways
        }
        update(0,n-1,0,nums2[0]); // because first and last cannot be considered as mid element of triplet
        long long res=0;
        for(int i=1;i<n-1;i++){
            long long int countLessThanE=findMinCount(0,n-1,0,0,nums2[i]-1); 
            long long int biggerElements=(n-1)-nums2[i];  // this is the count of elements bigger than nums2[i] that are present, since nums1 is sorted, we can simply find this....
            int leftOutBiggerElements=i-countLessThanE;  
			/* this is the count of biggerElements which have fallen behind i, i.e. they are on the left of i
			and hence cannot be used as right side bigger elements, see, we know the index, and we also
			know how many elemts are smaller than nums2[i] and are on the right, so if i-countLessThanE, 
			we get the remaining elements on the left side which are just bigger elements that are on the 
			left side and cannot be used on the rightmost side, that is why we remove them from 
			biggerELEMENTS AND hence get the correct count of elements on the right side which are bigger 
			than nums2[i]. Inshort, to find the correct value of elements on the right side of i, that are bigger
			than nums2[i]. Just get the count of values that are bigger than nums2[i], now subtract the count 
			of elements that are bigger than nums2[i], but are on the left side of i, since they cannot be used 
			in right side of i */
            long long int biggerElementOnRightSide=biggerElements-leftOutBiggerElements;
            res+=(countLessThanE*biggerElementOnRightSide);
            update(0,n-1,0,nums2[i]);  // updating this current number in segTree for furthur ops
        }
        return res;
    }
};