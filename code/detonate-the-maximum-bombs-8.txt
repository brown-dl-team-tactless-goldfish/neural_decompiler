// Time Complexity: O(n^2)+O(n^2)
// space Complexity: O(n^2)
class Solution {
    private:
     // to store ans
       int ans=0;
        
public:
   double calculateD(int x1, int y1, int x2, int y2)
   {
       return sqrt(pow((x2-x1),2)+pow((y2-y1),2));
   }
    int maximumDetonation(vector<vector<int>>& bombs) {
        // number of bombs
        int n=bombs.size();

        // Create an adjacency list
        vector<vector<int>>adjList(n,vector<int>());
          dist.resize(n,0);
        for(int i=0;i<n;i++)
           for(int j=i+1;j<n;j++)
             {
                 int x1=bombs[i][0];
                 int y1=bombs[i][1];
                 int r1=bombs[i][2];
                 int x2=bombs[j][0];
                 int y2=bombs[j][1];
                 int r2=bombs[j][2];
                 double c1c2=calculateD(x1,y1,x2,y2);

                 // if bomb1 can blow bomb2 
                 if(r1>=c1c2)
                  adjList[i].push_back(j);
                
                // if bomb2 can blow bomb1
                if(r2>=c1c2)
                  adjList[j].push_back(i);
             }
      
    
      // now blow all bomb one by one and see which one got highest answer
      // to check node is visited or not
      vector<int>visited(n,-1);
     
       
      
       for(int i=0;i<n;i++)
         { vector<int>visited(n,0);
             ans=max(dfs(i,adjList,visited),ans);
         }
        
          
        // return ans
        return ans;
    }
    int dfs(int node,vector<vector<int>>&adjList,vector<int>&visited)
    {
        // mark as visited
        visited[node]=1;
       
       // 
       int cnt=0;
        // traverse over neighbors
        for(auto adjNode:adjList[node])
          // yet not visited
          if(!visited[adjNode])
           {  
               cnt+=dfs(adjNode,adjList,visited);
           }
           
        

       return cnt+1;
    }
};