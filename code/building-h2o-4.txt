typedef struct {
    pthread_mutex_t m;                      // Common mutex
    pthread_cond_t hc, oc;                  // Hydrogen:producer, Oxygen:consumer
    int c;                                  // Common count
} H2O;

H2O* h2oCreate() {
    H2O* obj = malloc(sizeof (H2O));
    obj->c = 0;
    pthread_mutex_init(&obj->m, NULL);
    pthread_cond_init(&obj->hc, NULL);
    pthread_cond_init(&obj->oc, NULL);
    return obj;
}

//
// Common stub for both Hydrogen:producer and Oxygen:consumer.
// Depending upon whether it's hydrogen or oxygen calling this,
// the count logic(condition to wait for and count update) and
// molecule(hydrogen or oxygen) released differ.
//
inline void cmn(H2O *o, pthread_cond_t *c1, pthread_cond_t *c2, char c) {
    pthread_mutex_lock(&o->m);
    while (c == 'H' ? o->c == 2 : o->c != 2)
        pthread_cond_wait(c1, &o->m);
    c == 'H' ? releaseHydrogen() : releaseOxygen();
    o->c += c == 'H' ? 1 : -2;
    pthread_cond_signal(c2);
    pthread_mutex_unlock(&o->m);    
}

void hydrogen(H2O* obj) {
    cmn(obj, &obj->hc, &obj->oc, 'H');
}

void oxygen(H2O* obj) {
    cmn(obj, &obj->oc, &obj->hc, 'O');
}

void h2oFree(H2O* obj) {
    pthread_mutex_destroy(&obj->m);    
    pthread_cond_destroy(&obj->hc);
    pthread_cond_destroy(&obj->oc);
    free(obj);
}