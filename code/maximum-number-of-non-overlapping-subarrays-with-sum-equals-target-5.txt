class Solution {
public:
    //What we will do is maintain a prefix sum and put it into a hash map
    //When ever we find (prefix sum - target) into hashmap means we got a subarray with sum == target
    //At that time we will increase count ans now because we dont want any overlapping subarray so
    //we will make prefix sum = 0 and has map empty and start that again from that that point onward
    
    int maxNonOverlapping(vector<int>& nums, int target) {
        unordered_map<int, int> m;
        int prefSum = 0;
        int count = 0;
        m[0] = 1;            //initially we are pushing 0 in map to handle subarrays which start from inital
                            //point to the end point(where we find prefixSum - target in map) b/c at that time prefixSum == target
        for(int i=0; i<nums.size(); i++)
        {
            prefSum+=nums[i];
            
            if(m.find(prefSum - target) != m.end())
            {
                count++;
                prefSum = 0;
                m.clear();
            }
            m[prefSum]++;
        }
        return count;
    }
};