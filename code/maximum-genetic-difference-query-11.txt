class Node{
public:
    Node* links[2];
    int cnt=0;
    bool containsKey(int x){
        return (this->links[x]!=NULL);
    }
    void put(int x,Node* node){
        this->links[x]=node;
    }
    Node* get(int x){
        return this->links[x];
    }
};
class Trie{
private:
    Node* root;
public:
    Trie(){
        root=new Node();
    }
    void update(int x,bool add){
        Node* node=root;
        for(int i=30;i>=0;i--){
            int currbit=(x>>i)&1;
            if(!node->containsKey(currbit)) node->put(currbit,new Node());
            node=node->get(currbit);
            if(add) node->cnt++;
            else node->cnt--;
        }
    }
    int maxxor(int x){
        Node* node=root;
        int ans=0;
        for(int i=30;i>=0;i--){
            int currbit=(x>>i)&1;
            if(node->containsKey(currbit^1)&&node->links[currbit^1]->cnt>0){
                ans+=(1<<i);
                node=node->get(currbit^1);
            }
            else node=node->get(currbit);
        }
        return ans;
    }
};
class Solution {
public:
    vector<int>adj[100005];
    map<int,vector<pair<int,int>>>mp;
    Trie* t;
    vector<int>ans;
    void dfs(int src){
        t->update(src,true);
        for(auto x:mp[src]) ans[x.second]=t->maxxor(x.first);
        for(auto edge:adj[src]) dfs(edge);    
        t->update(src,false);
    }
    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {
        int start=-1;
        for(int i=0;i<parents.size();i++){
            if(parents[i]==-1) start=i;
            else adj[parents[i]].push_back(i);
        }
        for(int i=0;i<queries.size();i++) mp[queries[i][0]].push_back({queries[i][1],i});
        ans.resize((int)queries.size());
        t=new Trie();
        dfs(start);
        return ans;
    }
};