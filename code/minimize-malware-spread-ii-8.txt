class DSU {
public:
    DSU (int n) : arr_(n, -1) {}
    
    int find (int i) {
        return arr_[i] < 0 ? i : arr_[i] = find(arr_[i]);
    }
    
    void joint (int a, int b) {
        a = find(a), b = find(b);
        if (a != b) {
            if (arr_[a] > arr_[b])
                swap(a, b);
            arr_[a] += arr_[b];
            arr_[b] = a;
        }
    }
    
    int weight(int a) {
        a = find(a);
        return -arr_[a];
    }
private:
    vector<int> arr_;
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph[0].size();
        unordered_set<int> s(initial.begin(), initial.end());
        DSU ds(n);
        for (int i = 0; i < n; i++) {
            if (s.count(i))
                continue;
            for (int j = 0; j < n; j++) {
                if (!s.count(j) && graph[i][j])
                    ds.joint(i, j);
            }
        }
        
        vector<int> ref_cnt(n);
        for (auto a : initial) {
            unordered_set<int> nbrs;
            for (int i = 0; i < n; i++) {
                if (!s.count(i) && graph[a][i])
                    nbrs.insert(ds.find(i));
            }
            for (auto nbr : nbrs)
                ref_cnt[nbr]++;
        }

        int mx = INT_MIN, res = -1;
        for (auto a : initial) {
            unordered_set<int> nbrs;
            for (int i = 0; i < n; i++) {
                if (!s.count(i) && graph[a][i])
                    nbrs.insert(ds.find(i));
            }

            int cnt = 0;
            for (auto nbr : nbrs) {
                if (ref_cnt[nbr] == 1)
                    cnt += ds.weight(nbr);
            }
            if (cnt > mx || cnt == mx && a < res) {
                res = a;
                mx = cnt;
            }
        }
        
        return res;
    }
};