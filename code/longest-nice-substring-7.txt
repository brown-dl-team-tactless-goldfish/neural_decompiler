void f(string &s, int l, int r, int &ret, int &reti) {
    // ret >= r - l prune by @stackdaniel
    if (l == r || ret >= r - l) return ; // empty
    int a = 0, b = 0, c = 0; // big, small, xor intersection
    for (int j = l; j < r; j++) {
        if (s[j] < 'a') a |= (1 << (s[j] - 'A')); // Big char present
        else b |= (1 << (s[j] - 'a')); // Small char present
    }
    c = a ^ b; // bad chars
    if (c == 0) { // 'nice', no bad chars
        // check no longer needed cause of pruning earlier
        // if (ret < r - l) { // update the answer
            ret = r - l;
            reti = l;
        // }
        return ; // don't divide anymore
    }
    // otherwise divide into substrings over bad chars
    int i = l;
    for (int j = l; j < r; j++) {
        int x = s[j] < 'a' ?  'A' : 'a';
        if ((1 << (s[j] - x)) & c) { // bad char
            f(s, i, j, ret, reti); // check subarray [i -> j)
            i = j + 1;
        }
    }
    f(s, i, r, ret, reti); 
    // check up to end [i -> r) 
    // cause the for loop won't check it
}
string longestNiceSubstring(string s) {
    // divide until nice
    int ret = 0, reti = 0;
    f(s, 0, s.size(), ret, reti);
    return s.substr(reti, ret); // do substr only one time
    // technically O(N) space cause this return copies the string, 
    // but hey O(1) space anywhere else xD 
    // (*not including stack which is O(26) space) 
}