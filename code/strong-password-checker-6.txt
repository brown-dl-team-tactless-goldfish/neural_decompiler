static inline int min(int a, int b) {
    return a < b ? a : b;
}

static inline int max(int a, int b) {
    return a > b ? a : b;
}

int strongPasswordChecker(char * password){
    // Initial lengths
    char txt_len = strlen(password);
    if (txt_len < 3) {
        return 6 - txt_len;
    }

    // Basic building blocks for deletes/replaces
    char last_char = *password, c = password[1];
    char missing_lower = !(last_char >= 'a' && last_char <= 'z');
    char missing_upper = !(last_char >= 'A' && last_char <= 'Z');
    char missing_digit = !(last_char >= '0' && last_char <= '9');

    char replaces = 0, delete_ones = 0, delete_twos = 0;
    int len = 1;

    // Main loop for verification
    for (int i = 1; i < txt_len;) {
        // Tight loop for # of consecutive characters in sequence
        while (i < txt_len && last_char == c) {
            len++;
            c = password[++i];
        }

        // Calculate replacements/deletes
        if (len >= 3) {
            replaces += len / 3;

            int rem = len % 3;
            if (rem == 0) {
                delete_ones++;
            } else if (rem == 1) {
                delete_twos += 2;
            }
        }
        last_char = c;
        len = 0;

        // Missing character classification
        missing_lower &= !(c >= 'a' && c <= 'z');
        missing_upper &= !(c >= 'A' && c <= 'Z');
        missing_digit &= !(c >= '0' && c <= '9');
    }

    // Sum missing char classes
    int missing_classes = missing_lower + missing_upper + missing_digit;

    if (txt_len < 6) {
        // Check n < 6
        return max(6 - txt_len, missing_classes);
    } else if (txt_len <= 20) {
        // Check n <= 20
        return max(replaces, missing_classes);
    } else {
        // Check n > 20 for deletes - hardest of all!
        int deletes = txt_len - 20;

        // Single deletes to get series of 2 repeating chars instead of 3 repeating chars on x mod 3 == 0
        replaces -= min(deletes, delete_ones);

        // Double deletes to get series of 2 repeating chars instead of 3 repeating chars on x mod 3 == 1
        replaces -= min(max(deletes - delete_ones, 0), delete_twos) / 2;

        // Final cleanup using triple deletes for remaining sequences with 3 repeating chars
        replaces -= max(deletes - delete_ones - delete_twos, 0) / 3;

        return max(replaces, missing_classes) + deletes;
    }
}