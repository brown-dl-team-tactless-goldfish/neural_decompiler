class Solution {
public:
    
    int ans = INT_MAX;
    queue<pair<int, int>> q;
    
    void dfs(vector<vector<int>>& grid, int r, int c)
    {
        if(r < 0 or c < 0 or c >= grid.size() or r >= grid.size() or grid[r][c] == 2 or grid[r][c] == 0) return;
        
        grid[r][c] = 2;
        q.push({r, c});
        
        dfs(grid, r+1, c);
        dfs(grid, r-1, c);
        dfs(grid, r, c+1);
        dfs(grid, r, c-1);
    }
    
    int bfs(vector<vector<int>>& grid)
    {
        int dist = 0;
        vector<vector<int>> dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        
        while(!q.empty())
        {
            int n = q.size();
            while(n--)
            {
                pair<int, int> p = q.front();
                q.pop();
                
                for(int i=0; i<4; i++)
                {
                    int x = dir[i][0] + p.first;
                    int y = dir[i][1] + p.second;
                    
                    if(x>=0 and y>=0 and x<grid.size() and y<grid[0].size() and grid[x][y] == 1)
                        ans = min(ans, dist), grid[x][y] = 2;
                    if(x>=0 and y>=0 and x<grid.size() and y<grid[0].size() and grid[x][y] == 0)
                        q.push({x, y}), grid[x][y] = 2;
                }
            }
            ++dist;
        }
        return ans;
    }
    
    int shortestBridge(vector<vector<int>>& grid) 
    {
        bool flag = false;
        
        for(int i=0; i<grid.size(); i++) {
            for(int j=0; j<grid.size(); j++) {
                if(grid[i][j] == 1 and !flag) 
                {
                    dfs(grid, i, j);
                    flag = true;
                    break;
                }
            }
            if(flag) break;
        }
        
        return bfs(grid);
    }
};