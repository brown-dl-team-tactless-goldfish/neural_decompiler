
public class Solution {

    public class UnionFind {
        int[] parents;

        public UnionFind(int size) {
            parents = new int[size];

            for(int i = 0; i < parents.Length; i++) {
                parents[i] = i;
            }
        }

        public void Union(int u, int v) {
            int parentU = Find(u);
            int parentV = Find(v);

            parents[parentU] = parentV;
        }

        public int Find(int u) {
            while(u != parents[u]) {
                parents[u] = parents[parents[u]];
                u = parents[u];
            }

            return u;
        }

        public void ResetParent(int u) {
            parents[u] = u;
        }

        public bool IsConnected(int u, int v) {
            return Find(u) == Find(v);
        }
    }


    public IList<int> FindAllPeople(int n, int[][] meetings, int firstPerson) {
        var uf = new UnionFind(n);
        uf.Union(0, firstPerson);

        var map = new Dictionary<int, List<int[]>>();

        for(int i = 0; i < meetings.Length; i++) {
            int time = meetings[i][2];

            if(!map.ContainsKey(time)) map[time] = new List<int[]>();

            map[time].Add(meetings[i]);
        }

        int[] ordMeets = map.Keys.OrderBy(r => r).ToArray();

        for(int i = 0; i < ordMeets.Length; i++) {
            int time = ordMeets[i];
            List<int[]> currMeets = map[time];

            foreach(int[] meet in currMeets) {
                uf.Union(meet[0], meet[1]);
            }

            foreach(int[] meet in currMeets) {
                if(!uf.IsConnected(0, meet[0])) {
                    uf.ResetParent(meet[0]);
                    uf.ResetParent(meet[1]);
                }
            }
        }
      
        var res = new List<int>() { 0 };
        for(int i = 1; i < n; i++) {
            if(uf.IsConnected(0, i)) {
                res.Add(i);
            }
        }

        return res;
    }
}