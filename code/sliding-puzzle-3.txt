		public int SlidingPuzzle(int[][] board)
        {

            const string target = "123450";

            string v = string.Concat(board.SelectMany(u => u));

            if (v == target) return 0;

            Stack<(int zeroIndex, string build)> curr = new Stack<(int, string)>(), next = new Stack<(int zeroIndex, string build)>();

            ISet<string> visited = new HashSet<string>
            {
                v
            };

            curr.Push((v.IndexOf('0'), v));

            int res = 1;
            var success = Bfs(curr, next, () => { res++; }, currV =>
            {
                int i = currV.zeroIndex;
                var chars = currV.build.ToCharArray();
                if (i >= 3) // change top
                    Help(chars, i, i - 3);
                else // change bottom
                    Help(chars, i, i + 3);
                if (i % 3 != 0) // change left
                    Help(chars, i, i - 1);
                if (i % 3 != 2) // change right
                    Help(chars, i, i + 1);
                return false;
            });

            return success ? res : -1;

            bool Help(char[] arr, int sourceIndex,int targetIndex)
            {
                char[] newChars = (char[])arr.Clone();
                var c = newChars[sourceIndex];
                newChars[sourceIndex] = newChars[targetIndex];
                newChars[targetIndex] = c;

                var str = new string(newChars);

                if (str == target)
                    return true;

                if (visited.Add(str)) next.Push((targetIndex, str));

                return false;
            }
        }
		
		public static bool Bfs<T>(Stack<T> curr, Stack<T> next, Action moveToNext, Func<T, bool> coreFunc)
        {
            while (curr.Count > 0)
            {

                while (curr.Count > 0)
                    if (coreFunc(curr.Pop())) return true;

                var t = curr;
                curr = next;
                next = t;
                moveToNext();
            }
            return false;
        }