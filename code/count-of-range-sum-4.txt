using LL = long long ;
class Solution {
    vector<LL>tmp ;
    int lower, upper ;
    int DivideConque(vector<LL>&presum, int lo, int hi){
        if(lo >= hi)
            return 0 ;
        int ret = 0 ;
        int mid = lo + (hi - lo)/2 ;
        ret += DivideConque(presum, lo, mid) ;
        ret += DivideConque(presum, mid+1, hi) ;
        for(int i = lo; i <= mid; i++){
            auto it1 = lower_bound(presum.begin() + mid+1, presum.begin()+hi+1, presum[i]+lower) ;
            auto it2 = upper_bound(presum.begin() + mid+1, presum.begin()+hi+1, presum[i]+upper) ;
            ret += it2 - it1 ;
        }
        int p = lo, q = mid+1 ;
        int idx = 0 ;
        while(p <= mid && q <= hi){
            if(presum[p] < presum[q]){
                tmp[idx] = presum[p++] ;
                idx++ ;
            }
            else{
                tmp[idx] = presum[q++] ;
                idx++ ;
            }
        }
        while(p <= mid){
            tmp[idx] = presum[p++] ;
            idx++ ;            
        }
        while(q <= hi){
            tmp[idx] = presum[q++] ;
            idx++ ;            
        }
        idx = 0 ;
        for(int i = lo ; i <= hi; i++)
            presum[i] = tmp[idx++] ;
        
        return ret ;
    }
public:
    int countRangeSum(vector<int>& nums, int lower, int upper) {
        int n = nums.size() ; 
        tmp.resize(n+1) ;
        this->lower = lower ;
        this->upper = upper ;
        vector<LL>presum(n+1) ;
        for(int i = 0; i < n; i++)
            presum[i+1] = presum[i] + nums[i] ;
        
        return DivideConque(presum, 0, n) ;
    
    }
};