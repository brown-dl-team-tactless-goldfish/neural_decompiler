        public class Solution
        {
            private bool IsPalindrome(ulong num)
            {
                checked
                {
                    int digitsCount = (int) Math.Floor(Math.Log10(num)) + 1;
                    int[] digits = new int[digitsCount];
                    int idx = 0;
                    while (num != 0)
                    {
                        digits[idx++] = (int) (num % 10);
                        num /= 10;
                    }

                    int i = 0;
                    int j = digitsCount - 1;
                    while (i < j)
                    {
                        if (digits[i] != digits[j])
                        {
                            return false;
                        }

                        i++;
                        j--;
                    }

                    return true;
                }
            }

            private void GeneratePalindrome(ulong tmp, int left, int right, ulong max, ulong rootMax, out bool overflow, ref ulong res)
            {
                checked
                {
                    overflow = false;
                    int start = 0;
                    if (left == 0)
                    {
                        start = 1;
                    }

                    if (left > right)
                    {
                        if (tmp > rootMax)
                        {
                            overflow = true;
                            return;
                        }

                        try
                        {
                            var sq = tmp * tmp;
                            if (sq > max)
                            {
                                overflow = true;
                                return;
                            }

                            if (IsPalindrome(sq))
                            {
                                res++;
                            }

                            return;

                        }
                        catch (OverflowException)
                        {
                            overflow = true;
                            return;
                        }
                    }

                    for (int i = start; i <= 9; i++)
                    {
                        ulong diff = (ulong)Math.Pow(10, left) * (ulong)i;

                        if (left != right)
                        {
                            diff += (ulong)Math.Pow(10, right) * (ulong)i;
                        }

                        tmp += diff;
                        GeneratePalindrome(tmp, left + 1, right - 1, max, rootMax, out overflow, ref res);
                        tmp -= diff;
                    }
                }
            }

            private ulong Helper(ulong num)
            {
                int digitsCount = (int)Math.Floor(Math.Log10(num)) + 1;
                ulong root = (ulong)Math.Ceiling(Math.Sqrt(num));
                ulong res = 0;

                for (int i = 1; i <= digitsCount; i++)
                {
                    GeneratePalindrome(0, 0, i - 1, num, root, out bool overflow, ref res);
                    if (overflow)
                    {
                        break;
                    }
                }

                return res;
            }

            public int SuperpalindromesInRange(string l, string r)
            {
                checked
                {
                    ulong low = ulong.Parse(l);
                    ulong high = ulong.Parse(r);
                    ulong res = 0;
                    res = Helper(high) - Helper(low);

                    if (IsPalindrome(low))
                    {
                        var root = (ulong)Math.Floor(Math.Sqrt(low));
                        if (root * root == low && IsPalindrome(root))
                        {
                            res++;
                        }
                    }

                    return (int)res;
                }
            }
        }