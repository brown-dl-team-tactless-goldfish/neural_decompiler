class Solution {
public:
    typedef long long ll;
    const int mod = 1e9 + 7;
    
    vector<int> arr;
    vector<ll> seg;
    int maxN;
    
    // Function to build segment tree, storing the product of elements in range
    void build(int i, int low, int high) {
        if(low == high) {
            seg[i] = arr[low];
            return;
        }
        int mid = (low + high) / 2;
        build(i * 2 + 1, low, mid);
        build(i * 2 + 2, mid + 1, high);
        seg[i] = (seg[i * 2 + 1] * seg[i * 2 + 2]) % mod;
    }
    
    ll find(int i, int low, int high, int l, int r) {
        if(low >= l && high <= r)
            return seg[i];
        if(high < l || low > r)
            return 1;
        int mid = (low + high) / 2;
        ll left = find(i * 2 + 1, low, mid, l, r) % mod;
        ll right = find(i * 2 + 2, mid + 1, high, l, r) % mod;
        return (left * right) % mod;
    }
    
    vector<int> productQueries(int n, vector<vector<int>>& queries) {
        // Creating power array
        for(int i = 0; i < 31; i++) {
            int mask = 1 << i;
            if(n & mask)
                arr.push_back(mask);
        }
        // Creating segment tree
        maxN = arr.size();
        seg = vector<ll> (maxN * 4 + 10, 1);
        build(0, 0, maxN - 1);
        vector<int> ans;
        // Querying over segment tree to create the answer vector 
        for(auto it : queries) {
            ll f = find(0, 0, maxN - 1, it[0], it[1]);
            ans.push_back(f % mod);
        }
        return ans;
    }
};