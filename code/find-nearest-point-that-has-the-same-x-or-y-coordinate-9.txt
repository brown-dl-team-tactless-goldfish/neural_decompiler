class Solution {
public:
    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {
        using T = std::vector<int>;
        auto manhattan = [&](const std::vector<int>& p) {
            return std::abs(x - p[0]) + std::abs(y - p[1]);  
        };
        
        auto cmp = [&](const T& left, const T& right) {
            return manhattan(left) > manhattan(right);
        };
        
        std::priority_queue<T, std::vector<T>, decltype(cmp)> pq(cmp);
        
        for (int i = 0; i < points.size(); ++i) {
            auto& p = points[i];
            p.push_back(i);  // Store the index, since we have to return the index. 
            
            // Must share the same x-coordinate or the same y-coordinate to consider.
            if (p[0] == x || p[1] == y) pq.push(p);
        }
        if (pq.empty()) return -1;
        
        return pq.top()[2];
    }
};