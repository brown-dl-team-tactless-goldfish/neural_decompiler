public class Solution
{

	Dictionary<int, IList<int>> _graph = new Dictionary<int, IList<int>>();
	IList<IList<int>> _criticalConnections = new List<IList<int>>();
	int?[] _discoveredNodeOrder;

	public IList<IList<int>> CriticalConnections(int n, IList<IList<int>> connections)
	{
		_discoveredNodeOrder = new int?[n];
		foreach (var c in connections) // load all connections into dictionary, fast to query
		{
			int u = c[0];
			int v = c[1];

			if (!_graph.ContainsKey(u))
				_graph[u] = new List<int>();
			if (!_graph.ContainsKey(v))
				_graph[v] = new List<int>();

			_graph[u].Add(v);
			_graph[v].Add(u);
		}
		Dfs(0, null, 0);
		return _criticalConnections;

	}

	private int Dfs(int node, int? prevNode, int currDiscoveryOrder)
	{
		_discoveredNodeOrder[node] = currDiscoveryOrder;

		foreach (var nextNode in _graph[node])
		{
			if (nextNode == prevNode) continue;
			int childLowLink = 0;
			if (_discoveredNodeOrder[nextNode].HasValue)
				childLowLink = _discoveredNodeOrder[nextNode].Value;
			else
			{
				int childDiscoveredOrder = currDiscoveryOrder + 1;
				childLowLink = Dfs(nextNode, node, childDiscoveredOrder);
				if (childLowLink > currDiscoveryOrder)
				{
					_criticalConnections.Add(new List<int> { node, nextNode });
				}
			}
			_discoveredNodeOrder[node] = Math.Min(_discoveredNodeOrder[node].Value, childLowLink);
		}

		return _discoveredNodeOrder[node].Value;
	}
}