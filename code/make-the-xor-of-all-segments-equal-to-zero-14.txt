class Solution {
public:
    int res;
    int minChanges(vector<int>& nums, int k) {
        vector<unordered_map<int,int>> freq(k);
        vector<int> max_save_suffix(k,0), max_save(k,0);
        
        for (int i = 0; i < nums.size();i++){
            freq[i%k][nums[i]] ++;
        }
        for (int i = 0; i < k ;i++){
            for (auto &it : freq[i]){
                max_save[i] = max(max_save[i],it.second);
            }
        }
        max_save_suffix[k-1] = max_save[k-1];
        for (int i = k-2; i >= 0 ; i--){
            max_save_suffix[i] = max_save_suffix[i+1] + max_save[i];
        }
        ### case 1:
        res = max_save_suffix[0] - *min_element(max_save.begin(),max_save.end());
		### case 2:
        DFS(0,0,0,freq,max_save_suffix);
        return nums.size()-res;
    }
    
	
    void DFS(int i, int state, int cur_save, vector<unordered_map<int,int>> &freq, vector<int> &max_save_suffix){
        if (i == max_save_suffix.size() ){
            if (state == 0){
                res = max(res,cur_save);
            }
        }
        else if (cur_save+max_save_suffix[i] > res){
            for (auto it : freq[i]){
                DFS(i+1,state^it.first,cur_save+it.second,freq,max_save_suffix);
            } 
        }
    }
};