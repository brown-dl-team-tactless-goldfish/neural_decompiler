class Solution {
private:
    vector<vector<int>>dist;
    vector<vector<int>>adj;
    
	/*
	Floyd Warshall method to calculate shortest distance 
	from each node to each other node.
	@params int n
	@params vector<vector<int>>edges
	@return void
	*/
    void preComputeDist(int n, vector<vector<int>>edges){
        dist = vector<vector<int>>(n+1,vector<int>(n+1,INT_MAX));
        for(auto v:edges){
            dist[v[0]][v[1]]=1;
            dist[v[1]][v[0]]=1;
        } 
        
        for(int k=1;k<=n;k++){
            for(int i=1;i<=n;i++){
                for(int j=1;j<=n;j++){
                    if(i==j){
                        dist[i][j]=0;
                    }else{
                        if(dist[i][k]!=INT_MAX && dist[k][j]!=INT_MAX){
                            dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);
                        }
                    }
                }
            }
        }
        
        return;
    }
    
	/*
	Finds distance from each node of set,
	to each other node of set and 
	returns the maximum of all distance
	@params set<int>s
	@return int
	*/
    int maxDist(set<int>s){
        int ans=0;
        for(auto it1:s){
            for(auto it2:s){
                ans = max(ans,dist[it1][it2]);
            }
        }
        return ans;
    }
    
	/*
	Creates adjacency matrix from the given edges.
	@params int n
	@params vector<vector<int>>edges
	@return void
	*/
    void makeAdjMatrix(int n, vector<vector<int>>edges){
        adj = vector<vector<int>>(n+1);
        for(auto v:edges){
            adj[v[0]].push_back(v[1]);
            adj[v[1]].push_back(v[0]);
        }
        return;
    }
    
	/*
	@params int node
	@params int par
	@params int[] vis
	@return void
	*/
    void dfs(int node, int par, int *vis){
        for(auto it:adj[node]){
            if(it!=par && vis[it]){
                vis[it]=2;
                dfs(it, node, vis);
            }
        }
    }
    
	/*
	For a given subset, it returns true if the subset is
	valid subtree or not.
	@params int n
	@params set<int>s
	@return bool
	*/
    bool validSubtree(int n, set<int>s){
        int start = *s.begin();
        int vis[n+1];
        memset(vis,0,sizeof(vis));
        for(auto it:s){
            vis[it]=1;
        }
        vis[start]=2;
        dfs(start, -1, vis);
        int cnt=0;
        for(int i=1;i<=n;i++)cnt+=vis[i];
        if(cnt==2*s.size())return true;
        return false;
    }
    
public:

	/*
	@params int n
	@params vector<vector<int>>edges
	@return vector<int>
	*/
    vector<int> countSubgraphsForEachDiameter(int n, vector<vector<int>>& edges) {
        vector<int>ans(n-1);
        
		//create adj matrix
        makeAdjMatrix(n,edges);
		
		//store shortes dist from each 
		//node to each other node
        preComputeDist(n,edges);
        
		//generate all subsets.
        for(int i=0;i<(1<<n);i++){
            set<int>s;
            for(int j=0;j<n;j++){
                if(i&(1<<j)){
                    s.insert(j+1);
                }
            }
			
			//for each generated subsets,
			//check if it is valid subset or not.
            if(s.size()>1 && validSubtree(n,s)){
			
				//find the maximum distance (Maximum diameter)
				//of the subset.
                int dist = maxDist(s);
                ans[dist-1]++;
            }
        }
        
        return ans;
    }
};