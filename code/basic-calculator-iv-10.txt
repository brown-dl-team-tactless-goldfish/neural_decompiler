struct Term {
    int factor;
    vector<string> names;
    operator string() const {
        string res = to_string(factor);
        for (const string& name : names) {
            res += "*";
            res += name;
        }
        return res;
    }
    
    bool operator<(const Term& rhs) const {
        return names.size() > rhs.names.size() || (names.size() == rhs.names.size() && names < rhs.names);
    }
    
    Term operator*(const Term& rhs) const {
        Term res;
        res.factor = factor * rhs.factor;
        res.names = names;
        res.names.insert(res.names.end(), rhs.names.begin(), rhs.names.end());
        sort(res.names.begin(), res.names.end());
        return res;
    }
    
    bool can_join(const Term& rhs) const {
        return names == rhs.names;
    }
    
    void join(const Term& rhs) {
        factor += rhs.factor;
    }
};

class Solution {
public:
    void append(vector<Term>& cur, vector<Term>&& nxt) {
        if (cur.empty()) {
            cur = std::move(nxt);
        } else {
            cur = mul(cur, nxt);
        }
    }
    
    void negate(vector<Term>& ts) {
        for (Term& t : ts)
            t.factor = -t.factor;
    }
    
    vector<Term> calc(int& idx) {
        vector<Term> res;
        bool neg = false;
        for (vector<Term> cur;;) {
            if (isdigit(expr[idx])) {
                int val = 0;
                while (isdigit(expr[idx])) {
                    val = 10 * val + expr[idx] - '0';
                    ++idx;
                }
                Term t;
                t.factor = val;
                append(cur, {t});
            } else if (isalpha(expr[idx])) {
                string name;
                while (isalpha(expr[idx])) {
                    name.push_back(expr[idx]);
                    ++idx;
                }
                Term t;
                t.factor = 1;
                if (vals.count(name))
                    t.factor = vals[name];
                else
                    t.names.push_back(name);
                append(cur, {t});
            } else if (expr[idx] == '*') {
                idx += 2;
            } else if (expr[idx] == '(') {
                ++idx;
                vector<Term> ts = calc(idx);
                append(cur, std::move(ts));
            } else {
                // '+' or '-'.
                if (neg)
                    negate(cur);
                res.insert(res.end(), cur.begin(), cur.end());
                cur.clear();
                neg = expr[idx] == '-';
                idx += 2;
            }
            if (idx >= expr.size() || expr[idx] == ')') {
                if (neg)
                    negate(cur);
                res.insert(res.end(), cur.begin(), cur.end());
                ++idx;
                return res;
            }
            if (expr[idx] == ' ')
                ++idx;
        }
        return res;
    }

    void reduce(vector<Term>& terms) {
        sort(terms.begin(), terms.end());
        int j = 0;
        for (int i = 1; i < terms.size(); ++i) {
            if (terms[j].can_join(terms[i])) {
                terms[j].join(terms[i]);
            } else {
                ++j;
                if (j != i)
                    terms[j] = std::move(terms[i]);
            }
        }
        terms.resize(j + 1);
    }
    
    vector<Term> mul(const vector<Term>& v1, const vector<Term>& v2) {
        vector<Term> res;
        for (int i = 0; i < v1.size(); ++i) {
            for (int j = 0; j < v2.size(); ++j) {
                res.push_back(v1[i] * v2[j]);
            }
        }
        reduce(res);
        return res;
    }

    vector<string> basicCalculatorIV(string expression, vector<string>& evalvars, vector<int>& evalints) {
        expr = expression;
        vals.clear();
        for (int i = 0; i < evalvars.size(); ++i)
            vals[evalvars[i]] = evalints[i];
        int idx = 0;
        vector<Term> raw = calc(idx);
        reduce(raw);
        vector<string> res;
        for (const auto& term : raw) {
            if (term.factor != 0)
                res.push_back(string(term));
        }
        return res;
    }

    string expr;
    unordered_map<string, int> vals;
};