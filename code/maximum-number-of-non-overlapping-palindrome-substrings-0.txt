 int n = s.size();
        vector<pair<int,int>> vec;    //**** vector to store start & end indices of all valid palindromes
        vector<vector<int>> dp(n,vector<int>(n,0));
        for(int i =0;i<n;i++){
            dp[i][i] = 1;
            if(k==1)
            vec.push_back({i,i});
        }
        
        
       for(int j = 1;j<= n;j++){   //***** dp approach to find what are the start and end indices of palindromes
        for(int i=0;i<n;i++){
            if(i+j>=n)break;
            if(s[i]==s[i+j]){
                if(i+1 <= i+j-1)
                    dp[i][i+j]  =dp[i+1][i+j-1];
                
                else{
                    dp[i][i+j] = 1;
                }  
            } 
            if(dp[i][i+j]==1 && j>= k-1)    //** push in vec only if size of pal is >= k
                vec.push_back({i+j,i});    
        }
       }
        
        int res = 0;      //****  from the given palindrome indices select maximum number of non - overlapping
        sort(vec.begin(),vec.end());
        int end = -1;
        for(pair<int,int> &p:vec){   //*** this is a greedy way to find (same as maximum meetings in a room )
         if(p.second>end){
             end = p.first;
             res++;
          }        
        }
        
     
        return res;