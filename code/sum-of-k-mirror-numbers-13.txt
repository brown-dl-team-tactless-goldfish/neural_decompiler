digits = [str(i) for i in range(10)]
class Solution:
    def convert_baseK_to_base10(self, s, k):
        ret = 0
        for c in s:
            ret *= k
            ret += int(c)
        return ret

    
    def is_mirror_base10_number(self, s):
        k = len(s) // 2
        return len(s) == 1 or s[:k] == s[-k:][::-1]
        
            
    def get_this_length_ret(self, length_, k):
        """
        Get mirror numbers with lenght of length_
        """
        if length_ == 1:return list(range(1, k))
		# construct all possible candidates for left mirror, then the right will be the reverse of the candidate.
        left = ("".join(candidate) for candidate in list(itertools.product(digits[:k], repeat = length_ // 2)))
       
        if length_ % 2 == 0:
            ret = [element + element[::-1] for element in left]
        else:
            ret = [element + str(i) + element[::-1] for element in left 
                                                    for i in range(k)]
        # check whether base k is valid
        ret = [self.convert_baseK_to_base10(element, k) for element in ret 
                                        if element[0] != "0"]
        # check whether base 10 is valid
        ret = [element for element in ret 
                       if self.is_mirror_base10_number(str(element))]
        return ret
            
    def kMirror(self, k: int, n: int) -> int:
        ret = []
		# construct number with a specified length. 
        for length_ in range(1, 1000000):
            ret += self.get_this_length_ret(length_, k)
            if len(ret) >= n:
                return sum(sorted(ret)[:n])