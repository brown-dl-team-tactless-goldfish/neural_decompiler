class Solution {
    const int INF = 1e9+7;
    int dp[5][7][7][1<<5][1<<5];
    int recur(int idx, int x, int y, int mask1, int mask2, int m, int n) {
        if(idx<0)
            return 0;
        if(dp[idx][x][y][mask1][mask2]!=-1)
            return dp[idx][x][y][mask1][mask2];
        int ans = -INF, mask;
        for(int maskx=0; maskx<(1<<n); maskx++) {
            for(int masky=0; masky<(1<<n); masky++) {
                if(maskx&masky)
                    continue;
                int p = __builtin_popcount(maskx);
                int q = __builtin_popcount(masky);
                if(p>x or q>y)
                    continue;
                int cur = 120*p+40*q;
                mask = maskx|masky;
                int m = mask1|mask2;
                for(int i=0; i<n; i++) {
                    int l = ((mask&(mask>>1))>>i)&1;
                    int r = ((mask&(mask<<1))>>i)&1;
                    if((maskx>>i)&1) {
                        cur = cur-l*30-r*30;
                        if((m>>i)&1)
                            cur -= 30;
                    }
                    if((masky>>i)&1) {
                        cur = cur+l*20+r*20;
                        if((m>>i)&1)
                            cur += 20;
                    }
                    if(((mask1>>i)&1) and ((mask>>i)&1))
                        cur -= 30;
                    if(((mask2>>i)&1) and ((mask>>i)&1))
                        cur += 20;
                }
                ans = max(ans, cur+recur(idx-1, x-p, y-q, maskx, masky, m, n));
            }
        }
        return dp[idx][x][y][mask1][mask2] = ans;
    }
public:
    int getMaxGridHappiness(int m, int n, int x, int y) {
        memset(dp, -1, sizeof(dp));
        return recur(m-1, x, y, 0, 0, m, n);
    }
};   