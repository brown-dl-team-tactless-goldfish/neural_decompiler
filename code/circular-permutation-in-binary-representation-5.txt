#include<bits/stdc++.h>
using namespace std;

vector<int> ans , myans;
unordered_map<int,int> mpp;
int n, start;

void solve(int current , int picked)
{

    int maxx = (1 << n) - 1;
    if(myans.size()) return;
    //cout << " curr " << current << " picked " << picked << endl ;
    if(picked == (1 << n)){
        myans = ans;
        return ;
    }

    /// either we add one bit to current or subtract one bit from the current
    /// add one bit
    int curr = current;
    for(int i = 0 ; i <= 16 ; ++i){
        int foo = curr & (1 << i);
        if(foo == 0){
            int res = curr | ( 1 << i);
            if(res > maxx) continue;
            if(mpp[res] == 0){
                if(picked < ((1 << n) - 1)){
                    mpp[res] = 1;
                    ans.push_back(res);
                    solve(res , picked+1);
                    ans.pop_back();
                    mpp[res] = 0;
                }
                else {
                    int p0 = __builtin_popcount(start);
                    int p2n = __builtin_popcount(res);
                    int diff = abs(p0 - p2n);
                    if(diff == 1){
                        mpp[res] = 1;
                        ans.push_back(res);
                        solve(res, picked+1);
                        ans.pop_back();
                        mpp[res] = 0;
                    }
                }
            }
        }
        else if(foo){
            int res = curr ^ (1 << i);
            if(res > maxx) continue;
            if(mpp[res] == 0){
                if(picked < ((1 << n) - 1)){
                    mpp[res] = 1;
                    ans.push_back(res);
                    solve(res, picked+1);
                    ans.pop_back();
                    mpp[res] = 0;
                }
                else {
                    int p0 = __builtin_popcount(start);
                    int p2n = __builtin_popcount(res);
                    int diff = abs(p0 - p2n);
                    if(diff == 1){
                        mpp[res] = 1;
                        ans.push_back(res);
                        solve(res , picked + 1) ;
                        ans.pop_back();
                        mpp[res] = 0 ;
                    }
                }
            }
        }
    }
    return ;
}


class Solution {
public:
    vector<int> circularPermutation(int nn, int startt) {
        n = nn ; 
        start = startt; 
        mpp.clear();
        myans.clear();
        ans.clear();
        ans.push_back(start);
        mpp[start] = 1;
        solve(start, 1);
        return myans; 
            
    }
};