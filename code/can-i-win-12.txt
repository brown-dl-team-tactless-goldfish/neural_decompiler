var canIWin = function(maxChoosableInteger, desiredTotal) {
    if (desiredTotal <= 0 || maxChoosableInteger >= desiredTotal) return true;
    if ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal) return false; // unwinnable 

    var gameStates = {},    // hash of used-key => true/false
    used = 0;                      // each bit represents a used value (max 128 bits)
    
    // Our helper function
    var helper = function (runningTotal) {
        if (runningTotal <= 0) return false;
        var key = used;
        if (!gameStates.hasOwnProperty(key)) {
            for (var i = 1; i <= maxChoosableInteger; ++i) {
                if (!isUsed(i)) {
                    setUsed(i);
                    if (!helper(runningTotal - i)) {
                        gameStates[key] = true;
                        clearUsed(i);    // reset the state of used values
                        return true;        // return true as soon as we find
                                            // a winning combo
                    }
                    clearUsed(i);    // reset the state of used values
                }
            }
            gameStates[key] = false; // If we make this through the loop without
                                     // returning true, then it's a false
        }
        return gameStates[key];
    };
    
    var isUsed = function (i) {
        return ((used & (1 << (i - 1))) !== 0);
    };
    
    var setUsed = function (i) {
        return used |= (1 << (i - 1));
    };
    
    var clearUsed = function (i) {
        return used &= ~(1 << (i - 1));
    };
    
    return helper(desiredTotal);
};