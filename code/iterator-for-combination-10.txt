class CombinationIterator {
public:
    
    vector<bool> bits ; // to decide whether ith char is prent in current combination
    int n ;
        
    bool possible ; // for has next or not
    string str ;
    
    int len ;  // length of required combination
    
    CombinationIterator(string characters, int combinationLength)
    {
        possible = true ;
        str = characters ;
        len = combinationLength ;
        n = str.size() ;
        bits.resize(n,false) ; // size n , fill with 0 -> false 
        
        
        //making first len bits true, since it forms the first permutation
        for(int i=0;i<len;i++)
            bits[i] = true ;
    }
    
    string next()
    {
        string ans = "" ;
        
        // finding the current combination (foynd from current state of bits vector)
        for(int i=0;i<n;i++)
            if(bits[i])
                ans+=str[i] ;
        
        // we have got the answer already.
        // but now bits vector should represent next combination, not the current one anymore
        // so doing that computation before returning the answer
        
        
        // last bit is not set (i.e. 0)
        if(!bits[n-1])
        {
            // just shift the last one to right one step and return 
            for(int i=n-1;i>=0;i--)
            {
                if(bits[i])
                {
                    bits[i+1] = 1 ; bits[i] = 0 ; break ;
                }
            }
            
            return ans ;
        }
        
        // count consecutive ones at the right end, and make them zero
        // now find the right most one and shift it one step right
        // and place those number of ones that we made 0 previously just after the rightmost one
        
        int count = 0 ; // number of consecutive ones at right end
        
        for(int i=n-1;i>=0;i--)
        {
            if(!bits[i])
                break ;
            bits[i] = 0 ;
            count++ ;
        }
        
        // if all are ones, the next combination is not possible
        if(count == len)
        {
            possible = false ;
            return ans ;
        }
        
        // finding the right most 1 
        for(int i=n-1;i>=0;i--)
        {
            if(bits[i])
            {
                bits[i+1] = 1 ;
                bits[i] = 0 ;
                
                i = i+2 ;
                while(count--)
                {
                    bits[i] = 1 ;
                    i++ ;
                }
                
                break ;
            }
        }
        
        return ans ;
        
    }
    
    bool hasNext()
    {
        return possible ;
        
    }
};
