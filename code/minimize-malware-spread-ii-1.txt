    public class Solution
    {
        private class Unions
        {
            private readonly int[] _parents;
            private readonly int[] _ranks;

            public Unions(int n)
            {
                _parents = new int[n];
                _ranks = new int[n];
                for (int i = 0; i < n; i++)
                {
                    _parents[i] = i;
                }
            }

            public int Find(int x)
            {
                if (x != _parents[x])
                {
                    x = Find(_parents[x]);
                }
                return _parents[x];
            }

            public bool Union(int x, int y)
            {
                int px = Find(x);
                int py = Find(y);
                if (px == py)
                {
                    return false;
                }
                if (_ranks[px] > _ranks[py])
                {
                    _parents[py] = px;
                    _ranks[px]++;
                }
                else
                {
                    _parents[px] = py;
                    _ranks[py]++;
                }
                return true;
            }
        }

        private void Dfs(int[][] graph, int node, bool[] visited, Unions dsu, ISet<int> initial)
        {
            if (visited[node] || initial.Contains(node))
            {
                return;
            }

            visited[node] = true;
            for (int i = 0; i < graph[node].Length; i++)
            {
                if (graph[node][i] == 1)
                {
                    if (!initial.Contains(i))
                    {
                        dsu.Union(node, i);
                        Dfs(graph, i, visited, dsu, initial);
                    }
                }
            }
        }

        public int MinMalwareSpread(int[][] graph, int[] initial)
        {
            int length = graph.Length;
            var initialSet = initial.ToHashSet();
            bool[] visited = new bool[length];
            Unions dsu = new Unions(length);
            for (int i = 0; i < length; i++)
            {
                Dfs(graph, i, visited, dsu, initialSet);
            }

            IDictionary<int, IList<int>> components = new Dictionary<int, IList<int>>();
            for (int i = 0; i < length; i++)
            {
                var root = dsu.Find(i);
                if (!initialSet.Contains(i))
                {
                    if (!components.ContainsKey(root))
                    {
                        components[root] = new List<int>();
                    }
                    components[root].Add(i);
                }
            }

            IDictionary<int, ISet<int>> root2AdjInfectedNodes = new Dictionary<int, ISet<int>>();
            IDictionary<int, ISet<int>> inf2AdjComponents = new Dictionary<int, ISet<int>>();

            foreach (var inf in initial)
            {
                inf2AdjComponents[inf] = new HashSet<int>();
                for (int i = 0; i < graph[inf].Length; i++)
                {
                    if (graph[inf][i] == 1 && !initialSet.Contains(i))
                    {
                        var root = dsu.Find(i);
                        if (!root2AdjInfectedNodes.ContainsKey(root))
                        {
                            root2AdjInfectedNodes[root] = new HashSet<int>();
                        }

                        root2AdjInfectedNodes[root].Add(inf);
                        inf2AdjComponents[inf].Add(root);
                    }
                }
            }

            int? res = null;
            int? currCount = null;

            foreach (var inf in initial)
            {
                int c = 0;
                foreach (var adjRoot in inf2AdjComponents[inf])
                {
                    if (root2AdjInfectedNodes[adjRoot].Count == 1)
                    {
                        c += components[adjRoot].Count;
                    }
                }

                if (c > 0)
                {
                    res = res ?? inf;
                    currCount = currCount ?? c;

                    if (c > currCount)
                    {
                        currCount = c;
                        res = inf;
                    }
                    else
                    {
                        if (c == currCount && inf < res)
                        {
                            currCount = c;
                            res = inf;
                        }
                    }

                }
            }

            return res.GetValueOrDefault(initial.Min());
        }
    }