class Solution {
     vector<int> parent;
     vector<int> rank;
public:
    vector<bool> friendRequests(int n, vector<vector<int>>& b, vector<vector<int>>& r)
    {
        vector<bool> ans;
        //int n = g.size();
        parent.resize( n, -1);
        // all nodes are parent of themselves inititally, if parent[u] = -k thne u is leader of grp of k nodes
        rank.resize( n, 1); // initially no node is connected hence rank is 1 for all
        
        // edges
        for( int i =0 ; i < r.size() ; i ++)
           {
                int p1 = find(r[i][0]);
                int p2 = find(r[i][1]);
                // if this req doesnt violate any restriction, then this merger is valid
                int allowed =1;
                 for( int j =0 ; j < b.size() ; j ++)
                 {
                     int a = find(b[j][0]);
                     int b1 = find(b[j][1]);
                     // they shopuld be in diff grp that is theoir parents a/b shouldnt form pair {}
                    if( (a==p1 and b1 ==p2 ) or ( a==p2 and b1== p1) )
                       // not allowed
                       { allowed =0; break;}
                 }
                 if( allowed)
                       {
                        addedge(p1,p2);
                        ans.push_back( true);     
                       }   
                else
                    ans.push_back( false);     
            }
        return ans;
    }
    
    // start of template
    
     void addedge( int i , int j )
        {
            // add edge if their parents are diff
            if( find(i) == find(j))
                return; // same parents, also condition for cycle present
            else 
                merge( i , j);
        }
    int find( int u) // return parent of u 
    {
        if( parent[u] < 0 ) // it is its own parent
            return u;
        else 
            return parent[u] = find(parent[u]);
    }
    void merge( int u , int v )
    {
        // merge by rank
        int a = find(u); // find parent of both of them
        int b = find(v);
        if( a == b) // both have same parents
            return;
        int ra= rank[u]; // rank of parent a
        int rb = rank[v];
        if( ra > rb) // a has more nodes chain in its grp, hence add b in a's grp, to keep parent chain hierachy as sort as possible
        {
            parent[a] += parent[b]; //add nodes in b to nodes of a
            parent[b]=a;
        }
        else if( ra < rb) // a has more nodes chain in its grp, hence add b in a's grp, to keep parent chain hierachy as sort as possible
        {
            parent[b] += parent[a]; //add nodes in b to nodes of a
            parent[a]=b;
        
        }
        else // both have same rank
        {
            parent[a] += parent[b]; //add nodes in b to nodes of a
            parent[b]=a;
            rank[a]++;
        }
    }
};