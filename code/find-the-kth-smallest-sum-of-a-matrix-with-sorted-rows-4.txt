class Solution {
public:
    int kthSmallest(vector<vector<int>>& mat, int k) {
        //we will be pushing the first element of all rows since they are the smallest in each row and their sum would be the smallest
        set<vector<int>> visited;
        //set contains the vectors of indices in each row  which have visited
        using pi=pair<int,vector<int>>;
        pi pair;
        //we store p.first as the sum(the sum of elements from each row) 
        //p.second contains the indices of elements of the corresponding row
         int rows=mat.size();
         int cols=mat[0].size();
         //calculate the sum of first elements from each row
        int currSum=0;
        vector<int> v(rows,0);
        for(int i=0;i<rows;i++)
            currSum+=mat[i][0];
        pair={currSum,v};
        
        visited.insert(v);
        //we need min heap
        priority_queue<pi,vector<pi>,greater<pi>> pq;
        pq.push(pair);
        

        while(k)
        {
            auto [sum,vec]=pq.top();
            pq.pop();
            currSum=sum;
            //we check the next element after the ind in the row and calculate the sum and push it to the pq;
            //we remove the curr ind value from sum  and add the next index value to the sum 
            //we repeat this for every row
            for(int i=0;i<rows;i++)
            {
                int row=i;
                int ind=vec[i];
                if(ind<cols-1)
                {
                    vec[i]++;
                    if(!visited.count(vec)){
                        pq.push({sum-mat[row][ind]+mat[row][ind+1],vec});
                        visited.insert(vec);
                    }
                     vec[i]--;
                }
            }
            k--;
        }
        return currSum;
    }
};