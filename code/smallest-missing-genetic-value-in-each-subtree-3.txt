
class Solution {
public:
    vector<int> smallestMissingValueSubtree(vector<int>& parents, vector<int>& nums) {
        auto tree = getTree(parents);
        vector<int> res(parents.size(), 1);
        
        auto oneNode = find(nums.begin(), nums.end(), 1) - nums.begin();
        if (oneNode == nums.size()) {
            return res;
        }
        
        unordered_set<int> seen;
        int missing = 1;
        
        while (oneNode != -1) {
            dfs(tree, seen, nums, oneNode);

            while (seen.count(missing)) {
                ++missing;
            }
            
            res[oneNode] = missing;
            oneNode = parents[oneNode];
        }
        
        return res;
    }
    
private:
    vector<vector<int>> getTree(const vector<int>& parents) {
        vector<vector<int>> tree(parents.size());
        for (int node = 0; node < parents.size(); ++node) {
            if (parents[node] != -1) {
                tree[parents[node]].push_back(node);
            }
        }
        
        return tree;
    }
    
    void dfs(const vector<vector<int>>& tree, unordered_set<int>& seen, const vector<int>& nums, int node) {
        if (seen.count(nums[node])) {
            return;
        }
        seen.insert(nums[node]);
        for (auto child: tree[node]) {
            dfs(tree, seen, nums, child);
        }
    }
};
