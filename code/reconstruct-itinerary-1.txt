typedef struct  _TRIE      TRIE;
typedef struct  _TICKET    TICKET;

struct  _TICKET {
  char    *Name;
  TICKET  *Next;
};

struct     _TRIE {
  TICKET  *Next;
  char    *Name;
  TRIE    *Trie[26];
};


int MyStrCmp (char *Src, char *Dst) {
  int Index;

  for (Index = 0; Index < 3; Index++) {
    if (Src[Index] > Dst[Index]) {
      return 1;
    } else if (Src[Index] < Dst[Index]) {
      return -1;
    }
  }
  return 0;
}

void TrieInsert(TRIE* Head, char * Word) {
  TICKET   *Ticket;
  TICKET   *Node;
  TICKET   *Pre;

  Ticket = (TICKET *)calloc (1, sizeof (TICKET));
  Ticket->Name = Word;

  if (Head->Next == NULL) {
    Head->Next = Ticket;
    return;
  }
  Node = Head->Next;
  Pre = NULL;
  while (Node != NULL) {
    if (MyStrCmp (Node->Name, Ticket->Name) == 1) {
      if (Pre == NULL) {
        Ticket->Next = Head->Next;
        Head->Next   = Ticket;
      } else {
        Ticket->Next = Pre->Next;
        Pre->Next    = Ticket;
      }
      return;
    }
    Pre = Node;
    Node = Node->Next;
  }
  Pre->Next = Ticket;
}

TRIE * TrieCreate(TRIE* Head, char * Word) {
  int  Index;

  for (Index = 0; Index < 3; Index++) {
    if (Head->Trie[Word[Index] - 'A'] == NULL) {
      Head->Trie[Word[Index] - 'A'] = calloc (1, sizeof (TRIE));
    }
    Head =  Head->Trie[Word[Index] - 'A'];
  }
  Head->Name = Word;
  return Head;
}

TRIE * TrieSearch(TRIE  *Head, char *Word) {
  int  Index;

  for (Index = 0; Index < 3; Index++) {
    if (Head->Trie[Word[Index] - 'A'] == NULL) {
      return NULL;
    }
    Head = Head->Trie[Word[Index] - 'A'];
  }
  return Head;
}

bool Dfs (TRIE  *Head, char *Word, char **ReturnBuffer, int UsedSize, int Totalsize) {
  TRIE     *Trie;
  TICKET   *Node;
  TICKET   *Pre;
  TICKET   *Current;

  Trie = TrieSearch (Head, Word);
  Node = NULL;
  if (Trie != NULL) {
    Node = Trie->Next;
  }
  if (Node == NULL) {
    if (UsedSize != Totalsize) {
      return false;
    }
    return true;
  }

  Pre = NULL;
  while (Node != NULL) {
    Current = Node;
    //
    // remove node to indicate the node has been used.
    //
    if (Pre == NULL) {
      Trie->Next = Current->Next;
    } else {
      Pre->Next = Current->Next;
    }
    ReturnBuffer[UsedSize] = Current->Name;
    if (Dfs (Head, Current->Name, ReturnBuffer, UsedSize + 1, Totalsize)) {
      return true;
    }
    //
    // Insert node back to indicate the node has been not used.
    //
    if (Pre == NULL) {
      Current->Next = Trie->Next;
      Trie->Next = Current;
    } else {
      Current->Next = Pre->Next;
      Pre->Next     = Current;
    }
    Pre = Node;
    Node = Node->Next;
  }
  return false;
}
char ** findItinerary(char *** tickets, int ticketsSize, int* ticketsColSize, int* returnSize){

  TRIE     *Head;
  TRIE     *Node;
  char     **ReturnBuffer;
  char     *Start;
  int      Index;

  *returnSize = ticketsSize + 1;
  ReturnBuffer = (char **)malloc (*returnSize * sizeof (char *));

  //
  // Init graph.
  // 1. Using TRIE to store node because it only has 3 uupper case English letters.
  // 2. Sort from smaller lexical to higher lexical.
  // 3. Using List to store it so we can easy to remove and it back.
  //
  Head = (TRIE *)calloc (1, sizeof (TRIE));
  for (Index = 0; Index < ticketsSize; Index++) {
    Node = TrieSearch (Head, tickets[Index][0]);
    if (Node == NULL) {
      Node = TrieCreate(Head, tickets[Index][0]);
    }
    TrieInsert (Node, tickets[Index][1]);
  }
  //
  // Using DFS to find result, Once the first one is found. it must be the smallest
  // lexical order result so return true directly to terminate the search.
  //
  Start = (char *)malloc (4 * sizeof (char));
  strcpy (Start, "JFK");
  ReturnBuffer[0] = Start;
  Dfs (Head, Start, ReturnBuffer, 1, *returnSize);

  return ReturnBuffer;
}