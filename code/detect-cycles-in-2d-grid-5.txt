class Solution {
public:
    #define upper(c) ((c) >= 'A' && (c) <= 'Z')
    #define lower(c) ((c) >= 'a' && (c) <= 'z')
    #define to_upper(c) (lower((c)) ? (c) - 'a' + 'A' : (c))
    #define to_lower(c) (upper((c)) ? (c) - 'A' + 'a' : (c))
    
    //                                 00       01       10      11
    vector<vector<int>> directions = {{-1,0}, {1, 0}, {0, -1}, {0,1}};
    
    void dfs(vector<vector<char>>& grid, int row, int col, int len, int dir, int pdir, bool &res)
    {
        if(upper(grid[row][col]))
		{
			//if the length of current path is longer than 3 and you are not going back. then there is a cycle.
            res |= len > 2 && (dir ^ pdir) != 1;
            return;
        }
        
        char curr = grid[row][col];
        grid[row][col] = to_upper(grid[row][col]);
        for(int i = 0; i < directions.size(); i++)
        {
            int r = row + directions[i][0];
            int c = col + directions[i][1];
            if( r >= 0 && r < grid.size() && 
                c >= 0 && c < grid[r].size() && 
                (grid[r][c] == curr || grid[r][c] == to_upper(curr))) 
			{
                dfs(grid, r, c, len + 1, i, dir, res);
                if(res)
                    return;
            }
        }
    }
    
    bool containsCycle(vector<vector<char>>& grid) 
    {
        bool res = false;
        for(int i = 0; i < grid.size(); i++)
        {
            for(int j = 0; j < grid[i].size(); j++)
			{
                if(lower(grid[i][j]))
				{
                    dfs(grid, i, j, 0, -1, -1, res);
                    if(res)
                        break;
                }
            }
        }
            
        return res;
    }
};