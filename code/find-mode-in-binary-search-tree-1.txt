/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
void inorder(struct TreeNode* root, int* prev, int* num, int* max, int* size, int** maxlist, int* returnSize){
    
    if(root->left)
        inorder(root->left, prev, num, max, size, maxlist, returnSize);

    /*read an element of an increasing sorting list*/
    if(root->val == *prev){
       *num = (*num) +1;  
    }
    else{
        *num = 1;
        *prev = root->val;
    }
    
    if(*max < *num){
        
        *max = *num;
        (*maxlist)[0] = root->val;
        *returnSize = 1;
    }
    else if(*max == *num){
        
        (*maxlist)[*returnSize] = root->val;
        *returnSize = (*returnSize) + 1;
        if(*returnSize == *size){
            *size = (*size)*2;
            (*maxlist) = realloc((*maxlist), sizeof(int)*(*size));
            
        }
    }
    
    
    
    if(root->right)
        inorder(root->right, prev, num, max, size, maxlist, returnSize);
    
    
}

int* findMode(struct TreeNode* root, int* returnSize){

    /*1. prev  2. prenum  3. max  4. maxlist_size  5. maxlist  6. returnSize*/
    int* prev = malloc(sizeof(int));
    *prev = 0X80000000;
    
    int* num = malloc(sizeof(int));
    *num = 1;
    
    int* max = malloc(sizeof(int));
    *max = 0X80000000;
    
    int* size = malloc(sizeof(int));
    *size = 2;
    
    int** maxlist = malloc(sizeof(int*));
    *maxlist = malloc(sizeof(int)*(*size));
    memset((*maxlist),0,sizeof(int)*(*size));
    *returnSize = 0;
    
    inorder(root, prev, num, max, size, maxlist, returnSize);
    return *maxlist;
}