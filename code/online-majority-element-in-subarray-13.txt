struct SegTreeNode{
    int l;
    int r;
    int val;
    int count;
    SegTreeNode * left;
    SegTreeNode * right;
    SegTreeNode(int l,int r){
        this->l = l;
        this->r = r;
        this->val = 0;
        this->count = 0;
        this->left = NULL;
        this->right = NULL;
    }
};

bool pushupTree(SegTreeNode * root){
    if(!root){
        return false;
    }
        
    if(root->left){
        root->val = root->left->val;
        root->count = root->left->count;
    }
    if(root->right){
        if(root->val == root->right->val){
            root->count += root->right->count;
        }else if(root->count >= root->right->count){
            root->count -= root->right->count;
        }else if(root->count < root->right->count){
            root->val = root->right->val;
            root->count = root->right->count - root->count;
        }
    }
    
    return root;
}

SegTreeNode * buildTree(vector<int> & arr,int l,int r){
    if(l > r){
        return NULL;
    }
    
    SegTreeNode * root = new SegTreeNode(l,r);
    if(l == r){
        root->val = arr[l];
        root->count = 1;
        return root;
    }
    
    int mid = (l+r)/2;
    root->left = buildTree(arr,l,mid);
    root->right = buildTree(arr,mid+1,r);
    pushupTree(root);
    
    return root;
}

bool searchTree(SegTreeNode * root,int l,int r,int &key,int &count){
    if(!root || l > r){
        return false;
    }
    
    if(root->r < l && root-> l > r){
        return false;
    }
  
    int mid = (root->l + root->r)/2;
    if(root->l >= l && root->r <= r){
        if(root->val == key){
            count += root->count;
        }else if(root->count > count){
            key = root->val;
            count = root->count - count;
        }else if(root->count <= count){
            count -= root->count;
        }
        return true;
    }
    
    if(mid >= l){
       searchTree(root->left,l,r,key,count); 
    }
    if(r >= mid +1){
        searchTree(root->right,l,r,key,count);
    }
    
    return true;
}

class MajorityChecker {
public:
    MajorityChecker(vector<int>& arr) {
        for(int i = 0;i < arr.size(); ++i){
            idx[arr[i]].push_back(i);
        }
        root = buildTree(arr,0,arr.size()-1);
    }
    
    int query(int left, int right, int threshold) {
        int key = 0;
        int count = 0;
        searchTree(root,left,right,key,count);
        if(key == 0){
            return -1;
        }
        
        auto it_l = lower_bound(idx[key].begin(),idx[key].end(),left);
        auto it_r = upper_bound(idx[key].begin(),idx[key].end(),right);
        if(it_r - it_l >= threshold){
            return key;
        }else{
            return -1;
        }
    }
private:
    unordered_map<int,vector<int>> idx;
    SegTreeNode * root;
};

/**
 * Your MajorityChecker object will be instantiated and called as such:
 * MajorityChecker* obj = new MajorityChecker(arr);
 * int param_1 = obj->query(left,right,threshold);
 */