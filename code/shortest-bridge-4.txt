public class Solution {
    int r, c;
    Queue<int[]> q;
    int[] dirX, dirY;

    public int ShortestBridge(int[][] grid) {
        r = grid.Length;
        c = grid[0].Length;
        q = new Queue<int[]>();
        dirX = new int[]{1, -1, 0, 0};
        dirY = new int[]{0, 0, 1, -1};
        for (var i = 0; i < r; i++)
        {
            for (var j = 0; j < c; j++)
            {
                if (grid[i][j] == 1 && q.Count == 0)
                {
                    DFS(i, j, grid);
                }
            }
        }

        var cnt = 0;
        var visited = new bool[r][];
        for (var i = 0; i < r; i++)
            visited[i] = new bool[c];

        while (q.Count > 0)
        {
            int size = q.Count();
            for (var i = 0; i < size; i++)
            {
                var cell = q.Dequeue();
                for (var d = 0; d < 4; d++)
                {
                    var new_r = cell[0] + dirX[d];
                    var new_c = cell[1] + dirY[d];
                    if (new_r < 0 || new_c < 0 || new_r >= r || new_c >= c || visited[new_r][new_c])
                        continue;

                    if (grid[new_r][new_c] == 1)
                        return cnt;
                
                    q.Enqueue(new int[]{new_r, new_c});
                    visited[new_r][new_c] = true;
                }
            }

            cnt++;
        }

        return cnt;
    }

    private void DFS(int row, int col, int[][] grid)
    {
        q.Enqueue(new int[]{row, col});
        grid[row][col] = 0;
        for (var d = 0; d < 4; d++)
        {
            var new_r = row + dirX[d];
            var new_c = col + dirY[d];
            if (new_r < 0 || new_c < 0 || new_r >= r || new_c >= c || grid[new_r][new_c] == 0)
                continue;
            
            DFS(new_r, new_c, grid);
        }
    }
}