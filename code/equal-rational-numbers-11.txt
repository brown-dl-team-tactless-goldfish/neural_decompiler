class Solution {
public:
    bool isRationalEqual(string S, string T) {
        pair<long, long> p1 = convert(S);
        pair<long, long> p2 = convert(T);
        return p1.first == p2.first && p1.second == p2.second;
    }
    
    pair<long, long> convert(string s)
    {
        long numer = 0;
        long denum = 1;
        int state = 0; // 0: int part. 1: nonrepecting part. 2: repecting part
        // Get three different parts
        string int_par, nonr_par, r_par;
        for(int i = 0; i < s.size(); i++)
        {
            if(s[i] == '.' || s[i] == '(' || s[i] == ')')
            {
                state++;
                continue;
            }
            
            if(state == 0)
                int_par += string(1, s[i]);
            else if(state == 1)
                nonr_par += string(1, s[i]);
            else if (state == 2)
                r_par += string(1, s[i]);
        }
        
        // Convert three parts into fraction
        numer = stol(int_par);
        long base = pow(10, nonr_par.length());
        if(nonr_par.length())
        {
            long new_num = stol(nonr_par), new_denum = base;
            auto p = fraction_addition(numer, denum, new_num, new_denum);
            numer = p.first;
            denum = p.second;
        }
        if(r_par.length())
        {
            long new_num = stol(r_par), new_denum = (pow(10, r_par.length()) - 1) * base;
            auto p = fraction_addition(numer, denum, new_num, new_denum);
            numer = p.first;
            denum = p.second;
        }
        
        return make_pair(numer, denum);
    }
    
    pair<long, long> fraction_addition(long old_num, long old_denum, long new_num , long new_denum)
    {
        long numer = old_num * new_denum + old_denum * new_num;
        long denum = old_denum * new_denum;

        long g = __gcd(denum, numer);
        numer /= g;
        denum /= g;
        return make_pair(numer, denum);
    }
};