class Solution {
public:
    int n;
    unordered_map<int, int> hor, ver, d1, d2;
    unordered_set<long long> ps;
    void add(vector<int>& p) {
        hor[p[0]]++;
        ver[p[1]]++;
        d1[p[0] + p[1]]++;
        d2[p[0] - p[1]]++;
    }
    int check(vector<int>& p) {
        int x = p[0];
        int y = p[1];
        if (hor.count(x) > 0 && hor[x] > 0) return 1;
        if (ver.count(y) > 0 && ver[y] > 0) return 1;
        if (d1.count(x + y) > 0 && d1[x + y] > 0) return 1;
        if (d2.count(x - y) > 0 && d2[x - y] > 0) return 1; 
        return 0;
    }
    void close(int x, int y) {   
        if (x >= 0 && x < n && y >= 0 && y < n) {
            long long l = (((long long)x) << 32) | y;
            if (ps.count(l) == 0 ) return;
            ps.erase(l);
            hor[x]--;
            ver[y]--;
            d1[x + y]--;
            d2[x - y]--;
        }
    }
    vector<int> gridIllumination(int n1, vector<vector<int>>& lamps, vector<vector<int>>& queries) {
        n = n1;
        for (auto& l : lamps) {
            long long p = (((long long)l[0]) << 32) | l[1];
            if (ps.count(p) == 0) add(l);       
            ps.insert(p);
        }
        vector<int> ans;
        for (auto& q : queries) {
            int c = check(q);
            ans.push_back(c);
            for (int i = -1; i < 2; i++) {
                for (int j = -1; j < 2; j++) {
                    close(i + q[0], j + q[1]);
                }
            }
        }
        return ans;
    }
};