#define SIZE 101

struct trie_node {
    struct trie_node *child[26];
    int val;
    int leaf;
};

typedef struct {
    struct trie_node *root;
} MapSum;

struct database {
    int val;
    char str[100];
};

struct database base[SIZE];

/* calculate hash */
int get_idx(char *str)
{
    int pr = SIZE;
    int d = 256;
    int h = 0;
    
    for (int i = 0; i < strlen(str); i++) {
        char ch = str[i];
        h = (d * h + ch) % pr;
    }
    
    return h;
}

/** Initialize your data structure here. */

MapSum* mapSumCreate() {
    MapSum *obj = (MapSum *)malloc(sizeof(MapSum));
    obj->root = (struct trie_node *)malloc(sizeof(struct trie_node));
    for (int i = 0; i < 26; i++) {
        obj->root->child[i] = NULL;
    }
    memset(base, 0, sizeof(struct database) * SIZE);
    return obj;
}

void mapSumInsert(MapSum* obj, char * key, int val) {
    struct trie_node *temp = obj->root;
    
    for (int i = 0; i < strlen(key); i++) {
        char ch = key[i];
        if (temp->child[ch - 'a'] == NULL) {
            temp->child[ch - 'a'] = (struct trie_node *)malloc(sizeof(struct trie_node));
            for (int i = 0; i < 26; i++) {
                temp->child[ch - 'a']->child[i] = NULL;
            }
            temp->child[ch - 'a']->leaf = 0;
        }
        temp = temp->child[ch - 'a'];
    }
    
    temp->leaf = 1;
    temp->val = val;
    int idx = get_idx(key);
    base[idx].val = val;
    strcpy(base[idx].str, key);
}

int mapSumSum(MapSum* obj, char * prefix) {
    int sum = 0;
    int len = strlen(prefix);
    for (int i = 0; i < SIZE; i++) {
        if (memcmp(base[i].str, prefix, len) != 0)
            continue;
        sum += base[i].val;
    }
    
    return sum;
}

void mapSumFree(MapSum* obj) {
    //TODO
}

/**
 * Your MapSum struct will be instantiated and called as such:
 * MapSum* obj = mapSumCreate();
 * mapSumInsert(obj, key, val);
 
 * int param_2 = mapSumSum(obj, prefix);
 
 * mapSumFree(obj);
*/