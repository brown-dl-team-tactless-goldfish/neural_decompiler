class Solution {
public:
    int longestSubsequence(string s, int k) {
        int ret = 0;
        // How many 0 in the prefix in the subseq.
        int cnt0 = 0;
        
        // Convert k to binary string t.
        string t;
        int tmp = k;
        while(tmp){
            t += char('0' + tmp % 2);
            tmp>>=1;
        }
        reverse(t.begin(), t.end());
        
        // The position of the next 0;
        vector<int>nxt(s.size(), -1);
        int pos = -1;
        for(int i = s.size()-1;i>=0;i--){
            nxt[i] = pos;
            if(s[i]=='0')pos=i;
        }
        
        // Enumerate the position of the first 1 in the subseq.
        for(int i=0;i<s.size();i++){
            if(s[i]=='0'){
                cnt0++;
                continue;
            }
            
            // The length of the suffix starting from the first 1 is less than the length of binary string t.
            if(t.size()>1){
                int tmp = min(t.size()-1, s.size()-i);
                ret = max(ret, tmp + cnt0);
            }
            if(t.size()==1){
                ret = max(ret, 1 + cnt0);
            } else {
                // Find the smallest binary string that length is same as t using greedy.
                int pos = i;
                string tmp = "1";
                while(tmp.size()<t.size()&&pos+1<s.size()){
                    int x = nxt[pos];
                    if(x==-1||s.size()-x+tmp.size()<t.size()){
                        pos++;
                        tmp+=s[pos];
                    } else {
                        tmp+=s[x];
                        pos = x;
                    }
                }
                if(tmp<=t&&tmp.size()==t.size()){
                    ret = max(ret, cnt0 + (int)t.size());
                }
            }
        }
        ret = max(ret, cnt0);
        return ret;
    }
};