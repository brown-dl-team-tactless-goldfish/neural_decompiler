//This is based on a couple others..
//I take no credit other than the obvious refactoring.
//I deliberately chose the one that seemed easier to understand, not the fastest.

public class Solution 
{
    //Number of Permutations Table - Using long to avoid a lot of mod operations.
    long [,] np;
    int MOD;
    
    public void GetNumPermutationsEndingIn(int len, int end, int endStart, int endStop)
    {
        for(int k = endStart; k <= endStop; k++)
        {
            np[len,end] += np[len-1,k];
        }
        //This is just trying to keep the value from overflowing..
        if (np[len,end] > 0xFFFFFFFFFFFF)
        {
            np[len,end] = np[len,end]%this.MOD;
        }
    }
    
    public int NumPermsDISequence(string S) {
        int n = S.Length;
        this.MOD = 1000000000 + 7;
        this.np = new long[n+1,n+1];
        this.np[0,0] = 1;
        for(int len = 1; len <= n; len++)
        {
            for(int end = 0; end <= len; end++)
            {
                if(S[len-1] == 'D')
                {
                    //Here the transformation is to decrease.  This means the previous MUST be bigger than this one.
                    //The starting point is apparently end not end-1 here to also include the number of permutations frm the previous as a starting point. 
                    //The next np[len,end] is np[len-1,end] + np[len-1,end+1]... + np[len-1,len-1]
                    GetNumPermutationsEndingIn(len,end,  end/*prev end start*/, len-1/*prev end stop*/);
                }
                else
                {
                    //The next np[len,end] is np[len-1,0] + np[len-1,1]... + np[len-1,end-1]
                    GetNumPermutationsEndingIn(len,end,  0/*prev end start*/  , end-1/*prev end stop*/);
                }
            }
        }
        
        //To get the complete the complete set a simple sum is required.
        long res = 0;
        for(int i = 0; i <= n; i++)
        {
            res += np[n,i];
        }
        return (int)(res%MOD);
    }
}