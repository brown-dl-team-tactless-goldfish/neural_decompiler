class Solution {
public:
    vector<int> longestRepeating(string s, string qc, vector<int>& qi) {
        int n = s.size();
        int k = qc.size();
        vector<set<pair<int, int>>> where(26);
        multiset<int> st;
        for (int i = 0; i < n;) {
            int j = i;
            while (j < n && s[i] == s[j]) ++j;
            where[s[i] - 'a'].insert(make_pair(i, j - 1));
            st.insert(j - i);
            i = j;
        }
        auto add = [&] (int pos, int in) {
            int l = in;
            int r = in;
            auto it = where[pos].lower_bound({in, in});
            auto it1 = it;
            if (it != where[pos].begin()) {
                it1 = prev(it);
            }
            if (it != it1 && it != where[pos].end()) {
                if (it1->second == l - 1 && it->first == r + 1) {
                    l = it1->first;
                    r = it->second;
                    st.erase(st.lower_bound(it->second - it->first + 1));
                    st.erase(st.lower_bound(it1->second - it1->first + 1));
                    where[pos].erase(it);
                    where[pos].erase(it1);
                    st.insert(r - l + 1);
                    where[pos].insert({l, r});
                    return;
                }
            }
            if (it != where[pos].end()) {
                if (it->first == r + 1) {
                    r = it->second;
                    st.erase(st.lower_bound(it->second - it->first + 1));
                    where[pos].erase(it);
                    where[pos].insert({l, r});
                    st.insert(r - l + 1);
                    return;
                }
            }
            if (it != it1) {
                if (it1->second == l - 1) {
                    l = it1->first;
                    st.erase(st.lower_bound(it1->second - it1->first + 1));
                    where[pos].erase(it1);
                    where[pos].insert({l, r});
                    st.insert(r - l + 1);
                    return;
                }
            }
            st.insert(r - l + 1);
            where[pos].insert({l, r});
        };
        auto remove = [&] (int pos, int in) {
            auto it = where[pos].lower_bound({in, in});
            auto it1 = it;
            if (it != where[pos].begin()) {
                it1 = prev(it);
            }
            if (it != where[pos].end() && in >= it->first && in <= it->second) {
                int l = it->first;
                int r = it->second;
                st.erase(st.lower_bound(it->second - it->first + 1));
                where[pos].erase(it);
                if (l <= in - 1) {
                    where[pos].insert({l, in - 1});
                    st.insert(in - 1 - l + 1);
                }
                if (in + 1 <= r) {
                    where[pos].insert({in + 1, r});
                    st.insert(r - in - 1 + 1);
                }
                return;
            }
            if (in >= it1->first && in <= it1->second) {
                int l = it1->first;
                int r = it1->second;
                st.erase(st.lower_bound(it1->second - it1->first + 1));
                where[pos].erase(it1);
                if (l <= in - 1) {
                    where[pos].insert({l, in - 1});
                    st.insert(in - 1 - l + 1);
                }
                if (in + 1 <= r) {
                    where[pos].insert({in + 1, r});
                    st.insert(r - in - 1 + 1);
                }
            }
        };
        vector<int> sol(k);
        for (int i = 0; i < k; i++) {
            int in = qi[i];
            int pos = s[in] - 'a';
            s[in] = qc[i];
            remove(pos, in);
            pos = qc[i] - 'a';
            add(pos, in);
            sol[i] = *prev(st.end());
            
            
        }
        return sol;
    }
};