class Solution {
public:
    int fun(string st1,string ke1,int id,int n,unordered_map<int,unordered_map<string,int> > &dp){
        if(id==ke1.size()) return 0;
        if(dp[id][st1]!=0) return dp[id][st1];
        if(ke1[id]==st1[0]){
                return dp[id][st1]=1+fun(st1,ke1,id+1,n,dp);
            }
            else{
                int an=1,cl=1;
                for(int j=1;j<st1.size();j++){
                    if(ke1[id]==st1[j]){
                        break;
                    }
                    else{
                        cl++;
                    }
                }
                for(int j=st1.size()-1;j>0;j--){
                    if(ke1[id]==st1[j]){
                        break;
                    }
                    else{
                        an++;
                    }
                }
                
                    string te;
                    te.push_back(st1[cl]);
                    for(int j=(cl+1)%st1.size();j!=cl;j=(j+1)%st1.size()){
                        te.push_back(st1[j]);
                    }
                    
                    string te1;
                    te1.push_back(st1[n-an]);
                    for(int j=(n-an+1)%st1.size();j!=(n-an);j=(j+1)%st1.size()){
                        te1.push_back(st1[j]);
                    }
                    
                    return dp[id][st1]=min(1+an+fun(te1,ke1,id+1,n,dp),1+cl+fun(te,ke1,id+1,n,dp));
            }
        }
    int findRotateSteps(string ring, string key) {
        unordered_map<int,unordered_map<string,int> > dp;
        return fun(ring,key,0,ring.size(),dp);
    }
};