typedef int64_t item_key;
typedef int64_t item_value;
typedef int64_t num_items;

item_key compareKeys(item_key key1, item_key key2) {
    return key1-key2;
}

struct treap {
    item_key key;
    item_value value;
    item_value sum;
    num_items priority;
    num_items size;
    struct treap *left;
    struct treap *right;
};
struct treap_pair {
    struct treap *left;
    struct treap *right;
};

struct treap space[400000];
num_items numSpaceUsed;

num_items getTreapSize(struct treap *treap1) {
    if (treap1 == NULL) return 0;
    return treap1->size;
}

item_value getTreapSum(struct treap *treap1) {
    if (treap1 == NULL) return 0;
    return treap1->sum;
}

void calcTreapProperties(struct treap *treap1) {
    if (treap1 != NULL) {
        treap1->size = 1+getTreapSize(treap1->left)+getTreapSize(treap1->right);
        treap1->sum = treap1->value+getTreapSum(treap1->left)+getTreapSum(treap1->right);
    }
}

struct treap *newTreap(item_key key, item_value value) {
    if (numSpaceUsed > 400000) fprintf(stderr, "Ran out of treap space"), exit(1);
    space[numSpaceUsed].priority = rand();
    space[numSpaceUsed].key = key;
    space[numSpaceUsed].value = value;
    space[numSpaceUsed].left = NULL;
    space[numSpaceUsed].right = NULL;
    calcTreapProperties(space+numSpaceUsed);
    numSpaceUsed++;
    return space+(numSpaceUsed-1);
}

struct treap *mergeTreaps(struct treap *left, struct treap *right) {
    if (left == NULL) return right;
    if (right == NULL) return left;
    if (left->priority > right->priority) {
        left->right = mergeTreaps(left->right, right);
        calcTreapProperties(left);
        return left;
    } else {
        right->left = mergeTreaps(left, right->left);
        calcTreapProperties(right);
        return right;
    }
}

//Split treap into a left-side with all elements less than or equal to key and a right-side with the rest of the elements.
//Note that if exclusive is true, then left-side will have all elements less than key and right-side will have all elements greater than or equal to key.
struct treap_pair splitByKey(struct treap *treap1, item_key key, bool exclusive) {
    struct treap_pair answer;
    if (treap1 == NULL) {
        answer.left = answer.right = NULL;
        return answer;
    }
    
    item_key compareKeysResult = compareKeys(key, treap1->key);
    //If the key is less than the key of the root, then all items less than or equal to key are on the left-hand side.
    if (exclusive ? (compareKeysResult <= 0) : (compareKeysResult < 0)) {
        answer = splitByKey(treap1->left, key, exclusive);
        //Since answer.left is the tree rooted at key, make answer.right, which has all elements greater than key but less than the key of the root, the new left node of the treap:
        treap1->left = answer.right;
        //After making this modification, treap1 becomes the right-side, which has all elements greater than key:
        answer.right = treap1;
    }
    //If the key is greater than or equal to the key of the root, then we know that the left-side and the root is composed of all elements less than or equal to key, so we need to search the right-hand side for any other elements which are less than or equal to key.
    else {
        answer = splitByKey(treap1->right, key, exclusive);
        //Now, we need to combine treap1 and its left-side with all of the elements in the right-side which are also less than or equal to key.
        //These elements are now in answer.left, so make answer.left the new right-side of treap:
        treap1->right = answer.left;
        //After making this modification, treap1 becomes the left-side, which has all elements less than or equal to key:
        answer.left = treap1;
    }
    calcTreapProperties(treap1);
    return answer;
}

bool addElementByKey(struct treap **treapPtr, item_key newKey, item_value newValue, bool exclusive) {
    //Split treap up into a left-side with all elements less than newKey:
    struct treap_pair parts = splitByKey(*treapPtr, newKey, false);
    //Make sure newKey is not already in the tree:
    if (exclusive) {
        struct treap_pair parts2 = splitByKey(parts.left, newKey, true);
        if (parts2.right != NULL) {
            *treapPtr = mergeTreaps(mergeTreaps(parts2.left, parts2.right), parts.right);
            return false;
        }
        parts.left = mergeTreaps(parts2.left, parts2.right);
    }
    
    //Create a new node:
    struct treap *storeTreap = newTreap(newKey, newValue);
    //Put the new node to the right of the left-side, and then merge the new left-side with the right-side:
    *treapPtr = mergeTreaps(mergeTreaps(parts.left, storeTreap), parts.right);
    
    return true;
}

bool removeElementByKey(struct treap **treapPtr, item_key oldKey) {
    //Split treap up into a left-side which has all elements up to oldKey:
    struct treap_pair parts = splitByKey(*treapPtr, oldKey, false);
    //Now, split the left-side up into a left-side which has all elements before oldKey and a right-side which has all elements equal to oldKey:
    struct treap_pair parts2 = splitByKey(parts.left, oldKey, true);
    //Record whether there were actually any elements with oldKey:
    bool actuallyRemoved = parts2.right != NULL;
    //Merge treaps back together without the elements equal to oldKey:
    *treapPtr = mergeTreaps(parts2.left, parts.right);
    
    return actuallyRemoved;
}