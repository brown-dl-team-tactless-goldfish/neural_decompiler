
//Initializing visited to 0 

void initialize(int** visited){
    visited[0]=malloc(sizeof(int)*3);
    visited[0][0]=visited[0][1]=visited[0][2]=0;
    visited[1]=malloc(sizeof(int)*3);
    visited[1][0]=visited[1][1]=visited[1][2]=0;
    visited[2]=malloc(sizeof(int)*3);
    visited[2][0]=visited[2][1]=visited[2][2]=0;
    return ;
}
//returns 1 if it is a zero matrix else returns 0
int zeroMatChecker(int** mat,int r,int c){
    for(int i=0;i<r;i++)    for(int j=0;j<c;j++)    if(mat[i][j])   return 0;
    return 1;
}
//Flips target element and neighboor elements
void set(int** mat,int row,int col,int r,int c){
    mat[row][col]=!mat[row][col];
    
    if(col!=c-1)    mat[row][col+1]=!mat[row][col+1];
    if(col!=0)  mat[row][col-1]=!mat[row][col-1];
    if(row!=r-1)    mat[row+1][col]=!mat[row+1][col];
    if(row!=0)  mat[row-1][col]=!mat[row-1][col];
    
    return ;
}

//Finds and assigns the value to the shortest variable if it is possible else -1 remains
void findShortestPath(int** mat,int steps,int** visited,int* shortest,int r,int c){
    for(int i=0;i<r;i++){
        for(int j=0;j<c;j++){
		// if visited[i][j] is 0 then it is not visited hence we can flip and check for ZeroMat if it is not ZeroMat it calls the recursive function in else statement 
           if(visited[i][j]==0){
                visited[i][j]=1;
                set(mat,i,j,r,c);
                if(zeroMatChecker(mat,r,c)){
					if(*shortest==-1 || steps<*shortest){
                        *shortest=steps;//shortest values is assigned 
                    }
                    set(mat,i,j,r,c);
                    visited[i][j]=0;
					
                    return ;    
                }
                else{
					//by increasing steps we count on the no of times we flip for a particular i,j and we update the value of shortest once we arrive at the zeroMat
					findShortestPath(mat,steps+1,visited,shortest,r,c);
                }
				
				//resetting the previous state of the mat and visited matrices on leaving the function
                set(mat,i,j,r,c);
                visited[i][j]=0;
            }
        }
    }
	return ;
}

int minFlips(int** mat, int matSize, int* matColSize){
    int r=matSize;
    int c=*matColSize;
	
    if(zeroMatChecker(mat,r,c))return 0;//checks and return 0 if the given mat is zeroMat 
	
    int** visited=malloc(sizeof(int*)*3);
    initialize(visited);
	
    int shortest=-1;
    findShortestPath(mat,1,visited,&shortest,r,c);
	
    //if no solution is possible -1 remains
    
	return shortest;
}