typedef struct {
    sem_t sn, s3, s5, s35; // Individual semaphores for threads
    int i, n;
} FizzBuzz;

FizzBuzz* fizzBuzzCreate(int n) {
    FizzBuzz* obj = malloc(sizeof (FizzBuzz));
    sem_init(&obj->sn, 0, 0);  // All three will wait for number-thread to wake them up
    sem_init(&obj->s3, 0, 0);
    sem_init(&obj->s5, 0, 0);
    
    sem_init(&obj->s35, 0, 0);
    obj->i = 1;
    obj->n = n;
    return obj;
}

void fz(void) { printFizz(); }
void bz(void) { printBuzz(); }
void fbz(void) { printFizzBuzz(); }
inline void cstub(FizzBuzz *obj, sem_t *t, sem_t *n, void (*f) (void));
inline void pnum(FizzBuzz *o);
inline void dl(FizzBuzz *o);

void fizz(FizzBuzz* obj) {
    cstub(obj, &obj->s3, &obj->sn, fz);
}

void buzz(FizzBuzz* obj) {
    cstub(obj, &obj->s5, &obj->sn, bz);  
}

void fizzbuzz(FizzBuzz* obj) {
    cstub(obj, &obj->s35, &obj->sn, fbz);  
}

void number(FizzBuzz* obj) {
    pnum(obj);
}

void fizzBuzzFree(FizzBuzz* obj) {
    dl(obj);  
}

// Process number
inline void pnum(FizzBuzz *o) {
    while (o->i <= o->n) {
        bool m3 = !(o->i % 3);
        bool m5 = !(o->i % 5);        
        if (m3 || m5) {
            m3 && m5 ? sem_post(&o->s35) :    // Wake up *only* one of the three
                    m5 ? sem_post(&o->s5) :
                            sem_post(&o->s3);
            sem_wait(&o->sn);                 // Get ack
        } else
            printNumber(o->i);
        o->i++;        
    }
    sem_post(&o->s35);  // Wake all three so that they can exit/return
    sem_post(&o->s5);
    sem_post(&o->s3);    
}

// Common stub for all of the above three
inline void cstub(FizzBuzz *obj, sem_t *t, sem_t *n, void (*f) (void)) {
    while (1) {
        sem_wait(t);
        if (obj->i > obj->n) {
            sem_post(n);
            return;
        }
        f();
        sem_post(n);
    }    
}

// Relinquish the resources
inline void dl(FizzBuzz *o) {
    sem_destroy(&o->sn);
    sem_destroy(&o->s3);
    sem_destroy(&o->s5);
    sem_destroy(&o->s35);
    free(o);    
}