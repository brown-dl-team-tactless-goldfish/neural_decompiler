class Solution {
public:
    bool parseBoolExpr(string const &e) {
        auto internal_error     = []{ throw std::logic_error("internal error"); };
        
        enum class op_e { E_OR, E_AND, E_NOT };
        std::stack<op_e> ops;

        int skip_par = 0;
        bool eval    = false;
        
        auto update = [&](auto expr){
            bool exit_cycle = false;
            while (!exit_cycle && !ops.empty())
            {
                switch (ops.top())
                {
                    case op_e::E_NOT:
                        expr = !expr;
                        break;
                    case op_e::E_AND:
                        exit_cycle = expr;
                        break;
                    case op_e::E_OR:
                        exit_cycle = !expr;
                        break;
                    default:
                        internal_error();
                }
                
                if (!exit_cycle)
                {
                    ops.pop();
                    ++skip_par;
                }
            }
            eval = expr;
        };
        
        for (auto i = e.cbegin(); i < e.cend();)
        {
            switch (auto const c = *i)
            {
                case '!':
                    ops.push(op_e::E_NOT);
                    break;
                case '|':
                    ops.push(op_e::E_OR);
                    break;
                case '&':
                    ops.push(op_e::E_AND);
                    break;
                case '(':
                case ',':
                    break;
                case ')':
                    if (op_e::E_NOT == ops.top())
                        eval = !eval;
                    ops.pop();
                    update(eval);
                    break;
                case 't':
                case 'f':
                    update('t' == c);
                    break;
                default:
                    internal_error();
            }
            
            i = std::find_if(std::next(i), e.cend(), [&](auto c){
                if (0 == skip_par)
                    return true;
                switch (c)
                {
                    case '(':
                        ++skip_par;
                        break;
                    case ')':
                        --skip_par;
                        break;
                    case '!': case '|': case '&': case ',': case 't': case 'f':
                        break;
                    default:
                        internal_error();
                }
                return false;
            });
        }
        
        return eval;
    }
};