
        public int MinNumberOfSemesters(int n, int[][] dependencies, int k)
        {
            // Point 1 - Decrement everything by one to apply bit masking.
            foreach (var dependency in dependencies)
            {
                dependency[0]--;
                dependency[1]--;
            }

            // Fill with -1 to distinguish between processed and not processed.
            var dp = new int[1 << n];
            Array.Fill(dp, -1);
            return Helpers(n, dependencies, k, 0, dp);
        }

        private int Helpers(int n, int[][] dependencies, int k, int mask, int[] dp)
        {
            if (mask == dp.Length - 1)
                return 0;

            if (dp[mask] != -1)
                return dp[mask];

            var min = n + 1;
            var availableMask = 0;
            var inDegree = new int[n];

            // The objective is to find the AvailableMask which tells which courses can be taken now.
            // 1. Filter out courses which are already taken.
            for (var index = 0; index < n; index++)
            {
                if ((mask & (1 << index)) != 0)
                {
                    inDegree[index] = -1;
                }
            }
            // 2. Calculate InDegree for each course which hasn't been taken.
            foreach (var dependency in dependencies)
            {
                var source = dependency[0];
                var dest = dependency[1];
                if (inDegree[dest] != -1 && inDegree[source] != -1)
                    inDegree[dest]++;
            }

            // 3. If in Degree is 0 then we can take this course now, so add it AvailableMask.
            for (var i = 0; i < n; i++)
            {
                if (inDegree[i] == 0)
                    availableMask |= (1 << i);
            }

            var coursesToTake = CountOneBits(availableMask);
            // 4. If you can take all courses, go for it. 
            if (coursesToTake <= k)
            {
                min = Math.Min(min, 1 + Helpers(n, dependencies, k, mask | availableMask, dp));
            }
            else
            {
                // 5. Since you cannot take > k courses, Loop through sub masks of size k and calculate the minimum one.
				// https://cp-algorithms.com/algebra/all-submasks.html
                for (var s = availableMask; s > 0; s = (s - 1) & availableMask)
                {
                    var availCourses = CountOneBits(s);
                    if (availCourses != k)
                        continue;
                    min = Math.Min(min, 1 + Helpers(n, dependencies, k, mask | s, dp));
                }
            }

            dp[mask] = min;
            return dp[mask];
        }

        private int CountOneBits(int mask)
        {
            var c = 0;
            while (mask > 0)
            {
                if ((mask & 1) != 0)
                    c++;
                mask >>= 1;
            }
            return c;
        }
