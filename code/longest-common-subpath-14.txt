'''
class Solution {
public:
	long long p;
	long long mod=1e9+7;
	long long pinv;
	vector<int> lp, pr;
	int longestCommonSubpath(int m, vector<vector<int>>& paths) {
		primefactor();
		p=*upper_bound(pr.begin(), pr.end(), m);
		pinv=binpow(p, mod-2, mod);
		long long l=0;
		long long n=paths.size();
		long long r=paths[0].size();
		for(int i=0;i<n;i++) if(paths[i].size()<r) r=paths[i].size();
		int ans=0;
		while(l<=r)
		{
			int mid=(l+r)/2;
			if(check(mid, paths))
			{
				ans=mid;
				l=mid+1;
			}
			else r=mid-1;
		}
		return ans;
	}

	bool check(int len, vector<vector<int> >& paths)
	{
		if(len==0) return true;
		map<long long, int> seen;
		// cout<<len<<endl;
		for(int i=0;i<paths.size();i++) 
		{
			vector<long long> temp=rolling(paths[i], len);
			// for(int j=0;j<temp.size();j++) cout<<temp[j]<<" ";
			// cout<<endl;
			set<long long> exist;
			exist.clear();
			for(int j=0;j<temp.size();j++) 
			{
				if(exist.find(temp[j])==exist.end())
				{
					seen[temp[j]]++;
					exist.insert(temp[j]);
				}
			}
		}
		for(auto it : seen)
		{
			// cout<<it.first<<","<<it.second<<" ";
			if(it.second==paths.size()) return true;
		}
		// cout<<endl;
		return false;
	}

	vector<long long> rolling(vector<int>& a, int len)
	{
		vector<long long> ans(a.size()-len+1);
		long long h=0, power=1;
		if(len==0) return ans;
		for(int i=0;i<a.size();i++) 
		{
			h=(h+power*(long long)a[i])%mod;
			if(i<len-1) power=(power*p)%mod;
			else 
			{
				ans[i-len+1]=h;
				h=((h-a[i-len+1])*pinv)%mod;
				if(h<0) h+=mod;
			}
		}
		return ans;
	}

	long long binpow(long long a, long long b, long long mod1)
	{
		long long res = 1;
		while (b > 0) {
			if (b & 1)
				res = (res * a)%mod1;
			a = (a * a)%mod1;
			b >>= 1;
		}
		return res%mod1;
	}
	void primefactor()
	{
		int N=1e5+100;
		lp.resize(N+1,0);
		for (int i=2; i<=N; ++i) {
			if (lp[i] == 0) {
				lp[i] = i;
				pr.push_back (i);
			}
			for (int j=0; j<(int)pr.size() && pr[j]<=lp[i] && i*pr[j]<=N; ++j)
				lp[i * pr[j]] = pr[j];
		}
	}

};
'''