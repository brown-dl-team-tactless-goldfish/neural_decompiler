class Solution {
public:
    unordered_map<int,multiset<int>>adj;
    unordered_map<int,int>outDegree,inDegree;
    vector<vector<int>>ans;
    
    void dfs(int node,int parent){
        if(outDegree[node]==-2)
            return ;
        while(!adj[node].empty()){
            auto every = *adj[node].begin();
            adj[node].erase(adj[node].begin());
            outDegree[every]--;
            dfs(every,node);
        }
        ans.push_back({parent,node});
    }
    
    int getStartNode(){
        for(auto every:outDegree){
            if(every.second-inDegree[every.first]==1)
                return every.first;
        }
        return (*outDegree.begin()).first;
    }
    
    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {
        for(auto every:pairs){
            adj[every[0]].insert(every[1]);
            inDegree[every[1]]++;
            outDegree[every[0]]++;
        }
        int start=getStartNode();
        dfs(start,-1);
        ans.pop_back();
        reverse(ans.begin(),ans.end());
        return ans;
    }
};