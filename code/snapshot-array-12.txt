class SnapshotArray {
public:
    SnapshotArray(int length) {
        data.resize(length);
        snapId = 0;
    }
    
    void set(int index, int val) {
        // if this value has not been changed ever, we push the change into it
        if (data[index].size() == 0) {
            data[index].push_back({snapId, val});
        } else {
            // otherwise let's see whether the change happends in the same snap_id period as the last one
            // if so just change the vlaue, otherwise insert new snap shot values
            auto& backData = data[index].back();
            if (backData.first == snapId) {
                prev(data[index].end())->second = val;
            } else {
                data[index].push_back({snapId, val});
            }
        }
    }
    
    int snap() {
        return snapId++;
    }
    
    int get(int index, int snap_id) {
        // since items in data[index] are insert in sequence of the snap_id, so
        // use binary search to get the right value
        int dataSize = data[index].size();
        int left = 0, right = dataSize - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (data[index][mid].first == snap_id) {
                return data[index][mid].second;
            }
            if (data[index][mid].first < snap_id) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        if (right == -1) {
            return 0;
        } else {
            return data[index][right].second;
        }
    }
    
private:
    // data.size() is the same as length
    // each data item is a list of pair which record {snap_id, val}
    // if index i's value was changed and taken a snap shot at snap_id k and the value didn't change after that
    // the value we get at snap_id k + t where t > 0, would be the same as index i's snap_id k value
    // so we just need to store values when value is set
    vector<vector<pair<int, int>>> data;
    int snapId;
};