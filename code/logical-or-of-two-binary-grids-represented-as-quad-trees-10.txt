class Solution {
public:
    Node* intersect(Node* quadTree1, Node* quadTree2) {
        if (quadTree1 == nullptr || quadTree2 == nullptr)
            return nullptr;
        else if (quadTree1->isLeaf && quadTree1->val == true)
            return quadTree1;
        else if (quadTree2->isLeaf && quadTree2->val == true)
            return quadTree2;
        else if (quadTree1->isLeaf && quadTree2->isLeaf) //Then both leaves are have value false
            return quadTree1; //Could also return quadTree2;
        else if (quadTree1->isLeaf) //Then quadTree1 has value false and since (false || X == X), we return quadTree2
            return quadTree2;
        else if (quadTree2->isLeaf)
            return quadTree1;
        //Neither quadTree1 or quadTree2 are leaves.
        Node * ret = new Node();
        ret->isLeaf = false;
        ret->val = false;
        ret->topLeft     = intersect(quadTree1->topLeft,     quadTree2->topLeft);
        ret->topRight    = intersect(quadTree1->topRight,    quadTree2->topRight);
        ret->bottomLeft  = intersect(quadTree1->bottomLeft,  quadTree2->bottomLeft);
        ret->bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight);
        //If all 4 quadrants are leafs having the same value then make ret into a leaf of that value.
        if (ret->topLeft->isLeaf && ret->topRight->isLeaf && ret->bottomLeft->isLeaf && ret->bottomRight->isLeaf) {
            if ((ret->topLeft->val && ret->topRight->val && ret->bottomLeft->val && ret->bottomRight->val)
                || (!ret->topLeft->val && !ret->topRight->val && !ret->bottomLeft->val && !ret->bottomRight->val)) {
                ret->isLeaf = true;
                ret->val = ret->topLeft->val;
                ret->topLeft = nullptr;
                ret->topRight = nullptr;
                ret->bottomLeft = nullptr;
                ret->bottomRight = nullptr;
            }
        }
        return ret;
    }
};