class Solution {
public:
    
    unordered_map<TreeNode*, int> memo;
    
    void dfs(TreeNode* root) {
        if (!root)  return;
        else {
            dfs(root->left);
            dfs(root->right);
            memo[root] = root->val;
            if (root->left)     memo[root] += memo[root->left];
            if (root->right)    memo[root] += memo[root->right];
            //cout << root->val << ":" << memo[root] << endl;
        }
    }
    
    bool check_bst(TreeNode* root, TreeNode* left = NULL, TreeNode* right = NULL) {
        if (!root)  return true;
        if (left != NULL && root->val <= left->val)    return false; 
  
        if (right != NULL && root->val >= right->val)    return false; 
   
        bool val = check_bst(root->left, left, root) && check_bst(root->right, root, right);
        return val;
    }
    
    int maxSumBST(TreeNode* root) {
        if (!root)  return 0;
        dfs(root);   
        int maxi = 0;
        list<TreeNode*> ver;
        ver.push_back(root);
       
        while (!ver.empty()) {
            TreeNode* tr = ver.front();
            ver.pop_front();
            if (memo[tr] > maxi) {
                bool ret = check_bst(tr, NULL, NULL);
                if (ret)    maxi = max(maxi, memo[tr]);
            }
            if (tr->left)   ver.push_back(tr->left);
            if (tr->right)  ver.push_back(tr->right);
        }
        
        return maxi;
    }
};