struct MergeFindSet {
    std::vector<int> p;
    MergeFindSet(int n) : p(n) { init(); }
    int find(int x) { return p[x] == x ? x : p[x] = find(p[x]); }
    void merge(int root, int child) { p[find(child)] = find(root); }
    void init() {
        for (int i = 0; i < int(p.size()); i++) p[i] = i;
    }
};

const int N = 1 << 26;
uint16_t maskOrder[N];

class Solution {
public:
    vector<int> groupStrings(vector<string>& words) {
        int n = words.size();
        vector<int> masks;
        vector<bool> seen(N);
        for(const string& s: words) {
            int m = 0;
            for(char c: s) {
                m |= 1 << int(c - 'a');
            }
            masks.push_back(m);
            seen[m] = true;
        }
        sort(masks.begin(), masks.end());
        
        vector<int> cnt(n);
        int currOrder = 0;
        for(int i = 0; i < n; i++) {
            if(i == 0 or masks[i] != masks[i - 1]) {
                maskOrder[masks[i]] = currOrder++;
            }
            cnt[currOrder - 1]++;
        }
        
        MergeFindSet mfs(n);
        for(int i = 0; i < n; i++) {
            if(i != 0 and masks[i] == masks[i - 1]) {
                continue;
            }
            int mask = masks[i];
            int order1 = maskOrder[mask];
            for(int i = 0; i < 26; i++) {
                if(mask & (1 << i)) {
                    int mask2 = mask ^ (1 << i);
                    if(seen[mask2]) {
                        mfs.merge(order1, maskOrder[mask2]);
                    }
                    
                    for(int j = 0; j < 26; j++) {
                        if((mask2 & (1 << j)) == 0) {
                            int mask3 = mask2 | (1 << j);
                            if(seen[mask3]) {
                                mfs.merge(order1, maskOrder[mask3]);
                            }
                        }
                    }
                    
                } else {
                    int mask2 = mask | (1 << i);
                    if(seen[mask2]) {
                        mfs.merge(order1, maskOrder[mask2]);
                    }
                }
            }
        }
        
        vector<int> gSize(currOrder);
        int maxSize = 0;
        int groupCnt = 0;
        for(int i = 0; i < currOrder; i++) {
            int root = mfs.find(i);
            gSize[root] += cnt[i];
            maxSize = max(maxSize, gSize[root]);
            groupCnt += root == i;
        }
        
        return {groupCnt, maxSize};
    }
};