class Solution {
public:
    int inf = INT_MAX / 2;
    int dp[31][31][31], *arr, n, k;
    int pre[32];
    
    inline int sum(int l, int r) {  // inclusive
        return pre[r + 1] - pre[l];
    }
    
    int rec(int l, int r, int part) {  // inclusive
        if(part > r - l + 1) return inf;
        int &ret = dp[l][r][part];
        if(ret != -1) return ret;
        // not found
        
        if(part == 1) {  // break into k parts
            int cnt = r - l + 1;
            if(cnt == 1) return ret = 0;
            else if(cnt == k) return ret = sum(l, r);
            else if(cnt > 1 && cnt < k) return ret = inf;
            else return ret = rec(l, r, k) + sum(l, r);
        }
        // cut the first part
        ret = inf;
        // for(int i = l + 1; i <= r; ++i) {
        for(int i = l + 1; i <= r; i += (k - 1)) {
            int left = rec(l, i - 1, 1), right = rec(i, r, part - 1);
            if(left >= inf || right >= inf) continue;
            ret = min(ret, left + right);
        }
        return ret;
    }
    
    int mergeStones(vector<int>& stones, int k_) {
        arr = stones.data(), n = stones.size(), k = k_;
        memset(dp, -1, sizeof(dp));
        memset(pre, 0, sizeof(pre));
        // check availability
        if((n - 1) % (k - 1) != 0) return -1;
        
        // build prefix array
        for(int i = 0; i < n; ++i) pre[i + 1] = pre[i] + arr[i];
        return rec(0, n - 1, 1);
    }
};