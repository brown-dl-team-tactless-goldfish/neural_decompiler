int** ret;
int Size = 0;
int *ColumnSizes;

// We could realloc to dynamically size but 500 is relatively small in terms of allocation space
int max_size = 500;

// Reserve maximum possible size
ret = (int**) malloc (sizeof (int*) * max_size);
ColumnSizes = (int*) malloc (sizeof (int) * max_size);

// Load [0] index of groupSizes
ret [0] = (int*) malloc (sizeof (int) * groupSizes [0]);
ret [0][0] = 0;
ColumnSizes [0] = 1;      // We use this as size; this will eventually be the groupSizes [0]
Size++;

// Iterate over groupSizes
for (int i=1; i<groupSizesSize; ++i)
{
	// Iterate over **ret
    for (int j=0; j<Size; ++j)
    {
        // Get index value from return for comparison
        int index = ret [j][0];
        int index_size = ColumnSizes [j];
        
        // Check for existing entry in ret: (1) equals current groupSizes [i] and (2) is not full
        if (groupSizes [i] == groupSizes [index] && index_size < groupSizes [i])
        {
            ret [j][index_size] = i;
            ColumnSizes [j] = ColumnSizes [j] + 1;
            
            // Exit Loop
            j = Size;
        }
        // If no existing entry is found before end, make new group entry
        else if (j >= (Size - 1))
        {
            // Make new entry
            ret [Size] = (int*) malloc (sizeof (int) * groupSizes [i]);
            ret [Size][0] = i;
            ColumnSizes [Size] = 1;
            Size++;
            
            // Exit Loop
            j = Size;
        }
    }
}

*returnSize = Size;
*returnColumnSizes = ColumnSizes;
    
return ret;