class Transaction {
public:
    string name = "";
    int minutes = 0;
    int amount  = 0;
    string city = "";
    
    Transaction(string name, int minutes, int amount, string city){
        this->name    = name;
        this->minutes = minutes;
        this->amount  = amount;
        this->city    = city;
    }
};

class Solution {
private:
    
    void checkInvalid(Transaction *first, Transaction *second, unordered_set<string> &invalid){
        string firstName  = first->name;
        int firstMinutes  = first->minutes;
        int firstAmount   = first->amount;
        string firstCity  = first->city;
        
        string secondName = second->name;
        int secondMinutes = second->minutes;
        int secondAmount  = second->amount;
        string secondCity = second->city;         

        string invalid_one = firstName  + "," + to_string(firstMinutes)  + "," + to_string(firstAmount)  + "," + firstCity;
        string invalid_two = secondName + "," + to_string(secondMinutes) + "," + to_string(secondAmount) + "," + secondCity;        
        
        if(firstAmount  > 1000) invalid.insert(invalid_one);
        
        if(secondAmount > 1000) invalid.insert(invalid_two);          
        
        if((abs(firstMinutes - secondMinutes) <= 60 && firstCity != secondCity)){            
            invalid.insert(invalid_one);
            invalid.insert(invalid_two);
        }
    }
    
    
    void findInvalidTransactions(vector<Transaction*> &transactionData, unordered_set<string> &invalid){
        // if a person just made one transaction, simply check if the transaction amount exceeds 1000
        if(transactionData.size() == 1){
            Transaction *one = transactionData.at(0);
            if(one->amount > 1000){
                string invalid_one = one->name + "," + to_string(one->minutes) + "," + to_string(one->amount) + "," + one->city;
                invalid.insert(invalid_one);
                return;
            }
        }
        
        // if a person has multiple transactions, check if those transaction amount exceeds 1000
        // also check if more than one transaction has been made within 60 minutes in different cities
        for(int i = 0; i < transactionData.size(); i++){
            Transaction *one = transactionData.at(i);
            
			for(int j = i + 1; j < transactionData.size(); j++){
                Transaction *two = transactionData.at(j);
                
                checkInvalid(one, two, invalid); 
            }
        }            
    }
    
public:
    vector<string> invalidTransactions(vector<string>& transactions) {
        unordered_map<string, vector<Transaction*>> data;
        
        int pos = 0;
        for(string transaction : transactions){
            // get name
            pos = transaction.find(',');
            string name = transaction.substr(0, pos);
            transaction.erase(0, pos + 1);
            
            // get minutes
            pos = transaction.find(',');
            string minutes = transaction.substr(0, pos);
            transaction.erase(0, pos + 1);
            
            // get amount
            pos = transaction.find(',');
            string amount = transaction.substr(0, pos);
            transaction.erase(0, pos + 1);
            
            // get city (last string, no need to find delimiter)
            string city = transaction.substr(0);
            
            // {name : array of values (minutes, amount, city)}
            Transaction *transactionData = new Transaction(name, stoi(minutes), stoi(amount), city);
            data[name].push_back(transactionData);         
        }
        
        
        unordered_set<string> invalid;
        for(auto iter = data.begin(); iter != data.end(); iter++){
            vector<Transaction*> transactionData = iter->second;
            
            findInvalidTransactions(transactionData, invalid);            
        }
        
        vector<string> result;
        for(string transaction : transactions)
            if(invalid.find(transaction) != invalid.end())
                result.push_back(transaction);
        
        return result;
    }
};