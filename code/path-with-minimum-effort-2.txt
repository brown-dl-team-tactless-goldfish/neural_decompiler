
typedef struct {
    int x;
    int y;
} Coor; //Coordinate

typedef struct {
    Coor p1;
    Coor p2;
    int effort;
} Effort;


int cmp(const void *a, const void *b){
    return ((Effort*)a)->effort - ((Effort*)b)->effort;
}

int minimumEffortPath(int** heights, int heightsSize, int* heightsColSize){
    int ret = 0;
    //efforts
    int Effort_size = 0;
    for (int i = 0; i < heightsSize; i++){
        Effort_size =  Effort_size + heightsColSize[i]-1;
        if (i-1>=0){
            if (heightsColSize[i] > heightsColSize[i-1]){
                Effort_size = Effort_size + heightsColSize[i-1];
            } else {
                Effort_size = Effort_size + heightsColSize[i];
            }
        }
    }

    Effort *pEffort = calloc(Effort_size, sizeof(Effort));
    int effort_idx = 0;

    int **pGroup_id = calloc(heightsSize, sizeof(int*));
    for (int i = 0; i<heightsSize; i++){
        pGroup_id[i] = calloc(heightsColSize[i], sizeof(int));
    }

    for (int i = 0; i < heightsSize; i++){
        for (int j = 0; j < heightsColSize[i]; j++){

            //Effort going down
            if (i+1 < heightsSize){
                pEffort[effort_idx].p1.x = i;
                pEffort[effort_idx].p1.y = j;

                pEffort[effort_idx].p2.x = i+1;
                pEffort[effort_idx].p2.y = j;

                pEffort[effort_idx].effort = abs(heights[i][j] - heights[i+1][j]);
                effort_idx++;
            }
            //Effort going right
            if (j+1 < heightsColSize[i]){
                pEffort[effort_idx].p1.x = i;
                pEffort[effort_idx].p1.y = j;

                pEffort[effort_idx].p2.x = i;
                pEffort[effort_idx].p2.y = j+1;

                pEffort[effort_idx].effort = abs(heights[i][j] - heights[i][j+1]);
                effort_idx++;
            }

        }
    }

    qsort(pEffort, effort_idx, sizeof(Effort), cmp);

    for (int i = 0; i < Effort_size; i ++){
        //
        if (pGroup_id[pEffort[i].p1.x][pEffort[i].p1.y] == 0 || pGroup_id[pEffort[i].p2.x][pEffort[i].p2.y] == 0){ //New discover
            if (pGroup_id[pEffort[i].p1.x][pEffort[i].p1.y] != 0){
                pGroup_id[pEffort[i].p2.x][pEffort[i].p2.y] = pGroup_id[pEffort[i].p1.x][pEffort[i].p1.y];
            } else if (pGroup_id[pEffort[i].p2.x][pEffort[i].p2.y]!= 0){
                pGroup_id[pEffort[i].p1.x][pEffort[i].p1.y] = pGroup_id[pEffort[i].p2.x][pEffort[i].p2.y];
            } else {
                pGroup_id[pEffort[i].p1.x][pEffort[i].p1.y] = i+1; // +1 to avoid when i=0
                pGroup_id[pEffort[i].p2.x][pEffort[i].p2.y] = i+1;
            }
        } else if (pGroup_id[pEffort[i].p1.x][pEffort[i].p1.y] == pGroup_id[pEffort[i].p2.x][pEffort[i].p2.y] ){ //cycle

        } else { //bridge
            int group_id1 = pGroup_id[pEffort[i].p1.x][pEffort[i].p1.y];
            int group_id2 = pGroup_id[pEffort[i].p2.x][pEffort[i].p2.y];
            for (int ii = 0; ii < heightsSize; ii++){
                for (int jj = 0; jj < heightsColSize[ii]; jj++){
                    if (pGroup_id[ii][jj] == group_id1 || pGroup_id[ii][jj] == group_id2 ){
                        pGroup_id[ii][jj] = i+1;
                    }

                }
            }

        }

        if (pGroup_id[0][0] == pGroup_id[heightsSize-1][heightsColSize[heightsSize-1]-1] && pGroup_id[0][0] != 0){
            ret = pEffort[i].effort;
            break;
        }
    }

    free(pEffort);
    for (int i = 0; i<heightsSize; i++){
        free(pGroup_id[i]);
    }
    free(pGroup_id);

    return ret;
}