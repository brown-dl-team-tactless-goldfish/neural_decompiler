class Solution {
public:
    vector<int> nds; // this will store pre order of nodes formed
    void preOrd(TreeNode* r){ // function to do preorder
        if(r == NULL) return;
        preOrd(r->left);
        nds.push_back(r->val);
        preOrd(r->right);
    }

    TreeNode* canMerge(vector<TreeNode*>& trees) {
        int nodes = 0; // this will store count of nodes 
        map<int,TreeNode*> m; // for each value there will be 1 parent 
        for(int i=0;i<trees.size();i++){
            auto r = trees[i];   nodes++;
            if(r->left){   nodes++;
                if(m.find(r->left->val) != m.end()) return NULL;
                m[r->left->val] = r;
            }
            if(r->right){   nodes++;
                if(m.find(r->right->val) != m.end()) return NULL;
                m[r->right->val] = r;
            }
        }
        TreeNode* ans = NULL; // initially ans is NULL
        for(int i=0;i<trees.size();i++){
            auto r = trees[i];
            if(m.find(r->val) == m.end()) continue; // if we do not find it's parent then do not need to do anything
            // if we found it's parent then we will replace values of it's child
            if(m[r->val]->left && m[r->val]->left->val == r->val){ m[r->val]->left = r; trees[i] = NULL; }
            if(m[r->val]->right && m[r->val]->right->val == r->val){ m[r->val]->right = r; trees[i] = NULL; }
        }
        int cnt = 0; // this will count alone trees 
        for(auto i: trees){
            if(i != NULL){
                ans = i;
                cnt++;
            }
        }
        if(cnt != 1) return NULL; // if not only 1 tree is made then we cannot form tree
        // Now we have to check for made tree is BST or not so do preorder and see if all nodes satisfy
        preOrd(ans); // do pre order
        // if after making successfull BST we will have nodes-(trees.size()-1) nodes count 
        // so if we do not get this return NULL
        if(nodes-(trees.size()-1) != nds.size()) return NULL;
        // check for increasing order
        for(int i=0;i<nds.size()-1;i++){
            if(nds[i] >= nds[i+1]) return NULL;
        }
        return ans;
    }
};