//check the max list of node that one infected node can infect;
//return the index of this node;
//Create a list of infectedby array; Store all the initial into hashset;
//use bfs to search the infected nodes' neighbors;
//skip the three conditions;
// if (graph[w][j]==0) continue;  if there is no connections;
// if (seen[j]) continue;         if it has been visited before;
// if (initialinfect.Contains(j)) continue; if it is one one of the infected nodes originally.
public class Solution {
    public int MinMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.Length;
        List<int>[] infectedby = new List<int>[n];
        for(int i = 0; i < n; i++)
            infectedby[i] = new List<int>();
        
        HashSet<int> initialinfect = new HashSet<int>();
        for(int i = 0; i< initial.Length; i++)
            initialinfect.Add(initial[i]);
        
        Queue<int> q = new Queue<int>();
        foreach(int i in initial)
        {
            bool[]seen = new bool[n];
            q.Enqueue(i);
            while(q.Any())
            {
                int w = q.Dequeue();
                for(int j = 0 ; j < n; j++)
                {
                    if (graph[w][j]==0) continue;
                    if (seen[j]) continue;
                    if (initialinfect.Contains(j)) continue;
                    seen[j] = true;
                    infectedby[j].Add(i);
                    q.Enqueue(j);
                }
            }
        }
        int[] cntuniquelyinfectedby = new int[n];
        for(int i = 0; i<n; i++)
            if (infectedby[i].Count==1)
                cntuniquelyinfectedby[infectedby[i][0]]++;
        
        Array.Sort(initial);
        int ans=initial[0];
        int maxValue = cntuniquelyinfectedby.Max();
        int maxIndex = maxValue!=0?cntuniquelyinfectedby.ToList().IndexOf(maxValue):-1;
        ans = (maxIndex!=-1)?maxIndex:ans;
        return ans;
    }
}