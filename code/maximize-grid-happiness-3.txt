class Solution {
    static constexpr int d[] = {0, -30, 20};
    int cal(int p, int a) {
        return p == 0 ? 0 : (d[p] + a);
    }
    
    int get(int state, int x) {
        return (state >> (x << 1)) & 3;
    }
    
    int set(int state, int x, int y) {
        return state ^ ((get(state, x) ^ y) << (x << 1));
    }
    
public:
    int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {
        unordered_map<int, int> dp[2];
        dp[0][(introvertsCount << 10) | (extrovertsCount << 13)] = 0;
        int r = 0;
        for (int i = 0, last = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j, last ^= 1) {
                const int now = last ^ 1;
                dp[now].clear();
                for (const auto& p : dp[last]) {
                    const int up = get(p.first, j), left = j ? get(p.first, j - 1) : 0, x = (p.first >> 10) & 7, y = p.first >> 13, s = p.first & 1023;
                    int ns = set(p.first, j, 0);
                    dp[now][ns] = max(dp[now][ns], p.second);
                    if (x) {
                        ns = set(s, j ,1) | ((x - 1) << 10) | (y << 13);
                        r = max(r, dp[now][ns] = max(dp[now][ns], p.second + 120 + cal(up, -30) + cal(left, -30)));
                    }
                     if (y) {
                        ns = set(s, j ,2) | (x << 10) | ((y - 1) << 13);
                        r = max(r, dp[now][ns] = max(dp[now][ns], p.second + 40 + cal(up, 20) + cal(left, 20)));
                    }
                }
            }
        }
        return r;
    }
};