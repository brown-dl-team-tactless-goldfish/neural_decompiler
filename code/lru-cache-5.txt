// Circular Doubly Linked List
struct LRUObject{
  int key;
  int value;
  struct LRUObject* prev;
  struct LRUObject* next;
};
typedef struct LRUObject LRUObject;

typedef struct {
  LRUObject* Object;
}LRUCacheHash;

typedef struct {
  int capacity;
  int num_free;
  LRUObject* freelist;
  LRUObject* objects;
  LRUCacheHash* Hash_Table;
} LRUCache;

LRUCache* lRUCacheCreate(int capacity) {
  LRUCache* Cache = (LRUCache*)malloc(sizeof(LRUCache));
  Cache->capacity = capacity;
  Cache->num_free = capacity;
  Cache->objects  = NULL;
  Cache->freelist = calloc(capacity, sizeof(LRUObject));
  Cache->Hash_Table = (LRUCacheHash *)calloc(3001, sizeof(LRUCacheHash));
  return Cache;
}

LRUObject* lRUCacheGetObject(LRUCache* Cache, int key){
  //Cache is empty
  if (Cache->num_free == Cache->capacity) {
    return NULL;
  }
  
    //Cache is non-empty, so Scan it
  LRUObject *Object = NULL;
  
  if ((Object = (Cache->Hash_Table[key]).Object) && 
       Object->key == key)
  {
    //Object found in HT, move it to head of the list and return Object
    if ((Object != Cache->objects)) {
      //Move only if the Object is not at the head of the list already
      Object->prev->next = Object->next;
      Object->next->prev = Object->prev;
      Object->next = Cache->objects;
      Object->prev = (Cache->objects)->prev;
      (Cache->objects)->prev->next = Object;
      (Cache->objects)->prev = Object;

      Cache->objects = Object;
    }
    return Object;
  }
  
  return NULL;
}

int lRUCacheGet(LRUCache* Cache, int key) {
  LRUObject* Object = NULL;
  if ((Object = lRUCacheGetObject(Cache, key))) {
    return Object->value;
  }
  else {
    return -1;
  }
}

void lRUCachePut(LRUCache* Cache, int key, int value) {
  
  //Cache empty, All objects in Freelist
  if(Cache->capacity == Cache->num_free){
      Cache->objects =  Cache->freelist;
      (Cache->objects)->prev = Cache->objects;
      (Cache->objects)->next = Cache->objects;
      (Cache->objects)->key = key;
      (Cache->objects)->value = value;

      (Cache->Hash_Table[key]).Object = Cache->objects;
      
      Cache->num_free -= 1;
    return;
  }
  
  LRUObject* Object = NULL;
  //Check if Object to Put exists in Cache
  if ((Object = lRUCacheGetObject(Cache, key))){
    //Object exists, update and return
    Object->value = value;
    return;
  }
  
  //Object to put doesn't exist in Cache, Add it if possible
  if (Cache->num_free) {
    //Free space available
    Object = Cache->freelist + ((Cache->capacity - Cache->num_free));
    Object->next = Cache->objects;
    Object->prev = (Cache->objects)->prev;
    Object->key = key;
    Object->value = value;
    (Cache->objects)->prev->next = Object;
    (Cache->objects)->prev = Object;
    Cache->objects = Object;
    
    (Cache->Hash_Table[key]).Object = Object;
    
    Cache->num_free -= 1;
    return;
  }
  else {
    //No free space in Cache, Evict from the end!
    Object = Cache->objects->prev;
    
    (Cache->Hash_Table[Object->key]).Object = NULL;
    
    Object->key = key;
    Object->value = value;
    Cache->objects = Object;
    
    (Cache->Hash_Table[key]).Object = Object;
    
    return;
  }
}

void lRUCacheFree(LRUCache* Cache) {
  free(Cache->Hash_Table);
  free(Cache->freelist);
  free(Cache);
}

/**
 * Your LRUCache struct will be instantiated and called as such:
 * LRUCache* obj = lRUCacheCreate(capacity);
 * int param_1 = lRUCacheGet(obj, key);
 
 * lRUCachePut(obj, key, value);
 
 * lRUCacheFree(obj);
*/