void helper(struct TreeNode* node, int currDepth, int *totalDepth, double* result, int* count) {
    if (node == NULL) return;
    
    // update the maximum depth if we're deeper than we've ever been
    if (currDepth > *totalDepth) *totalDepth = currDepth;
    
    // update the doubles and the number of doubles appearing in this level
    result[currDepth] += node->val;
    ++count[currDepth];
    
    // DFS
    helper(node->left, currDepth + 1, totalDepth, result, count);
    helper(node->right, currDepth + 1, totalDepth, result, count);
}

double* averageOfLevels(struct TreeNode* root, int* returnSize){ 
    // allocate memory for resulting array and count of nodes per level
    // we'll allocate the maximum number of nodes possible, as we could in the most extreme case
    // have a one-sided 1000-node list
    double* result = calloc(1000, sizeof(double));
    int* count = calloc(1000, sizeof(int));
    // since we cannot dynamically allocate space per array, we'll need to keep track of the depth travelled.
    // one way to do this is to DFS travel the structure once and return the depth, THEN allocate the exact memory needed
    // this may be the most space efficient method, but time limit will be exceeded as we need to traverse the graph twice
    // instead we create an int and pass by reference
    int depth = 0;
    
    // average
    helper(root, 0, &depth, result, count);
    for (int i = 0; i <= depth; ++i) {
        result[i] /= count[i];    
    }
    // free this space up before we leave
    free(count);
    
    *returnSize = depth + 1;
    return result;
}