/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 * };
 */
/**
 * Return an array of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */
int cmp(void* a, void* b){
    return (*(int**)a)[0]-(*(int**)b)[0];
}
int cmp1(void* a, void* b){
    return (*(int**)a)[1]-(*(int**)b)[1];
}
int* findRightInterval(struct Interval* intervals, int intervalsSize, int* returnSize) {
    int* ret=(int*)calloc(intervalsSize,sizeof(int));
    *returnSize=intervalsSize;
    struct Interval* q=intervals;
    int** array=(int**)malloc(intervalsSize*sizeof(int*));
    int** array1=(int**)malloc(intervalsSize*sizeof(int*));
    for(int i=0;i<intervalsSize;i++){
        array[i]=(int*)calloc(3,sizeof(int));
        array[i][0]=q->start;
        array[i][1]=q->end;
        array[i][2]=i;
        array1[i]=(int*)calloc(3,sizeof(int));
        array1[i][0]=q->start;
        array1[i][1]=q->end;
        array1[i][2]=i;
        q++;
    }
    qsort(array,intervalsSize,sizeof(array[0]),cmp);
    qsort(array1,intervalsSize,sizeof(array1[0]),cmp1);
    int i=0;
    int j=0;
    for(;i<intervalsSize;i++){
        for(;j<intervalsSize;j++){
            if(array1[i][1]<=array[j][0]){
                ret[array1[i][2]]=array[j][2];
                break;
            }
        }
        if(j==intervalsSize){
            ret[array1[i][2]]=-1;
        }
    }
    return ret;
}
// method 2 Runtime: 280ms
// int* ret=(int*)calloc(intervalsSize,sizeof(int));
//     *returnSize=intervalsSize;
//     struct Interval* q=intervals;
//     int** array=(int**)malloc(intervalsSize*sizeof(int*));
//     for(int i=0;i<intervalsSize;i++){
//         array[i]=(int*)calloc(3,sizeof(int));
//         array[i][0]=q->start;
//         array[i][1]=q->end;
//         array[i][2]=i;
//         q++;
//     }
//     qsort(array,intervalsSize,sizeof(array[0]),cmp);
//     for(int i=0;i<intervalsSize-1;i++){
//         int j=i+1;
//         for(;j<intervalsSize;j++){
//             if(array[i][1]<=array[j][0]){
//                 ret[array[i][2]]=array[j][2];
//                 break;
//             }
//         }
//         if(j==intervalsSize){
//             ret[i]=-1;
//         }
//     }
//     ret[array[intervalsSize-1][2]]=-1;
//     return ret;