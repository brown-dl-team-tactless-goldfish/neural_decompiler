int count(int *nums, int startIdx, int endIdx, int turn, int len);

bool PredictTheWinner(int* nums, int numsSize){
    if(numsSize == 1){
        return true;
    }
    // take total sum of the array
    int sum = 0;
    for(int i=0; i<numsSize; i++){
        sum += nums[i];
    }
    // take first value, forward second index
    int tempFirstPass = nums[0] + count(nums, 1, numsSize-1, 2, numsSize-1);
    // take last value, forward first index
    int tempLastPass = nums[numsSize-1] + count(nums, 0, numsSize-2, 2, numsSize-1);
    // take maximum of the above two cases, and find player 2 value
    int maxPlayer1 = (tempFirstPass > tempLastPass) ? tempFirstPass : tempLastPass;
    int maxPlayer2 = sum - maxPlayer1;
    // printf("Sum: %d, P1: %d P2: %d\n", sum, maxPlayer1, maxPlayer2);
    // return True if P1 >= P2, False otherwise
    return (maxPlayer1 >= maxPlayer2) ? true : false;
}

int count(int *nums, int startIdx, int endIdx, int turn, int len){
    // base case where indexes meet, we dont need to traverse further
    if(startIdx == endIdx){
        return nums[startIdx];
    }
    int returnVal = 0;
    // handle player 2
    if(turn == 2){
        // player 2 takes first value, ignores last value
        int temp1 = count(nums, startIdx+1, endIdx, 1, len);
        // player 2 takes last value, ignores first value
        int temp2 = count(nums, startIdx, endIdx-1, 1, len);
        // take min of the two values for P2
        returnVal = (temp1 < temp2) ? temp1 : temp2;
    }
    // handle player 1
    else{
        // player 1 takes first value, ignores last value
        int temp1 = nums[startIdx] + count(nums, startIdx+1, endIdx, 2, len);
        // player 1 takes last value, ignores first value
        int temp2 = nums[endIdx] + count(nums, startIdx, endIdx-1, 2, len);
        // take max of the two values for P1
        returnVal = (temp1 > temp2) ? temp1 : temp2;
    }
    return returnVal;
}