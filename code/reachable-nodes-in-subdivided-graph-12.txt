/*
 *  Pass every node will occupy  a move, this is a little difference from standed djikstra alghrithm
 */
int reachableNodes(vector<vector<int>>& edges, int maxMoves, int n) {
  unordered_map<int, vector<pair<int, int>>> graph;
  for (const auto& edge : edges) {
	graph[edge[0]].emplace_back(edge[1], edge[2]);
	graph[edge[1]].emplace_back(edge[0], edge[2]);
  }
  vector<long> dists(n, INT_MAX);
  dists[0] = 0;
  queue<int> store;
  store.push(0);  
  while(!store.empty()) {
	int curNode = store.front();
	store.pop();
	for(const auto& edge : graph[curNode]) {
	  auto peer = edge.first;
	  auto dist = edge.second;
	  if(dists[peer] > dists[curNode] + dist + 1) {
		dists[peer] = dists[curNode] + dist + 1;
		store.push(peer);
	  }
	}
  }

  int result = 0;
  for (const auto& dist : dists) {
	if (dist <= maxMoves) {
	  ++ result;
	}
  }
  for (const auto& edge : edges) {
	int uv = maxMoves > dists[edge[0]] ? (maxMoves - dists[edge[0]]) : 0;
	int vu = maxMoves > dists[edge[1]] ? (maxMoves - dists[edge[1]]) : 0;
	result += std::min(edge[2], uv + vu);
  }
  return result;
}