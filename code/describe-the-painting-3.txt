#define pii pair<int,int>
#define s second
#define f first
#define piii pair<int,pii> 

class Solution {
public:
    
    long long min(long long a, long long b)
    {
        if(a<=b)
            return a;
        return b;
    }
    long long max(long long a, long long b)
    {
        if(a>=b)
            return a;
        return b;
    }
	
    vector<vector<long long>> splitPainting(vector<vector<int>>& segments) {
        
        unordered_map<long long,long long>mp;
        long long mini = INT_MAX;
        long long maxi = INT_MIN;
        unordered_map<long long,long long>mark;
        for(int i=0;i<segments.size();i++)
        {
			// If adding makes 0 at that position , mark it 
            if(mp[segments[i][0]]==(-1)*segments[i][2])
                mark[segments[i][0]]=1;
			//add at position to mark increment by line sweep
            mp[segments[i][0]]+=segments[i][2];
			
			// Similar as above
            if(mp[segments[i][1]]==segments[i][2])
                mark[segments[i][1]]=1;
				
			// Bracket is half open so , we have to suptract at end , not at end+1
            mp[segments[i][1]]-=segments[i][2];
			
            mini = min(mini,segments[i][0]);
            maxi = max(maxi,segments[i][1]);
        }
        long long val=mp[mini];
        long long st = mini;
        vector<vector<long long >>ans;
        for(long long i=mini+1;i<=maxi;i++)
        {
			// If that position is not zero then the value of iterval will be changed so we need to break
			// If the pos is 0 , but according to sample test 2 , it is actuay end and begin of new interval , so its like 1-1 =0, ie it became 0 by adding and subtracting same values at that position 
            if(mp[i]!=0||mark[i]==1)
            {
				// Only if value is non zero we consider it as interval
                if(val!=0)
                {
                    vector<long long>curr ={st,i,val};
                    ans.push_back(curr);
                }
				// Mark new start and add value
                st=i;
                val+=mp[i];
            }
                
        }
        return ans;
        
    }
};