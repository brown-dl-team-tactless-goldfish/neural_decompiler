class Solution {
public:
    
    void findEulerianPath(unordered_map<int, vector<int>>& graph, vector<vector<int>>& path, int node) {
        
        auto& adj = graph[node];
        while(adj.size()) {
            int adjnode = adj.back();
            adj.pop_back();
            findEulerianPath(graph, path, adjnode);
            path.push_back({node, adjnode});
        }
    }
    
    int findStartNode(unordered_map<int, int>& degree) {
        int start = -1;
        
        for(auto& [i, cnt] : degree) {
            if(cnt == 1) return i;
            start = i;
        }
        
        return start;
    }
    
    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {
         
		// Create adjacency list
        unordered_map<int, vector<int>> graph;
        unordered_map<int, int> degree;  // Store degree of nodes
        
        for(auto& pair : pairs) {
            int u = pair[0], v = pair[1];
            graph[u].push_back(v);
            degree[u]++;
            degree[v]--;
        }
        
		// Get starting node of Eulerian Path
        int start = findStartNode(degree);
        
        vector<vector<int>> path;
        findEulerianPath(graph, path, start);
        
        reverse(path.begin(), path.end());
        
        return path;
    }
};