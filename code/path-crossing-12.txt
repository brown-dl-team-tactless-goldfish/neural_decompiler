class Solution {
private:
    struct hasher {
        size_t operator()(std::pair<int, int> const &p) const noexcept {
            return (static_cast<size_t>(p.first) << 32) | static_cast<size_t>(p.second);
        }
    };

public:
    bool isPathCrossing(string const &path) {
        std::unordered_set<std::pair<int, int>, hasher> s;
        s.emplace(0, 0);
        std::pair<int, int> p{0, 0};
        for (auto c : path){
            switch (c) {
                case 'N':
                    ++p.second;
                    break;
                case 'S':
                    --p.second;
                    break;
                case 'E':
                    ++p.first;
                    break;
                case 'W':
                    --p.first;
                    break;
            }
            if (auto [_, inserted] = s.insert(p); !inserted)
                return true;
        }
        return false;
    }
};