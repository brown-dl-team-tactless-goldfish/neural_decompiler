class Solution {
public:
    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {
        vector<vector<int>> graph(n); // adjacent list
        for (auto &e : edges) {
			// 0-index
            graph[e[0]-1].emplace_back(e[1]-1);
            graph[e[1]-1].emplace_back(e[0]-1);
        }
        
        vector<vector<int>> min_dist(n);
        min_dist[0].emplace_back(0);
        
        queue<pair<int,int>> q; // (cur_dist, vertex)
        q.emplace(0, 0);
        
        while (!q.empty()) {
            auto [cur_dist, v] = q.front();
            q.pop();
            
            cur_dist++;
            
            for (auto &next_v : graph[v]) {
                if (min_dist[next_v].size() == 0 or (min_dist[next_v].size() == 1 and cur_dist > min_dist[next_v][0])) {
                    min_dist[next_v].emplace_back(cur_dist);
                    q.emplace(cur_dist, next_v);
                }
            }
        }
        
		// calculate time
        int res = 0;
        while (min_dist.back()[1]--) {
            if ((res / change) & 1) {
                res += change - res % change; // wait until green light
            }
            res += time;
        }
        return res;
    }
};