int fun(string &s , int k ,int i,  int cnt,int num,map<pair<int,int>,int>& fre)
{
    if(num>k)
        return -1e9 ; 
    if(i>=s.size())
        return cnt ; 
    //if we have already answer then we return that
    if(fre.find({i,cnt})!=fre.end())
        return fre[{i,cnt}];
    char c =s[i] ; 
    if(c=='0')
        return fun(s, k ,i+1,cnt+1, num,fre) ; 
    
    //to avoid overflow we put cnt<30
    else if(c=='1' and  cnt<30)
    {
        int op1 = fun(s , k , i+1,cnt+1, num|(1<<cnt),fre) ; 
        int op2 = fun(s, k, i+1,cnt, num,fre); 
        fre[{i,cnt}]=max(op1,op2);
            return max(op1,op2) ; 
    }
    //if s[i] is not 1 and cnt>30 then we search for the remaining zeros in the string
    return fun(s,k,i+1,cnt,num,fre);
}
int longestSubsequence(string s, int k) {
    //here we reverse the string bez in num addition of zero not effect the num
    reverse(s.begin(),s.end() ); 
    map<pair<int,int>,int> fre;
    int ans = fun(s, k, 0 , 0 , 0,fre) ; 
    return ans ; 
}