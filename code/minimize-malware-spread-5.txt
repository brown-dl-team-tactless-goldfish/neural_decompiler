    public class Solution
    {
        private class Unions
        {
            private readonly int[] _parents;
            private readonly int[] _ranks;

            public Unions(int n)
            {
                _parents = new int[n];
                _ranks = new int[n];
                for (int i = 0; i < n; i++)
                {
                    _parents[i] = i;
                }
            }

            public int Find(int x)
            {
                if (x != _parents[x])
                {
                    x = Find(_parents[x]);
                }
                return _parents[x];
            }

            public bool Union(int x, int y)
            {
                int px = Find(x);
                int py = Find(y);
                if (px == py)
                {
                    return false;
                }
                if (_ranks[px] > _ranks[py])
                {
                    _parents[py] = px;
                    _ranks[px]++;
                }
                else
                {
                    _parents[px] = py;
                    _ranks[py]++;
                }
                return true;
            }
        }

        private void Dfs(int[][] graph, int node, bool[] visited, Unions dsu)
        {
            if (visited[node])
            {
                return;
            }

            visited[node] = true;
            for (int i = 0; i < graph[node].Length; i++)
            {
                if (graph[node][i] == 1)
                {
                    dsu.Union(node, i);
                    Dfs(graph, i, visited, dsu);
                }
            }
        }

        public int MinMalwareSpread(int[][] graph, int[] initial)
        {
            int length = graph.Length;
            var initialSet = initial.ToHashSet();
            bool[] visited = new bool[length];
            Unions dsu = new Unions(length);
            for (int i = 0; i < length; i++)
            {
                Dfs(graph, i, visited, dsu);
            }

            IDictionary<int, IList<int>> components = new Dictionary<int, IList<int>>();
            for (int i = 0; i < length; i++)
            {
                var root = dsu.Find(i);
                if (!components.ContainsKey(root))
                {
                    components[root] = new List<int>();
                }
                components[root].Add(i);
            }

            int? res = null;
            IDictionary<int, IList<int>> components2Initial = new Dictionary<int, IList<int>>();

            foreach (var c in components)
            {
                components2Initial[c.Key] = new List<int>();
                foreach (var n in c.Value)
                {
                    if (initialSet.Contains(n))
                    {
                        components2Initial[c.Key].Add(n);
                    }
                }


                if (components2Initial[c.Key].Count == 1)
                {
                    var cand = components2Initial[c.Key].First();
                    res = res ?? cand;

                    if (components[c.Key].Count > components[dsu.Find(res.Value)].Count)
                    {
                        res = cand;
                    }
                    else
                    {
                        if (components[c.Key].Count == components[dsu.Find(res.Value)].Count)
                        {
                            res = Math.Min(res.Value, cand);
                        }
                    }
                }
            }


            return res.GetValueOrDefault(initial.Min());
        }
    }