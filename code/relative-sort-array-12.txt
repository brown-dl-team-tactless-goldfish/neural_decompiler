int comparator1(const void * lhs, const void * rhs){
    int a = *(const int *)lhs;
    int b = *(const int *)rhs;
    
    return (a > b) - (a < b);
}

int comparator2(const void * lhs, const void * rhs){
    int a = *(const int *)lhs & 0xFFFF;
    int b = *(const int *)rhs & 0xFFFF;
    
    return (a > b) - (a < b);
}

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* relativeSortArray(int* arr1, int arr1Size, int* arr2, int arr2Size, int* returnSize){
    int * output = malloc(arr1Size * sizeof(int));
    int i;
    int hi, mid, lo;
    int elem;
    
    /* Bake in original position in reference array. */
    for(i = 0; i < arr2Size; ++i)
        arr2[i] |= (i + 1) << 16;
    
    /* Sort reference array in order of value. */
    qsort(arr2, arr2Size, sizeof(int), comparator2);
    
    /* Binary search reference array to find matching value. */
    for(i = 0; i < arr1Size; ++i){
        lo = 0;
        hi = arr2Size - 1;
        
        while (lo <= hi) {
            mid = (lo + hi) / 2;
            elem = arr2[mid] & 0xFFFF;
            
            if (elem < arr1[i]){
                lo = mid + 1;    
            }else if (elem > arr1[i]) {
                hi = mid - 1;
            }else{
                /* Take reference element's position and value. */
                arr1[i] |= arr2[mid];
                break;
            }
        }
        
        if(lo > hi){
            /* Apply highest position in order to put at end. */
            arr1[i] |= 0x7FFF0000;
        }
    }
    
    /* Sort original array by reference index. */
    qsort(arr1, arr1Size, sizeof(int), comparator1);
    
    /* Strip reference index off when writing to output. */
    for(i = 0; i < arr1Size; ++i)
        output[i] = arr1[i] & 0xFFFF;
    
    *returnSize = arr1Size;
    
    return output;
}