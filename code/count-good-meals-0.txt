#define LIMIT 22
int cmpfunc(const void* a, const void* b){
    return *(int*)a - *(int*)b;
}
//
//find how many items k between [begin, end]
//
int process(int* nums, int begin, int end, int k){
    int i;
    int mid;
    int cn = 0;
    int left = begin;
    int right = end;
    bool find = false;
    while(left <= right){
        mid = (left + right)/2;
        if(nums[mid] == k){
            find = true;
            cn = 1;
            break;
        }
        
        if(nums[mid] > k){
            right = mid -1;
        }
        else{
            left = mid + 1;
        }
    }
    
    if(find == true){
        for(i = mid + 1; i <= end; i++){
            if(nums[i] == k)
                cn++;
            else
                break;
        }
        
        for(i = mid - 1; i >= begin; i--){
            if(nums[i] == k)
                cn++;
            else
                break;
        }
    }
    
    return cn;
}
int countPairs(int* deliciousness, int deliciousnessSize){
    int i, j;
    int k;
    int* pow = malloc(LIMIT * sizeof(int));
    pow[0] = 1;
    for(i = 1; i < LIMIT; i++){
        pow[i] = 2* pow[i-1];
    }
    int mod = 1e9 + 7;
    int ans = 0;
    int match; 
    qsort(deliciousness, deliciousnessSize, sizeof(int), cmpfunc);
    for(i = 0; i < deliciousnessSize-1; i++){
        //
        //if same as ex-item, save the process time
        if(i > 0 && deliciousness[i] == deliciousness[i-1]){
            for(j = 0; j < LIMIT; j++){
                if(pow[j] == deliciousness[i] *2){
                    match--; 
                    break;
                }
                if(pow[j] > deliciousness[i] *2)
                    break;
            }
            ans = (1L* ans + match) % mod;
            continue;
        }
        
        match  = 0;   //each pow[] round 
        for(j = 0; j < LIMIT; j++){
            k = pow[j] - deliciousness[i];
            if(k < deliciousness[i])
                continue;
            if(k > deliciousness[deliciousnessSize-1] )
                break;
            
            else{
                match += process(deliciousness, i+1, deliciousnessSize-1, k);
            }
        }
        ans = ans + match;
    }
    
    free(pow);
    return ans;
}