class Solution {
public:
    vector<int> bestCoordinate(vector<vector<int>>& towers, int radius) {
        int n = towers.size(), max_val = INT_MIN;
        vector<int> result(2, INT_MAX);
        
       for(int i=0; i<n; i++){
           int curr_val = 0;
           for(int j=0; j<n; j++){
               double distance = (double)sqrt((double)pow((double)(abs(towers[i][0] - towers[j][0])), 2) + (double)pow((double)abs(towers[i][1] - towers[j][1]), 2));
               if(distance <= radius){
                   int signal_quality = towers[j][2] / (1 + distance);
                   curr_val += signal_quality;
               }
           }
           if(curr_val >= max_val){
               if(curr_val == max_val){
                   if(result[0] > towers[i][0])
                       result = {towers[i][0], towers[i][1]};
                   else if(result[0] == towers[i][0] && result[1] > towers[i][1]){
                       result = {towers[i][0], towers[i][1]};
                   }
               }
               else
                   result = {towers[i][0], towers[i][1]};
               max_val = curr_val;
           }
       }
        
        return result;
    }
};

/*
Algorithm Outline:
1. O(n^2) for loop all combinationsradius
2. take max and update lex smaller in a value
3/ check if distance <= radius
*/