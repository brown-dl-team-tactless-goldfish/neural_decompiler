/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
struct list{
    int val;
    int x;
    int y;
};

struct pp{
    int val;
    int place;
};

int comp(const void* a, const void* b){
    return (*(struct pp*)a).val - (*(struct pp*)b).val;
}

void input(int** grid, int gridSize, int gridColSize, int i, int j, struct list* helper, int* count, bool** used, int* nowpoint, int nowval){
    used[i][j] = true;
    if (nowval > grid[i][j]){
        *nowpoint += 1;
        if (i-1 >= 0 && !used[i-1][j]){
            input(grid, gridSize, gridColSize, i-1, j,  helper, count, used, nowpoint, nowval);
        }
        if (i+1 < gridSize && !used[i+1][j]){
            input(grid, gridSize, gridColSize, i+1, j,  helper, count, used, nowpoint, nowval);
        }
        if (j-1 >= 0 && !used[i][j-1]){
            input(grid, gridSize, gridColSize, i, j-1,  helper, count, used, nowpoint, nowval);
        }
        if (j+1 < gridColSize && !used[i][j+1]){
            input(grid, gridSize, gridColSize, i, j+1,  helper, count, used, nowpoint, nowval);
        }
    } else {
        helper[*count].val = grid[i][j];
        helper[*count].x = i;
        helper[*count].y = j;
        *count += 1;
    }
}

int* maxPoints(int** grid, int gridSize, int* gridColSize, int* queries, int queriesSize, int* returnSize){
    int nowpoint = 0;
    struct list* helper1 =  malloc(sizeof(struct list)*(gridSize*(*gridColSize)));
    struct list* helper2 =  malloc(sizeof(struct list)*(gridSize*(*gridColSize)));
    int count1 = 0;
    int count2 = 0;

    struct pp* remake = malloc(sizeof(struct pp)*queriesSize);
    for (int i = 0 ; i < queriesSize ; i++){
        remake[i].val = queries[i];
        remake[i].place = i;
    }
    qsort(remake, queriesSize, sizeof(struct pp), comp);

    *returnSize = queriesSize;
    int* ans = malloc(sizeof(int)*queriesSize);

    bool** used = malloc(sizeof(bool*)*gridSize);
    for (int i = 0 ; i < gridSize ; i++){
        used[i] = calloc(*gridColSize, sizeof(bool));
    }
    
    input(grid, gridSize, *gridColSize, 0, 0,  helper1, &count1, used, &nowpoint, remake[0].val);
    ans[remake[0].place] = nowpoint;

    for (int i = 1 ; i < queriesSize ; i++){
        if ((i&1) == 1){
            count2 = 0;
            for (int m = 0 ; m < count1 ; m++){
                input(grid, gridSize, *gridColSize, helper1[m].x, helper1[m].y,  helper2, &count2, used, &nowpoint, remake[i].val);
            }
        } else {
            count1 = 0;
            for (int m = 0 ; m < count2 ; m++){
                input(grid, gridSize, *gridColSize, helper2[m].x, helper2[m].y,  helper1, &count1, used, &nowpoint, remake[i].val);
            }
        }
        ans[remake[i].place] = nowpoint;
    }
    free(remake);
    free(helper1);
    free(helper2);
    for (int i = 0 ; i < gridSize ; i++){
        free(used[i]);
    }
    free(used);

    return ans;
}