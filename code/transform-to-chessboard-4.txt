    public class Solution
    {
        private int Helper(int[] rows, int[] rowPatterns, int[] columnPatterns, int n, int m)
        {
            int rowSwaps = 0;

            for (int i = 0; i < n; i++)
            {
                if (rows[i] != rowPatterns[i & 1])
                {
                    rowSwaps++;
                }
            }

            if ((rowSwaps & 1) == 1)
            {
                return int.MaxValue;
            }

            int colSwaps = 0;
            for (int j = 0; j < m; j++)
            {
                var bit = (rowPatterns[0] & (1 << j)) >> j;
                if (bit != columnPatterns[j & 1])
                {
                    colSwaps++;
                }
            }

            if ((colSwaps & 1) == 1)
            {
                return int.MaxValue;
            }

            rowSwaps /= 2;
            colSwaps /= 2;

            return rowSwaps + colSwaps;
        }

        public int MovesToChessboard(int[][] board)
        {
            int n = board.Length;
            int m = board[0].Length;

            int[] rows = new int[n];
            IDictionary<int, int> row2Count = new Dictionary<int, int>();

            for (int i = 0; i < n; i++)
            {
                int row = 0;
                for (int j = 0; j < m; j++)
                {
                    row |= (board[i][j] << j);
                }

                if (!row2Count.ContainsKey(row))
                {
                    row2Count[row] = 0;
                }

                row2Count[row]++;
                rows[i] = row;
            }

            if (row2Count.Count != 2)
            {
                return -1;
            }

            int[] rowPatterns = new int[2];
            rowPatterns[0] = row2Count.First().Key;
            rowPatterns[1] = rowPatterns[0];

            for (int j = 0; j < m; j++)
            {
                rowPatterns[1] ^= (1 << j);
            }

            if (!row2Count.ContainsKey(rowPatterns[1]))
            {
                return -1;
            }

            if ((n & 1) == 1 && Math.Abs(row2Count[rowPatterns[0]] - row2Count[rowPatterns[1]]) != 1)
            {
                return -1;
            }

            if ((n & 1) == 0 && row2Count[rowPatterns[0]] != row2Count[rowPatterns[1]])
            {
                return -1;
            }
            
            int[] bitsCount = new int[2];

            for (int j = 0; j < m; j++)
            {
                var bit = (rowPatterns[0] & (1 << j)) >> j;
                bitsCount[bit]++;
            }

            if ((m & 1) == 1 && Math.Abs(bitsCount[0] - bitsCount[1]) != 1)
            {
                return -1;
            }

            if ((m & 1) == 0 && bitsCount[0] != bitsCount[1])
            {
                return -1;
            }


            int res = int.MaxValue;

            res = Math.Min(res, Helper(rows, rowPatterns, new[] {0, 1}, n, m));
            res = Math.Min(res, Helper(rows, rowPatterns, new[] { 1, 0 }, n, m));

            var tmp = rowPatterns[0];
            rowPatterns[0] = rowPatterns[1];
            rowPatterns[1] = tmp;

            res = Math.Min(res, Helper(rows, rowPatterns, new[] { 0, 1 }, n, m));
            res = Math.Min(res, Helper(rows, rowPatterns, new[] { 1, 0 }, n, m));

            return res;
        }
    }