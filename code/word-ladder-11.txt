/* deque_type is a deque object that the deque_foo functions
 * act upon.  New deque_type objects can be created with deque_alloc.
 */
typedef struct deque_struct deque_type;

/* This deque_val_type is the type of all values stored in the deque.
 * Change this to the type you want to store in your deque.
 */
typedef unsigned long deque_val_type;

/* Instantiates a new deque_type.
 * Returns a pointer to a new deque_type with memory allocated by malloc,
 * returns NULL if it fails.
 */
deque_type * deque_alloc();

/* Frees a deque_type pointed to by *d */
void deque_free(deque_type *d);

/* Returns true if there are no values in the deque, false otherwise. */
bool deque_is_empty(deque_type *d);

/* Adds a new value to the front/back of the deque_type *d */
void deque_push_front(deque_type *d, deque_val_type v);
void deque_push_back(deque_type *d, deque_val_type v);

/* Removes and returns the front/back value of the deque *d */
deque_val_type deque_pop_front(deque_type *d);
deque_val_type deque_pop_back(deque_type *d);

/* Returns the front/back value of the deque *d */
deque_val_type deque_peek_front(deque_type *d);
deque_val_type deque_peek_back(deque_type *d);


struct node_struct {
	struct node_struct *next;
	struct node_struct *prev;
	deque_val_type val;
};

struct deque_struct {
	struct node_struct *head;
	struct node_struct *tail;
};

deque_type * deque_alloc() {
	deque_type *d = malloc(sizeof(deque_type));
	if (d != NULL)
		d->head = d->tail = NULL;
	return d;
}

void deque_free(deque_type *d) {
	free(d);
}

bool deque_is_empty(deque_type *d) {
	return d->head == NULL;
}

void deque_push_front(deque_type *d, deque_val_type v) {
	struct node_struct *n = malloc(sizeof(struct node_struct));
	assert(n != NULL);
	n->val = v;
	n->next = d->head;
	n->prev = NULL;
	if (d->tail == NULL) {
		d->head = d->tail = n;
	} else {
		d->head->prev = n;
		d->head = n;
	}
}

void deque_push_back(deque_type *d, deque_val_type v) {
	struct node_struct *n = malloc(sizeof(struct node_struct));
	assert(n != NULL);
	n->val = v;
	n->prev = d->tail;
	n->next = NULL;
	if (d->head == NULL) {
		d->head = d->tail = n;
	} else {
		d->tail->next = n;
		d->tail = n;
	}
}

deque_val_type deque_pop_front(deque_type *d) {
	deque_val_type v = d->head->val;
	struct node_struct *n = d->head;
	if (d->head == d->tail)
		d->head = d->tail = NULL;
	else
		d->head = n->next;
	free(n);
	return v;
}

deque_val_type deque_pop_back(deque_type *d) {
	deque_val_type v = d->tail->val;
	struct node_struct *n = d->tail;
	if (d->head == d->tail)
		d->head = d->tail = NULL;
	else
		d->tail = n->prev;
	free(n);
	return v;
}

deque_val_type deque_peek_front(deque_type *d) {
	return d->head->val;
}

deque_val_type deque_peek_back(deque_type *d) {
	return d->tail->val;
}

int dist(char *a, char *b)
{
    int i, n, cnt = 0;
    
    n = strlen(a);
    assert(n == strlen(b));
    
    for (i = 0; i < n; i++) {
        if (a[i] != b[i])
            cnt++;
    }
    
    return cnt;
}

int **adjacency_matrix(char **words, int N)
{
    int **m = malloc(sizeof(int *) * N);
    int r, i, j;
    
    for (r = 0; r < N; r++)
        m[r] = calloc(N, sizeof(int));
        
    // for every pair of words, if distance is 1,
    // then add it to the graph
    for (i = 0; i < N; i++) {
        for (j = i + 1; j < N; j++) {
            if (dist(words[i], words[j]) == 1) {
                m[i][j] = 1;
                m[j][i] = 1;
            }
        }
    }
    
    return m;
}

typedef struct node_t {
    int n;
    int dist;
} node_t;

node_t *new_node(int n, int dist)
{
    node_t *node = malloc(sizeof(node_t));
    node->n = n;
    node->dist = dist;
    return node;
}

int ladderLength(char * beginWord, char * endWord, char ** wordList, int wordListSize)
{
    // add beginword and endword to the list
    int N = wordListSize + 1;
    int begin_idx = N - 1, end_idx;
    int *visited = calloc(N, sizeof(int));
    int i;
    
    wordList = realloc(wordList, sizeof(char *) * N);
    assert(wordList);
    wordList[begin_idx] = beginWord;
    
    // search the end_idx word
    for (i = 0; i < N; i++) {
        if (strcmp(endWord, wordList[i]) == 0)
            end_idx = i;
    }

    int **graph = adjacency_matrix(wordList, N);
    
    // bfs   
    deque_type *d = deque_alloc();
    deque_push_back(d, new_node(begin_idx, 1));
	while (deque_is_empty(d) != true) {
		node_t *n = deque_pop_front(d);
        int nei;
        for (nei = 0; nei < N; nei++) {
            if (graph[n->n][nei] == 1) {
                if (visited[nei])
                    continue;
                visited[nei] = 1;
                if (nei == end_idx) {
                    return n->dist + 1;
                }
                deque_push_back(d, new_node(nei, n->dist + 1));
            }
        }
        free(n);
	}
    
    return 0;
}