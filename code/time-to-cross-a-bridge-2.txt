class Solution {
public:
    int findCrossingTime(int n, int k, vector<vector<int>>& time) {
        int ans = 0, free = 0; 
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> l, r; 
        priority_queue<pair<int, int>> ll, rr; 
        for (int i = 0; i < time.size(); ++i) 
            ll.emplace(time[i][0]+time[i][2], i); 
        while (n || r.size() || rr.size()) {
            if (rr.empty() && (r.empty() || r.top().first>free) && (!n || ll.empty() && (l.empty() || l.top().first>free))) {
                int cand = INT_MAX; 
                if (n && l.size()) cand = min(cand, l.top().first); 
                if (r.size()) cand = min(cand, r.top().first); 
                free = cand; 
            }
            while (l.size() && l.top().first <= free) {
                auto [_, i] = l.top(); l.pop(); 
                ll.emplace(time[i][0]+time[i][2], i); 
            }
            while (r.size() && r.top().first <= free) {
                auto [_, i] = r.top(); r.pop(); 
                rr.emplace(time[i][0]+time[i][2], i); 
            }
            if (rr.size()) {
                auto [_, i] = rr.top(); rr.pop(); 
                free += time[i][2]; 
                if (n) l.emplace(free+time[i][3], i); 
                else ans = max(ans, free); 
            } else {
                auto [_, i] = ll.top(); ll.pop();
                free += time[i][0]; 
                r.emplace(free+time[i][1], i); 
                --n; 
            }
        }
        return ans; 
    }
};