/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

void dfs( struct TreeNode *root, int dis, int *llt, int *rlt, int *merge, int l, int *cnt, int *leaf_num_l, int *leaf_num_r ){
    if( root == NULL ){
        return;
    }//end if
    if( root -> left == NULL && root -> right == NULL && l ){
        llt[(*leaf_num_l)++] = 1;
        return;
    }//end if
    if( root -> left == NULL && root -> right == NULL && !l ){
        rlt[(*leaf_num_r)++] = 1;
        return;
    }//end if
    
    int i, j, count = 0;
    int *lt;
    int *rt;
    lt = malloc( sizeof(int) * 256 );
    rt = malloc( sizeof(int) * 256 );
    
    dfs( root -> left, dis, llt, rlt, merge, 1, cnt, leaf_num_l, leaf_num_r );
    int leaf_l = *leaf_num_l;
    for( i = 0; i < leaf_l; i++ ){
        lt[i] = llt[i];
    }//end for
    *leaf_num_l = 0;
    *leaf_num_r = 0;
    dfs( root -> right, dis, llt, rlt, merge, 0, cnt, leaf_num_l, leaf_num_r );
    int leaf_r = *leaf_num_r;
    for( i = 0; i < leaf_r; i++ ){
        rt[i] = rlt[i];
    }//end for
    *leaf_num_l = 0;
    *leaf_num_r = 0;
    
    for( i = 0; i < leaf_l ; i++ ){
        for( j = 0; j < leaf_r ; j++ ){
            if( lt[i] + rt[j] <= dis ){
                (*cnt)++;
            }//end if
        }//end for
        int t = lt[i] + 1;
        if( t < dis ){
            merge[count++] = t;
        }//end if
    }//end for
    
    for( j = 0; j < leaf_r; j++ ){
        int t = rt[j] + 1;
        if( t < dis ){
            merge[count++] = t;
        }//end if
    }//end for
    if( l == 1){
        for( i = 0; i < count; i++ ){
            llt[i] = merge[i];
        }//end for
        *leaf_num_l = count;
    }//end if
    else{
        for( i = 0; i < count; i++ ){
            rlt[i] = merge[i];
        }//end for
        *leaf_num_r = count;
    }//end else
    
    free(lt);
    free(rt);
    
    return;
}

void helper( struct TreeNode *root, int dis, int *llt, int *rlt, int *merge, int *cnt ){
    int leaf_num_l = 0;
    int leaf_num_r = 0;
    int *lt;
    int *rt;
    int i, j;
    
    lt = malloc( sizeof(int) * 256 );
    rt = malloc( sizeof(int) * 256 );
    dfs( root -> left, dis, llt, rlt, merge, 1, cnt, &leaf_num_l, &leaf_num_r );
    int leaf_l = leaf_num_l;
    for( i = 0; i < leaf_l; i++ ){
        lt[i] = llt[i];
    }//end for
    leaf_num_l = 0;
    leaf_num_r = 0;
    dfs( root -> right, dis, llt, rlt, merge, 0, cnt, &leaf_num_l, &leaf_num_r );
    int leaf_r = leaf_num_r;
    for( i = 0; i < leaf_r; i++ ){
        rt[i] = rlt[i];
    }//end for

    for( i = 0; i < leaf_l ; i++ ){
        for( j = 0; j < leaf_r ; j++ ){
            if( lt[i] + rt[j] <= dis ){
                (*cnt)++;
            }//end if
        }//end for
    }//end for
    
    free(lt);
    free(rt);
}
int countPairs(struct TreeNode* root, int distance){
    //int depth = 0;
    int cnt = 0;
    int *llt;
    int *rlt;
    int *merge;
    int i;
    
    llt = malloc( sizeof( int ) * 256 );
    rlt = malloc( sizeof( int ) * 256 );
    merge = malloc( sizeof( int ) * 256 );
    
    helper( root, distance, llt, rlt, merge, &cnt );
    
    return cnt;
}