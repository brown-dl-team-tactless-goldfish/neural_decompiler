class Solution {
public:
    int maximumTop(vector<int>& nums, int k) {
	
	//if there is only one element, must alternately remove it and replace it;
	//if k is odd then the top will be left empty.
        if(nums.size() == 1 && k % 2 == 1) return -1; 
		
		// if k is smaller than nums size, removing k will expose nums[k] as top.
		//Element at k-1 cannot be top b/c no replace operation left to put it back after removal at kth step.
		//Otherwise, any element up to k-1 can be put back as final step.
        int max_top = 0;
        if(k < nums.size()){
            max_top = nums[k];
            for(int i = 0; i < k-1; i++)
                if(nums[i] > max_top) max_top = nums[i];
        }
		
		//if k is same as number of elements, removing k leaves empty stack.
		//Removing k-1 leaves one move left to replace any previous removal,
		//however the last element itself cannot be replaced after using the last
		//move to remove it. So any max value in nums besides that one may be
		//the final top.
        else if(k == nums.size()){
            for(int i = 0; i <= k-2; i++)
                if(nums[i] > max_top) max_top = nums[i];
        }
		//if k is greater than size of nums, can remove all, then alternate remove-replace
		//  to pick any val in nums as final top.
        else if(k > nums.size()){
            for(int i = 0; i <= nums.size()-1; i++)
                if(nums[i] > max_top) max_top = nums[i];
        }
        return max_top;
    }
};