/*
    Subsequence ends only with 2
    0^n->1^m->2^k n,m,k>=1 
    Invalid: 1->0 , 2->0 , 2->1 ,  0->2 . So u cannot include current index. Go to next index. 
    No skipping: Include current index so prev becomes nums[index] or skip current index; 
*/
class Solution {
public:
    int mod = 1e9+7 , n;
    int dp[100001][4]; 
    
    int solve(vector<int>& nums,int prev , int index) {
        if(index == n)
            return prev==2;  
        if(dp[index][prev+1]!=-1)
            return dp[index][prev+1]%mod;  
        
        if(nums[index]<prev || (prev==0 && nums[index]==2) || (prev==-1 && nums[index]!=0))
            return dp[index][prev+1] = solve(nums,prev,index+1) %mod; 
        
        return dp[index][prev+1] = (solve(nums,prev,index+1)%mod + solve(nums,nums[index] , index+1)%mod)%mod; 
    }
            
    int countSpecialSubsequences(vector<int>& nums) {
        n = nums.size(); 
        memset(dp , -1, sizeof(dp)); 
        return solve(nums,-1,0)%mod;
    }    
};