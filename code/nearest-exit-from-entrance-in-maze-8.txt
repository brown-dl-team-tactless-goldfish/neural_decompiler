class Solution {
    
private:
    int bfs(int row,int col,vector<vector<char>>&maze,vector<vector<int>>&visited){
        int n = maze.size();
        int m = maze[0].size();
        vector<int> dr = {-1,0,1,0};
        vector<int> dc = {0,1,0,-1};
        queue<vector<int>> q;
        q.push({row,col,0});
        visited[row][col] = 1;
        while(!q.empty()){
            int r = q.front()[0];
            int c = q.front()[1];
            int steps = q.front()[2];
            q.pop();
            if((r!=row || c!=col) && (r==0 || c==0 || r==n-1 || c==m-1)){
                return steps;
            }
            steps++;
            for(int i=0;i<4;i++){
                int nr = r + dr[i];
                int nc = c + dc[i];
                if(nr>=0 && nr<n && nc>=0 && nc<m && !visited[nr][nc] && maze[nr][nc]=='.'){
                    visited[nr][nc] = 1;
                    q.push({nr,nc,steps});
                }
            }
        }
        return -1;
    }
    
    
public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
        int n = maze.size();
        int m = maze[0].size();
        vector<vector<int>>visited(n,vector<int>(m,0));
        int r = entrance[0];
        int c = entrance[1];
        
        int steps = bfs(r,c,maze,visited);
        return steps;
    }
};