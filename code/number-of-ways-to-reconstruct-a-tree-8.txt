class Solution:
    def checkWays(self, pairs: List[List[int]]) -> int:
        neighbor = defaultdict(set)
        for x,y in pairs:
            neighbor[x].add(y)
            neighbor[y].add(x)
        
        # find out all connected components among nodes
        def split(nodes, pres):
            rst = []
            seen = set()
            for n in nodes:
                if n not in seen and n not in pres:
                    tmp = set()
                    que = deque([n])
                    seen.add(n)
                    while que:
                        q = que.popleft()
                        tmp.add(q)
                        for nextnode in neighbor[q]:
                            if nextnode not in seen and nextnode not in pres:
                                que.append(nextnode)
                                seen.add(nextnode)
                    rst.append(tmp)
            return rst
            
        
        # how many ways, given node set as nodes.
        def check(nodes, pres):
            if len(nodes) == 1: return 1
            if len(nodes) == 2: return 2
            root = set()
            for n in nodes:
                if len(neighbor[n]) == len(nodes) - 1 + len(pres):
                    root.add(n)
            if not root: return 0
            elif len(root) == len(nodes): return len(root)
            pres = pres | root
            comps = split(nodes, pres)
            rst = 1
            for c in comps: rst *= check(c, pres)
                
            return rst*len(root)
        
        t =  check(neighbor.keys(), set())
        if t > 1: return 2
        return t