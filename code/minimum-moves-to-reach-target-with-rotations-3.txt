void bfs(vector<vector<int>>& grid, vector<int> pos, vector<vector<vector<int>>>& dp, queue<vector<int>>& q) {
        int n = grid.size();
        int r = pos[0];
        int c = pos[1];
        int f = pos[2];//0 for horizontal, 1 for vertical
        int cur = dp[r][c][f];
        vector<int> next(3);
        if (f == 0) {
            if (r < n - 1 && grid[r + 1][c] == 0 && grid[r + 1][c + 1] == 0) {
                if (dp[r + 1][c][0] < 0) {//向下平移
                    dp[r + 1][c][0] = cur + 1;
                    next[0] = r + 1; next[1] = c; next[2] = 0;
                    q.push(next);
                }
                if (dp[r][c][1] < 0) {//顺时针转
                    dp[r][c][1] = cur + 1;
                    next[0] = r; next[1] = c; next[2] = 1;
                    q.push(next);
                }
            }
            if (c < n - 2 && grid[r][c + 2] == 0) {
                if (dp[r][c + 1][0] < 0) {//向右平移
                    dp[r][c + 1][0] = cur + 1;
                    next[0] = r; next[1] = c + 1; next[2] = 0;
                    q.push(next);
                }
            }
         }
        if (f == 1) {
            if (c < n - 1 && grid[r][c + 1] == 0 && grid[r + 1][c + 1] == 0) {
                if (dp[r][c + 1][1] < 0) {//向右平移
                    dp[r][c + 1][1] = cur + 1;
                    next[0] = r; next[1] = c + 1; next[2] = 1;
                    q.push(next);
                }
                if (dp[r][c][0] < 0) {//逆时针转
                    dp[r][c][0] = cur + 1;
                    next[0] = r; next[1] = c; next[2] = 0;
                    q.push(next);
                }
            }
            if (r < n - 2 && grid[r + 2][c] == 0) {
                if (dp[r + 1][c][1] < 0) {//向下平移
                    dp[r + 1][c][1] = cur + 1;
                    next[0] = r + 1; next[1] = c; next[2] = 1;
                    q.push(next);
                }
            }
        }
    }
	
int minimumMoves(vector<vector<int>>& grid) {
        int n = grid.size();
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(2, -1)));
        queue<vector<int>> q;
        vector<int> pos = {0, 0, 0};
        vector<int> last(3);
        last[0] = n - 1;
        last[1] = n - 2;
        q.push(pos);
        dp[0][0][0] = 0;
        while (!q.empty()) {
            pos = q.front();
            if (pos == last) break;
            q.pop();
            bfs(grid, pos, dp, q);
        }
        return dp[n - 1][n - 2][0];
  }