class Solution {
private:
    int rows;
    int cols;
public:
    bool isValid(int x, int y){
        if(x<0 || x>=rows || y<0 || y>=cols)return false;
        return true;
    }
    
    vector<pair<int, int>>dfs(vector<vector<int>>&grid, int x, int y){
        if(!isValid(x, y))return {}; // return an empty vector
        
        int dx[] = {0, 0, 1, -1};
        int dy[] = {1, -1, 0, 0,};
        
        vector<pair<int, int>>ans;
        for(int i = 0; i<4; i++){
            if(isValid(dx[i]+x, dy[i]+y)){
                if(grid[dx[i]+x][dy[i]+y] == 1){
                    ans.push_back({dx[i]+x, dy[i]+y});
                }
            }
        }
        return ans;
    }
    int orangesRotting(vector<vector<int>>& grid) {
        ios_base::sync_with_stdio(false);
        cin.tie(0);
        
        int m = (int)grid.size();
        int n = (int)grid[0].size();
        this->rows = m;
        this->cols = n;
        // to check if there exists an apple which is not yet rotten
        bool exists = false;
        
        for(int i = 0; i<m; i++){
            for(int j = 0; j<n; j++){
                if(grid[i][j] == 1){
                    exists = true;
                    break;
                }
            }
        }
		
        if(!exists)return 0;
        queue<pair<int, int>>q; // to store the indices of the rotten oranges.
		
        for(int i = 0; i<m; i++){
            for(int j = 0; j<n; j++){
                if(grid[i][j] == 2){
                    q.push({i, j});
                }
            }
        }
        
        // Keep pushing the rotten apples as soon as we get inside the Queue.
        
        int time = -1;
        while(!q.empty()){
            int sz = q.size();
            while(sz){
                auto top = q.front();
                q.pop();
                // do the magic 
                auto ans = dfs(grid, top.first, top.second);
                if(ans.size() != 0){
                    for(auto&it:ans){
                        grid[it.first][it.second] = 2;
                    }
                    while(!ans.empty()){
                        q.push(ans.back());
                        ans.pop_back();
                    }
                }
                --sz;
            }
            time++;
        }
		// Check if there was an apple that did not get rot
		// if so return -1.
        for(int i = 0; i<m; i++){
            for(int j = 0; j<n; j++){
                if(grid[i][j] == 1)return -1;
            }
        }
        
        
        return time;
    }
};