
/*

The idea of my solution is simple and maths-based. For whatever input n, 
we start by dividing it into 2, 3, 4, etc. The sequence of the results of the product of 2 
then 3 then 4 numbers is increasing untill it starts decreasing. 
All we have to do is return that value at the summit. 

Example to better understand the idea:

n = 27
we start by dividing 27 into 2 :13 + 14 --> 13 * 14 = 182
then into 3 then 4, the product keeps increasing until we reach the point
where we divide 27 into 9 numbers which gives us the highest value of 19683.
How do we know it is the maximum? When we try dividing 27 into 10 numbers,
we get a smaller product than 19683.

VERY IMPORTANT NOTE: How do we divide n into x pieces while making sure 
the product we get it is the maximum value we can by dividing n into x pieces.
There is a mathematical proof for it, but I will not get into it here, but here is how it works:

Let's say we want to divide 104 into 5 pieces while getting the maximum possible product.
Some of the possible variations are 20 * 20 * 20 * 20 * 24 and 20 *20 * 21 * 21 * 22. However,
to get the highest possible product we need to make sure that the value of (104 % 5 which is 4)
is spread evenly between all pieces. Therefore, the highest product is 20 * 21 * 21 * 21 * 21;

*/


int integerBreak(int n)
{
    int counter = 1, tmp, max = 0, mod, counter_temp;
    while(counter < n)
    {
        tmp = 1;
        counter_temp = 0;
        mod = n % (counter + 1);
        while(counter_temp <= counter)
        {
            if(mod == 0)
                tmp *= (n / (counter + 1));
            else
            {
                tmp *= ((n / (counter + 1)) + 1);
                mod--;
            }
            counter_temp++;
        }
        if(tmp > max)
            max = tmp;
        counter++;
    }
    return max;
}