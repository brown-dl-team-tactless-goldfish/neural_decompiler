class ZeroEvenOdd {

private:

    int n, c;
    bool z;

    pthread_mutex_t m;
    pthread_cond_t c0, c1, c2;

public:

    ZeroEvenOdd(int n) {
        this->n = n;

        c = 0;
        z = true;
        
        m = PTHREAD_MUTEX_INITIALIZER;
        c0 = PTHREAD_COND_INITIALIZER;
        c1 = PTHREAD_COND_INITIALIZER;
        c2 = PTHREAD_COND_INITIALIZER;
    }

    void zero(function<void(int)> f) {
        while (true) {

            pthread_mutex_lock(&m);
            if (!z) { pthread_cond_wait(&c0, &m); }

            f(0);

            c += 1;
            z = false;
            bool stop = (c == n);

            pthread_cond_signal(c % 2 == 0 ? &c1 : &c2);
            pthread_mutex_unlock(&m);

            if (stop) { break; }
        }
    }

    void even(function<void(int)> f) {
        while (n > 1 && true) {

            pthread_mutex_lock(&m);
            if (z || c % 2 == 1) { pthread_cond_wait(&c1, &m); }

            f(c);
            
            z = true;
            bool stop = (c + 2 > n);
            
            pthread_cond_signal(&c0);
            pthread_mutex_unlock(&m);
            
            if (stop) { break; }
        }
    }

    void odd(function<void(int)> f) {
        while (true) {

            pthread_mutex_lock(&m);
            if (z || c % 2 == 0) { pthread_cond_wait(&c2, &m); }

            f(c);
            
            z = true;
            bool stop = (c + 2 > n);
            
            pthread_cond_signal(&c0);
            pthread_mutex_unlock(&m);
            
            if (stop) { break; }
        }
    }
};