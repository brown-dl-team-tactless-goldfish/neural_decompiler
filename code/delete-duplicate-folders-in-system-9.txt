// <editor-fold defaultstate="collapsed" desc="#define out(...)">
#ifndef out
#define out(...)
#endif
// </editor-fold>

struct TrieElement {
    map<string, TrieElement *> next{};
    int id{-1};
};

class Trie {
    deque<TrieElement> container{};

    TrieElement *newTrieElement() {
        return &container.emplace_back();
    }

    TrieElement *const root{newTrieElement()};

    int g_id{0};
    map<vector<pair<string, int> >, int> mp{};
    map<int, int> cnt{};

    int dfs(TrieElement *p) {
        vector<pair<string, int> > v;
        for (auto pair : p->next) v.emplace_back(pair.first, dfs(pair.second));
        int &id = mp[v];
        if (!id) id = ++g_id;
        out(v, id);
        ++cnt[id];
        return p->id = id;
    }

    void dfs(TrieElement *p, vector<string> &stack, vector<vector<string> > &ans) {
        for (auto pair : p->next) {
            if (pair.second->next.empty() || cnt[pair.second->id] == 1) {
                stack.push_back(pair.first);
                ans.push_back(stack);
                dfs(pair.second, stack, ans);
                stack.pop_back();
            }
        }
    }

public:
    void add(const vector<string> &v) {
        auto p = root;
        for (auto s : v) {
            auto &q = p->next[s];
            if (!q) q = newTrieElement();
            p = q;
        }
    }

    vector<vector<string> > solve() {
        dfs(root);
        vector<vector<string> > ans;
        vector<string> stack;
        dfs(root, stack, ans);
        return ans;
    }
};

class Solution {
public:
    vector<vector<string> > deleteDuplicateFolder(
            const vector<vector<string> > &paths) {
        Trie trie;
        for (auto &path : paths) trie.add(path);
        return trie.solve();
    }
};