    public class Solution
    {
        private int Helper(IList<int> indices, int[,] dpInput)
        {
            checked
            {
                int[] dp = new int[indices.Count];
                for (int i = indices.Count - 1; i >= 0; i--)
                {
                    dp[i] = int.MaxValue;

                    for (int j = i + 1; j < indices.Count; j++)
                    {
                        dp[i] = Math.Min(
                            dp[i],
                            dpInput[indices[i] + 1, indices[j] - 1] + (j != indices.Count - 1 ? dp[j] : 0)
                        );
                    }
                }
                return dp[0];
            }
        }

        public int StrangePrinter(string s)
        {
            checked
            {
                if (s.Length == 0)
                {
                    return 0;
                }

                //First of all, we don't need whole sequence. So we can merge 'aaaabbbbccbbbaaa' into 'abcba'
                IList<char> series = new List<char>();
                series.Add(s[0]);
                foreach (var c in s)
                {
                    if (c == series[series.Count - 1])
                    {
                        continue;
                    }

                    series.Add(c);
                }

                
                //dp[start, end] = result on subarray from series[start] to series[end]
                int[,] dp = new int[series.Count, series.Count];
                IList<int> tmp = new List<int>();

                for (int l = 1; l <= series.Count; l++)
                {
                    for (int start = 0; start < series.Count; start++)
                    {
                        int end = start + l - 1;
                        if (end >= series.Count)
                        {
                            continue;
                        }

                        if (l == 1)
                        {
                            //lonely char, easiest variant
                            dp[start, end] = 1;
                            continue;
                        }

                        if (l == 2)
                        {
                            //two neighbouring chars, answer is 2
                            dp[start, end] = 2;
                            continue;
                        }

                        dp[start, end] = int.MaxValue;


                        tmp.Clear();
                        for (int i = start; i <= end; i++)
                        {
                            //try concatenate two adjacent blocks
                            dp[start, end] = Math.Min(dp[start, end], (i < end ? dp[start, i] + dp[i + 1, end] : int.MaxValue));

                            if (series[start] == series[end])
                            {
                                //if series[start] == series[end] then base block for this chunk may be created. 
                                //and rest of symbols in range [start + 1,end - 1] are on the top of this base block
                                //we need to find optimal way of mounting chars on top of base block. collect indices that represents appearance of base block
                                if (series[i] == series[start])
                                {
                                    tmp.Add(i);
                                }
                            }
                        }

                        if (tmp.Count > 0)
                        {

                            //Helper helps us to choose optimal way of chunking upon the base block. Use another dp
                            dp[start, end] = Math.Min(dp[start, end], Helper(tmp, dp) + 1);
                        }
                    }
                }

                return dp[0, series.Count - 1];
            }
        }
    }