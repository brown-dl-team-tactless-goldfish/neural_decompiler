class Solution {
public:
    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {
        vector<vector<char>> field(m, vector<char>(n, 'e'));
        for(const auto &g : guards) {
            field[g[0]][g[1]] = 'g';
        }
        for(const auto &w : walls) {
            field[w[0]][w[1]] = 'w';
        }
        for(const auto &g : guards) {
            const int r = g[0];
            const int c = g[1];
            // move up until we reach a guard, a wall or a border
            for(int i = r - 1; i >= 0; --i) {
                if(field[i][c] == 'e' || field[i][c] == 'p') {
                    field[i][c] = 'p';
                } else
                    break;
            }
            // move down until we reach a guard, a wall or a border
            for(int i = r + 1; i < m; ++i) {
                if(field[i][c] == 'e' || field[i][c] == 'p') {
                    field[i][c] = 'p';
                } else
                    break;
            }
            // move left until we reach a guard, a wall or a border
            for(int i = c - 1; i >= 0; --i) {
                if(field[r][i] == 'e' || field[r][i] == 'p') {
                    field[r][i] = 'p';
                } else
                    break;
            }
            // move right until we reach a guard, a wall or a border
            for(int i = c + 1; i < n; ++i) {
                if(field[r][i] == 'e' || field[r][i] == 'p') {
                    field[r][i] = 'p';
                } else
                    break;
            }
        }
        
        int ans = 0;
        // count a number of non-protected cells ('e' -> empty)
        for(const auto &r : field) {
            ans += count(r.cbegin(), r.cend(), 'e');
        }
        
        return ans;
    }
};