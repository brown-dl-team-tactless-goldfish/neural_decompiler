typedef struct {
    char s[16];
    int count;
    UT_hash_handle hh;
} WordHash;

WordHash* h;

void backtracking(int* nums, int numsSize, int** ans, int* col, int* ansIdx, int* q, int qIdx, int idx){
    if(qIdx >= 2){
        if(q[qIdx - 2] > q[qIdx - 1])
            return;
        
        char* s = (char*)calloc(qIdx+1, sizeof(char));
        for(int i = 0; i < qIdx; i++)
            s[i] = q[i]==0? '0' : q[i]; /* transfer 0 to 0x30 to avoid '\0' */
        s[qIdx] = '\0';
        WordHash* e;
        HASH_FIND_STR(h, s, e);
        if(e)
            return; 
        
        e = (WordHash*)calloc(1, sizeof(WordHash));
        memcpy(e->s, s, sizeof(char)*qIdx);
        HASH_ADD_STR(h, s, e);
        
        ans[*ansIdx] = (int*)calloc(qIdx, sizeof(int));
        col[*ansIdx] = qIdx;
        memcpy(ans[(*ansIdx)++], q, sizeof(int) * qIdx);
    }
    for(int i = idx; i < numsSize; i++){
        q[qIdx] = nums[i];
        backtracking(nums, numsSize, ans, col, ansIdx, q, qIdx+1, i+1);
    }
}

void deleteAll(void){
  WordHash* current, *tmp;

  HASH_ITER(hh, h, current, tmp) {
    HASH_DEL(h, current);  
    free(current_user);            
  }
}

int** findSubsequences(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    int** ans = (int**)calloc(32768, sizeof(int*));
    int* col = (int*)calloc(32768, sizeof(int));
    int* q = (int*)calloc(numsSize, sizeof(int));
    int ansIdx = 0;
    
    backtracking(nums, numsSize, ans, col, &ansIdx, q, 0, 0);   
    deleteAll(); /* need to free to avoid incorrect behavior when doing next test item */
    
    *returnSize = ansIdx;
    *returnColumnSizes = col;
    return ans;
}