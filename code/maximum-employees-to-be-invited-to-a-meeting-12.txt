class Solution {
private:
    list<int>* adj;
    list<int>* rev;
public:
    void dfs(int node, vector<bool> &vis, vector<bool> &rec, vector<int> &par, int &res){
        rec[node]=true;
        vis[node]=true;
        for(auto nei: adj[node]){
            if(vis[nei]==false){
                par[nei]=node;
                dfs(nei,vis,rec,par,res);
            }
            else if(rec[nei]==true){ // CYCLE FOUND
                int vertex=node;
                int len=1;
                while(vertex!=nei){  // going backwards from vertex to neighbour it is cylic
                    len++;
                    vertex=par[vertex];
                }
                res=max(res,len);
            }
        }
        rec[node]=false;
    }
    
    int findLen(int node, int par, vector<bool> &vis){
        vis[node]=true;
        int res=1;
        for(auto nei: rev[node]){
            if(par==nei || vis[nei]==true){
                continue;
            }
            res=max(res,1+findLen(nei,node,vis));
        }
        return res;
    }
    
    int maximumInvitations(vector<int>& fav) {
        int V=fav.size();
        adj=new list<int>[V];
        rev=new list<int>[V];

        
        vector<bool> rec(V,false);
        vector<bool> vis(V,false);
        vector<bool> Rvis(V,false);
        vector<int> par(V,-1);
        
        for(int i=0;i<V;i++){
            adj[i].push_back(fav[i]);
            rev[fav[i]].push_back(i);
        }
        
        int res=0;
        int allTwoCycles=0;
        for(int i=0;i<V;i++){
            if(vis[i]==false){
                dfs(i,vis,rec,par,res);
            }a
            if(i<fav[i] && fav[fav[i]]==i){
                allTwoCycles+=(findLen(i,fav[i],Rvis)+findLen(fav[i],i,Rvis));  // we are expanding from the sides, we will be taking the largest chain. See, if a wanna sits with b, so a is directed towards b, so we make a reverse graph to find, how long the chain can extend from the node. WATCH THE DRAWING I ATTACHED IN THE NOTE
            }
        }
        return max(res,allTwoCycles);
    }
};