class Solution {
    vector<int> colors;
    int min = INT_MAX;
    int used = 0;
    bool isColorAvailable(int n, vector<vector<int>>& a, int k, int c, vector<int> colors){

        for(int i = 0; i <n; i++){
            if( a[k][i] ==1 && c == colors[i]){
                return false;
            }
        }

        return true;
    }

    void dfs(int n, vector<vector<int>>& a, int m, int k ){
        unordered_map<int, int> map;

        // Try every color
        for(volatile int t = 0; t < m; t++)
        {
            if(used == m-1 && used < k) return;
            if(isColorAvailable(n, a, k, t, colors)){
                used = t;colors[k] = t;
                if(k+1 < n) dfs(n, a, m, k+1);
                else{
                    for( auto c : colors) map[c] = 1;
                    if(map.size() < min) min = map.size();
                    return;
                }
            }            
        }
    }


public:
    bool isBipartite(vector<vector<int>>& graph) {
            
        
    int n = graph.size();
    vector<vector<int>> a(n, vector<int>(n, 0) );
    
    for(int i = 0; i < graph.size(); i++){
        int s = graph[i].size();
        for(int j = 0; j < s; j++)
        {
            int node = graph[i][j];
            a[i][node] = 1;
        }
    }
        

    for(int i = 0; i < n; i++)
        colors.push_back(-1);
    
    dfs(n, a, 3, 0);
    
    if(min <= 2) return true;
    return false;
        
    }
};