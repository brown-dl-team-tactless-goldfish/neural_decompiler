class Solution {
public:
    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {
        vector <vector<int>> g(n);
        for (auto e: edges) {
            g[e[0]].push_back(e[1]);
            g[e[1]].push_back(e[0]);
        }
        vector <int> cnt(n);

        auto bfs = [&](int s, int t) -> void {
            vector <int> par(n, -1);
            queue <int> Q;
            Q.push(s);
            while (!Q.empty()) {
                int x = Q.front();
                Q.pop();
                for (auto &v: g[x]) {
                    if (par[v] == -1 and v != s) {
                        par[v] = x;
                        Q.push(v);
                    }
                }
            } 
            int cur = t;
            while (par[cur] != -1) {
                cnt[cur]++;
                cur = par[cur];
            }
            cnt[s]++;
        };

        for (auto trip: trips) {
            int x = trip[0];
            int y = trip[1];
            bfs(x, y);
        }
        
        int cached[n][2];
        memset(cached, -1, sizeof cached);

        function<int(int, int, int)> go = [&](int node, int p, int is) -> int {
            if (cached[node][is] != -1) return cached[node][is];
            int new_p = price[node] / (is ? 2 : 1);
            int res = cnt[node] * new_p;
            for (auto &v: g[node]) {
                if (v != p) {
                    if (is) {
                        res += go(v, node, 0);
                    } else {
                        res += min(go(v, node, 0), go(v, node, 1));
                    }
                }
            }
            return cached[node][is] = res;
        };

        return min(go(0, -1, 0), go(0, -1, 1));
    }
};
















