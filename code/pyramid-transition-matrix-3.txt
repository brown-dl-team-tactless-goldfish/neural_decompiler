class Solution {
public:
    
    // check all possible combiantion to reach to the pyramid top 
    bool dfs(string bottom, int index, string nbottom, vector<vector<vector<bool>>>&track)
    {
        // pyramid top reached as bottom has 1 element and nbottom is empty, so return true
        if(bottom.length()==1 && nbottom.empty()) return true;
        
        // bottom processed but len(nbottom) ! = len(bottom)-1, so not valid and return false
        if(index==bottom.length() && nbottom.length()!=index-1)
            return false;
        
        // bottom processed and nbottom valid so call new DFS with nbottom as bottom
        if(index==bottom.length() && nbottom.length()==index-1)
            return dfs(nbottom,1,"",track);
        
        // check if triple <bottom[index-1],bottom[index],c> is allowed, then call DFS
        // If no DFS call reach to the top then return false
        for(int c=0;c<7 && index < bottom.length();c++)
        {
            char x = c + 'A';     

            if(track[bottom[index-1]-'A'][bottom[index]-'A'][c])
            {
                if(dfs(bottom,index+1,nbottom+x,track)) return true;
            }
        }            
        
        // no possible combination to reach top
        return false;
    }
    
    bool pyramidTransition(string bottom, vector<string>& allowed) {

        // 3D vector to track allowed triples
        vector<vector<vector<bool>>>track(7,vector<vector<bool>>(7,vector<bool>(7,false)));

        // populate allowed triples in track vector
        for(int i=0;i<allowed.size();i++)
            track[allowed[i][0]-'A'][allowed[i][1]-'A'][allowed[i][2]-'A'] = true;
        
        // call DFS from the start
        return dfs(bottom,1,"",track);
    }
};