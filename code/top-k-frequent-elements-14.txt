struct hash_entry {
    int id;            /* we'll use this field as the key */
    int quantity;
    UT_hash_handle hh; /* makes this structure hashable */
};

int cmp(const struct hash_entry *a, const struct hash_entry *b) {
    return (b->quantity - a->quantity);
}
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){

    struct hash_entry *users = NULL;
    
    for(int i = 0; i < numsSize; i++)
    {
        int user_id = nums[i];
        struct hash_entry *s;
        HASH_FIND_INT(users, &user_id, s);
        
        if(s)
        {
            s->quantity++;
        }
        else
        {
            s = malloc(sizeof *s);
            s->id = nums[i];
            s->quantity = 1;
            HASH_ADD_INT(users, id, s);
        }
    }
    
    struct hash_entry *s;
    struct hash_entry** hashes = malloc(sizeof(struct hash_entry*) * HASH_COUNT(users));
    HASH_SORT(users, cmp);
    
    int* ret = malloc(sizeof(int) * HASH_COUNT(users));
    int count = 0;
    for (s = users; s != NULL; s = s->hh.next)
    {
        ret[count++] = s->id;
    }
    
    *returnSize = k;
    return ret;
}