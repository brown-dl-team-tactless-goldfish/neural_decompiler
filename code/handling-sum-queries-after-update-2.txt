class Solution {
private:
    vector<long long> tree;
    vector<bool> lazy;
public:
    void build(vector<int> &bits, long long start, long long end, long long parent){
        if(start==end){
            tree[parent]=bits[start];
            return;
        }
        long long mid=(start+end)/2;
        build(bits,start,mid,2*parent+1);
        build(bits,mid+1,end,2*parent+2);
        tree[parent]=tree[2*parent+1]+tree[2*parent+2];
    }
    
    void querySolver(long long start, long long end, long long qstart, long long qend, long long parent){
        if(start>end){
            return;
        }

        if(lazy[parent]==true){ // lazy happened
            long long totalBits=end-start+1;
            tree[parent]=totalBits-tree[parent];
            if(start!=end){
                lazy[2*parent+1]=!lazy[2*parent+1];
                lazy[2*parent+2]=!lazy[2*parent+2];
            }
            lazy[parent]=false;
        }
        
        if(qstart>end || qend<start){ // no overlapping
            return;
        }
        
        if(qstart<=start && qend>=end){  // lazy work
            long long totalBits=end-start+1;
            tree[parent]=totalBits-tree[parent];
            if(start!=end){
                lazy[2*parent+1]=!lazy[2*parent+1];
                lazy[2*parent+2]=!lazy[2*parent+2];
            }
            return;
        }
        
        long long mid=(start+end)/2;
        querySolver(start,mid,qstart,qend,2*parent+1);
        querySolver(mid+1,end,qstart,qend,2*parent+2);
        tree[parent]=tree[2*parent+1]+tree[2*parent+2];
    }
    
    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {
        /*
		The second query says:-
		nums2[i]=nums2[i]+nums1[i]*p
		
		Elaborating...
		        (nums2[0] + nums1[0]*p) + (nums2[1] + nums1[1]*p) + ........
				Collecting nums2 and nums1 together..
                (nums2[0]+nums2[1]+...) + (nums1[0]+nums1[1]+...) *p
                summation(nums2) + summation(nums1)*p
				
				So the answer for queries can be given if you can efficiently count the sum of
				nums1 after each update (l,r). nums2 sum is just updated by the new sum.
        */
        long long n=nums1.size();
        lazy.resize(4*n+1);
        tree.resize(4*n+1,false);

        build(nums1,0,n-1,0);
        
        long long sum_nums2=accumulate(nums2.begin(),nums2.end(),0LL);
        
        vector<long long> res;
        
        for(auto query: queries){
            long long type=query[0];
            if(type==1){
                long long l=query[1];
                long long r=query[2];
                querySolver(0,n-1,l,r,0);               
            }
            if(type==2){
                long long p=query[1];
                long long newSum=sum_nums2+tree[0]*p;
                sum_nums2=newSum;
            }
            if(type==3){
                res.push_back(sum_nums2);
            }
        }
        return res;
    }
    
};