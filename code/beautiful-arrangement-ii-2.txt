/**
 * Return an array of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */

//1 2 3 4 5//5 4 3 2 1//5 1 2 3 4//5 1 4 3 2//5 1 4 3 2//5 1 4 2 3//
// 1 1 1 1 // 4 3 2 1

//we discovered the pattern that 
//when k=1,the largest value of the array(5) should be the first element[5, , , , ],the rest of the element should be descending order[5,4,3,2,1]
////when k=2,the largest value of the array(5) should be the first element[5, , , , ],then the smallest element should be the second element[5,1, , , ],the rest of the element should be ascending order[5,1,2,3,4]
//when k=3,[5, , , , ],[5,1, , , ],[5,1,4, , ],the rest of the element should be descending order,[5,1,4,3,2]
//when k=4,[5, , , , ],[5,1, , , ],[5,1,4,2, ],the rest of the element should be ascending order,[5,1,4,2,3]
int* constructArray(int n, int k, int* returnSize) {
    int *a=(int*)malloc(sizeof(int)*n);
    int b[n],i;
    int last=n-1;
    int a_start=0,b_start=0,flag1=0,flag2=0;
    
    for(i=1;i<=n;i++){
        b[i-1]=i;    
    }
    
  while(k>0){
      if(k>0){
          a[a_start++]=b[last--];
          k--;
          flag1=1;
          flag2=0;
      }
      if(k>0){
          a[a_start++]=b[b_start++];
          k--;
          flag1=0;
          flag2=1;
      }
  }
    
    if(flag1){
       for(i=a_start;i<n;i++){
           a[i]=b[last--];
       }
    }
    else{
        for(i=a_start;i<n;i++){
           a[i]=b[b_start++];
       }
    }
    
    (*returnSize)=n;
    return a;
}