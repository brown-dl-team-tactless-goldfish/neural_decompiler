class SegT {
public:
    SegT(vector<int>& costs)
        : costs(costs), n(costs.size()), n2(1),
          T(4 * costs.size(), -1)
    {
        while (n2 < n) {
            n2 <<= 1;
        }
        buildT(0);
    }

    int query(int ql, int qr) {
        return query(0, 0, n2 - 1, ql, qr);
    }
    void update(int i) {
        update_(n2 - 1 + i);
    }

private:
    void buildT(int r) {
        if (r >= n2 - 1) {
            if (r - (n2 - 1) < n) {
                T[r] = r - (n2 - 1);
            } else {
                T[r] = -1;
            }
            return;
        }
        buildT(2 * r + 1);
        buildT(2 * r + 2);
        int i1 = T[2 * r + 1];
        int i2 = T[2 * r + 2];
        if (i1 != -1 && i2 != -1) {
            if (costs[i1] <= costs[i2]) {
                T[r] = i1;
            } else {
                T[r] = i2;
            }
        } else if (i1 != -1) {
            T[r] = i1;
        } else if (i2 != -1) {
            T[r] = i2;
        } else {
            T[r] = -1;
        }
    }
    int query(int r, int rl, int rr, int ql, int qr) {
        if (r >= n2 - 1) {
            return T[r];
        }
        if (rl == ql && rr == qr) {
            return T[r];
        }
        int i1 = -1;
        int i2 = -1;
        int mid = (rl + rr) / 2;
        if (ql <= mid) {
            i1 = query(2 * r + 1, rl, mid, ql, min(qr, mid));
        }
        if (qr > mid) {
            i2 = query(2 * r + 2, mid + 1, rr, max(mid + 1, ql), qr);
        }
        if (i1 != -1 && i2 != -1) {
            if (costs[i1] <= costs[i2]) {
                return i1;
            } else {
                return i2;
            }
        } else if (i1 != -1) {
            return i1;
        } else if (i2 != -1) {
            return i2;
        } else {
            return -1;
        }
    }
    void update_(int i) {
        if (i >= n2 - 1) {
            T[i] = -1;
        } else {
            int i1 = T[2 * i + 1];
            int i2 = T[2 * i + 2];
            if (i1 != -1 && i2 != -1) {
                if (costs[i1] <= costs[i2]) {
                    T[i] = i1;
                } else {
                    T[i] = i2;
                }
            } else if (i1 != -1) {
                T[i] = i1;
            } else if (i2 != -1) {
                T[i] = i2;
            } else {
                T[i] = -1;
            }
        }
        if (i > 0) {
            update_((i - 1) / 2);
        }
    }

    vector<int>& costs;
    int n;
    int n2;
    vector<int> T;
};
class Solution {
public:
    long long totalCost(vector<int>& costs, int k, int candidates) {
        int n = costs.size();
        int nextl = 0;
        int nextr = n - 1;
        while (nextl < candidates && nextl <= nextr) {
            ++nextl;
        }
        while (n - nextr - 1 < candidates && nextr >= nextl) {
            --nextr;
        }
        SegT t(costs);
        long long ans = 0;
        for (int i = 0; i < k; ++i) {
            int i1 = -1;
            int i2 = -1;
            if (nextl > 0) {
                i1 = t.query(0, nextl - 1);
            }
            if (nextr < n - 1) {
                i2 = t.query(nextr + 1, n - 1);
            }
            if (i1 != -1 && i2 != -1) {
                if (costs[i1] <= costs[i2]) {
                    ans += costs[i1];
                    if (nextl <= nextr) {
                        ++nextl;
                    }
                    t.update(i1);
                } else {
                    ans += costs[i2];
                    if (nextr >= nextl) {
                        --nextr;
                    }
                    t.update(i2);
                }
            } else if (i1 != -1) {
                ans += costs[i1];
                if (nextl <= nextr) {
                    ++nextl;
                }
                t.update(i1);
            } else if (i2 != -1) {
                ans += costs[i2];
                if (nextr >= nextl) {
                    --nextr;
                }
                t.update(i2);
            } else {
                assert(false);
            }
        }
        return ans;
    }
};