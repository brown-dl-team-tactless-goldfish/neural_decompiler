class Solution {
    
    void add(vector<vector<int>> &have, int x) {
        for (int i = 17; i >= 0; --i) {
            ++have[i][(x >> i) << i];
        }
    }
    
    void remove(vector<vector<int>> &have, int x) {
        for (int i = 17; i >= 0; --i) {
            --have[i][(x >> i) << i];
        } 
    }
    
    int find(const vector<vector<int>> &have, int x) {
        int temp = 0;
        for (int i = 17; i >= 0; --i) {
           temp |= (((x >> i) & 1) ^ 1) << i;
            if (have[i][temp] == 0) {
                temp ^= 1 << i;
            }
        }
        return temp ^ x;
    }
    
    void dfs(int x, int p, const vector<vector<int>> &con, const vector<vector<vector<int>>> &q, vector<vector<int>> &have, vector<int> &ans) {
        add(have, x);
        for (const auto& v : q[x]) {
            ans[v[1]] = find(have, v[0]);
        }
        for (int y : con[x]) {
            if (y != p) {
                dfs(y, x, con, q, have, ans);
            }
            
        }
        remove(have, x);
        
    }
    
public:
    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {
        const int n = parents.size();
        vector<vector<int>> con(n);
        int root = 0;
        for (int i = 0; i < n; ++i) {
            if (parents[i] >= 0) {
                con[i].push_back(parents[i]);
                con[parents[i]].push_back(i);
            } else {
                root = i;
            }
        }
        const int m = queries.size();
        vector<int> ans(m);
        vector<vector<vector<int>>> q(n);
        for (int i = 0; i < m; ++i) {
            q[queries[i][0]].push_back({queries[i][1], i});
        }
        vector<vector<int>> have(18, vector<int>(1 << 18));
        dfs(root, -1, con, q, have, ans);
        return ans;
        
    }
};