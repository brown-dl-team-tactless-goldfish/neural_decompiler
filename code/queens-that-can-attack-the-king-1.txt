// Check if a location is in the board
unsigned int is_safe(int x, int y)
{
    return (x >= 0 && x < 8) && (y >= 0 && y < 8); 
}


// Pretend the king is a queen and simulates queen movements, stopping at 
// the first queen founded in each row
int** queensAttacktheKing(int** queens, int queensSize, int* queensColSize, int* king, int kingSize, int* returnSize, int** returnColumnSizes){
    
    
    int hash[64] = {0}; 
    int **ret = calloc(sizeof(int*), queensSize); 
    
    // Stores all queens in a 8x8 hash
    for (int i = 0; i < queensSize; i++)
    {
       hash[queens[i][0] + (queens[i][1] * 8)] = 1;  
    }
	// Define the colum retrun size
    *returnColumnSizes = calloc(sizeof(int), queensSize); 
    
    
    int count= 0;
    // Loop in all x directions
    for (int dx = -1; dx < 2; dx++)
    {
		// Loop in all y directions
        for (int dy = -1; dy < 2; dy++)
        {
            int i, j;
			
			// Skip infinite loop
           if (dx == 0 && dy == 0) continue; 
		   
		   // Start at the king position, moving dx and dy each iteration
           for (i = king[0], j = king[1]; is_safe(i, j); i+=dx, j += dy) 
           {
			   // If there is a queen in the location, add to the return array and break
               if (hash[i + (j * 8)])
               {
                   int* queen = calloc(sizeof(int), 2);
                   queen[0] = i;
                   queen[1] = j; 
                   ret[count] = queen;
                   count++;
                   break;
               }
           }
        }
    }
    
    for (int i = 0; i < count; i++)
    {
        
       (*returnColumnSizes)[i] = 2; 
    }
	
	// Set the return size to the number of queens found
    *returnSize = count;
    
    return ret; 

}