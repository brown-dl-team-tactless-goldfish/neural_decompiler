/*Longest Substring
 * Input: "abcabcbb"
	Output: 3
	Explanation: The answer is "abc", with the length of 3.

	Input: "bbbbb"
	Output: 1
	Explanation: The answer is "b", with the length of 1


	Solution: sliding window problem!!
	add in a Hash table all the values of the input string and calculate the max_len
	check each value if is twice in the hash
	if is in hash, delete the value

	return max_len
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define HASH_SIZE_STR 1000
//#define NULL ((char *)0)

/* 0. Define my hash structure */
typedef struct  HashNode_item {
    char *key;
    int val;
    struct HashNode_item* next; // ptr to another entry, used for KEY Collision, to go to the next elem
} HashNode_item;

typedef struct Hash_table {
	 int size;
	 int count;
	 struct HashNode_item* hash;
} Hash_table;


void hash_init_str(Hash_table* self);
int hash_get_key_index_str(char *key);
HashNode_item* create_hash_item(char* key, int value);
Hash_table* create_hash_table(int size);
void hash_insert_Intvalue(struct Hash_table* self, char *key, int value);
void hash_collision_string(Hash_table *self, int index, HashNode_item *hash_item);
int  hash_find_key(const Hash_table* self, char *key);
void free_item(HashNode_item* item);

int get_len_string(char *s);


/* 1. Define the initialization */
void hash_init_str(Hash_table* self) {
    self->size = HASH_SIZE_STR;
    // allocate table entries
    self->hash = (struct HashNode_item*) malloc(sizeof(struct HashNode_item)*self->size);
    // initialize to NULL the pointers
    for (int i = 0; i < self->size; ++i)
        self->hash[i].next = 0; //NULL;
}


/* 2. Define my hash_function - customised method to get the index */
int hash_get_key_index_str(char *key) {
    int i = 0;
	for (int j=0; key[j]; j++)
		i += key[j];

	int value = i % HASH_SIZE_STR;
	printf("\n Index value = %d,  for [%s]\n", value, key);
	return value;
}


/* 3. Create hash item */
HashNode_item* create_hash_item(char* key, int value) {
    /* - Creates a pointer to a new hash table item
     * - allocate memory for them and initialize with 0
     * - copy the key & value
     * - return item
     */
	HashNode_item* item = (HashNode_item*) malloc(sizeof(HashNode_item));
    item->key = (char*) malloc(strlen(key) + 1);
    strcpy(item->key, key);
    item->val = value;

    return item;
}

/* 4. Create hash table */
Hash_table* create_hash_table(int size) {
    // Creates a new HashTable
	Hash_table* table = (Hash_table*) malloc(sizeof(Hash_table)*size);
    table->size = size;
    table->count = 0;
    // allocate table entries
    //  self->hash = (struct entry_s*)malloc(sizeof(struct entry_s)*self->size);
    table->hash = (HashNode_item*) malloc(sizeof(struct HashNode_item)*table->size);      //(table->size, sizeof(Ht_item*));
    for (int i=0; i<table->size; i++)
        table->hash[i].next = 0; // NULL;

    return table;
}


/* 5. Define the insert function */
void hash_insert_Intvalue(struct Hash_table* self, char *key, int value) {
	/* - create the hash_item & the hash_table
	 *
	 */
	HashNode_item *hash_item = create_hash_item(key, value);
	int index = hash_get_key_index_str(key);
	HashNode_item* current_item = self->hash + index; // or self->hash[index]

	if (current_item->key == 0 ) { //NULL
		/* Key does not exist.*/
	    if (self->count == self->size) {
			/* Hash Table Full, Remove the created item */
			printf("Insert Error: Hash Table is full\n");
			free_item(hash_item);
			return;
	        }
	        /* Insert directly the created hash_item */
	        memcpy(current_item, hash_item, sizeof(HashNode_item));
	        self->count++;
	    }
	    else {
	    	// Scenario 1: We only need to update the value
	    	if (strcmp(current_item->key, key) == 0) {
	                current_item->val = value;
	                return;
	        }
	        else {
	            // Scenario 2: Collision
	        	hash_collision_string(self, index, hash_item);
	            return;
	        }
	    }
}


/* 6. Define the collision function */
void hash_collision_string(Hash_table *self, int index, HashNode_item *hash_item) {
    HashNode_item* p        = self->hash + index;;
    HashNode_item* new_node = (struct HashNode_item*)malloc(sizeof(struct HashNode_item));
    strcpy(new_node->key, hash_item->key);
    new_node->val  = hash_item->val;
    new_node->next = p->next;
    p->next        = new_node;
}

/* 7. Define find function */
int  hash_find_key(const Hash_table* self, char *key) {
	// base of the hash0 + index
    HashNode_item* p = self->hash + hash_get_key_index_str(key);
   // while (p->next != 0) { // if entry not NULL, walk through all the entry until find the key
        // p = p->next;

    if ( get_len_string(p->key) == get_len_string(key)) {
		if (strcmp(p->key, key) == 0) {
				return p->val;
		}
    }
	
	// means the key not found
	return -1;

}

void free_item(HashNode_item* item) {
    // Frees an item
//    free(item->key);
//    free(item->val);
    free(item);
}

int get_len_string(char *s) {
	int len = 0;
	int i = 0;
	if (s == 0) {
		return 0;
	}
	while (s[i] != '\0' ) {
		i++;
	}
	len = i;
	return len;
}

int lengthOfLongestSubstring(char * s){
    Hash_table* ht = create_hash_table(HASH_SIZE_STR);
	int i, j, max_len = 0;
	int count = 0;
	char *temp = (char*) malloc(sizeof(char));
	int len_string = get_len_string(s);
	while (j < len_string) {
		strncpy(temp, &s[j], 1);
		if (hash_find_key(ht, temp) == -1) {
			count++;
			hash_insert_Intvalue(ht, temp, j); // add in hash
			max_len = count;

		}
		/*means the key is already in the hash */
		else {
			// count--;
			/* Do nothing */
		}
		j++;

	}

	return max_len;
}