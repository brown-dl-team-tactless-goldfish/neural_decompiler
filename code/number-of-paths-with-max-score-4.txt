class Solution {
public:
    int dirs[3][2] = { {-1, 0 /* left */}, {0, -1 /* up */}, {-1, -1 /* diag */} };
    
    vector<int> pathsWithMaxScore(vector<string>& b) {
        int sz = b.size(), dp[sz+1][sz+1][2];   /* DP array */ 
        memset(dp, 0, sizeof(dp));              /* Initialize the array */
        b[0][0] = '0'; b[sz-1][sz-1] = '0';     /* set 'S' and 'E' to '0' */
        dp[sz-1][sz-1][1] = 1                   /* assume we have one path to b[0][0] or 'E' */;
        
        for (int r = sz - 1; r >= 0; r--) {     /* Start from 'S' all the way up to 'E' */
            for (int c = sz - 1; c >= 0; c--) {
                if (b[r][c] == 'X') continue;   /* If an obstacle is met, skip dp */
                for (auto d : dirs) {           /* For all directions (left, up or diagonal) get new position */
                    int _r = r + d[0], _c = c + d[1];
                    if (_r < 0 || _c < 0 || _r >= sz || _c >= sz) continue; /* Check bounds ... */
                    int v = dp[r][c][0] + (b[_r][_c] - '0');    /* Compute current sum so far in this path
                                                                    plus the value of new position */
                    
                    if (dp[_r][_c][0] <= v) {   /* If sum v is more or equal to last sum ... */
                        /* If sum is the same, aggregate paths ... */
                        if (dp[_r][_c][0] == v) dp[_r][_c][1] = (dp[_r][_c][1] + dp[r][c][1]) % 1000000007;
                        /* ... else just keep taking the number of paths forward */
                        else dp[_r][_c][1] = dp[r][c][1] % 1000000007;
                        /* store sum */
                        dp[_r][_c][0] = v;
                    }
                }
            }
        }
        /* If a path exists then a score exists */
        int score = dp[0][0][1] ? dp[0][0][0] : 0, paths = dp[0][0][1];
        return { score, paths };
    }
};