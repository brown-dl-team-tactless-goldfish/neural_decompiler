/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

int* MorrisTraversal(struct TreeNode* root, int* index)
{
    int size = 64;
    int *ret = (int*)malloc(sizeof(int) * size);
    
    struct TreeNode *curr = root, *prev = NULL;
    
    while(curr != NULL)
    {
        if(curr->left == NULL)
        {
            if(*index == size - 1)
            {
                size *= 2;
                ret = (int*)realloc(ret, sizeof(int) * size);
            }
            
            ret[(*index)++] = curr->val;
            curr = curr->right;
        }
        else
        {
            prev = curr->left;
            while(prev->right != NULL && prev->right != curr)
                prev = prev->right;
            
            if(prev->right == NULL)
            {
                prev->right = curr;
                curr = curr->left;
            }
            else
            {
                prev->right = NULL;
                if(*index == size - 1)
                {
                    size *= 2;
                    ret = (int*)realloc(ret, sizeof(int) * size);
                }
                
                ret[(*index)++] = curr->val;
                curr = curr->right;
            }
        }
    }
    
    ret[*index] = INT_MAX; // The guardian
    
    return ret;
}


int* getAllElements(struct TreeNode* root1, struct TreeNode* root2, int* returnSize){
    int size1 = 0, size2 = 0;
    
    int* arr1 = MorrisTraversal(root1, &size1);
    int* arr2 = MorrisTraversal(root2, &size2);
    
    *returnSize = size1 + size2;
    int* ans = (int*)malloc(sizeof(int) * (*returnSize));

    int index = 0, i = 0, j = 0;
    
    while(i < size1 || j < size2)
    {
        if(arr1[i] < arr2[j])
        {
            ans[index++] = arr1[i];
            i++;
        }else{
            ans[index++] = arr2[j];
            j++;
        }
    }
    
    free(arr1);
    free(arr2);
    
    return ans;
}