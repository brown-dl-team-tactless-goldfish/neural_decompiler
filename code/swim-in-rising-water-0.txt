void mark (int** arrive, int i, int j, int** grid, int gridSize, int ans){
    if (i < 0 || j < 0 || i >= gridSize || j >= gridSize || arrive[i][j] == 1){
        return;
    }
    if (grid[i][j] <= ans){
        arrive[i][j] = 1;
        mark(arrive, i+1, j, grid, gridSize, ans);
        mark(arrive, i-1, j, grid, gridSize, ans);
        mark(arrive, i, j+1, grid, gridSize, ans);
        mark(arrive, i, j-1, grid, gridSize, ans);
    }
    return;
}

void find (int** grid, int gridSize, int ans, int* m, int* n){
    for (int i = 0 ; i < gridSize ; i++){
        for (int j = 0 ; j < gridSize ; j++){
            if (grid[i][j] == ans){
                *m = i;
                *n = j;
                return;
            }
        }
    }
}

bool can_arrive_or_not (int** arrive, int gridSize, int i, int j){
    if (i + 1 < gridSize) {
        if (arrive[i+1][j] == 1){
            return true;
        }
    }
    if (i - 1 >= 0) {
        if (arrive[i-1][j] == 1){
            return true;
        }
    }
    if (j + 1 < gridSize) {
        if (arrive[i][j+1] == 1){
            return true;
        }
    }
    if (j - 1 >= 0) {
        if (arrive[i][j-1] == 1){
            return true;
        }
    }
    return false;
}

int swimInWater(int** grid, int gridSize, int* gridColSize){
    int** arrive = malloc(sizeof(int*)*gridSize);
    for (int i = 0 ; i < gridSize ; i++){
        arrive[i] = calloc(gridSize,sizeof(int));
    }
    int ans = grid[gridSize-1][gridSize-1] > (gridSize-1)*2 ? grid[gridSize-1][gridSize-1] : (gridSize-1)*2;
    if (grid[0][0] > ans){
        ans = grid[0][0];
    }
    mark(arrive, 0, 0, grid, gridSize, ans); 
    int m,n;
    while(arrive[gridSize-1][gridSize-1] == 0){
        ans++;
        find(grid, gridSize, ans, &m, &n);
        if (can_arrive_or_not(arrive, gridSize, m, n)){
            mark(arrive, m, n, grid, gridSize, ans);
        }
    }
    for (int i = 0 ; i < gridSize ; i++){
        free(arrive[i]);
    }
    free(arrive);
    return ans;
}