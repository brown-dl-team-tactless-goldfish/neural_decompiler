typedef struct LRUNode{
    int key;
    int value;
    struct LRUNode* next;
    struct LRUNode* prev;
} LRUNode;

typedef struct {
    int capacity;
    LRUNode* buffer[10000]; //Could be hashmap
    int cur_size;
    LRUNode* most_recent_node;
    LRUNode* least_recent_node;
} LRUCache;

LRUCache* lRUCacheCreate(int capacity) {
    LRUCache* cache = malloc(sizeof(LRUCache));
    for (int i = 0; i < 10000; ++i) {
        cache->buffer[i] = NULL;
    }
    cache->capacity = capacity;
    return cache;
}

LRUNode* lRUNodeCreate(int key, int val) {
    LRUNode* node = malloc(sizeof(LRUNode));
    node->prev = node->next = NULL;
    node->key = key;
    node->value = val;
    return node;
}

void insertNewMRU(LRUCache* cache, int key, int val) {
    LRUNode* node = lRUNodeCreate(key, val);
    cache->buffer[key] = node;

    if (cache->most_recent_node != NULL) {
        cache->most_recent_node->next = node;
        node->prev = cache->most_recent_node;
    }
    if (cache->least_recent_node == NULL) {
        cache->least_recent_node = node;
    }
    cache->most_recent_node = node;
}

void evictLRU(LRUCache* cache) {
    LRUNode* node = cache->least_recent_node;
    if (node->next != NULL) {
        node->next->prev = NULL;
    }
    cache->least_recent_node = node->next;
    if (node == cache->most_recent_node) {
        cache->most_recent_node = NULL;
    }
    cache->buffer[node->key] = NULL;
    free(node);
}

void moveNodeToMRU(LRUCache* cache, int key) {
    LRUNode* node = cache->buffer[key];
    if (node == cache->most_recent_node) {
        return; //already MRU, dont link
    }
    if (node->next != NULL) {
        node->next->prev = node->prev; //link next node to prev
    }
    if (node->prev != NULL) {
        node->prev->next = node->next; //link prev node to next
    }
    if (cache->least_recent_node == node) { // update lru node
        cache->least_recent_node = node->next; //remove from lru, update
        cache->least_recent_node->prev = NULL;
    }
    cache->most_recent_node->next = node;
    node->prev = cache->most_recent_node;
    node->next = NULL;
    cache->most_recent_node = node;
}

int lRUCacheGet(LRUCache* obj, int key) {
    if (obj->buffer[key] == 0) {
        return -1;
    }
    int val = (obj->buffer[key]->value);
    moveNodeToMRU(obj, key);
    return val;
}

void lRUCachePut(LRUCache* obj, int key, int value) {
    //node doesnt exist for key
    if (obj->buffer[key] == NULL) {
        //evict lru first to make room
        if (obj->cur_size >= obj->capacity) {
            evictLRU(obj);
            obj->cur_size--;
        }
        //create and insert new lru node and add to buffer
        insertNewMRU(obj, key, value);
        obj->cur_size++;
    }
    //node already exists for key, update value and move to MRU
    else {
        obj->buffer[key]->value = value;
        moveNodeToMRU(obj, key);
    }
}

void lRUCacheFree(LRUCache* obj) {
    LRUNode* cur = obj->least_recent_node;
    while (cur != NULL) {
        LRUNode* temp = cur->next;
        free(cur);
        cur = temp;
    }
    free(obj);
}

/**
 * Your LRUCache struct will be instantiated and called as such:
 * LRUCache* obj = lRUCacheCreate(capacity);
 * int param_1 = lRUCacheGet(obj, key);
 
 * lRUCachePut(obj, key, value);
 
 * lRUCacheFree(obj);
*/