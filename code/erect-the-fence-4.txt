typedef pair<int, int> pt;
#define x first
#define y second
pt operator -(pt a, pt b) {
  return pt(a.x - b.x, a.y - b.y);
}

class Solution {
  int cross(pt a, pt b) { // 2d cross product
    return a.x*b.y - a.y*b.x;
  }
  bool ccw(pt a, pt b, pt c) { // counter clockwise rotation
    return cross(b - a, c - a) > 0; // Use >= to not include points on boundary
  }
  
  vector<pt> half_hull(vector<pt>& pts) {
    vector<pt> res;
    for (int i = 0; i < pts.size(); i++) {
      while (res.size() >= 2 && ccw(pts[i], res[res.size()-1], res[res.size()-2]))
        res.pop_back();
      res.push_back (pts[i]);
    }
    return res;
  }
  
  vector<pt> convex_hull(vector<pt>& pts) {
    sort(pts.begin(), pts.end());
    vector<pt> top = half_hull(pts);
    reverse(pts.begin(), pts.end());
    vector<pt> bottom = half_hull(pts);
    top.pop_back();
    bottom.pop_back();
    vector<pt> res(top.begin(), top.end());
    res.insert(res.end(), bottom.begin(), bottom.end());
    return res;
  }


public:
    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {
      if (trees.size() < 4) return trees;
      vector<pt> pts;
      for (vector<int>& p : trees) {
        pts.push_back({p[0], p[1]});
      }
      vector<pt> hull = convex_hull(pts);
      vector<vector<int>> res;
      set<pt> hset;
      for (pt p : hull) {
        if (hset.insert(p).second) // filter out duplicate points
          res.push_back({p.x, p.y});
      }
      return res;
    }
};