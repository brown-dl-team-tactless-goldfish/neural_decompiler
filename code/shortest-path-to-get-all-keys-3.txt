#define upper(c) ((c) >= 'A' && (c) <= 'Z')
#define lower(c) ((c) >= 'a' && (c) <= 'z')

#ifndef set_bit
#define set_bit(n, pos, b)(b == 1 ? n |= (1 << (pos)) : n &= ~(1 << (pos)))
#endif

#ifndef get_bit
#define get_bit(n,pos)((n & (1<<(pos))) != 0)
#endif

class Solution {
public:
    vector<vector<int>> directions = { {-1, 1, 0, 0}, {0, 0, -1, 1} };
    int bfs(vector<string> &grid, int r, int c, int key)
    {
        queue<vector<int>> q;
        q.push({r, c, 0, key});
        int res = 0;
        unordered_set<int> seen;
        while(!q.empty())
        {
            res++;
            int sz = q.size();
            for(int i = 0; i < sz; i++)
            {
                int row = q.front()[0], col = q.front()[1]; 
                for(int d = 0; d < 4; d++)
                {
                    int r = row + directions[0][d];
                    int c = col + directions[1][d];
                    int k = q.front()[2];
                    int cnt = q.front()[3];
                    if (r >= 0 && r < grid.size()
                     && c >= 0 && c < grid[r].size() 
                     && grid[r][c] != '#' 
                     && !seen.count((k << 10) + r * 30 + c)
                     && (!upper(grid[r][c]) || get_bit(k, grid[r][c] - 'A')))
                    {                    
                        if(lower(grid[r][c]) && !get_bit(k, grid[r][c] - 'a'))
                        {
                            set_bit(k, grid[r][c] - 'a', 1);
                            if(--cnt == 0)
                                return res;
                        }

                        int id = (k << 10) + r * 30 + c;
                        seen.insert(id);
                        q.push({r, c, k, cnt});                   
                    }
                }
                q.pop();
            }
        }
        return -1;
    }
    
    int shortestPathAllKeys(vector<string>& grid) 
    {
        int r = 0, c = 0, key = 0;
        for(int i = 0; i < grid.size(); i++)
        {
            for(int j = 0; j < grid[i].size(); j++)
            {
                if(lower(grid[i][j]))
                    key++;
                else if(grid[i][j] == '@') 
                    r = i, c = j;
            }
        }
        return bfs(grid, r, c, key);
    }
};