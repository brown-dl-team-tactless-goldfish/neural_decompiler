#define and &&
#define or ||
#define N 100001

int timestamp;

typedef struct{
    int index, value;
} pair;

pair* make_pair(int a, int b)
{
    pair* p = (pair*)malloc(sizeof(pair));
    p->index = a;
    p->value = b;
    return p;
}

typedef struct{
    int key, freq, recent;
} trio;

trio* make_trio(int a, int b, int c)
{
    trio* t = (trio*)malloc(sizeof(trio));
    t->key = a;
    t->freq = b;
    t->recent = c;
    return t;
}

bool can_swap(trio** heap, int index, int parent)
{
    return heap[index]->freq < heap[parent]->freq or (heap[index]->freq == heap[parent]->freq and heap[index]->recent < heap[parent]->recent);
}

void swap(trio** heap, int i, int j, pair** ipq)
{
    //indexed priority queue 
    ipq[heap[i]->key]->index = j;
    ipq[heap[j]->key]->index = i;
    
    trio* temp = heap[i];
    heap[i] = heap[j];
    heap[j] = temp;
}

void heapify(trio** heap, int index, int* length, pair** ipq)
{
    // assuming that the left and right subtrees are also minheaps
    int left = 2 * index + 1, right = 2 * index + 2, smallest = index;
    if(left < *length and can_swap(heap, left, smallest))
        smallest = left;
    if(right < *length and can_swap(heap, right, smallest))
        smallest = right;
    if(smallest != index)
    {
        swap(heap, smallest, index, ipq);
        heapify(heap, smallest, length, ipq);
    }
    
}

void heappush(trio** heap, trio* t, int* length, pair** ipq)
{
    *length += 1;
    heap[*length - 1] = t;
    ipq[t->key]->index = *length - 1;
    int index = *length - 1, parent = (index - 1)/2;
    while(index != 0 and can_swap(heap, index, parent))
    {
        swap(heap, index, parent, ipq);
        index = parent;
        parent = (index - 1)/2;
    }
}

trio* heappop(trio** heap, int* length, pair** ipq)
{
    swap(heap, 0, *length - 1, ipq);
    trio * t = heap[*length - 1];
    *length -= 1;
    heapify(heap, 0, length, ipq);
    return t;
}

void update(trio** heap, int* length, int key, int add, bool counter, pair** ipq)
{
    int index = ipq[key]->index;
    if(counter)
        heap[index]->recent = add;
    else
        heap[index]->freq = add;
    heapify(heap, index, length, ipq);
}

typedef struct {
    trio** heap;
    pair** ipq;
    int* length;
    int capacity;
} LFUCache;


LFUCache* lFUCacheCreate(int capacity) {
    LFUCache* lfu = (LFUCache*)malloc(sizeof(LFUCache));
    lfu->heap = (trio**)malloc(sizeof(trio*) * N);
    lfu->ipq = (pair**)malloc(sizeof(pair*) * N);
    memset(lfu->ipq, (int)NULL, sizeof(pair*) * N);
    lfu->length = (int*)malloc(sizeof(int));
    *(lfu->length) = 0;
    lfu->capacity = capacity;
    timestamp = 0;
    return lfu;
}

int lFUCacheGet(LFUCache* obj, int key) 
{
    timestamp += 1;
    if(obj->ipq[key] == NULL)
        return -1;
    update(obj->heap, obj->length, key, timestamp, true, obj->ipq);
    update(obj->heap, obj->length, key, 1 + obj->heap[obj->ipq[key]->index]->freq, false, obj->ipq);
    return obj->ipq[key]->value;
}

void lFUCachePut(LFUCache* obj, int key, int value)
{
    if(obj->capacity == 0)
        return;
    timestamp += 1;
    if(obj->ipq[key] == NULL and *(obj->length) == obj->capacity)
    {
        trio* t = heappop(obj->heap, obj->length, obj->ipq);
        obj->ipq[t->key] = NULL;
    }
    
    if(obj->ipq[key] == NULL)
    {
        obj->ipq[key] = make_pair(-1, value);
        heappush(obj->heap, make_trio(key, 1, timestamp), obj->length, obj->ipq);
    }
    else
    {
        obj->ipq[key]->value = value;
        update(obj->heap, obj->length, key, timestamp, true, obj->ipq);
        update(obj->heap, obj->length, key, 1 + obj->heap[obj->ipq[key]->index]->freq, false, obj->ipq);
    }
}

void lFUCacheFree(LFUCache* obj) {
    int i = 0;
    for(i = 0; i < N; i++)
        if(obj->ipq[i] != NULL)
            free(obj->ipq[i]);
    free(obj->ipq);
    for(i = 0; i < *(obj->length); i++)
        free(obj->heap[i]);
    free(obj->heap);
    free(obj->length);
}

/**
 * Your LFUCache struct will be instantiated and called as such:
 * LFUCache* obj = lFUCacheCreate(capacity);
 * int param_1 = lFUCacheGet(obj, key);
 
 * lFUCachePut(obj, key, value);
 
 * lFUCacheFree(obj);
*/