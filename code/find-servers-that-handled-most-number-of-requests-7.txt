class Solution {
public:
    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {
        //stores all the servers that are busy.
        //pair.first = time at which it will get free
        //pair.second = id of the server
        set<pair<int,int>>busyServer;
        
        //tracks the number of requests served by k servers
        vector<int>frequency(k,0);
        
        //tracks the available servers.
        set<int>availableServer;
        for(int i=0;i<k;i++){
            availableServer.insert(i);
        }
        
        //simulate the process
        for(int i=0;i<arrival.size();i++){
            while(!busyServer.empty()){              
                //it pointing to first pair of busyServer
                auto it = busyServer.begin();
                
                if(it->first<=arrival[i]){
                    //unload the first server because at time
                    //arrival[i], that server will become free to use again.
                    //Add the id of that server to available server.
                    availableServer.insert(it->second);
                    busyServer.erase(it);
                }else{
                    //if the first element has greater time than
                    //arrival[i] then all the elements of set will have 
                    //greater than arrival[i], as set is sorted in increasing order
                    break;
                }
            }   
            
            //if there are no available servers then drop the current request
            if(availableServer.size()==0){
                continue;
            }
            
            //find the i%k server from available server. If that points to end
            //then take the first available server from the list, assuming the cyclic 
            //nature
            auto it = availableServer.lower_bound(i%k);
            if(it==availableServer.end()){
                it = availableServer.begin();
            }
            
            //remove the it from available server and insert into busy server
            //note: insert ending time = arrival[i]+load[i]
            int id = *it;
            frequency[id]++;
            availableServer.erase(it);
            busyServer.insert({arrival[i]+load[i],id});
        }
        
        //finding the busiest server
        vector<int>result;
        int maxx = -1;
        for(auto it:frequency){
            maxx = max(maxx,it);
        }
        
        for(int i=0;i<k;i++){
            if(frequency[i]==maxx){
                result.push_back(i);
            }
        }
        
        return result;
    }
};