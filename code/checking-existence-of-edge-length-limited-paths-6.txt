bool comp(vector<int>&a , vector<int>&b)
{
	if(a[2]<=b[2])
	{
		return true;
	}
	return false;
}
class Solution {
public:

int find_parent(vector<int>& parent, int n1)
{
	if(parent[n1]==n1)
	{
		return n1;
	}
	return parent[n1]  = find_parent(parent, parent[n1]);
}

void joinn(vector<int>&parent, vector<int>& rank, int n1, int n2)
{
	int par1 = find_parent(parent, n1);
	int par2 = find_parent(parent, n2);
	if(par1==par2)
		return;
	if(rank[par1]>rank[par2])
	{
		parent[par2] = par1;
		rank[par1] += rank[par2];
	}
	else
	{
		parent[par1] = par2;
		rank[par2] += rank[par1];
	}
}

vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& qq)
{

	int si = edgeList.size();
	for(int k = 0;k<qq.size();k++)
	{
	   qq[k].push_back(k);   
	}
	sort(qq.begin(),qq.end(), comp);
	sort(edgeList.begin(), edgeList.end(), comp);
	vector<int>parent(n);
	vector<int>rank(n,1);
	for(int  i = 0;i<n;i++)
	{
		parent[i] = i;
	}
   int i = 0;
	vector<bool>ans(qq.size(), false);
	for(auto it: qq)
	{
		int limit =it[2];
		 while(i<si && edgeList[i][2]<limit)
		 {
			 joinn(parent, rank, edgeList[i][0], edgeList[i][1]);
				 i++;
		 }
		int par1 = find_parent(parent, it[0]);
		int par2 = find_parent(parent, it[1]);
		if(par1==par2)
		{
			ans[it[3]] = true;
		}
	}
	return ans;

}
};