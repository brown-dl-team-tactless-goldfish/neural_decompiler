
bool flipv[400001]; // tell the range o[L, R] is flipped or not
int  sumv[400001];  // tell the sum of o[L, R]

class SegmentTree {
public:
    SegmentTree() {
        memset(flipv, 0, sizeof(flipv));
        memset(sumv, 0, sizeof(sumv));
    }

    void flip(int o, int L, int R, int x, int y) {
        // Flip all the elements in [x, y] on
        // node o with a range of [L, R]

        // left  child(l): id = o*2,   range = [L, mid]
        // right child(r): id = o*2+1, range = [mid+1, R]
        int l = o<<1, r = (o<<1)+1;
        int mid = (L+R)/2;

        if (x <= L && R <= y) {
            // case 1: [x, y] covers [L, R]
            // 1. directly flip node o[L, R]
            // 2. update sumv[o] by maintain
            flipv[o] = !flipv[o];
        } else {
            // case 2: partially overlap
            // 1. pushdown the flipv at o first
            // 2. update the overlapping segments [L, mid] or/and [mid+1, R]
            pushdown(o, L, R);
            if (x <= mid) {flip(l, L, mid, x, y);}
            if (mid+1<=y) {flip(r, mid+1, R, x, y);}
        }
        // keep flipv[o], sumv[o] correct
        maintain(o, L, R);
    }

    int query(int o, int L, int R, int x, int y) {
        // Query the sum in [x, y] on
        // node o with a range of [L, R]

        // left  child(l): id = o*2,   range = [L, mid]
        // right child(r): id = o*2+1, range = [mid+1, R]
        int l = o<<1, r = (o<<1) + 1;
        int mid = (L+R)/2, res = 0;
        if (x <= L && R <= y) {
            res = sumv[o];
        } else {
            if (x <= mid) {res += query(l, L, mid, x, y);}
            if (mid+1<=y) {res += query(r, mid+1, R, x, y);}
        }
        return res;
    }
private:
    void pushdown(int o, int L, int R) {
        // If the flip flag for range [L, R] is set 
        // flip the flags of the two children, and 
        // maintain the sumv, flipv of them.
        // The range o[L,R] is maintained at the end of 
        // function "flip".
        if (!flipv[o]) return;
        int l = o << 1, r = (o<<1) + 1, mid = (L+R)/2;
        flipv[l] = !flipv[l];
        flipv[r] = !flipv[r];
        maintain(l, L, mid);
        maintain(r, mid+1, R);
        flipv[o] = 0;
    }

    void maintain(int o, int L, int R) {
        // Make the sum value of the range [L, R] correct
        // considering the flip flag of the range [L, R].
        // It can be done by summing the left/right child
        // of the interval and 
        // 1. sumv[o] = sumv[l] + sumv[r] if flipv[o] is false
        // 2. sumv[o] = len(L, R) - (sumv[l] + sumv[r]) if flipv[o] is true
        int len = R-L+1;
        if (L == R) {
            sumv[o] = flipv[o]?1:0;
        } else {
            int sum = sumv[o<<1] + sumv[(o<<1)+1];
            sumv[o] = flipv[o]?len-sum:sum;
        }
    }
};

class Solution {
public:
    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {
        int n = nums1.size();
        SegmentTree t;

        for (int i = 0; i < n; ++i) {
            if (nums1[i] == 0) { continue; }
            // j is the first non-1 element after i
            // flip the segment [i, j-1] of the segment tree 
            int j = i;
            while (j < n && nums1[j] == 1) {++j;}
            t.flip(1, 0, n-1, i, j-1);
            i = j;
        }

        vector<long long> ans;
        long long sum = accumulate(begin(nums2), end(nums2), 0LL);
        for (auto & q: queries) {
            int op = q[0];
            if      (op == 3) ans.push_back(sum);
            else if (op == 2) sum += 1LL*t.query(1, 0, n-1, 0, n-1)*q[1];
            else              t.flip(1, 0, n-1, q[1], q[2]);
        }
        return ans;
    }
};