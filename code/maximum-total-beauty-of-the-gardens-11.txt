class Solution {
public:
    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {
        int n = flowers.size();
        sort(flowers.rbegin(), flowers.rend());
        int ps = 0;
        int complete = 0;
        while (ps < n && flowers[ps] >= target) {
            ++complete;
            ++ps;
        }
        if (ps == n) return (long long) n * full;
        vector<long long> req(n);
        long long sum = 0;
        for (int i = n - 1; i >= 0; i--) {
            sum += flowers[i];
            long long rsum = (long long) flowers[i] * (n - i);
            req[i] = rsum - sum;
        }
        long long sol = 0;
        auto get = [&] (int low) -> pair<long long, long long> {
            int high = n - 1;
            int pos = n - 1;
            while (low <= high) {
                int mid = (low + high) / 2;
                if (req[mid] <= newFlowers) {
                    pos = mid;
                    high = mid - 1;
                }
                else {
                    low = mid + 1;
                }
            }
            return make_pair(pos, req[pos]);
        };
        for (int i = ps; i < n; i++) {
            pair<long long, long long> p = get(i);
            long long rest = newFlowers - p.second;
            long long tot = flowers[p.first] + rest / (n - p.first);
            tot = min(tot, (long long) target - 1);
            long long val = (long long) complete * full;
            val += (long long) partial * tot;
            sol = max(sol, val);
            if (target - flowers[i] <= newFlowers) {
                newFlowers -= target - flowers[i];
                ++complete;
            }
            else {
                break;
            }
        }
        if (complete == n) {
            sol = max(sol, (long long) n * full);
        }
        return sol;
    }
};