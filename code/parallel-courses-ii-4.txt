class Solution {
public:
    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {
        int N = 1 << n;
        int pre[15] = {};
        
        // Compute binary representation of prerequisites for each course.
        for (auto &d : dependencies) {
            pre[d[1] - 1] |= 1 << (d[0] - 1);
        }
        
        // Breadth-first search for the completed state.
		// We start in the zero state, having completed no courses.
        deque<int> q = {0};
        int dist[1<<15] = {};
        int seen[1<<15] = {};
        
        while (!q.empty()) {
            // Binary representation of current state.
            int curr = q.front(); q.pop_front();
            if (curr == N - 1) {
                break;
            }
            
            // The set of all possible courses we can take next.
            int s = 0;
            for (int i = 0; i < n; i++) {
                if ((pre[i] & curr) == pre[i] && !(curr & (1 << i))) {
                    s |= 1 << i;
                }
            }
            
            // Enumerate subsets of possible next courses.
            for (int i = s; i; i = (i - 1) & s) {
                if (__builtin_popcount(i) <= k) {
                    int next = curr | i;
                    if (!seen[next]) {
                        seen[next] = true;
                        dist[next] = dist[curr] + 1;
                        q.push_back(next);
                    }
                }
            }
        }
        
        return dist[N - 1];
    }
};