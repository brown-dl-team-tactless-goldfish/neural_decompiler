class Solution {
public:
    
    // function for finding toposort of a graph
    
    vector<int> toposort(vector<vector<int>> adj)
    {
        int V = adj.size();
        
        // find the indegree of every node
        
        vector<int> indegree(V, 0);
        
        for(int u = 0; u < V; u++)
        {
            for(auto v : adj[u])
            {
                indegree[v]++;
            }
        }
        
        // res will store the toposort order of graph
        
        vector<int> res;
        
        // push the node with indegree = 0 into q
        
        queue<int> q;
        
        for(int u = 0; u < V; u++)
        {
            if(indegree[u] == 0)
            {
                q.push(u);
            }
        }
        
        while(!q.empty())
        {
            int size = q.size();
            
            for(int k = 0; k < size; k++)
            {
                int u = q.front();
                
                q.pop();
                
                res.push_back(u);
                
                // go to adjacent nodes
                
                for(auto v : adj[u])
                {
                    indegree[v]--;
                    
                    if(indegree[v] == 0)
                    {
                        q.push(v);
                    }
                }
            }
        }
        
        // res.size() != V, it means there is cycle
        
        if(res.size() != V)
            return {};
        
        return res;
    }
    
    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {
        
        int n = rowConditions.size();
        
        int m = colConditions.size();
        
        // create two adjacency list one for rowConditions and other for colConditions
        
        vector<vector<int>> adj_r(k);
        
        vector<vector<int>> adj_c(k);
        
        for(int i = 0; i < n; i++)
        {
            int u = rowConditions[i][0];
            
            int v = rowConditions[i][1];
            
            adj_r[u - 1].push_back(v - 1);
        }
        
        for(int i = 0; i < m; i++)
        {
            int u = colConditions[i][0];
            
            int v = colConditions[i][1];
            
            adj_c[u - 1].push_back(v - 1);
        }
        
        // call for toposort
        
        vector<int> row = toposort(adj_r);
        
        if(row.size() == 0)
        {
            return {};
        }
        
        // call for toposort
        
        vector<int> col = toposort(adj_c);
        
        if(col.size() == 0)
        {
            return {};
        }
        
        // create matrix
        
        // store the index of number of col in mp array
        
        vector<int> mp(k, 0);
        
        for(int i = 0; i < col.size(); i++)
        {
            mp[col[i]] = i;
        }
        
        vector<vector<int>> res(k, vector<int> (k, 0));
        
        for(int i = 0; i < row.size(); i++)
        {
            // find the val
            
            int val = row[i] + 1;
            
            // find the row and col
            
            int r = i;
            
            int c = mp[row[i]];
            
            // put in res matrix
            
            res[r][c] = val;
        }
        
        return res;
    }
};