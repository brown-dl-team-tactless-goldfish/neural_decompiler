class Solution {
public:
    unordered_map<int, unordered_map<int, int>> cache;
    int maxStudents(vector<vector<char>>& seats) {
        
        // for each open spot, try to place if possible
        return helper(seats, 0);
    }
    
    // need to cache based on last row
    int helper(vector<vector<char>>& seats, int i) {
        int m = seats.size();
        int n = seats[0].size();
        if (i == m * n) {
            return 0;
        }
        int r = i / n;
        int c = i % n;
        if (c == 0 && r > 0) {
            // convert last row into int
            int key = convert(seats[r-1]);
            // check cache
            if (cache.find(r) != cache.end() && cache[r].find(key) != cache[r].end()) {
                return cache[r][key];
            }
        }
        
        int max_count = helper(seats, i + 1);
        if (seats[r][c] == '.') {
            // check to see if cheating is possible
            // no one is up left, up right, left, right, bottom left, bottom right
            if (check_neighbors(seats, r, c)) {
                seats[r][c] = 'x';
                max_count = max(max_count, helper(seats, i + 1) + 1);
                seats[r][c] = '.';
            }
        }
        if (c == 0 && r > 0) {
            int key = convert(seats[r-1]);
            cache[r][key] = max_count;
        }
        
        return max_count;
    }
    
    int convert(vector<char>& row) {
        int n = 0;
        for (int i = 0; i < row.size(); ++i) {
            n = n * 2 + (row[i] == 'x');
        }
        return n;
    }
    
    bool check_neighbors(vector<vector<char>>& seats, int r, int c) {
        int m = seats.size();
        int n = seats[0].size();
        // upper
        if (r - 1 >= 0) {
            // upper left
            if (c - 1 >= 0 && seats[r-1][c-1] == 'x') {
                return false;
            }
            // upper right
            if (c + 1 < n && seats[r-1][c+1] == 'x') {
                return false;
            }
        } 
        // left
        if (c - 1 >= 0 && seats[r][c-1] == 'x') {
            return false;
        }
        // right
        if (c + 1 < n && seats[r][c+1] == 'x') {
            return false;
        }
        // lower
        if (r + 1 < m) {
            // lower left
            if (c - 1 >= 0 && seats[r+1][c-1] == 'x') {
                return false;
            }
            // lower right
            if (c + 1 < n && seats[r+1][c+1] == 'x') {
                return false;
            }
        }
        return true;
    }
    
};