//to store state
unordered_map<string, int> dp;

int solve(string ring, string key, int idx, int m){
    
    if(m == key.size()){
        return 0;
    }
    
	//store the state as key in the dp map
    string state = to_string(m) + "|" + to_string(idx);
    
	//if we have visited the current state already then just return its corresponding value.
    if(dp.find(state) != dp.end()){
        return dp[state];
    }
    
    int c = key[m];
    int ans = INT_MAX;
    
    for(int i=0; i<ring.length(); i++){
	//if the character matches with the current key character then 
        if(ring[i] == c){
		// a and b are the left/right or right/left rotation of the ring
            int a = abs(idx - i);
            int b = ring.length() - a;
            
			//number of minimum steps from the both rotation
            int steps = 1 + min(a,b);
            
			//now check for the next character in the key considering that the current character of the key is opened by the index i
            steps += solve(ring, key, i, m+1);
            
			//take the minimum steps as the answer of all the possible cases
            ans = min(ans, steps);
        }
    }
    
    
    return dp[state] = ans;
}

int findRotateSteps(string ring, string key) {
    int n = ring.size();
    int m = key.size();
    
    if(m == 0){
        return 1;
    }
    
	//pass the ring and key strings along with their starting indices 
    return solve(ring, key, 0, 0);
}