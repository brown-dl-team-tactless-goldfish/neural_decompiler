class Solution {
public:
    unordered_map<int, unordered_map<int, int> > dis;
    unordered_map<int, unordered_map<int, bool> > f;
    
    int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    
    struct cmp {
        bool operator()(const pair<pair<int, int>, int>& a, const pair<pair<int, int>, int>& b) {
            return a.second > b.second;
        }
    };
    
    void assign(int n, int m) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                dis[i][j] = 1000000;
            }
        }
    }
    
    bool isValid(int r, int c, vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        
        return r >= 0 && r < n && c >= 0 && c < m;
    }
    int minimumObstacles(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        
        assign(n, m);
        priority_queue<pair<pair<int, int> , int>, vector<pair<pair<int, int>, int> >, cmp> q;
        
        q.push({{n - 1, m - 1}, 0});
        
        dis[n - 1][m - 1] = 0;
        
        while (!q.empty()) {
            pair<pair<int, int>, int> node = q.top();
            q.pop();
            
            int r = node.first.first;
            int c = node.first.second;
            int wt = node.second;
            
            //cout<<r<<" "<<c<<" "<<wt<<endl;
            if (f[r][c]) {
                continue;
            }
            
            for (int d = 0; d < 4; d++) {
                int n_r = r + dir[d][0];
                int n_c = c + dir[d][1];
                
                if (!f[n_r][n_c] && isValid(n_r, n_c, grid)) {
                    if (grid[n_r][n_c] == 1) {
                        if (dis[n_r][n_c] > dis[r][c] + 1) {
                            dis[n_r][n_c] = dis[r][c] + 1;
                            q.push({{n_r, n_c}, dis[n_r][n_c]});
                        }
                    } else {
                        if (dis[n_r][n_c] > dis[r][c]) {
                            dis[n_r][n_c] = dis[r][c];
                            q.push({{n_r, n_c}, dis[n_r][n_c]});
                        }
                    }
                }
            }
            
            f[r][c] = true;
            
        }
        
        return dis[0][0];
    }
};