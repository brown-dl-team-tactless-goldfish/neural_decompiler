class Solution {
public:
#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>


vector<int> findSubstring(string s, vector<string>& words) {
    // Initialize an empty result vector
    vector<int> result;
    
    // Return the empty result vector if either the string s or the words array is empty
    if (s.empty() || words.empty()) return result;

    // n is the length of the string s, m is the length of each word in words, k is the number of words in words
    int n = s.size(), m = words[0].size(), k = words.size();
    
    // Create a wordCount map to store the count of each word in words
    unordered_map<string, int> wordCount;
    for (const auto& word : words) wordCount[word]++;

    // Iterate through all possible starting indices of the concatenated substring
    for (int i = 0; i < m; ++i) {
        // left is the starting index of the current concatenated substring
        int left = i, count = 0;
        
        // currWordCount is a map to store the count of each word in the current concatenated substring
        unordered_map<string, int> currWordCount;

        // Iterate through all possible ending indices of the concatenated substring
        for (int j = i; j <= n - m; j += m) {
            // currWord is the current word at index j
            string currWord = s.substr(j, m);
            
            // If currWord is in the wordCount map, we update the currWordCount map and count
            if (wordCount.count(currWord)) {
                currWordCount[currWord]++;

                // If the count of currWord in currWordCount is less than or equal to its count in wordCount,
                // we increment count by 1
                if (currWordCount[currWord] <= wordCount[currWord]) count++;
                
                // If the count of currWord in currWordCount is greater than its count in wordCount,
                // we need to move the left pointer to the right until the count of currWord in currWordCount
                // becomes less than or equal to its count in wordCount
                else {
                    while (currWordCount[currWord] > wordCount[currWord]) {
                        // leftWord is the word at index left
                        string leftWord = s.substr(left, m);
                        currWordCount[leftWord]--;
                        // If the count of leftWord in currWordCount becomes less than its count in wordCount,
                        // we decrement count by 1
                        if (currWordCount[leftWord] < wordCount[leftWord]) count--;
                        left += m;
                    }
                }

                // If count becomes equal to k, it means that all the words in words have been matched,
                // and we add the starting index left to the result vector
                if (count == k) {
                    result.push_back(left);
                    // we decrement the count and move the left pointer to the right
                    // in order to continue checking for other concatenated substrings
                    currWordCount[s.substr(left, m)]--;
                    count--;
                    left += m;
                }
            }
            // If currWord is not in the wordCount map, we reset currWordCount and count,
            // and move the left pointer to the rightmost possible position
            else {
                currWordCount.clear();
                count = 0;
                left = j + m;
            }
        }
    }
    return result;
}
};