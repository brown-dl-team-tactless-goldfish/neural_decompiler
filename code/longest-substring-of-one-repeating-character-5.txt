namespace internal {

// @param n `0 <= n`
// @return minimum non-negative `x` s.t. `n <= 2**x`
int ceil_pow2(int n) {
    int x = 0;
    while((1U << x) < (unsigned int)(n))
    	x++;
    return x;
}

} // namespace internal

// Source: ac-library/atcoder/segtree.hpp
template<class T, T (*unit)(), T (*op)(T, T)>
class segtree {
public:
	segtree() : segtree(0) {}

	segtree(int _n) : segtree(std::vector<T>(_n, unit())) {}
	
	segtree(const std::vector<T>& arr): n(int(arr.size())) {
		log = internal::ceil_pow2(n);
		size = 1 << log;
		st.resize(size << 1, unit());
		for(int i = 0; i < n; ++i)
			st[size + i] = arr[i];
		for(int i = size - 1; i; --i)
			update(i);
	}
	
	void set(int p, T val) {
		assert(0 <= p && p < n);
		p += size;
		st[p] = val;
		for(int i = 1; i <= log; ++i)
			update(p >> i);
	}

	inline T get(int p) const {
		assert(0 <= p && p < n);
		return st[p + size];
	}

	inline T operator[](int p) const {
		return get(p);
	}
	
	T prod(int l, int r) const {
		assert(0 <= l && l <= r && r <= n);
		T ans_left = unit(), ans_right = unit();
		l += size;
		r += size;
		while(l < r) {
			if(l & 1)
				ans_left = op(ans_left, st[l++]);
			if(r & 1)
				ans_right = op(st[--r], ans_right);
			l >>= 1;
			r >>= 1;
		}
		return op(ans_left, ans_right);
	}

	inline T all_prod() const { return st[1]; }

	template<bool (*f)(T)> int max_right(int l) const {
		return max_right(l, [](T x) { return f(x); });
	}

	template<class F> int max_right(int l, F f) const {
		assert(0 <= l && l <= n);
		assert(f(unit()));
		if(l == n)
			return n;
		l += size;
		T sm = unit();
		do {
			while(l & 1 ^ 1)
				l >>= 1;
			if(!f(op(sm, st[l]))) {
				while(l < size) {
					l <<= 1;
					if(f(op(sm, st[l]))) {
						sm = op(sm, st[l]);
						l++;
					}
				}
				return l - size;
			}
			sm = op(sm, st[l]);
			l++;
		} while((l & -l) != l);
		return n;
	}

	template<bool (*f)(T)> int min_left(int r) const {
		return min_left(r, [](T x) { return f(x); });
	}

	template<class F> int min_left(int r, F f) const {
		assert(0 <= r && r <= n);
		assert(f(unit()));
		if(r == 0)
			return 0;
		r += size;
		T sm = unit();
		do {
			r--;
			while(r > 1 && (r & 1))
				r >>= 1;
			if(!f(op(st[r], sm))) {
				while(r < size) {
					r = r << 1 | 1;
					if(f(op(st[r], sm))) {
						sm = op(st[r], sm);
						r--;
					}
				}
				return r + 1 - size;
			}
			sm = op(st[r], sm);
		} while((r & -r) != r);
		return 0;
	}
	
private:
	int n, size, log;
	std::vector<T> st;

	inline void update(int v) { st[v] = op(st[v << 1], st[v << 1 | 1]); }
};

struct S {
    char left_char, right_char;
    int left_len, mid_len, right_len, size;
};

S e() {
    return S{'\0', '\0', 0, 0, 0, 0};
}

S op(S a, S b) {
    S res;
    res.left_char = a.left_char;
    res.left_len = a.left_len;
    if(a.left_len == a.size && a.left_char == b.left_char) {
        res.left_len += b.left_len;
    }
    res.right_char = b.right_char;
    res.right_len = b.right_len;
    if(b.right_len == b.size && b.right_char == a.right_char) {
        res.right_len += a.right_len;
    }
    res.size = a.size + b.size;
    res.mid_len = max(a.mid_len, b.mid_len);
    if(a.right_char == b.left_char) {
        res.mid_len = max(res.mid_len, a.right_len + b.left_len);
    }
    return res;
}

class Solution {
public:
    vector<int> longestRepeating(string s, string qc, vector<int>& qi) {
        const int n = (int) s.size();
        const int q = (int) qc.size();
        segtree<S, e, op> seg(n);
        for(int i = 0; i < n; ++i) {
            seg.set(i, S{s[i], s[i], 1, 0, 1, 1});
        }
        vector<int> ans(q);
        for(int i = 0; i < q; ++i) {
            char c = qc[i];
            int index = qi[i];
            seg.set(index, S{c, c, 1, 0, 1, 1});
            S res = seg.all_prod();
            ans[i] = max({res.left_len, res.mid_len, res.right_len});
        }
        return ans;
    }
};