class LockingTree {
public:
  struct Node{
    Node *par;
    vector<Node*> next;
    int is_locked;
    Node(Node *p){is_locked = 0;par = p;}
  };
  unordered_map<int, Node*> table;
  
  
  LockingTree(vector<int>& parent) {                             //construct DAG
     for(int i = 0; i != parent.size(); i++){
       if(!table.count(parent[i])) table[parent[i]] = new Node(NULL);
       
       if(!table.count(i)) table[i] = new Node(table[parent[i]]);
       else table[i]->par = table[parent[i]];
       
       table[parent[i]]->next.push_back(table[i]);
     }  
  }
    
    bool lock(int num, int user) {
      return table[num]->is_locked ? false : table[num]->is_locked = user; 
    }
    
    bool unlock(int num, int user) {
      return table[num]->is_locked == user ? !( table[num]->is_locked = 0 ) : false;
    }
    
    bool upgrade(int num, int user) {
      Node *tmp = table[num];
      if(tmp->is_locked == 0){                      //if node is locked
        Node *w   = tmp->par;
        
        for(; w; w = w->par)
          if(w->is_locked != 0) return false;       //if parent of node is locked  
                
        queue<Node*>q;
        q.push(tmp);
        while(!q.empty()){
          w = q.front(); q.pop();
          
          if(w->is_locked){                         //if we have a children that is locked 
            q.push(w);
            while(!q.empty()){
              w = q.front(); q.pop();
              w->is_locked = 0;
              for(auto &x: w->next) q.push(x);
            }
            return table[num]->is_locked = user;
          }
          
          for(auto &x: w->next) q.push(x);
        }
      }      
      
      return false;  
    }
};