

struct SegTree {
    SegTree* left = nullptr;
    SegTree* right = nullptr;
    
    long a = 0;
    long b = 0;
    int count = 0;
    
    SegTree(long l, long u) : a(l), b(u) {
        assert(a <= b);
    }
    
    long mid() {
        long ret = (a + b) / 2;
        if (ret + 1 > b) {
            --ret;
        }
        assert(a <= ret && ret <= b);
        return ret;
    }
    
    void split() {
        if (left == nullptr || right == nullptr) {
            assert(left == nullptr && right == nullptr);
            assert(count == 0);
            left = new SegTree(a, mid());
            right = new SegTree(mid() + 1, b);
        }
    }
    
    void update(long c) {
        if (c < a || c > b) {
            return;
        }
        if (a == b) {
            // Leaf
            ++count;
            return;
        }
        split();
        // No need to do lazy propagation as c is just one single point.
        left->update(c);
        right->update(c);
        count = left->count + right->count;
        // cout << count << " " << a << " " << b << " " << c << endl;
    }
    
    int query(long l, long u) {
        if (std::max(a, l) > std::min(b, u)) {
            // No overlap.
            return 0;
        }
        if (l <= a && b <= u) {
            // Inside
            return count;
        }
        if (left == nullptr || right == nullptr) {
            // cout << a << " " << b << " " << count << endl;
            return count;
        }
        return left->query(l, u) + right->query(l, u);
    }
    
};


class Solution {
public:
    SegTree* root;
    
    int countRangeSum(vector<int>& nums, int lower, int upper) {
        vector<long> sums(nums.size() + 1, 0); // Partial sum.
        long l = 0;
        long u = 0;
        for (int i = 0; i < nums.size(); ++i) {
            sums[i + 1] = nums[i] + sums[i];
            l = std::min(l, sums[i+1]);
            u = std::max(u, sums[i+1]);
        }
        root = new SegTree(l, u);
        root->update(sums[0]);
        int ret = 0;
        for (int i = 1; i < sums.size(); ++i) {
            long lower_bound = (long)sums[i] - upper;
            long upper_bound = (long)sums[i] - lower;
            int val = root->query(lower_bound, upper_bound);
            // cout << val << " " << lower_bound << " " << upper_bound << " " << sums[i] << endl;
            ret += val;
            root->update(sums[i]);
        }
        return ret;
    }
};