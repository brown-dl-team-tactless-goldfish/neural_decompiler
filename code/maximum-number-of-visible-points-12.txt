class Solution {
public:
    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {
        int inplace = 0;
        vector<double> thetas;
        
        // Count points on `location` and calculate angles
        for (const auto& p: points) {
            if (p == location) {
                ++inplace;
            } else {
                auto v = atan2((double)p[1] - location[1], (double)p[0] - location[0]) * 180 / M_PI;
                thetas.push_back(v < 0 ? v + 360 : v);   
            }
        }
        
        // Wraparound logic: essentially double the array elements and add 360
        int n = thetas.size();
        for (int i = 0; i < n; ++i) {
            thetas.push_back(thetas[i] + 360);
        }
        
        // Sort angles and do sliding window
        sort(thetas.begin(), thetas.end());
        
        int maxPoints = 0;
        for (int i = 0, j = 0; j < thetas.size(); ++j) {
            while (i <= j && thetas[j] - thetas[i] > angle) {
                ++i;
            }
            
            maxPoints = max(maxPoints, j - i + 1);
        }
        
        return inplace + maxPoints;
    }
};