class Solution {
public:
    int isBMoreClockWiseThanCAndAIsCentre(const vector<int> &a, const vector<int> &b, const vector<int> &c) {
        return (b[1] - a[1]) * (c[0] - b[0]) - (b[0] - a[0]) * (c[1] - b[1]);
    }
    
    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {
        set<vector<int>> set;
        int leftMostIndex = 0;
        int n = trees.size();
        if (n < 4) return trees;
        for (int i = 0; i < n; ++i) {
            if (trees[i][0] < trees[leftMostIndex][0]) leftMostIndex = i;
        }
        //we start from the leftMostIndex
        //and then try to pick the next
        //point from the available points
        //which is more clockwise from the current point
        //and we stop when we come to the same point
        int cur_point = leftMostIndex;
        while (1) {
            int candidate = (cur_point + 1) % n;
            //try to pick the next point which is more clockwise
            //to the current point
            for (int i = 0; i < n; ++i) {
                if (isBMoreClockWiseThanCAndAIsCentre(trees[cur_point], trees[candidate], trees[i]) > 0) candidate = i;
            }
            //pick all the points from the space
            //which are co-linear with the candidate
            for (int i = 0; i < n; ++i) {
                if (isBMoreClockWiseThanCAndAIsCentre(trees[cur_point], trees[candidate], trees[i]) == 0) {
                    set.insert(trees[i]);
                }
            }
            cur_point = candidate;
            if (cur_point == leftMostIndex || set.size() == n) break;
        }
        
        vector<vector<int>> result;
        for (const auto &node: set) {
            result.emplace_back(node);
        }
        return result;
    }
};