typedef struct {

    // Enqueue policy
    // R: Store and increment
    // Dequeue policy
    // F: Read and Increment
    int* q;

    // tail - where deq happens
    int F;

    // head - where new enq happens
    int R;

    int k;
    int count;
} MyCircularQueue;


MyCircularQueue* myCircularQueueCreate(int k) 
{
    MyCircularQueue* obj = (MyCircularQueue*) malloc (sizeof (MyCircularQueue));
    obj->q = (int*) malloc (sizeof (int) * k);
    obj->F = 0;
    obj->R = 0;
    obj->k = k;
    obj->count = 0;
    return obj;    
}

bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) 
{
    if (obj->count == obj->k)
        return 0;

    obj->q[obj->R] = value;
    obj->R += 1;
    obj->R %= obj->k;
    obj->count++;
    return 1;
}

bool myCircularQueueDeQueue(MyCircularQueue* obj) 
{
    // if queue is empty
    if (obj->count == 0)
        return 0;

    // Move F
    obj->F += 1;  
    obj->F %= obj->k;
    obj->count--;
    return 1;
}

int myCircularQueueFront(MyCircularQueue* obj)
{
    if (obj->count == 0)
        return -1;
    return obj->q[obj->F];
}

int myCircularQueueRear(MyCircularQueue* obj)
{
    if (obj->count == 0)
        return -1;
    int R_minus_one = obj->R + obj->k - 1;
    R_minus_one %= obj->k;
    return obj->q[R_minus_one];
}

bool myCircularQueueIsEmpty(MyCircularQueue* obj)
{
    return (obj->count == 0);
}

bool myCircularQueueIsFull(MyCircularQueue* obj)
{
    return (obj->count == obj->k);
}

void myCircularQueueFree(MyCircularQueue* obj)
{
    free (obj->q);
    free (obj);
}