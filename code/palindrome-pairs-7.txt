class Solution {
public:
    inline char ComputeHash(const string &word) {
        unsigned char hash = 0;
        for (char c : word)
            hash ^= c;
        return hash;
    }
    inline vector<char> GetHashes(const vector<string>& words) {
        vector<char> hashes(words.size());
        for (int i = 0; i < words.size(); ++i) {
            hashes[i] = ComputeHash(words[i]);
        }
        return hashes;
    }
	//Get the middle letter of words[i]##words[j].
    inline char GetMiddleLetter(const vector<string>& words, int i, int j, int total_length) {
        const string &word1 = words[i];
        const string &word2 = words[j];
        if (word1.size() > word2.size())
            return words[i][(total_length) / 2];
        return word2[(total_length) / 2 - word1.size()];
    }
	//Basic check of whether words[i]##words[j] is a palindrome.
    bool DirectCheckIfPalindrome(const vector<string>& words, int i, int j) {
        int k = 0;
        while (k < words[i].size() && words[j].size() >= 1 + k) {
            if (words[i][k] != words[j][words[j].size() - 1 - k])
                return false;
            ++k;
        }
        if (k == words[i].size()) {
            if (k == words[j].size())
                return true;
            int l = 0;
            while (words[j].size() >= 1 + k && l < words[j].size() - 1 - k) {
                if (words[j][l] != words[j][words[j].size() - 1 - k])
                    return false;
                ++l;
                ++k;
            }
            return true;
        }
        assert(k == words[j].size());
        int l = 0;
        while (k < words[i].size() - 1 - l) {
            if (words[i][k] != words[i][words[i].size() - 1 - l])
                return false;
            ++k;
            ++l;
        }
        return true;
    }
	//Optimized check of whether words[i]##words[j] is a palindrome.
    bool CheckIfPalindromic(const vector<string>& words, int i, int j, const vector<char> &hashes) {
        const string &word1 = words[i];
        const string &word2 = words[j];
        if (word1.size() > 0 && word2.size() > 0 && word1[0] != word2[word2.size() - 1])
            return false;
        if (word1.size() > 1 && word2.size() > 1 && word1[1] != word2[word2.size() - 2])
            return false;
        if (word1.size() > 2 && word2.size() > 2 && word1[2] != word2[word2.size() - 3])
            return false;
        int total_length = word1.size() + word2.size();
        bool is_total_length_even = total_length % 2 == 0;
        int hashes_xored = hashes[i] ^ hashes[j];
        if (is_total_length_even && hashes_xored != static_cast<char>(0))
            return false;
        if (!is_total_length_even && hashes_xored != GetMiddleLetter(words, i, j, total_length))
            return false;
		//At this point, it is likely that words[i]##words[j] is a palindrome.
        return DirectCheckIfPalindrome(words, i, j);
        
    }
    vector<vector<int>> palindromePairs(vector<string>& words) {
        vector<char> hashes = GetHashes(words);
        vector<vector<int>> result;
        for (int i = 0; i < words.size(); ++i) {
            for (int j = 0; j < words.size(); ++j) {
                if (i == j)
                    continue ;
                if (CheckIfPalindromic(words, i, j, hashes))
                    result.push_back({i, j});
            }
        }
        return result;
    }
};