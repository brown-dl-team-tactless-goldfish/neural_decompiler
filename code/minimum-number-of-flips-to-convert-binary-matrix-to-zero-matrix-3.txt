public class Solution 
{
    int[] dx = new int[] {0, 1, 0, -1};
    int[] dy = new int[] {1, 0, -1, 0};
    
    public int MinFlips(int[][] mat) 
    {
        int r = mat.Length, c = mat[0].Length;
        var visited = new HashSet<int>();
        var queue = new Queue<int[][]>();
        queue.Enqueue(mat);
        visited.Add(ConvertToInt(mat));
        int depth = 0;
        
        while (queue.Count != 0) 
        {
            int count = queue.Count;
            for(int cnt = 0; cnt < count; cnt++)
            {
                var curr = queue.Dequeue();
                if(ConvertToInt(curr) == 0) return depth;
                for(int x = 0; x < r; x++)
                {
                    for(int y = 0; y < c; y++)
                    {
                        var clone = CloneMatrix(curr);
                        clone[x][y] =  clone[x][y] == 1 ? 0 : 1;
                        for(int d = 0; d < 4; d++)
                        {
                            int nx = x + dx[d], ny = y + dy[d];
                            if(nx >= 0 && nx < r && ny >= 0 && ny < c)
                                clone[nx][ny] =  clone[nx][ny] == 1 ? 0 : 1;
                        }
                        
                        if(visited.Add(ConvertToInt(clone)))
                            queue.Enqueue(clone);
                    }
                }
            }
            
            depth++;
        }
        
        return -1;
    }
    
    private int ConvertToInt(int[][] mat) 
    {
        var result = 0;
        for(int i = 0; i < mat.Length; i++) 
            for (int j = 0; j < mat[0].Length; j++) 
                result = (result * 2) + mat[i][j];
        
        return result;
    }
    
    private int[][] CloneMatrix(int[][] mat)
    {
        int r = mat.Length, c = mat[0].Length;
        var result = new int[r][];
        for(int i = 0; i < r; i++)
            result[i] = (int[]) mat[i].Clone();

        return result;
    }
}