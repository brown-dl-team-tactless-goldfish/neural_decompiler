class Solution {
public:
    
    int vis[301][301];
    int visFire[301][301];
    
    int dir[4][2] = {{0,1}, {1,0}, {0, -1}, {-1, 0}};
    
    void assign(int n, int m) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                visFire[i][j] = -1;
            }
        }
    }
    
    void assign2(int n, int m) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                vis[i][j] = -1;
            }
        }
    }
    
    
    bool isValid(int r, int c, vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        
        return r >= 0 && r < n && c >= 0 && c < m;
    }
    

    
    void markfires(vector<vector<int>>& grid) {
        queue<pair<int, int> > q;
        
        int n = grid.size();
        int m = grid[0].size();
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == 1) {
                    q.push({i, j});
                    visFire[i][j] = 0;
                }
            }
        }
        
        while (!q.empty()) {
            pair<int, int> node = q.front();
            q.pop();
            
            int r = node.first;
            int c = node.second;
            
            
            for (int d = 0; d < 4; d++) {
                int n_r = r + dir[d][0];
                int n_c = c + dir[d][1];
                
                if (isValid(n_r, n_c, grid) && grid[n_r][n_c] == 0 && visFire[n_r][n_c] == -1) {
                    visFire[n_r][n_c] = visFire[r][c] + 1;
                    q.push({n_r, n_c});
                }
            }
        }
    }
    
    bool isSafe(int r, int c, int time, vector<vector<int> >& grid) {
        int n = grid.size();
        int m = grid[0].size();
        
        if (visFire[r][c] == -1) {
            return true;
        }
        
        if (r == n - 1 && c == m - 1) {
            return visFire[r][c] >= time + 1;
        } else {
            return visFire[r][c] > time + 1;
        }
    }
    bool canReach(vector<vector<int>>& grid, int time) {
        queue<pair<int, int> > q;
        
        int n = grid.size();
        int m = grid[0].size();
        
        q.push({0, 0});
        q.push({-1, -1});
        vis[0][0] = 1;
        
        int ctime = time;
        
        while (!q.empty()) {
            pair<int, int> node = q.front();
            q.pop();
            
            int r = node.first;
            int c = node.second;
            
            if (r == -1 && c == -1) {
                if (!q.empty()) {
                    q.push({-1, -1});
                    ctime++;
                } else {
                    break;
                }
            }
            
            
            for (int d = 0; d < 4; d++) {
                int n_r = r + dir[d][0];
                int n_c = c + dir[d][1];
                
                if (isValid(n_r, n_c, grid) && grid[n_r][n_c] == 0 && vis[n_r][n_c] == -1 && isSafe(n_r, n_c, ctime, grid)) {
                    vis[n_r][n_c] = 1;
                    q.push({n_r, n_c});
                }
            }
        }
        
        return vis[n - 1][m -1] == 1;
    }
    
    
    int maximumMinutes(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        assign(n, m);
        
        markfires(grid);
        

        int l = 0;
        int r = 1e9;
                
        
        while (l < r) {
            assign2(n, m);
            int mid = (l + (r - l) / 2);
            //cout<<l<<" "<<r<<" "<<mid<<endl;

            if (!canReach(grid, mid)) {
                //cout<<"n"<<endl;
                r = mid - 1;
            } else {
                //cout<<"y"<<endl;
                l = mid + 1;
            }
        } 
        
        assign2(n, m);
        if (!canReach(grid, l)) {
            l--;
        } 
        
        return l;
    }
};