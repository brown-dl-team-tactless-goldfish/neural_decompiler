class Solution {
public:
    int smallestChair(vector<vector<int>>& times, int targetFriend) {
        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>>pq;
        priority_queue<int,vector<int>,greater<int>> temp_str;
        map<int,vector<int>> um;
        int left = 0, chair_cnt = 0, mn = INT_MAX, mx = INT_MIN;
        while(left < times.size())
        {
            pq.push({times[left][0],{times[left][1],left}});
            mn = min(times[left][0],mn);
            mx = max(times[left][1],mx);
            left++;
        }
        int idx = mn;
        while(!pq.empty() && idx <= mx)
        {
            pair<int,pair<int,int>> tmp = pq.top();
            if(um.count(idx))
            {
                for(int i = 0; i < um[idx].size(); i++)
                {
                    temp_str.push(um[idx][i]);
                }
                um.erase(idx);
            }
            if(tmp.first != idx)
            {
                idx++;
                continue;
            }
            pq.pop();
            if(!temp_str.empty())
            {
                int chair = temp_str.top();
                temp_str.pop();
                um[tmp.second.first].push_back(chair);
                if(tmp.second.second == targetFriend)
                    return chair;
            }
            else
            {
                um[tmp.second.first].push_back(chair_cnt);
                if(tmp.second.second == targetFriend)
                    return chair_cnt;
                chair_cnt++;
            }
        }
        return chair_cnt;
    }
};