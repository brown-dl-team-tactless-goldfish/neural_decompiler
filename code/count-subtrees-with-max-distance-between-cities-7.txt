class Solution {
public:
    tuple<int,int,int> bfs(int src, int generatedSubset, vector<int> adj[], int n) {
        unordered_set<int> vis;
        queue<pair<int,int>> q;
        q.push({src,0});
        vis.insert(src);
        int farthestNode=-1;
        int farthestDist=0;
        while(!q.empty()){
            auto [u,d]=q.front(); 
            q.pop();
            farthestNode=u;
            farthestDist=d;
            for(auto nei: adj[u]){
                if(vis.find(nei)==vis.end() && (generatedSubset & (1<<nei))){ // checks if the nei bit of generatedSubset is set 
                    q.push({nei,d+1});
                    vis.insert(nei);
                }
            }
        }
        return {farthestNode,farthestDist,vis.size()};
    }
    
    int maxDistance(int generatedSubset, vector<int> graph[], int n){
        int startNode=0;
        int count_City=0;
        for(int v=0;v<n;v++){
            if((generatedSubset & (1<<v))){ // checks if the v-th bit of generatedSubset is set 
                startNode=v;
                count_City++;
            }
        }
        auto [farthestNode1,dist1,visitedSize1]=bfs(startNode,generatedSubset,graph,n);
        if(visitedSize1!=count_City){
            return 0; // NOT ALL NODES ARE CONNECTED
        }
        auto [farthestNode2,dist2,visitedSize2]=bfs(farthestNode1,generatedSubset,graph,n);
        return dist2;
    }
    
    vector<int> countSubgraphsForEachDiameter(int n, vector<vector<int>>& edges) {
        vector<int> adj[n+1];
        for(auto edge: edges){
            adj[edge[0]-1].push_back(edge[1]-1);
            adj[edge[1]-1].push_back(edge[0]-1);
        }
        vector<int> res(n-1,0);
        
        for(int i=1;i<(1<<n);i++){  // subset generation
            int d=maxDistance(i,adj,n);
            if(d>0){
                res[d-1]++;
            }
        }
        return res;
    }
};

