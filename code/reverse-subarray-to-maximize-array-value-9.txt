
/*

case 1: swap num[i] and num[j] this impacts sum by 
        abs(nums[j] - nums[i - 1]) - abs(nums[i] - nums[i - 1]) + 
        abs(nums[j + 1] - nums[i]) - abs(nums[j + 1] - nums[j])
        
    * Treat [num[i - 1], num[i]] as interval1 and assume num[i - 1] < num[i] for simplicity
    * Treat [num[j + 1], num[j]] as interval2 and assume num[j] < num[j + 1] for simplicity
    
    If these intervals are non overlapping then you can make them overlapping by swapping
    num[i] and num[j]. This will increase sum by 2 * (num[j] - num[i]) else if they are overlapping 
    then swapping num[i] and num[j] will decrease sum by 2 * (num[j] - num[i])
        
    => keep track on max start point num[j] of Interval2
    => keep track of min end pont num[i] of Interval1
    
   
case 2: swap num[0] and num[j] 
    => Keep track of max abs(nums[0] - nums[i]) - abs(nums[i] - nums[i - 1])
    

case 3: swap nums[nums.size() - 1] and nums[i]
    => Keep track of max abs(nums[N - 1] - nums[i - 1]) - abs(nums[i] - nums[i - 1])
 
*/

class Solution {
public:
    int maxValueAfterReverse(vector<int>& nums) {
        int N = nums.size();
        int origSum = 0;
        int endInterval1 = INT_MAX;     // For case 1: make this as small as possible
        int startInterval2 = INT_MIN;   // For case1 : make this as big as posible
        int change = 0;                 // For case 2 and 3
        
        for (int i = 1; i < N; ++i) {
            int length = abs(nums[i] - nums[i - 1]);
            origSum += abs(nums[i] - nums[i - 1]);
            endInterval1 = min(endInterval1, max(nums[i], nums[i - 1]));
            startInterval2 = max(startInterval2, min(nums[i], nums[i - 1]));
            change = max(change, max(abs(nums[N - 1] - nums[i - 1]), abs(nums[0] - nums[i])) - length);  
        }
        
        
        return origSum + max(change, 2 *(startInterval2 - endInterval1));
    }
};
