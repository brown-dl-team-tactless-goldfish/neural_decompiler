class Solution {
private:
    //memoization table with two variables:-
    //index->defines a point in group 1
    //config->is a bitmask used to keep a track of the points in group 2 which have been paired
    vector<vector<int>>mem;
    //stores the minimum cost required to connect a point in group 2 to any point in group 1
    vector<int>minCostForColumn;
    int solve(vector<vector<int>>&cost,int index,int config){
        int size1=cost.size(),size2=cost[0].size();
        if(index==size1){
            //all the group one points have been connected, the group two points which remain
            //will be connected to those points which have the least cost
            int ans=0;
            for(int i=0;i<size2;i++){
                if(((config>>i)&1)==0){
                    ans+=minCostForColumn[i];
                }
            }
            return ans;
        } else if(mem[index][config]!=-1){
            return mem[index][config];
        } else {
            int ans=1e9;
            //every point in group 1 is connected to atleast one point in group 2. Here we 
            //brute force all possible options
            for(int i=0;i<size2;i++){
                ans=min(ans,cost[index][i]+solve(cost,index+1,config|(1<<i)));
            }
            return mem[index][config]=ans;
        }
    }
public:
    int connectTwoGroups(vector<vector<int>>& cost) {
        int size1=cost.size(),size2=cost[0].size();
        minCostForColumn=vector<int>(size2,1e9);
        mem=vector<vector<int>>(size1,vector<int>(1<<size2,-1));
        //storing the minimum cost for each element in the second group of points
        for(int j=0;j<size2;j++){
            for(int i=0;i<size1;i++){
                minCostForColumn[j]=min(minCostForColumn[j],cost[i][j]);
            }
        }
        return solve(cost,0,0);
    }
};