bool check(char** grid, int n, int r, int c)          // Function to check for winner given a move
{
    int i;
    
    for(i=0; i<n; i++)
    {
        if(grid[r][i] != grid[r][c])          // Check row for winner
        {
            break;
        }
    }
    
    if(i == n)
    {
        return(true);
    }
    
    for(i=0; i<n; i++)          // Check column for winner
    {
        if(grid[i][c] != grid[r][c])
        {
            break;
        }
    }
    
    if(i == n)
    {
        return(true);
    }
    
    if(r == c)          // Check main diagonal
    {
        for(i=0; i<n; i++)
        {
            if(grid[i][i] != grid[r][c])
            {
                break;
            }
        }
        
        if(i == n)
        {
            return(true);
        }
    }
    
    if(r + c == n-1)          // Check counter-diagonal
    {
        for(i=0; i<n; i++)
        {
            if(grid[i][n-1-i] != grid[r][c])
            {
                break;
            }
        }
        
        if(i == n)
        {
            return(true);
        }
    }
    
    return(false);
}

char * tictactoe(int** moves, int movesSize, int* movesColSize)
{
    int i, j, n = 3;
    char** grid = malloc(sizeof(char*) * n);          // Allocate memory for the grid
    
    for(i=0; i<n; i++)
    {
        grid[i] = malloc(sizeof(char) * n);
        
        for(j=0; j<n; j++)
        {
            grid[i][j] = ' ';          // Fill all boxes with spaces
        }
    }
  
    for(i=0; i<movesSize; i++)
    {
        if(i%2)
        {
            grid[moves[i][0]][moves[i][1]] = 'X';          // Even moves correspond to B's turn
            
            if(check(grid, n, moves[i][0], moves[i][1]))          // Check if B can move with the current move
            {
                return("B");
            }
        }
        
        else
        {
            grid[moves[i][0]][moves[i][1]] = 'O';          // Odd moves correspond to A's turn
            
            if(check(grid, n, moves[i][0], moves[i][1]))          // Check if A can move with the current move
            {
                return("A");
            }
        }
    }
    
    return(movesSize == n * n ? "Draw" : "Pending");          // If above moves cannot produce a winner
}