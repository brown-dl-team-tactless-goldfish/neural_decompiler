class Solution {
public:
    
    struct UF{
        vector<int> parents;
        
        UF(int n):parents(n){
            for(int i = 0; i < n; ++i){
                parents[i] = i;
            }
        }
        
        int find(int i){
            if(parents[i] != i){
                parents[i] = find(parents[i]);
            }
            
            return parents[i];
        }
        
        void unionn(int i, int j){
            int r1 = find(i);
            int r2 = find(j);
            
            if(r1 != r2){
                parents[r2] = r1;
            }
        }
    };
    
    
    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {
        vector<int> result;
        unordered_map<int,pair<int,vector<int>> > indeg;
        vector<vector<int>> multiparents;
        int N = 0;
        
        for(auto &e : edges){
            indeg[e[1]].first++;
            N = max(N, max(e[0],e[1]));
            
            if(indeg[e[1]].first > 1){
                multiparents.push_back(indeg[e[1]].second);
                multiparents.push_back(e);
            }else {
                indeg[e[1]].second = e;
            }
        }
        
        UF uf(N + 1);
        
        // Check for a cycle and assume its the second candidate that is causing the cycle
        // ignore it as we are traversing the edges. If we encounter an edge that still causes 
        // a cycle it can either be the first candidate (if exists) or another edge.
        vector<int> edge = !multiparents.empty() ? multiparents[1] : vector<int>();
        
        for(auto &e : edges){
            if(!multiparents.empty() && e == multiparents[1]){
                continue;
            }

            if(uf.find(e[0]) != uf.find(e[1])){
                uf.unionn(e[0],e[1]);
            }else{
                if(!multiparents.empty()){
                    edge = multiparents[0];
                } else{
                    edge = e;
                }

                break;
            }
        }
        
        return edge;
    }
};