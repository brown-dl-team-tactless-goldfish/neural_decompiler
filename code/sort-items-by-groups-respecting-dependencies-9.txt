class Solution {
public:
    const int inc = 30005;
    // map to store members
    unordered_map<int,vector<int>> members;
    
    // DSU to maintain parents
    int par[100005];
    int find(int i)
    {
        if(par[i] == i)return i;
        return par[i] = find(par[i]);
    }
    void merge(int a,int b)
    {
        a = find(a);
        b = find(b);
        par[a] = b;
    }

    void go(int p,vector<vector<int>>&graph,vector<int>&answer,vector<int>&in)
    {
        queue<int> q;
        for(auto member:members[p])
        {
            if(in[member] == 0)
            q.push(member);
        }
        while(!q.empty())
        {
            int m = q.front();//cout << m << ' ';
            answer.push_back(m);
            q.pop();
            for(auto v:graph[m])
            {
                in[v]--;
                if(in[v] == 0)q.push(v);
            }
        }
        cout << endl;
    }
    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {
        for(int i=0;i<100005;i++)par[i] = i;
        members.clear();
        // inc is used for taking gropus range different than the range of elements
        for(int i=0;i<n;i++)
        {
            if(group[i] == -1)
            {

            }
            else
            {
                merge(i,group[i]+inc);
            }
        }

        vector<vector<int>> graph;
        vector<vector<int>> g;


        g.resize(n+inc);
        
        vector<int> in(100005,0),inn(100005,0);

    
        graph.resize(n);

        for(int i=0;i < beforeItems.size();i++)
        {
            for(auto x: beforeItems[i])
            {
                // group topological sorting
                if(find(i) != find(x))
                {
                    g[find(x)].push_back(find(i));
                    in[find(i)]++;
                }
                else
                {
                    // topological sorting logic for members if they belong to same group
                    graph[x].push_back(i);
                    inn[i]++;
                }
            }
        }

        set<int> parents;
        for(int i=0;i<n;i++)
        {
            parents.insert(find(i));
            members[find(i)].push_back(i);
        }

        queue<int> q;
        for(auto it:parents)
        {
            if(in[it] == 0)
                q.push(it);
            //for(auto x:members[it]) cout << x << ' ';
            //cout << endl;
        }

        vector<int> answer;

        while(!q.empty())
        {
            
            int now = q.front();
            q.pop();
            //cout << now << '\n';
            
            // add elements of current group
            go(now,graph,answer,inn);

            for(auto v:g[now])
            {
                in[v]--;
                if(in[v] == 0)q.push(v);
            }
        }
        
        // check for invalid cases using in time arrays
        for(int i=0;i<in.size();i++)
        {
            if(in[i])return {};
        }
        for(int i=0;i<inn.size();i++){
            if(inn[i])return {};
        }
        return answer;


    }
};