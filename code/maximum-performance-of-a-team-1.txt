struct Data
{
    int sp;
    int eff;
};

int cmp(const void *a , const void *b)
{
    const struct Data* a1 = (const struct Data*) a;
    const struct Data* b1 = (const struct Data*) b;

    return(b1->eff - a1->eff);
}

void heapify_min(int *heap, int N, int idx)
{
    int min = idx, l = 2 * idx + 1, r = 2 * idx + 2;
    int temp;
 
    min = l < N && heap[l] < heap[min] ? l : min;
    min = r < N && heap[r] < heap[min] ? r : min;
    
    if(min != idx)
    {
        temp = heap[min];
        heap[min] = heap[idx];
        heap[idx] = temp;
        
        heapify_min(heap, N, min);
    }
    
    return;
}

int maxPerformance(int n, int* speed, int speedSize, int* efficiency, int efficiencySize, int k){
    struct Data data[speedSize];
    long ans = 0, sum = 0;
    int heap[k], mod = 1e9+7;

    for(int i = 0; i < speedSize; i++)
    {
        data[i].sp = speed[i];
        data[i].eff = efficiency[i];
    }

    qsort(data, speedSize, sizeof(data[0]), cmp);

    for(int i = 0; i < k; i++)
    {
        heap[i] = data[i].sp;
        sum += data[i].sp;
        ans = sum * data[i].eff > ans ? sum * data[i].eff : ans;
    }
        
    for(int i = k / 2 - 1; i >= 0 ; i--)
        heapify_min(heap, k, i);

    for(int i = k; i < speedSize; i++)
    {
        sum += data[i].sp - heap[0];
        ans = sum * data[i].eff > ans ? sum * data[i].eff : ans;
        
        heap[0] = data[i].sp;
        heapify_min(heap, k, 0);
    }

    return ans % mod;
}