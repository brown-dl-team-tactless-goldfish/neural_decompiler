#define SIZE 200000    //定义Hash table的初始大小
struct HashArray
{
    int key;
    int count;
    struct HashArray* next;
}Hash[SIZE];       //主函数中需要初始化
void addHash(int num)     //在Hash table中添加数据
{
    int temp=abs(num%SIZE);     //添加的数据可包括负数
    if(Hash[temp].key==0)
    {
        Hash[temp].key=num;
        Hash[temp].count++;
    }else if(Hash[temp].key==num)
    {
        Hash[temp].count++;     
    }else
    {
        struct HashArray *p=&Hash[temp]; 
        while(p->key!=num&&p->next!=NULL)    
        {p=p->next;}
        if(p->key==num)
        {p->count++;}
        else
        {
            p->next=(struct HashArray*)malloc(sizeof(struct HashArray));
            p=p->next;
            p->key=num;
            p->count=1;
            p->next=NULL;
        }
    }   
}
int searchHash(int num){
    int temp=abs(num%SIZE);     //添加的数据可包括负数
    if(Hash[temp].count==0)
    {
        return 0;
    }else if(Hash[temp].key==num)
    {
        return Hash[temp].count;     
    }else
    {
        struct HashArray *p=&Hash[temp]; 
        while(p->key!=num&&p->next!=NULL)    
        {p=p->next;}
        if(p->key==num)
        {return p->count;}
        else
        {
            return 0;
        }
    } 
    return 0;
}
int fourSumCount(int* A, int ASize, int* B, int BSize, int* C, int CSize, int* D, int DSize) {
    int ret=0;
    for(int i=0;i<SIZE;i++){
        Hash[i].key=0;
        Hash[i].count=0;
        Hash[i].next=NULL; 
    }
    for(int i=0;i<ASize;i++){
        for(int j=0;j<BSize;j++){
            addHash(A[i]+B[j]);
        }
    }
    for(int i=0;i<CSize;i++){
        for(int j=0;j<DSize;j++){
            ret=ret+searchHash(-(C[i]+D[j]));
        }
    }
    return ret;
}
// Time Limit Exceeded 
/*int fourSumCount(int* A, int ASize, int* B, int BSize, int* C, int CSize, int* D, int DSize) {
    int ret=0;
    for(int i=0;i<ASize;i++){
        for(int j=0;j<BSize;j++){
            for(int k=0;k<CSize;k++){
                for(int l=0;l<DSize;l++){
                    if(A[i] + B[j] + C[k] + D[l]==0){ret++;}
                }
            }
        }
    }
    return ret;
}*/