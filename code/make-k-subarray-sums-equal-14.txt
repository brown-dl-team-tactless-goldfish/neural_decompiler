

class Solution {
public:
    
struct DSU {
	vector<int> e;
	DSU(int N) { e = vector<int>(N, -1); }

	int get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }

	bool same(int a, int b) { return get(a) == get(b); }

	bool unite(int x, int y) {  
		x = get(x), y = get(y);
		if (x == y) return false;
		if (e[x] > e[y]) swap(x, y);
		e[x] += e[y]; e[y] = x;
		return true;
	}
};
    
    long long makeSubKSumEqual(vector<int>& arr, int k) {
        long long n1=arr.size();
        DSU dsu(n1);
        for(int i=0;i<arr.size();i++){
            dsu.unite(i,(i+k)%n1);
        }
        
        vector<vector<long long>> v(k);
        for(int i=0;i<arr.size();i++){
            v[dsu.get(i)].push_back(arr[i]*1ll);
        }
        long long ans=0;
        for(int id=0;id<k;id++){
            vector<long long>a=v[id];
            sort(a.begin(),a.end());
            long long n=a.size();
            if(!n) continue;
            vector<long long>pref(n),suff(n);
            long long sum=a[0]; pref[0]=0;
            for(int i=1;i<n;i++){
                pref[i]=i*a[i]-sum;
                sum+=a[i];
            }
            sum=a[n-1]; suff[n-1]=0;
            for(int i=n-2;i>=0;i--){
                suff[i]=sum-(n-i-1)*a[i];
                sum+=a[i];
            }
            long long res=pref[0]+suff[0];
            for(int i=1;i<n;i++) res=min(res,pref[i]+suff[i]);
            ans=ans+res;
        }
        return ans;
    }
};