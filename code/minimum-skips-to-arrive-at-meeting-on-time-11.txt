class Solution {
public:
    #define EPS 0.00000001
    
    double nearestInt(double x){
        int y = int(x);
        if(abs(y-x) < EPS) return y;
        return y + 1; 
    }
    
    int minSkips(vector<int>& dist, int speed, int hoursBefore) {
        int n = dist.size();
        double dp[n+1][n+1];
        
        // initialisation
        for(int i = 0;i <= n;i++){
            for(int j = 0;j <= n;j++){
                dp[i][j] = INT_MAX;
                if(i == 0) dp[i][j] = 0;
            }
        }
        
        // iterate through dp
        for(int i = 1;i <= n;i++){
            for(int j = 0;j <= i;j ++){
                // no skip
                if(abs(dp[i-1][j] - INT_MAX) > EPS) {
                    dp[i][j] = min(dp[i][j], nearestInt(dp[i-1][j]) + dist[i-1]/(1.00 * speed));
                }
                
                // skip
                if(j > 0 && abs(dp[i-1][j-1] - INT_MAX) > EPS) {
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1] + dist[i-1]/(1.00 * speed));
                }
            }
        }
        
		// evaluate optimal skips
        for(int i = 0;i <= n;i++){
            if(dp[n][i] < hoursBefore + EPS) return i;
        }
        return -1;
    }
};