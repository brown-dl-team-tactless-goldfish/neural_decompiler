class Solution {
public:
    struct Node {
        char op = 0;
        Node* left = nullptr;
        Node* right = nullptr;
        bool one = false;
    };
    
    unordered_map<Node*, int> cache;

    int minOperationsToFlip(string expression) {
        auto* node = parse(expression.data(), expression.data() + expression.size()); 
        return dfs(node);
    }
    
    int dfs(Node* node) {
        if (!node) {
            return 0;
        }
        
        if (node->op == 0) {
            return 1;
        }
        
        auto it = cache.find(node);
        if (it != cache.end()) {
            return it->second;
        }
        
        int ret = 0;
        if (node->one) {
            if (node->op == '|') {
                if (node->left->one != node->right->one) {  // 1 | 0
                    ret = 1;  // -> &
                } else {  // 1 | 1
                    auto l = dfs(node->left);
                    auto r = dfs(node->right);
                    ret = min(l + r, min(l+1, r+1));  // 0|0, 1&0
                }
            } else {  // 1 & 1
                ret = min(dfs(node->left), dfs(node->right));
            }
        } else {
            if (node->op == '|') {  // 0 | 0
                ret = min(dfs(node->left), dfs(node->right));
            } else {
                if (node->left->one || node->right->one) {  // 1 & 0
                    ret = 1;
                } else {  // 0 & 0
                    auto l = dfs(node->left);
                    auto r = dfs(node->right);
                    ret = min(l + r, min(l+1, r+1));  // 1&1, 1|0
                }
            }
        }
        
        cache[node] = ret;
        return ret;
    }
    
    static Node* parse(const char* p, const char* end) {
        vector<Node*> nodes;
        vector<char> ops;
        
        for (; p < end; ++p) {
            if (*p == '(') {
                ops.push_back(*p);
                continue;
            } else if (*p == ')') {
                // assert(!ops.empty() && ops.back() == '(')
                ops.pop_back();
            } else if (*p == '|' || *p == '&') {
                ops.push_back(*p);
                continue;
            } else {
                auto* current = new Node();
                current->one = *p == '1';
                nodes.push_back(current);
            }
            
            while (!ops.empty() && ops.back() != '(') {
                auto* current = new Node();
                current->op = ops.back();
                ops.pop_back();
                current->right = nodes.back();
                nodes.pop_back();
                current->left = nodes.back();
                nodes.pop_back();
                
                // eval
                current->one = current->op == '|' ? (current->left->one || current->right->one) : (current->left->one && current->right->one);
                
                nodes.push_back(current);
            }
        }
        
        // assert(nodes.size() == 1 && ops.empty())
        return nodes[0];
    }
};