class Solution {
public:
    vector<int> getBiggestThree(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        set<int> bestOfThree;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                getMaxRhomSum(i, j, m, n, grid, bestOfThree);
            }   
        }
        vector<int> result(rbegin(bestOfThree), rend(bestOfThree));
        return result;
    }
    
    void updateBestOfThree(set<int> &bestOfThree, int &curSum) {
        // Update set
        bestOfThree.insert(curSum);
        if (bestOfThree.size() > 3) {
            bestOfThree.erase(bestOfThree.begin());
        }
    }
    
    // Returns maximum rhombus sum for given point
    void getMaxRhomSum(int i, int j, int &m, int &n, vector<vector<int>> &grid, set<int> &bestOfThree) {
        // Update set, Include single point as well
        updateBestOfThree(bestOfThree, grid[i][j]);
                                        //   up          down          left         right
        vector<vector<int>> points = { { i - 1, j }, { i + 1, j }, { i, j - 1 }, { i, j + 1 } };
        while (inside(points, m, n)) {
            // Get square sum for current four points
                                         // up        down       left      right
            int squareSum = getSquareSum(points[0], points[1], points[2], points[3], grid);
            
            // Update set
            updateBestOfThree(bestOfThree, squareSum);
            
            // Update points
            points[0][0] -= 1;
            points[1][0] += 1;
            points[2][1] -= 1;
            points[3][1] += 1;
        }
    }
    
    // Calculates rhomsum for given square rotated 45 degree
    int getSquareSum(vector<int> up, vector<int> down, vector<int> left, vector<int> right, vector<vector<int>> &grid) {
        int squareSum = 0;
        for (int stepsLeft = (down[0] - up[0]) / 2; stepsLeft > 0; stepsLeft--) {
            squareSum += grid[up[0]++][up[1]++];
            squareSum += grid[down[0]--][down[1]--];
            squareSum += grid[left[0]--][left[1]++];
            squareSum += grid[right[0]++][right[1]--];
        }
        return squareSum;
    }
    
    // Checks if given point is inside of the grid
    bool inside(vector<vector<int>> &points, int &m, int &n) {
        for (vector<int> &point : points) {
            if (point[0] >= m || point[0] < 0 || point[1] >= n || point[1] < 0 ) {
                return false;
            }
        }
        return true;
    }
};