int longestPalindrome(char ** words, int wordsSize){
	// allocate lookupTable -- short is sufficiently large for this problem
    short lookupTable[26][26];
    memset(lookupTable, 0, sizeof(lookupTable));
    
    int count = 0; // running count of length of palindrome we can build
    int c1, c2;
    for (int i=0; i<wordsSize; i++){
		// convert chars to ints for indexing the table
        c1 = words[i][0] - 'a';
        c2 = words[i][1] - 'a';
        
		// if we have a positive count for the reverse of this string, 
		// increment count and decrement the reverse string in the table
        if (lookupTable[c2][c1] > 0){
            count += 4;
            lookupTable[c2][c1]--; // decrementing the reverse string
        } else {
			// otherwise just increment the value of this string
            lookupTable[c1][c2]++;
        }
    }
    
	// Finally, we have to look for a palindrome that can go in the center
	// If there is a positive value anywhere in the diagonal, we add 2 to count
    for (int i=0; i<26; i++){
        if (lookupTable[i][i] > 0){
            count += 2;
            break;
        }
    }
    
    return count;
}