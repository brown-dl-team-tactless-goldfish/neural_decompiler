struct neighbor_list{
    int vertex;
    struct neighbor_list* next;
};
 
struct graph_node{
    struct neighbor_list* neighbor;
    bool visited;
};
 
struct graph_node* G[200001];

void init_graph(){
    for(int i=0; i<200001; i++)
        G[i] = NULL;
}
 
void add_edge(int u, int v){
    struct neighbor_list* new = 
           (struct neighbor_list*)malloc(sizeof(struct neighbor_list));
    struct neighbor_list* neighbor = NULL;
 
    new->vertex = v;
    new->next = NULL;
 
    if(G[u] == NULL) {
        G[u] = (struct graph_node *) malloc(sizeof(struct graph_node));;
        G[u]->neighbor = new;
        G[u]->visited = false;
    }
    else {
        neighbor = G[u]->neighbor;
        while(neighbor->next)         
            neighbor = neighbor->next; 
        neighbor->next = new;       
    }
}

bool validPath(int n, int** edges, int edgesSize, int* edgesColSize, int source, int destination){
    int queue[10000];
    struct neighbor_list* neighbor = NULL;
    int vertex;
    int head = 0, tail = 0;
   
    init_graph();
    
    for(int i=0; i<edgesSize; i++) {
        add_edge(edges[i][0], edges[i][1]);
        add_edge(edges[i][1], edges[i][0]);
    }
    
    if(source == destination) // very weird test case!
        return true;
    
    G[source]->visited = true;
    
    queue[tail++] = source; //enqueue source
 
    while(head < tail) {
        vertex = queue[head++]; //dequeue
        neighbor = G[vertex]->neighbor;
    
        while(neighbor) {
            if(G[neighbor->vertex]->visited== false){
                G[neighbor->vertex]->visited = true;  
                if(neighbor->vertex == destination)
                    return true;
                else 
                    queue[tail++] = neighbor->vertex; //enqueue 
            }
            neighbor = neighbor->next; // visit all neighbors of given graph node      
        }
    } // until Q is empty
    
    return false;
}
