// Uncomment to increase debuggability (which increases run time)
//#define DEBUG

#ifdef DEBUG
# define PRINT  printf
# define ASSERT assert
#else
# define PRINT
# define ASSERT
#endif

static inline int numberOfDigits(int n)
{
    int count = 0;
    
    while(n > 0) {
        n /= 10;
        count++;
    }
    
    return count;
}

int numDupDigitsAtMostN(int n){
    const int origN = n;
    const int origNumDigits = numberOfDigits(n);
    
    bool highUsed[10] = { false };
    // Count of numbers with NO repeated digits
    int count = 0;
    int multiple = 1;
    
    for (int i = 1; i < origNumDigits; i++) {
        multiple *= 10;
    }
    const int origMultiple = multiple;
    
    // test number = [1..(highDigit-1)]...
    if ((n / multiple) > 1) {
        int add = (n / multiple) - 1; // All digits below highDigit except 0
        for (int numUsed = 1; numUsed < origNumDigits; numUsed++) {
		    // 10 is for all digits 0 to 9
			// numUsed is the number of those digits already used to generate the test number
            add *= 10 - numUsed;
        }
        count += add;
    }
    
    PRINT("1: %d\n", count);
    
    // test number = [prevHighDigit]...[highDigit][0..(nextHighDigit-1)]...
    for (int numDigits = origNumDigits; numDigits > 0; numDigits--) {
        const int highDigit = n / multiple;
        const int highN = highDigit * multiple;
        
        // Prepare for next loop
        n -= highN;
        multiple /= 10;
    
        if (highUsed[highDigit] == true) {
		    // If our highDigit was already used before, then all non-repeating solutions were counted
			// in previous loop iterations already
            break;
        } else if (numDigits == 1) {
		    // The last digit in the number allows us to not repeat using all highDigits, so add one
            count++;
        } else {
            const int nextHighDigit = n / multiple;
            int numOptions = 0;
            int numUsed = 0;
                
            highUsed[highDigit] = true;

            for (int i = 0; i < 10; i++) {
                if (highUsed[i] == false) {
                    if (i < nextHighDigit) {
                        numOptions++;
                    }
                } else {
                    numUsed++;
                }
            }
            if (numOptions > 0) {
                int add = numOptions;

                numUsed++;
                for (; numUsed < origNumDigits; numUsed++) {
                    add *= 10 - numUsed;
                }
                count += add;
            }
        }

        PRINT("2: %d\n", count);
    }
    
    n = origN;
    multiple = origMultiple;
    
    // test number = 0...0[1..9]...
    for (int numDigits = origNumDigits; numDigits > 0; numDigits--) {
        const int highDigit = n / multiple;
        const int highN = highDigit * multiple;
                
        if (numDigits > 1) {
            int add = 9; // All digits except 0
            for (int numUsed = 1; numUsed < (numDigits - 1); numUsed++) {
                add *= 10 - numUsed;
            }
            count += add;
        }
        
        PRINT("3: %d\n", count);
        
        // Prepare for next loop
        n -= highN;
        multiple /= 10;
    }
    
    PRINT("%d vs %d\n", origN, count);
    ASSERT(origN >= count);
    return (origN - count);
}