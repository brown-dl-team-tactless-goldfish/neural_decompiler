class Solution {
public:
    int bestRotation(vector<int>& A) {
        int n = A.size();
        deque<int> count(n); // 用deque统计当前i - A[i]的个数
        int cnt = 0;
        for (int i = 0; i < n; ++i) {
            if (A[i] <= i) {
                ++cnt;
                ++count[i - A[i]];
            }
        }
        int res = 0, mx = cnt;
        for (int i = 1; i < n; ++i) {
            cnt -= count[0]; // 每次左移一位以后，所有i - A[i]为0的数就不再符合要求，要减去
            count.pop_front(); // 移除i - A[i]为0这一项
            count.push_back(0); // 添加i - A[i]为n - 1这一项
            if (A[i - 1] <= n - 1) { // 将数组头部的数放到尾部以后，更新i - A[i]的个数及计数器cnt
                ++count[n - 1 - A[i - 1]];
                ++cnt;
            }
            if (cnt > mx) { // 更新全局mx及结果res
                mx = cnt;
                res = i;
            }
        }
        return res;
    }
};