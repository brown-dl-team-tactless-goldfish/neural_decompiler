public class Solution {
    Dictionary<int, List<int>> graph = new();
    bool[] visited;
    
    public int MostProfitablePath(int[][] edges, int bob, int[] amount) {
        foreach(var edge in edges){
            graph.TryAdd(edge[0], new List<int>());
            graph.TryAdd(edge[1], new List<int>());
            
            graph[edge[0]].Add(edge[1]);
            graph[edge[1]].Add(edge[0]);
        }
        
        visited = new bool[amount.Length];
        var result = DFS(0, 1, bob, amount);
        
        return result[0];
    }
    
    private int[] DFS(int node, int steps,  int bobNode, int[] amount){     
        long cost = Int64.MinValue;
        int bobsSteps = 0;
        visited[node] = true;
        
        if(graph.ContainsKey(node)){
            foreach(int child in graph[node]){
                if(visited[child])
                    continue;
                
                var childResult =  DFS(child, steps +1, bobNode, amount);
                cost = Math.Max(cost, childResult[0]);
                bobsSteps = Math.Max(bobsSteps, childResult[1]);
                
            }
        }
        cost = cost == Int64.MinValue ?  0 : cost;
        
        if(bobsSteps == 0 && bobNode == node)
            bobsSteps = 1;
        
        int currCost = 0;
        
        if(bobsSteps == 0 || (steps < bobsSteps))
            currCost = amount[node];
        else if(steps == bobsSteps)
            currCost = amount[node]/2; 
        
       // Console.WriteLine($" at node {node}- steps: {steps}, bobsSteps: {bobsSteps}, cost {cost} , currentCost {currCost}/{amount[node]} ");
        return new int[]{(int)(currCost + cost), bobsSteps == 0 ? 0 : bobsSteps + 1};
    }
}