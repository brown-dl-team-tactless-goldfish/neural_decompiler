class Solution {
public:
    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {
        sort(nums.begin(), nums.end());
        const int n = queries.size();
        vector<tuple<int,int,int>> sortedQuery;
        for(int i=0;i<n;i++){
            sortedQuery.emplace_back(queries[i][1], queries[i][0], i);
        }
        sort(sortedQuery.begin(), sortedQuery.end());
        vector<int> res(n, -1);
        auto it = nums.begin();
        for(auto [m, x, i] : sortedQuery){
            while(it != nums.end() && *it <=m) add(*it++);
            if(it != nums.begin()) res[i] = findMaxXor(x);
        }
        return res;        
    }
    
    void add(int x){
        auto p = &nodePool[0];
        auto v = toVec(x);
        for(auto i:v){
            if(!p->next[i]) p->next[i] = &nodePool[++nodeEnd];
            p = p->next[i];
        }
        p->val = x;
    }
    
    int findMaxXor(int x){
        auto v = toVec(x);
        auto p = &nodePool[0];
        for(auto i:v){
            int j = 1-i;
            if(p->next[j]) p = p->next[j];
            else p = p->next[i];
        }
        return x ^ p->val;
    }
    
    struct Node{
        int val = -1;
        array<Node*, 2> next = {};
    };
    
    vector<int> toVec(int x){
        vector<int> v(size, 0);
        for(int i=0;i<size;i++){
            v[i] = (x & (1<<i)) == 0 ? 0 : 1;
        }
        reverse(v.begin(), v.end());
        return v;
    }
    
    const int size = 30;
    vector<Node> nodePool = vector<Node>(2000001);    
    int nodeEnd = 0;
};