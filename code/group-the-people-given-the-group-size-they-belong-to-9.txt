typedef struct DATA
{
    short i;
    short v;
} DATA;

static void merge(register DATA* A, register short l, register short m, register short r)
{
    register short i,j,k, n1 = m-l+1, n2 = r-m;
    DATA L[n1+1];
    DATA R[n2+1];
    for (i=0;i<n1;++i) L[i] = A[l+i];
    for (i=0;i<n2;++i) R[i] = A[m+1+i];
    
    i=0;j=0,k=l;
    while (i < n1 && j < n2) A[k++] = L[i].v <= R[j].v ? L[i++] : R[j++];
    
    while (i < n1) A[k++] = L[i++];
    while (j < n2) A[k++] = R[j++];
}

static void msort(register DATA* a, register short l, register short r)
{
    register short m;
    if (l < r)
    {
        m = l + (r-l)/2;
        msort(a, l, m);
        msort(a, m+1, r);
        merge(a, l, m, r);
    }
}


/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** groupThePeople(int* gs, int G, int* N, int** C)
{
    *N=0;
    int** out = NULL;
    register short i,j,k,s;
    if (G==1)
    {
        *C=(int*) malloc(4), out = (int**) malloc(sizeof(int**)), out[0]=(int*)malloc(gs[0]*4);
        for (i=0;i<gs[0];++i) out[0][i]=i; 
        return ++(*N), (*C)[0]=gs[0], out;
    }
    register DATA* data = (DATA*) malloc(G * sizeof(DATA));
    *C=(int*) malloc(G*4);
    for (i=0;i<G;++i) data[i].i=i, data[i].v=gs[i], (*C)[i]=0;
    msort(data, 0, G-1), out = (int**) malloc(G*sizeof(int**));
    for (i=1,s=0;i<G;++i)
    {
        if (data[i-1].v==data[i].v) continue;
        for (j=s,out[*N]=(int*)malloc(G*4);j<i;++j)
        {
            out[*N][(*C)[*N]++]=data[j].i;
            if (data[j].v==(*C)[*N]) out[*N]=(int*)realloc(out[*N], (*C)[*N]*4), out[++(*N)]=(int*)malloc(G*4);
        }
        s=i;
    }
    for (j=s,out[*N]=(int*)malloc(G*4);j<G;++j)
    {
        out[*N][(*C)[*N]++]=data[j].i;
        if (data[j].v==(*C)[*N])
        {
            out[*N]=(int*)realloc(out[*N], (*C)[*N]*4);
            if (++(*N)<G) out[*N]=(int*)malloc(G*4);
        }
    }
    return free(data), data=NULL, out = (int**) realloc(out, *N * sizeof(int**)), out;
}