class Solution {
public:
    vector<int> minOperations(string boxes) {
        int n = boxes.size();
        
        
        // idea is that we will separately calculate the distance that all the 1s
        // left to i will have to travel to position i
        // and the distance all the 1s will have to travel from the right of i to position i.
        
        // observation : 
        // at any point i, if we want to calcualte the distance all the 1s
        // will have to travel to reach i, which are left of i
        // say left[i] = left[i-1] + #1s to left of i (excluding if there is a 1 at i).
        
        // e.g. in "00101"
        // left-prefix looks like : [0,0,0,1,1]
        // distance travelled by 1s to left of i will be 
        // for i=0, left[0] = 0
        // for i=1, left[1] = 0  (no 1s to the left of this position).
        // for i=2, left[2] = left[1] + lprefix[2] = 0 + 0 = 0
        // for i=3, left[3] = left[2] + lprefix[3] = 0 + 1 = 1.
        
        // This works because let's say there are 3 1s to left of position i. 
        // till position i-1 they had to travel distance d to reach i-1. 
        // now each of these 1s will need to travel a unit = 1 distance more from i-1 to i.
        // so the total additional distance all these one's need to travel in addition to 
        // reaching i-1 position = #1s.
        // total distance = till i-1 + extra,
        // extra = from i-1 to i = unit_distance * number of 1s = 1*lprefix[i].
        
        // Calculation for the one's on the right side is similar. 
        
        // Finally, we add the distance that's required to be travelled by all the ones
        // from the left and the right. 
        
        
        // left prefix sum and right prefix sum. 
        vector<int> rpre(n, 0);
        vector<int> lpre(n, 0); // counts number of 1s to left/right of i. (excluding i).
        
        // left prefix.
        lpre[0] = 0;
        for(int i=1;i<n;i++){
            int b = 0;
            if(boxes[i-1] == '1')
                b = 1;
            lpre[i] = lpre[i-1] + b;
        }
        // right prefix.
        rpre[n-1] = 0;
        for(int i=n-2;i>=0;i--){
            int b = 0;
            if(boxes[i+1] == '1')
                b = 1;
            rpre[i] = rpre[i+1] + b;
        }
        
        
        // now distance of all 1s to left and to right of i. 
        
        vector<int> left(n,0);
        vector<int> right(n,0);
        
        left[0] = 0;
        for(int i=1;i<n;i++){
            left[i] = left[i-1] + lpre[i];
        }
        
        right[n-1] = 0;
        for(int i=n-2;i>=0;i--){
            right[i] = right[i+1] + rpre[i];
        }
        
        
        vector<int> ans(n,0);
        
        for(int i=0;i<n;i++){
            ans[i] = left[i] + right[i];
        }
        
        return ans;
    }
};