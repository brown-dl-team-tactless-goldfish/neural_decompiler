class Solution {
public:
    bool canDistribute(vector<int>& nums, vector<int>& quantity) {
        auto [vfeq, vquant] = preprocess(nums, quantity);
        return dfs(vfeq, vquant, 0);
    }
    
    bool dfs(vector<int>& vfeq, const vector<int>& vquant, int i){
        if(i == vquant.size()){
            return true;
        }
        set<int> visited;
        for(auto& f:vfeq){
            if(f < vquant[i] || visited.count(f)) continue;
            visited.insert(f);
            f-=vquant[i];
            if(dfs(vfeq, vquant, i+1)) return true;
            f+=vquant[i];
        }
        return false;
    }
    
    pair<vector<int>, vector<int>> preprocess(vector<int>& nums, vector<int>& quantity){
        unordered_map<int,int> cnt; 
        for(auto x:nums) cnt[x]++;

        map<int,int> feqs;
        for(auto [x, n]:cnt) feqs[n]++;
        sort(quantity.begin(), quantity.end());
        while(!feqs.empty() && feqs.begin()->first < quantity[0]) feqs.erase(feqs.begin());
        map<int,int> mQuanti;
        for(auto x:quantity) mQuanti[x]++;
        for(auto& [n, cnt] : mQuanti) {
            int y = feqs[n];
            feqs[n] -= min(y, cnt);
            cnt -= min(y, cnt);
        }
        
        vector<int> vfeq, vquant;
        for(auto [n, cnt] : feqs) while(cnt-- >0) vfeq.push_back(n);
        for(auto [n, cnt] : mQuanti) while(cnt-- >0) vquant.push_back(n);
        sort(vquant.begin(), vquant.end(), greater());
        return pair{vfeq, vquant};
    }
};