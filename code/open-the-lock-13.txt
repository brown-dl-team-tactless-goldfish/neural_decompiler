class Solution {
private:
    const vector<char> next = {'1', '2', '3', '4', '5', '6', '7', '8', '9', '0'};
    const vector<char> prev = {'9', '0', '1', '2', '3', '4', '5', '6', '7', '8'};
    
    bool bfsStep(queue<string>& q, unordered_set<string>& visited, int& depth, const unordered_set<string>& otherVisited) {
        int qSize = q.size();
            
        for (int i = 0; i < qSize; ++i) {
            auto front = q.front(); q.pop();

            if (otherVisited.find(front) != otherVisited.end()) {
                return true;
            }

            string child = front;
            for (int c = 0; c < child.length(); ++c) {
                child[c] = next[child[c] - '0'];
                if (visited.find(child) == visited.end()) {
                    q.push(child);
                    visited.insert(child);
                }
                child = front;

                child[c] = prev[child[c] - '0'];
                if (visited.find(child) == visited.end()) {
                    q.push(child);
                    visited.insert(child);
                }
                child = front;
            }
        }

        ++depth;
        
        return false;
    }
    
public:
    int openLock(vector<string>& deadends, const string& target) {
        unordered_set<string> visitedS;
        for (const auto& d : deadends) {
            
            // Edge case where the dead end is the start or end of the journey
            // In this case there is no possible solution
            if (d == "0000" || d == target)
                return -1;
            
            visitedS.insert(d);
        }
        auto visitedF = visitedS;
        
        queue<string> qS;
        qS.push(target);
        visitedS.insert(target);
        
        queue<string> qF;
        qF.push("0000");
        visitedF.insert("0000");
        
        int depthS = 0; int depthF = 0;
        while (!qS.empty() && !qF.empty()) {
            bool foundS = bfsStep(qS, visitedS, depthS, visitedF);
            bool foundF = bfsStep(qF, visitedF, depthF, visitedS);
            
            if (foundS || foundF) {
                return depthS + depthF;
            }
        }
        
        return -1;
    }
};