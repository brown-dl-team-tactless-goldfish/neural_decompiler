#define USE_HASH

# ifndef USE_HASH
typedef struct node_t_ {
    int num;
    int count;
} node_t;

int comp_count(const void *a, const void *b)
{
    const node_t *na = a;
    const node_t *nb = b;
    return nb->count - na->count;
}

int comp_num(const void *a, const void *b)
{
    const int *ia = a;
    const int *ib = b;
    return *ia - *ib;
}

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){
    int i, len;
    int *rtn = calloc(k, sizeof(rtn[0]));
    node_t nodes[numsSize];
    
    qsort(&nums[0], numsSize, sizeof(nums[0]), comp_num);

    for (i=len = 0;i<numsSize;++i) {
        if (!i || (nums[i] != nums[i-1])) {
            nodes[len].num = nums[i];
            nodes[len].count = 1;
            ++len;
        } else {
            ++nodes[len-1].count;
        }
    }
    qsort(&nodes[0], len, sizeof(nodes[0]), comp_count);
    
    for (i=0;i<k;++i) {
        rtn[i] = nodes[i].num;
    }
    
    *returnSize = k;
    return rtn;
}



#else


#define MAX_BUCKET 1000
typedef struct node_t_ {
    int num;
    int count;
    struct node_t_ *next;
} node_t;

typedef struct hash_t_ {
    int num, k;
    node_t bucket[MAX_BUCKET];
    node_t *nodes;
} hash_t;

hash_t *hash_init(int numsSize, int k)
{
    hash_t *obj = calloc(1, sizeof(hash_t));
    obj->k = k;
    obj->nodes = calloc(numsSize, sizeof(obj->nodes[0]));
    return obj;
}
void hash_free(hash_t *obj)
{
    free(obj->nodes);
    free(obj);
}

int hash_bucket(hash_t *obj, int num)
{
    int bucket = abs(num) % MAX_BUCKET;
    return bucket;
}

void hash_update(hash_t *obj, int num)
{
    int bucket = hash_bucket(obj, num);
    node_t *node = obj->bucket[bucket].next;
    while(node) {
        if (node->num == num) {
            ++node->count;
            return;
        }
        node = node->next;
    }
    node = &obj->nodes[obj->num++];
    node->num = num;
    node->count = 1;
    node->next = obj->bucket[bucket].next;
    obj->bucket[bucket].next = node;
    return;
}

int comp(const void *a, const void *b)
{
    const node_t *na = a;
    const node_t *nb = b;
    return nb->count - na->count;
}

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){
    int i;
    int *rtn = calloc(k, sizeof(rtn[0]));
    hash_t *obj = hash_init(numsSize, k);
    
    for (i=0;i<numsSize;++i) {
        hash_update(obj, nums[i]);
    }
    qsort(obj->nodes, obj->num, sizeof(obj->nodes[0]), comp);
    
    for (i=0;i<k;++i) {
        rtn[i] = obj->nodes[i].num;
    }
    *returnSize = k;
    hash_free(obj);
    return rtn;
}
#endif