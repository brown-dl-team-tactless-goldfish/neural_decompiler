    public class Solution
    {
        private class Unions
        {
            private readonly int[] _parents;
            private readonly int[] _ranks;

            public Unions(int n)
            {
                _parents = new int[n];
                _ranks = new int[n];
                for (int i = 0; i < n; i++)
                {
                    _parents[i] = i;
                }
            }

            public int Find(int x)
            {
                if (x != _parents[x])
                {
                    x = Find(_parents[x]);
                }
                return _parents[x];
            }

            public bool Union(int x, int y)
            {
                int px = Find(x);
                int py = Find(y);
                if (px == py)
                {
                    return false;
                }
                if (_ranks[px] > _ranks[py])
                {
                    _parents[py] = px;
                    _ranks[px]++;
                }
                else
                {
                    _parents[px] = py;
                    _ranks[py]++;
                }
                return true;
            }
        }

        public int LargestComponentSize(int[] nums)
        {
            IDictionary<int, int> factor2Root = new Dictionary<int, int>();
            Unions dsu = new Unions(nums.Length);

            for (int i = 0; i < nums.Length; i++)
            {
                int currentNum = nums[i];

                int factor = 2;
                while (factor * factor <= currentNum)
                {
                    if (currentNum % factor != 0)
                    {
                        factor++;
                        continue;
                    }

                    if (factor2Root.ContainsKey(factor))
                    {
                        dsu.Union(i, factor2Root[factor]);
                    }

                    factor2Root[factor] = dsu.Find(i);

                    while (currentNum % factor == 0)
                    {
                        currentNum /= factor;
                    }

                    factor++;
                }


                if (factor2Root.ContainsKey(nums[i]))
                {
                    dsu.Union(i, factor2Root[nums[i]]);
                }
                factor2Root[nums[i]] = dsu.Find(i);



                if (currentNum != 1)
                {
                    if (factor2Root.ContainsKey(currentNum))
                    {
                        dsu.Union(i, factor2Root[currentNum]);
                    }
                    factor2Root[currentNum] = dsu.Find(i);
                }
            }

            IDictionary<int, int> roots2Count = new Dictionary<int, int>();
            for (int i = 0; i < nums.Length; i++)
            {
                var r = dsu.Find(i);
                if (!roots2Count.ContainsKey(r))
                {
                    roots2Count[r] = 0;
                }

                roots2Count[r]++;
            }


            return roots2Count.Values.Max();
        }
    }