class Solution {
    // algorithm: swap the selected one with the last one, establish a mapping
    int last;
    int row, col; 
    unordered_map<int, int> dict; 
public:
    Solution(int n_rows, int n_cols) {
        row=n_rows;
        col=n_cols;         
       reset();
    }
    
    vector<int> flip() {
        int orig_val = rand()%(last+1);
        int ret_val=orig_val; 
        
        if (dict.count(orig_val)!=0)
            ret_val= dict[orig_val];
        
        //swap with current last element
        // update the mapping
        
        // if selected one is already the last one, no swap action needed
        if (orig_val != last)
        {        
           if (dict.count(last)==0)
                dict[orig_val]=last;
            else
                dict[orig_val]=dict[last];
        }
        last--; 
        return {ret_val/col, ret_val%col };
    }
    
    void reset() {
        last = row*col -1; 
        dict.clear();
    }
};