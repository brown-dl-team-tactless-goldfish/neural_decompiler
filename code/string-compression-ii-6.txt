/*
dp[i][j] means till i+1 th char and cut total j char, minimum encoded lengths

e.g.   
             a a a b c c c d 
                   ^       ^
                   |       |
                   l       r
                  most = 3 (c)
                  del = r - l + 1 - most =  8 - 4 + 1 - 3 = 2

                  dp [8][2] = min(dp[8][2], 1 + 1('c3') + dp[4-1][2-2]) 
                            = min(dp[8][2], 1 + 1('c3') + dp[3][0])    
                            = min(dp[8][2], 1 + 1('c3') + 2)  
                            dp[3][0] is first three characters without cup

*/



class Solution {
public:
    int Len(int x) { 
        if(x == 1) return 0;
        else if(x < 10) return 1;
        else if (x< 100) return 2;
        return 3;
    }

    
    int getLengthOfOptimalCompression(string s, int k) {
        int n = s.size();
        vector<vector<int>>dp(n+1, vector<int>(k+1, n+1));        
        for(int r = 1; r<=n; ++r){ //right side of interval to process
            unordered_map<char,int>cnt;
            int most = 0;
            for(int l = r; l>=1; --l){ //left side of interval to process
                
                most = max(most, ++cnt[s[l-1]]);  
                for(int j = 0; j<=k && j <= r; ++ j){
                    
                    int del = r - l +1 - most; //means the number element to be deleted
                    
                    if(del > j) continue; //not enough to delete, need to increase j so as to delete
                    if(r == j)  dp[r][j] = 0; //delete all
                    else
                        dp[r][j] = min(dp[r][j], 1 + Len(most) + ( l-1  == 0 ? 0:  dp[l-1][j-del]));
                }   // l-1  == 0 means no characters at all,  lengths = 0
            }
        }
        return dp[n][k];
    }
};