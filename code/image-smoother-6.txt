

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** imageSmoother(int** M, int MSize, int* MColSize, int* returnSize, int** returnColumnSizes){
    int** res = (int**)malloc(MSize * sizeof(int*));
    *returnColumnSizes = calloc(MSize,sizeof(int));
    
    
    for (int i = 0 ; i < MSize ; ++i) {
        res[i] = calloc(*MColSize, sizeof(int));
    	(*returnColumnSizes)[i] = *MColSize;
    }
    
   for (int i = 0 ; i < MSize ; ++i) {
       for (int j = 0 ; j < *MColSize ; ++j){
           int sum = M[i][j], count = 1;
           for (int k = 0 ; k < 8 ; ++k) {
               switch(k){
    				case 0:
    					if (j - 1 >= 0) {
                            sum += M[i][j - 1];
                            count++;
                        }
    					break;
    				case 1:
    					if ((i - 1 >= 0) && (j - 1 >= 0)) {
                            sum += M[i - 1][j - 1];
                            count++;
                        }
    					break;
    				case 2:
    					if (i - 1 >= 0) {
                            sum += M[i - 1][j];
                            count++;
                        }
    					break;
    				case 3:
    					if ((i - 1 >= 0 ) && (j + 1 < *MColSize)) {
                            sum += M[i - 1][j + 1];
                            count++;
                        }
    					break;
    				case 4:
    					if (j + 1 < *MColSize) {
                            sum += M[i][j + 1];
                            count++;
                        }
    					break;
    				case 5:
    					if ((i + 1 < MSize) && (j + 1 < *MColSize)) {
                            sum += M[i + 1][j + 1];
                            count++;
                        }
    					break;
    				case 6:
    					if (i + 1 < MSize) {
                            sum += M[i + 1][j];
                            count++;
                        }
    					break;
    				case 7:
    					if ((i + 1 < MSize) && (j - 1 >= 0)) {
                            sum += M[i + 1][j - 1];
                            count++;
                        }
    					break;
    			}
           }
           
           res[i][j] = floor(sum / count);
       }
   }
    
    *returnSize = MSize;
    return res;
    
}