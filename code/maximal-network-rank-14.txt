class Solution {
public:
    int maximalNetworkRank(int n, vector<vector<int>>& roads) {
        int max_val = 0;
        vector<unordered_set<int>> grid(n);
        
        for(vector<int> road : roads){
            grid[road[0]].insert(road[1]);
            grid[road[1]].insert(road[0]);
        }
        
        for(int i=0; i<n; i++){
            for(int j=i+1; j<n; j++){
                int curr_val = grid[i].size() + grid[j].size();
                
                if(grid[i].find(j) != grid[i].end())
                    curr_val--;
                max_val = max(max_val, curr_val);
            }
        }
        
        return max_val;
    }
};

/*
Algorithm Outline:
1. Store vector of hts
2. 2 for loops for combos
3. check every nodes for combo
4. if found in both ht, only +1 else +2
5. take max_val

*/