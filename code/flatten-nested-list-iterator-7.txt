struct Node {
    struct Node *before;
    struct NestedInteger **current;
    size_t size;
    size_t index;
};
struct NestedIterator {
    struct Node *node;
    int cached_next;
    int is_cached;
    int has_next;
};

struct NestedIterator *nestedIterCreate(struct NestedInteger** nestedList, int nestedListSize) {
    
    struct NestedIterator *it = (struct NestedIterator*)calloc(1, sizeof(struct NestedIterator));
    it->has_next = 1;
    it->is_cached = 0;
    it->node = (struct Node*)malloc(sizeof(struct Node));
    it->node->before = NULL;
    it->node->current = nestedList;
    it->node->size = nestedListSize;
    it->node->index = 0;
    return it;
}

int nestedIterNext(struct NestedIterator *iter) {
    
    struct Node *n = iter->node;
    
    if (iter->is_cached) {
        
        iter->is_cached = 0;
        return iter->cached_next;
    }
    
    if (n->index < n->size) {
        
        n->index++;
        
        if (NestedIntegerIsInteger(*n->current)) {
            
            int ret = NestedIntegerGetInteger(*n->current);
            n->current++;
            return ret;
        }
        else {
            
            struct Node *after = (struct Node*)malloc(sizeof(struct Node));
            after->before = n;
            after->current = NestedIntegerGetList(*n->current);
            after->size = NestedIntegerGetListSize(*n->current);
            after->index = 0;
            n->current++;
            iter->node = after;
            return nestedIterNext(iter);
        }
    }
    else {
        
        if (iter->node->before != NULL) {
            
            struct Node *before = iter->node->before;
            free(iter->node);
            iter->node = before;
            return nestedIterNext(iter);
        }
        else {
            
            iter->has_next = 0;
            return 0;
        }
    }
}

bool nestedIterHasNext(struct NestedIterator *iter) {
    
    iter->cached_next = nestedIterNext(iter);
    iter->is_cached = 1;
    return iter->has_next != 0;
}

/** Deallocates memory previously allocated for the iterator */
void nestedIterFree(struct NestedIterator *iter) {
    free(iter->node);
    free(iter);
}