#define MIN 5

typedef struct myInstance
{
    int index;
    int count;
} Instance;

typedef struct myList
{
    int size;
    int maxSize;
    Instance * data;
} InstanceList;

void cleanup(InstanceList ** mapping, int ** stickerSignatures, int signatureSize)
{
    for (int i = 0; i < 26; i++)
    {
        InstanceList * current = mapping[i];
        if (current != NULL)
        {
            if (current->data != NULL)
            {
                free(current->data);
            }
            free(current);
        }
    }
    
    for (int i = 0; i < signatureSize; i++)
    {
        if (stickerSignatures[i] != NULL)
            free(stickerSignatures[i]);
    }
}

// hash function for the hash map: letter to 0-26 int
int hashFunction(char c)
{
    return c - 'a';
}

void initializeSignature(char * word, int * signature)
{
    for (int i = 0; i < 26; i++)
        signature[i] = 0;
    
    for (char * c = word; *c != '\0'; c++)
    {
        signature[hashFunction(*c)]++;
    }
}

int preprocessStickers(char ** stickers, int stickersSize, 
                       int ** stickerSignatures, char ** workingStickers, const int const * targetSignature)
{
    // First initialize the workingStickers and stickerSignatures for all words
    for (int i = 0; i < stickersSize; i++)
    {
        workingStickers[i] = stickers[i];
        
        stickerSignatures[i] = (int*) malloc(sizeof(int)*26);
        for (int j = 0; j < 26; j++)
        {
            stickerSignatures[i][j] = 0;
        }
        
        for (char * c = stickers[i]; *c != '\0'; c++)
        {
            int index = hashFunction(*c);
            
            if (targetSignature[index] > 0)
                stickerSignatures[i][index]++;
        }
    }
    
    // Then filter out the ones that are dominated by another sticker
    // Determine which ones are dominated by another sticker and mark dominated ones with NULL
    // Then swap that null with an unprocessed one to retain contiguous use of the arrays
    int remaining = stickersSize;
    for (int i = 0; i < remaining; i++) // Check if sticker i dominated by another
    {
        for (int j = 0; j < remaining; j++)
        {
            if (i == j || workingStickers[j] == NULL)
                continue;
            
            // Check if sticker i is dominated by sticker j       
            int dominated = 1;
            for (int k = 0; k < 26; k++)
            {
                if (stickerSignatures[i][k] > stickerSignatures[j][k])
                {
                    dominated = 0;
                    break;
                }
            }
            
            if (dominated)
            {
                free(stickerSignatures[i]);
                stickerSignatures[i] = NULL;
                workingStickers[i] = NULL;
                remaining--;
                
                if (i < remaining)
                {
                    stickerSignatures[i] = stickerSignatures[remaining];
                    workingStickers[i] = workingStickers[remaining];
                    stickerSignatures[remaining] = NULL;
                    workingStickers[remaining] = NULL;
                    i--;
                }
                
                break;
            }
        }
    }
    
    return remaining;
}


int makeHashTable(char ** stickers, int stickersSize, char * target, InstanceList ** mapping)
{
    // Initialize the values of mapping
    for (int i = 0; i < 26; i++)
    {
        mapping[i] = NULL;
    }
    
    // Allocate an InstanceList for each spot in the mapping that corresponds
    // to a letter in the target word
    for (char * c = target; *c != '\0'; c++)
    {
        int index = hashFunction(*c);
        
        // If there is not yet an InstanceList for this index, create one
        if (mapping[index] == NULL)
        {
            mapping[index] = (InstanceList*) malloc(sizeof(InstanceList));
            mapping[index] -> data = NULL;
        }
    }
    
    // Now go through the list of stickers and update the hash table
    // to reflect the data in stickers
    for (int i = 0; i < stickersSize; i++)
    {
        for (char * c = stickers[i]; *c != '\0'; c++)
        {
            int index = hashFunction(*c);
            
            if (mapping[index] != NULL)
            {
                InstanceList * spot = mapping[index];
                
                // If a sticker has the same letter multiple times, then increment the count
                // instead of taking another Instance in data
                if (spot->data != NULL && spot->size > 0
                    && spot->data[spot->size - 1].index == i)
                {
                    spot->data[spot->size - 1].count++;
                    continue;
                }
                
                // If this is the first time we put this letter in the table, malloc the spots data
                if (spot->data == NULL)
                {
                    spot->data = (Instance *) malloc(sizeof(Instance) * MIN);
                    spot->size = 0;
                    spot->maxSize = MIN;
                }
                // If the data ran out of room, make it bigger to make room for the new Instance
                else if (spot->size == spot->maxSize)
                {
                    spot->maxSize *= 2;
                    spot->data = realloc(spot->data, sizeof(Instance) * spot->maxSize);
                }
                
                spot->data[spot->size].index = i;
                spot->data[spot->size].count = 1;
                spot->size++;
            }
        }
    }
    
    return 0;
}

int minIndex(InstanceList ** mapping, int * targetSignature)
{    
    int index = -1;
    for (int i = 0; i < 26; i++)
    {
        if (targetSignature[i] > 0 && (index == -1 || mapping[i]->size < mapping[index]->size))
            index = i;
    }
    
    return index;
}

void search(InstanceList ** mapping, int ** stickerSignatures, int * targetSignature, int depth, int * maxDepth)
{
    if (depth >= *maxDepth && *maxDepth > 0)
        return;
        
    int minLetter = minIndex(mapping, targetSignature);
    if (minLetter < 0)
    {
        if (*maxDepth == 0 || depth < *maxDepth)
            *maxDepth = depth;

        return;
    }
        
    for (int option = 0; option < mapping[minLetter]->size; option++)
    {
        int index = mapping[minLetter]->data[option].index;
        for (int i = 0; i < 26; i++)
            targetSignature[i] -= stickerSignatures[index][i];
        
        search(mapping, stickerSignatures, targetSignature, depth + 1, maxDepth);
        
        for (int i = 0; i < 26; i++)
            targetSignature[i] += stickerSignatures[index][i];
    }
    
    return;
}

int minStickers(char ** stickers, int stickersSize, char * target)
{
    // Make the target signature to count how many of each letter occur in target
    int targetSignature[26];
    initializeSignature(target, targetSignature);
    
    
    // Array of sticker signatures (each row is a sticker signature, or a record of the letters in that sticker)
    int * stickerSignatures[stickersSize];
    
    // Array of sticker strings. Is a subset of the given stickers, with dominated stickers removed
    char * workingStickers[stickersSize];
    
    int domainSize = preprocessStickers(stickers, stickersSize, stickerSignatures, workingStickers, targetSignature);
    
    
    // Create our hashtable (mapping)
    InstanceList * mapping[26];
    
    // Make the hash table and if it returns 0, there was some sort of error so return 0
    makeHashTable(workingStickers, domainSize, target, mapping);

    
    // Now check if the task is impossible
    // It is impossible iff there is a non-null entry in the hash table with NULL data
    // (which means it is a letter we need but it was not found in any of the given stickers)
    for (int i = 0; i < 26; i++)
    {
        if (mapping[i] != NULL && mapping[i]->data == NULL)
        {
            cleanup(mapping, stickerSignatures, domainSize);
            return -1;
        }
    }
    
    // Then do a backtracking search using the hash table.
    // (MRV or Minimum remaining values, so first process those values with only one option,
    // then those with two, then those with three, etc.
    int maxDepth = 0;
    search(mapping, stickerSignatures, targetSignature, 0, &maxDepth);
    
    // Finally cleanup and return count
    cleanup(mapping, stickerSignatures, domainSize);
    return maxDepth;
}