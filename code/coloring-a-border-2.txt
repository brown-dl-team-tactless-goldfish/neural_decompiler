class Solution {
public:
    using VI = vector< int >;
    using VVI = vector< VI >;
    using PII = pair< int, int >;
    struct Hash {
        size_t operator()( const PII& p ) const {
            return p.first * 51 + p.second;
        }
    };
    using Seen = unordered_set< PII, Hash >;
    VVI colorBorder( VVI& G, int r, int c, int next ){
        auto ans{ G };
        auto M = G.size(),
             N = G.back().size();
        VVI CC{ G };
        go( CC, M, N, r, c, G[ r ][ c ], next ); // fill in entire (C)onnected (C)omponent
        for( auto i{ 0 }; i < M; ++i )
            for( auto j{ 0 }; j < N; ++j )
                if( G[ i ][ j ] != CC[ i ][ j ] && isEdge( G, M, N, i, j ) ) // only update (G)raph with (C)onnected (C)omponent's edge
                    ans[ i ][ j ] = CC[ i ][ j ];
        return ans;
    }
private:
    const VVI dir{ VI{ -1,0 }, VI{ 0,1 }, VI{ 1,0 }, VI{ 0,-1 } };
    void go( VVI& G, int M, int N, int i, int j, int cur, int next, Seen&& seen={} ){
        if( i < 0 || j < 0 || M <= i || N <= j || G[ i ][ j ] != cur || ! seen.insert({ i,j }).second )
            return;
        G[ i ][ j ] = next;
        for( auto d: dir )
            go( G, M, N, i + d[0], j + d[1], cur, next, move( seen ) );
    }
    bool isMiddle( VVI& G, int M, int N, int i, int j ){
        if( i == 0 || j == 0 || i == M-1 || j == N-1 )
            return false;
        for( auto d: dir )
            if( G[ i ][ j ] != G[ i + d[0] ][ j + d[1] ] )
                return false;
        return true;
    }
    bool isEdge( VVI& G, int M, int N, int i, int j ){
        return ! isMiddle( G, M, N, i, j );
    }
};