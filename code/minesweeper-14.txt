// time: O(r * c * 8) => O(r * c)
// space: O(r * c)

class Solution {
public:
  vector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click) {
    int rows = board.size();
    int cols = board[0].size();
    
    int r = click[0], c = click[1];
    if (board[r][c] != 'M' and board[r][c] != 'E') // if we click any revealed board[r][c], nothing happen, simply return the current board
      return board;
    
    if (board[r][c] == 'M') { // if the clicked board[r][c] is an unrevealed mine, set it as a revealed mine, game over and return
      board[r][c] = 'X';
      return board;
    }
    
	// neighbors represent 8 adjacent blocks
    vector<pair<int, int>> neighbors {
      { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 },
      { 1, 1 }, { -1, -1 }, { 1, -1 }, { -1, 1 }
    };
    
    queue<pair<int, int>> queue; // cur_r, cur_c
    queue.emplace(r, c); // BFS starts from the 'click', i.e. starting position
    
    while (queue.size()) {
      auto [ cur_r, cur_c ] = queue.front();
      queue.pop();
      
	  // count the number of adjacent mines first
      int neighborMine = 0;
      for (const auto& [ dr, dc ] : neighbors) {
        int newr = cur_r + dr;
        int newc = cur_c + dc;
        if (0 <= newr and newr < rows and 0 <= newc and newc < cols and board[newr][newc] == 'M')
          neighborMine++;
      }
	  
      // if there is one or more adjacent mines, set it as a char number, otherwise a revealed blank
      board[cur_r][cur_c] = neighborMine ? neighborMine + '0' : 'B'; 
	  
	  // if it is confirmed as a revealed blank, we continue revealing its adjacent blocks
	  // otherwise, which means it is a char number, we will not reveal from it anymore
      if (board[cur_r][cur_c] == 'B') {
        for (const auto& [ dr, dc ] : neighbors) {
          int newr = cur_r + dr;
          int newc = cur_c + dc;
          if (0 <= newr and newr < rows and 0 <= newc and newc < cols and board[newr][newc] == 'E') {
            board[newr][newc] = 'B'; // mark this as visited, will not be added to the queue again
            queue.emplace(newr, newc);
          }
        }
      }
    }
    
    return board;
  }
};