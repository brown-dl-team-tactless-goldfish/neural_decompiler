long long  maxIn4(long long a, long long b, long long c, long long d){
    long long g1 = (a >= b)? a : b; 
    long long g2 = (c >= d)? c : d; 
    
    return (g1 >= g2) ? g1 : g2 ;
}
long long  minIn4(long long a, long long b, long long c, long long d){
    long long g1 = (a <= b)? a : b; 
    long long g2 = (c <= d)? c : d; 
    
    return (g1 <= g2) ? g1 : g2 ;
}
int maxProductPath(int** grid, int gridSize, int* gridColSize){
    int m = gridSize; 
    int n = *gridColSize;
    int mod = 1e9 +7;
    long long** MAX = malloc(m * sizeof(long long*)) ;
    long long** MIN = malloc(m * sizeof(long long*)) ;
    for(int i = 0; i < m; i++)
    {
        MAX[i] = malloc(n * sizeof(long long)) ;
        MIN[i] = malloc(n * sizeof(long long)) ;
    }
    MAX[0][0] = grid[0][0];
    MIN[0][0] = grid[0][0];
    //row 0
    for(int i = 1; i < n; i++)
    {
        MAX[0][i] =(long long) MAX[0][i-1] * grid[0][i];
        MIN[0][i] = (long long)MIN[0][i-1] * grid[0][i];
    }
    //col 0
    for(int i = 1; i < m; i++)
    {
        MAX[i][0] = (long long)MAX[i-1][0] * grid[i][0];
        MIN[i][0] = (long long)MIN[i-1][0] * grid[i][0];
    }
    for(int i = 1; i < m; i++)
    {
        for(int j = 1; j < n; j++)
        {
            MAX[i][j] = maxIn4( MAX[i-1][j]*grid[i][j], MAX[i][j-1]*grid[i][j],\
                              MIN[i-1][j]*grid[i][j], MIN[i][j-1]*grid[i][j]  );

            MIN[i][j] = minIn4( MAX[i-1][j]*grid[i][j], MAX[i][j-1]*grid[i][j],\
                              MIN[i-1][j]*grid[i][j], MIN[i][j-1]*grid[i][j]  );
        }
    }
    long long ans = MAX[m-1][n-1];
    if(ans < 0)
        ans = -1;
    ans %= mod;
    return ans;
}