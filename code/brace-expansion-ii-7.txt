class Solution {
public:
    vector<string> braceExpansionII(string expression) {
        this->expression = expression;
        int n = expression.length();
        jump.resize(n);
        output.resize(n);
        stack<int> st;
        for (int i = 0; i < n; ++i) {
            char c = expression[i];
            if (c == '{') {
                st.push(i);
            } else if (c == '}') {
                int open = st.top();
                st.pop();
                jump[open] = i + 1;
                solve(open + 1, i - 1);
            } else {
                jump[i] = i + 1;
            }
        }
        auto ans = solve(0, n - 1);
        sort(ans.begin(), ans.end());
        return ans;
    }

    vector<string> solve(int st, int en) {
        unordered_set<string> res;
        vector<string> cur;
        for (int i = st; i <= en; i = jump[i]) {
            char c = expression[i];
            if (c == ',') {
                res.insert(cur.begin(), cur.end());
                cur.clear();
            } else {
                vector<string> data;
                assert(c != '}');
                if (c == '{') {
                    data = output[i + 1];
                } else {
                    data.push_back(string(1, c));
                }
				if (data.empty()) continue;
                if (cur.empty()) {
				    cur = data;
				}
                else {
                    vector<string> cur2;
                    for (const string& str1 : cur) {
                        for (const string& str2 : data) {
                            cur2.push_back(str1 + str2);
                        }
                    }
                    cur = cur2;
                }
            } 
        }
        res.insert(cur.begin(), cur.end());
        return output[st] = vector<string>(res.begin(), res.end());
    }
    vector<vector<string>> output;
    vector<int> jump;
    string expression;
};