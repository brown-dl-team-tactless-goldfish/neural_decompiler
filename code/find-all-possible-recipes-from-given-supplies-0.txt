/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
#define MAXH (27*26*26)
struct Node{
    char* s;
    int dirty;
    int idx;
    struct Node* next;
};

int makekey(char *s){
    int key = 0;
    int len = strlen(s);
    
    key += s[0] - 'a';
    if(len > 1)
        key = (key * 26) + (s[1]-'a');
    key = (key * 26) + strlen(s);
    
    return key;
}

bool cook(char* recipe, char *** ingredients, int* ingredientsColSize, struct Node** h) {
    struct Node* p;
    int key;
    bool res = false;
    int count = 0;
    int idx = -1;

    key = makekey(recipe);
    p = h[key];

    while(p){
        if(strcmp(p->s, recipe) == 0){
            if(p->dirty == 1)
                return true;
            if(p->dirty == -1 || p->dirty == 2)
                return false;
            idx = p->idx; // need to cook
            break;
        }
        p = p->next;
    }
    
    if(idx == -1){ //no recipes and supplies for this
        return false;
    }
    p->dirty = 2; // cooking: avoid deadlock

    for(int i = 0; i < ingredientsColSize[idx]; i++){
        count += cook(ingredients[idx][i], ingredients, ingredientsColSize, h);
    }
    if (count == ingredientsColSize[idx]){
        p->dirty = 1;
        return true;
    } else{ //fail to cook
        p->dirty = -1;
        return false;
    }
}

char ** findAllRecipes(char ** recipes, int recipesSize, char *** ingredients, int ingredientsSize, int* ingredientsColSize, char ** supplies, int suppliesSize, int* returnSize){
    struct Node** h;
    int count = 0;
    char** sol;
    
    h = calloc(sizeof(struct Node*), MAXH);
    sol = calloc(sizeof(char*), recipesSize);
    
    //fill hashmap
    for(int i = 0; i < suppliesSize; i++) {
        int key = 0;
        struct Node* p;
        p = malloc(sizeof(struct Node));
        key = makekey(supplies[i]);
        p->next = h[key];
        p->s = supplies[i];
        p->idx = -1; //not recipes
        p->dirty = 1; //available;
        h[key] = p;        
    }
    
    for(int i = 0; i < recipesSize; i++){
        int key = 0;
        struct Node* p;
        p = calloc(sizeof(struct Node), 1);
        key = makekey(recipes[i]);
        p->next = h[key];
        p->s = recipes[i];
        p->idx = i;
        p->dirty = 0; //unknown;
        h[key] = p;           
    }
    
    for(int i = 0; i < recipesSize; i++){

        bool flag = false;
        flag = cook(recipes[i], ingredients, ingredientsColSize, h);
        if(flag) {
            sol[count++] = recipes[i];
        }  
    }
    *returnSize = count;
    free(h);
    return sol;
}