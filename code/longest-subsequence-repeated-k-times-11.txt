class Solution {
    using histo_t = std::array<int, 26>;
public:
    string longestSubsequenceRepeatedK(string s, int k) {
        histo_t histo;
        histo.fill(0);
        for (char ch : s) {
            ++histo[static_cast<int>(ch - 'a')];
        }
		
		// Remove characters with less than `k` counts.
        std::stringstream ss;
        for (char ch : s) {
            if (histo[static_cast<int>(ch - 'a')] >= k) {
                ss << ch;
            }         
        }
        std::string target = ss.str();     
        
        if (target.empty()) {
            return "";
        }
  
        Context ctx{.k = k, .target = target};
        std::string patt;
        find(ctx, patt, 0);
        return ctx.res;
    }
private:
    struct Context {
        const int k;
        const std::string &target;
        std::string res;
        std::unordered_set<std::string> visited;
        
        void update(const std::string &text) {
            if (text.size() > res.size()) {
                res = text;
                return;
            } 
            if ((text.size() == res.size()) && (text > res)) {
                res = text;
                return;
            }
        }
    };
    
    static constexpr int MAX_PATT_SIZE = 8;
    
	// Grow a pattern and try if there's a k-repeated match.
    void find(Context &ctx, std::string &patt, const int pos) {
        if (pos >= ctx.target.size()) {
            return;
        }       
        if (patt.size() > MAX_PATT_SIZE) {
            return;
        }
                
		// Add a new char to the pattern and update cache.
        patt.push_back(ctx.target[pos]);
        if (ctx.visited.count(patt) == 0) {
            ctx.visited.insert(patt);
			// See if there are `k - 1` reps from `pos + 1` in the target string.
            if (check_match(ctx, patt, pos + 1)) {
                ctx.update(patt);
                find(ctx, patt, pos + 1);
            }
        }
        patt.pop_back();
        
		// Don't add this char to the pattern. 
        find(ctx, patt, pos + 1);
    }
    
    bool check_match(Context &ctx, const std::string &patt, const int pos) {
        int reps = 1;
        int idx = 0;
        for (int i = pos; i < ctx.target.size(); ++i) {
            if (patt[idx] != ctx.target[i]) {
                continue;
            }
            if (++idx == patt.size()) {
                idx = 0;
                if (++reps == ctx.k) {
                    return true;
                }
            }
        }
        return false;
    }
};