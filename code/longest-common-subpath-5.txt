ll base, MOD;
vector<ll> p;
bool isValid(ll len,vector<vector<int>>& paths,ll m){
    unordered_set<ll> s;
    for(ll i=0;i<m;i++){
         if(paths[i].size()<len){
            return false;
         }
         unordered_set<ll> ss;
         ll hash=0;
        for(ll j=0;j<len;j++){  // just consider hash = 2 and we want to make 2345 how we can do? 
            hash = (hash + ((ll)paths[i][j])*p[len-1-j]%MOD)%MOD;  // 2*pow(10,3)+3*pow(10,2)+4*pow(10,1)+5*pow(10,0)
        }
        if(i==0) s.insert(hash);
        else{
            if(s.find(hash)!=s.end()) ss.insert(hash);
        }
        
        for(ll j=len;j<paths[i].size();j++){//let hash=314(len=3) and we want to make 145 by excluding 3(start) and add 5(end)
            hash = (hash + MOD - ((ll)paths[i][j-len])*p[len-1]%MOD)%MOD; // 314 - 3*pow(10,len-1) = 14
            hash = ((ll)hash*base)%MOD;  // hash = 14*10 = 140 
            hash = (hash + (ll)paths[i][j])%MOD;  // hash = 140 + 5 = 145
            if(i==0) s.insert(hash);
             else{
                if(s.find(hash)!=s.end()) ss.insert(hash);
             }
        }
        if(i>0) s=ss;
        if(s.size()==0) return false;
    }
    return s.size()>0;
}
int longestCommonSubpath(int n, vector<vector<int>>& paths) {
    ll l=0, r=1e9L, m=paths.size();
    base=100007, MOD=1e11L+7;
    for(ll i=0; i<m; i++){
        r=min(r, (ll)paths[i].size());
    }
    p=vector<ll>(r);
    p[0]=1;
    for(ll i=1; i<r; i++){
        p[i]=(ll)base*p[i-1]%MOD;
    }
    while(l<r){
        ll mid=(l+r+1)/2;
        if(isValid(mid, paths, m)){
            l=mid;
        }
        else{
            r=mid-1;
        }
    }
    return r;
}