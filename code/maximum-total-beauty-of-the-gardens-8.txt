typedef long long ll;

long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {
    
    ll n=flowers.size();
    
    sort(flowers.begin(),flowers.end());
    
    vector<ll>prefix(n,0LL);
    
    prefix[0]=flowers[0];
    
    for(ll i=1;i<n;i++){
        prefix[i]=prefix[i-1]+(ll)flowers[i];
    }
    
    
    ll max_beauty=0LL;
    
    // Travrese from the end of the array as discussed previously.......
    
    // Check Whether we can make full flowers from index n-1 to index i [ if not then break ]
    
    // There is one additional corner case --> Sometimes it will be optimal that we'll select 0 number of full flowers and try to maximize the partial_beauty using newFlowers.
    
    
    for(ll i=n;i>=0;i--){
        
        if(i==n){
            
            
        }
    
        else{
            
            ll req_for_full=max(0LL,(ll)(target-flowers[i]));
            
            if(req_for_full > newFlowers){
                break;
            }
            
            newFlowers-=req_for_full; 
            
            flowers.pop_back();  // This the line where your code fails even after it is correct logically , as there is some situation when number of full flowers and number of partial flowers can collide and it increase our answer than the actual one . Try the Example TestCase 2 by your own.
            
        }
        
        
        ll curr_beauty_full=((n-i)*full);
        
        ll curr_beauty_partial=0LL;
        
        ll low=0,high=target-1;
        
        while(low<=high){
            
            ll mid=(low+high)/2;
            
            ll idx=upper_bound(flowers.begin(),flowers.end(),mid)-flowers.begin();
            
            if(idx==0){
                
                low=mid+1;
                
            }
            
            else{
                
                ll have_flowers=prefix[idx-1];
                
                ll req_flowers=(idx*mid);
                
                ll extra_flowers=(req_flowers-have_flowers);
                
                if(extra_flowers<=newFlowers){
                    
                    curr_beauty_partial=(mid*partial);
                    
                    low=mid+1;
                    
                }
                
                else{
                    
                    high=mid-1;
                    
                }
                
            }
            
        }
        
        max_beauty=max(max_beauty,curr_beauty_partial+curr_beauty_full);
        
    }
    
    return max_beauty;
    
}