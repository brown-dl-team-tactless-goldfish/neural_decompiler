class Solution {
public:
    bool works(vector<int> &plantTime, vector<int> &growTime, int k){
        vector<long> v;
        for(long i = 0; i < growTime.size(); i ++){
            v.push_back((i << 32) | (k - growTime[i]));
        }
        auto c = [](int l, int r){
            return l < r;  
        };
        sort(v.begin(), v.end(), c);   // This can be optimized such that we only sort once. Then the algorithm would be decreased by a factor of lgN
        int time = 0;
        bool valid = true;
        for(int i = 0; i < v.size(); i ++){
            int index = v[i] >> 32;
            time += plantTime[index];
            if(time > (int)v[i]){
                valid = false;
                break;
            }
        }
        return valid;
    }
    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {
        int low = INT_MIN;
        int high = 0;
        int maxGrow = INT_MIN;
        for(int i = 0; i < plantTime.size(); i ++){
            high += plantTime[i];
            maxGrow = max(maxGrow, growTime[i]);
            low = max(low, plantTime[i] + growTime[i]);
        }
        high += maxGrow;
        int res = INT_MAX;
        while(low < high){
            int k = (high + low)/2;
            if(low + 1 == high){
                if(works(plantTime, growTime, low))return low;
                return high;
            }
            if(works(plantTime, growTime, k))
                high = k;
            else
                low = k;
        }
        return low;
    }
};