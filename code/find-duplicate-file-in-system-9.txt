vector<vector<string>> findDuplicate(vector<string>& paths) {
    int n = paths.size();
    if(n == 0){
        return {};
    }
    
	
    unordered_map<string, vector<string>> mp;
    vector<vector<string> > ans;
    
    for(int i=0; i<n; i++){
        string file = paths[i];
        
		//use string stream to tokenizing the string at the spaces
        stringstream ss(file);
        string word;
        int k=0;
        string path = "/";
        
        while(getline(ss, word, ' ')){
		//the first word will always be the path to the file...and we'll do a little formatting according to the given output format
		//i.e at "/" at the end
            if(k == 0){
                path = word + path;
                k++;
            }
			//the preceeding elements will be the filenames followed by its contents
            else{
                int pos = 0;
                string fileName = "";
                string content = "";
                //store the file name and the file content 
                for(; pos  < word.length() && word[pos] != '('; pos++){
                    fileName += word[pos];
                }
                
                pos++;
                
                for(; pos < word.length() && word[pos] != ')'; pos++){
                    content += word[pos];
                }
                
				//add this filename with its path in the list for the respective content.
                string temp = path + fileName;
                mp[content].push_back(temp);
            }
        }
    }
    
    for(auto itr: mp){
        
		//if the list has more than twl paths (dulicate) then store the list to our answer
        if(itr.second.size() > 1){
            ans.push_back(itr.second);
        }
    }
    
    return ans;
}