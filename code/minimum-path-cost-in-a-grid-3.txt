class Solution {
public:
    using tp = tuple<int,int,int>;
    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {
        // min heap for the cost
        priority_queue<tp,vector<tp>,greater<tp>> pq;
        int r = grid.size();
        int c = grid[0].size();
        
        vector<vector<int>> visited(r,vector<int>(c,INT_MAX));
        
        for (int j = 0; j < c; j++) {
            pq.push({grid[0][j],0,j});
            visited[0][j] = grid[0][j];
        }
        
        while(!pq.empty()) {
            auto [cost,x,y] = pq.top();
            pq.pop();
            if (x == r-1)
                return cost;
            if (cost < visited[x][y])
                continue;
            for (int k = 0; k < c; k++) {
                int nc = cost + moveCost[grid[x][y]][k]  + grid[x+1][k];
                if (nc > visited[x+1][k]) {
                    continue;
                }
                visited[x+1][k] = nc;
                pq.push({nc,x+1,k});
            }
        }
        return -1;
    }
};