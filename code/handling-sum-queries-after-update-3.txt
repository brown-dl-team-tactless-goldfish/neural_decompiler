#define ll long long
class LST {
public:
 vector<ll>seg, lazy;
 LST(ll n) {
  seg.resize(4 * n + 1);
  lazy.resize(4 * n + 1);
 }

 void build(ll ind, ll low, ll high, vector<ll>&arr) {
  if (low == high) {
   seg[ind] = arr[low];
   return;
  }
  ll mid = (low + high) / 2;
  build(2 * ind + 1, low, mid, arr);
  build(2 * ind + 2, mid + 1, high, arr);
  seg[ind] = seg[2 * ind + 1] + seg[2 * ind + 2];
 }

 ll query(ll ind, ll low, ll high, ll l, ll r) {
  //update if there are any update remaining
  // as the node will stay fresh and updated

  if (lazy[ind] != 0) {
   seg[ind] = (high - low + 1) - seg[ind];
   //propogate the lazy updates downwards
   // for the remaining elements
   if (low != high)
   {
	lazy[2 * ind + 1] += lazy[ind];
	lazy[2 * ind + 2] += lazy[ind];
   }
   lazy[ind] = 0;
  }

  //no overlap
  // l r low high or low high l r
  if (r < low || high < l) {
   return 0;
  }
  //complete overlap
  // l low high r
  if (low >= l && high <= r) {
   return seg[ind];
  }
  ll mid = (low + high) >> 1;
  ll left = query(2 * ind + 1, low, mid, l, r);
  ll right = query(2 * ind + 2, mid + 1, high, l, r);
  return left + right;
 }
 void update(ll ind, ll low, ll high, ll l, ll r) {
  //update the previous remaining updates
  // and propogate downwards
  if (lazy[ind] != 0) {
   seg[ind] = (high - low + 1) - seg[ind];
   //propogate the lazy updates downwards
   // for the remaining elements
   if (low != high)
   {
	lazy[2 * ind + 1] = !lazy[2 * ind + 1];
	lazy[2 * ind + 2] = !lazy[2 * ind + 2];
   }
   lazy[ind] = 0;
  }
  //no overllap
  // we dont do anything and return
  // low high l r or l r low high
  if (high < l or r < low) {
   return;
  }
  // complete overralp
  //l low high r
  if (low >= l && high <= r) {
   seg[ind] = (high - low + 1) - seg[ind];
   if (low != high) {
	lazy[2 * ind + 1] = !lazy[2 * ind + 1];
	lazy[2 * ind + 2] = !lazy[2 * ind + 2];
   }
   return;
  }

  //last case has to be partial overlap
  ll mid = (low + high) / 2;
  update(2 * ind + 1, low, mid, l, r);
  update(2 * ind + 2, mid + 1, high, l, r);
  seg[ind] = (seg[2 * ind + 1] + seg[2 * ind + 2]);



 }
};
class Solution {
 public:
  vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {
   vector<long long> res;
			int n= nums1.size();
   long long ans=0;
   for(int i:nums2) ans+=i;
			LST sg1(n);
			vector<ll>arr;
			// arr.push_back(0);
			for(auto it:nums1)
				arr.push_back(it);
		 sg1.build(0, 0, n-1, arr);
			for(auto it:queries){
				if(it[0]==3)
					res.push_back(ans);
				else if(it[0]==1){
					sg1.update(0, 0, n-1, it[1], it[2]);
				}
				else{
					ans+=sg1.query(0, 0, n-1, 0, n-1)*it[1];
				}
			}
			return res;

  }
};