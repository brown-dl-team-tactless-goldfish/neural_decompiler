class Solution {
public:
    int minimumEffortPath(vector<vector<int>>& heights) {
        const int Nr = heights.size();
        const int Nc = heights[0].size();
        vector<vector<int>> minEff(Nr, vector<int>(Nc, INT_MAX));
        queue<pair<int, int>> q;
        queue<pair<int, int>> nextq;
        
        q.push(make_pair(0,0));
        minEff[0][0] = 0;
        while (not q.empty()) {
            const int r = q.front().first;
            const int c = q.front().second;
            q.pop();
			// Left neighbor
            if (r > 0) {
                const int goLeftEff = max(minEff[r][c], abs(heights[r][c] - heights[r-1][c]));
                if (goLeftEff < minEff[r-1][c]) {
                    minEff[r-1][c] = goLeftEff;
                    nextq.push(make_pair(r-1, c));
                }
            } 
			// Right neighbor
            if (r < Nr-1) {
                const int goRightEff = max(minEff[r][c], abs(heights[r][c] - heights[r+1][c]));
                if (goRightEff < minEff[r+1][c]) {
                    minEff[r+1][c] = goRightEff;
                    nextq.push(make_pair(r+1, c));
                }
            }
            // Down neighbor
            if (c > 0) {
                const int goDownEff = max(minEff[r][c], abs(heights[r][c] - heights[r][c-1]));
                if (goDownEff < minEff[r][c-1]) {
                    minEff[r][c-1] = goDownEff;
                    nextq.push(make_pair(r, c-1));
                }
            }
            // Up neighbor
            if (c < Nc-1) {
                const int goUpEff = max(minEff[r][c], abs(heights[r][c] - heights[r][c+1]));
                if (goUpEff < minEff[r][c+1]) {
                    minEff[r][c+1] = goUpEff;
                    nextq.push(make_pair(r, c+1));
                }
            }
            
            if (q.empty()) {
                q.swap(nextq);
            }
        }
        
        return minEff[Nr-1][Nc-1];
    }
};