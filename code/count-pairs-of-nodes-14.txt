using cd = complex<double>;
const double PI = acos(-1);

class Solution {
public:
    void fft(vector<cd> & a, bool invert) {
        int n = a.size();
        if (n == 1)
            return;

        vector<cd> a0(n / 2), a1(n / 2);
        for (int i = 0; 2 * i < n; i++) {
            a0[i] = a[2*i];
            a1[i] = a[2*i+1];
        }
        fft(a0, invert);
        fft(a1, invert);

        double ang = 2 * PI / n * (invert ? -1 : 1);
        cd w(1), wn(cos(ang), sin(ang));
        for (int i = 0; 2 * i < n; i++) {
            a[i] = a0[i] + w * a1[i];
            a[i + n/2] = a0[i] - w * a1[i];
            if (invert) {
                a[i] /= 2;
                a[i + n/2] /= 2;
            }
            w *= wn;
        }
    }

    vector<int> multiply(vector<int> const& a, vector<int> const& b) {
        vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());
        int n = 1;
        while (n < a.size() + b.size()) 
            n <<= 1;
        fa.resize(n);
        fb.resize(n);

        fft(fa, false);
        fft(fb, false);
        for (int i = 0; i < n; i++)
            fa[i] *= fb[i];
        fft(fa, true);

        vector<int> result(n);
        for (int i = 0; i < n; i++)
            result[i] = round(fa[i].real());
        return result;
    }
    
    vector<int> countPairs(int n, vector<vector<int>>& edges, vector<int>& queries) {
        
        vector<int> ans;
        int deg[n];
        for(int i = 0; i < n; i++) deg[i] = 0;

        for(int i = 0; i < edges.size(); i++) if(edges[i][0] > edges[i][1]) swap(edges[i][0], edges[i][1]);
        sort(edges.begin(), edges.end());
        
        for(int i = 0; i < edges.size(); i++){
            int u = edges[i][0]-1, v = edges[i][1]-1;
            deg[u]++;deg[v]++;
        }
        
        vector<int> v1, v2;
        for(int i = 0; i <= edges.size(); i++){
            v1.push_back(0);v2.push_back(0);
        }
        for(int i = 0; i < n; i++){
            v1[deg[i]]++;v2[deg[i]]++;
        }
        vector<int> res = multiply(v1, v2);
        for(int i = 0; i < n; i++) res[deg[i]*2]--; //Remove self-pair
        
        int cnt[edges.size()*2+100];
        for(int i = 0; i < min(res.size(), 2*edges.size()+100); i++) cnt[i] = res[i]/2; //Remove duplicate pairs
		
        int tem = 0;
        for(int i = 0; i < edges.size(); i++){
            tem++;
            if(i == edges.size()-1 || edges[i][0] != edges[i+1][0] ||edges[i][1] != edges[i+1][1] ){
                int u = edges[i][0]-1, v = edges[i][1]-1;
                int ori = deg[u] + deg[v];
                cnt[ori]--;
                cnt[ori-tem]++;
                tem = 0;
            }
        }
        
        for(int i = edges.size(); i >= 0; i--) cnt[i] += cnt[i+1];
        for(int i = 0; i < queries.size(); i++) ans.push_back(cnt[queries[i]+1]);
        
        return ans;
    }
};