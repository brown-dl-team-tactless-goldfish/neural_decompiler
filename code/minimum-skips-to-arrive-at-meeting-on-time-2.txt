class Solution {
public:
    int minSkips(vector<int>& dist, int speed, int hoursBefore) {
        int n = dist.size();

        // Translate to type 'long' to avoid accuracy problem in 'double'
        vector<long> dist2(begin(dist), end(dist));
        for (int i = 0; i < n; ++i) {
            dist2[i] *= speed;
        }

        return minSkips(dist2, speed, 1L * hoursBefore * speed);
    }

    int minSkips(vector<long>& dist, long speed, long hoursBefore) {
        int n = dist.size();

        // dp(i,j) [0,i] must rest j times, minimal time. We only create n - 1 rows because the last road is special:
        // it definitely does not need to rest. All roads with index <= n - 2 might rest.
        vector<vector<long>> dp(n - 1, vector<long>(n, 0));
        // One type of border case: zero rest
        for (int i = 0; i < n - 1; ++i) {
            dp[i][0] = (i ? dp[i - 1][0] : 0) + dist[i] / speed;
        }
        // Another type of border case: must rest after each road
        for (int i = 0; i < n - 1; ++i) {
            dp[i][i + 1] = (i ? dp[i - 1][i] : 0) + roundUp(dist[i] / speed, speed);
        }
        // The state transfer function is: dp[i][j] has two sub-problems: 1st, after taking road i, we do not rest;
        // 2nd, after taking road i, we rest. For the 1st, dp[i][j] = dp[i - 1][j] + dist[i] / speed; 2nd, dp[i][j] =
        // roundUp(dp[i - 1][j - 1] + dist[i] / speed)
        for (int i = 1; i < n - 1; ++i) {
            for (int j = 1; j <= i; ++j) {
                long candidate1 = dp[i - 1][j] + dist[i] / speed;
                long candidate2 = roundUp(dp[i - 1][j - 1] + dist[i] / speed, speed);
                dp[i][j] = min(candidate1, candidate2);
            }
        }
        // We have calculated all possible cases in [0, n - 2], which includes rest 0 times, rest 1 times, etc. When
        // considering the last road (the (n-1)-th road), we just append the last road to each of them. The more rest
        // we take, the longer time we reach the office. The less rest we take, the opposite. So it satisfies the
        // binary search property, but we did not use the binary search. Instead, we just iterate all.
        int ans = -1;
        for (int j = n - 1; j >= 0; --j) {
            if (dp[n - 2][j] + dist[n - 1] / speed <= hoursBefore) {
                ans = n - 1 - j;
                break;
            }
        }
        return ans;
    }

private:
    long roundUp(long num, long speed) {
        long r = num % speed;
        return r ? num + (speed - r) : num;
    }
};