/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
typedef struct edge{
    int key;
    int size;
    int* data;
}Edge;

int findFirst(int** adjacentPairs, int adjacentPairsSize, Edge** hash, int N, int* neighbor){
    int val, d;
    for(int i = 0; i < adjacentPairsSize; i++){
        val = adjacentPairs[i][0];
        d = abs(val);
        while(1){
            if(hash[d%N]->key == val)
                if(hash[d%N]->size == 1){
                    *neighbor = hash[d%N]->data[0]; 
                    return val;
                }
                else
                    break;
            else
                d++;
            
        }
        val = adjacentPairs[i][1];
        d = abs(val);
        while(1){
            if(hash[d%N]->key == val)
                if(hash[d%N]->size == 1){
                    *neighbor = hash[d%N]->data[0]; 
                    return val;
                }
                else
                    break;
            else
                d++;
        }
    }
    return INT_MAX;
}

void findNext(int** adjacentPairs, int adjacentPairsSize, Edge** hash, int N, int ptr, int* one, int* two){
    int d = abs(ptr);
    while(1){
        if(hash[d%N]->key == ptr){
            *one = hash[d%N]->data[0]; 
            *two = hash[d%N]->data[1]; 
            return;
        }
        else
            d++;            
    }
}


int* restoreArray(int** adjacentPairs, int adjacentPairsSize, int* adjacentPairsColSize, int* returnSize){
    int n = adjacentPairsSize + 1;
    int N = 10 * n; 
    Edge** hash = calloc(N , sizeof(Edge*));
    for(int i = 0; i < adjacentPairsSize; i++){
        int a = adjacentPairs[i][0];
        int b = adjacentPairs[i][1];
        int val = a;
        int d = abs(val);
        
        while(1){
            if(hash[d % N] == NULL){
                hash[d%N] = malloc(sizeof(Edge));
                hash[d%N]->data = malloc(2 * sizeof(int));
                hash[d%N]->key = val;
                hash[d%N]->size = 1;
                hash[d%N]->data[0] = b; 
                break;
            }
            else if(hash[d % N]->key == val){
                hash[d%N]->size = 2;
                hash[d%N]->data[1] = b;
                break;
            }
            else
                d++;
        }
        
        //------------------
         val = b;
         d = abs(val);
        while(1){
            if(hash[d % N] == NULL){
                hash[d%N] = malloc(sizeof(Edge));
                hash[d%N]->data = malloc(2 * sizeof(int));
                hash[d%N]->key = val;
                hash[d%N]->size = 1;
                hash[d%N]->data[0] = a; 
                break;
            }
            else if(hash[d % N]->key == val){
                hash[d%N]->size = 2;
                hash[d%N]->data[1] = a;
                break;
            }
            else
                d++;
        }        
    }
    
    //find first
    int neighbor;
    int first = findFirst(adjacentPairs, adjacentPairsSize, hash, N, &neighbor);

    int* ans = malloc(n * sizeof(int));
    *returnSize =  n;
    ans[0] = first;
    ans[1] = neighbor;
    int ptr = neighbor;
    int a, b;
    for(int i = 2; i < n; i++){
        findNext(adjacentPairs, adjacentPairsSize, hash, N, ptr, &a, &b);
        if(ans[i-2] == a)
            ans[i] = b;
        else
            ans[i] = a;
        ptr = ans[i];
    }
    
    for(int i = 0; i < N; i++){
        if(hash[i] != NULL){
            free(hash[i]->data);
            free(hash[i]);
        }
    }
    free(hash);
    return ans;
}