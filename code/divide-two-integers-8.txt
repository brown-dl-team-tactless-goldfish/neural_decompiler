#define NEGATIVE -1
#define POSITIVE 1
#define HALF_MAX 1073741823

int divide(int dividend, int divisor) {
    // edge cases
    if (dividend == divisor) return 1;
    if (dividend == 0 || divisor == INT_MIN) return 0;

    int sign = dividend > 0 ? (divisor > 0 ? POSITIVE : NEGATIVE) : (divisor > 0 ? NEGATIVE : POSITIVE);
    int result = 0;

    // edge cases/setup
    if (dividend == INT_MIN) {
        if (divisor == INT_MAX) return sign;
        if (divisor == -1) return INT_MAX;
        if (divisor == 1) return INT_MIN;

        // increase INT_MIN before flipping sign
        divisor = abs(divisor);
        dividend += divisor;
        dividend = -dividend;
        ++result;

    } else {
        dividend = abs(dividend);
        divisor = abs(divisor);
        if (dividend == divisor) return sign;
        if (divisor == 1) return sign == POSITIVE ? dividend : -dividend;
    }

    // speed up trick, divisor exponential scaling
    for (int remaining = dividend; remaining >= divisor;) {
        if (divisor <= HALF_MAX && divisor + divisor <= remaining) {
            int scaledDivisor = divisor + divisor;
            int multiple = 2;
            for (; scaledDivisor <= HALF_MAX && scaledDivisor + scaledDivisor < remaining; scaledDivisor += scaledDivisor, multiple += multiple);
            remaining -= scaledDivisor;
            result += multiple;
        } else {
            remaining -= divisor;
            ++result;
        }
    }
    return sign == POSITIVE ? result : -result;
}
