public class Solution
{
    public int GetLengthOfOptimalCompression(string s, int k)
    {
        if (string.IsNullOrEmpty(s))
        {
            return 0;
        }
        if (s.Length <= k)
        {
            return 0;
        }
        if (s.Length == k + 1)
        {
            return 1;
        }
        
		// pre-calculate run lengths
        var lasts = new int[s.Length];
        for (int i = 0; i < s.Length; )
        {
            char c = s[i];
            int j = i;
            while (j+1 < s.Length && s[j+1] == c)
            {
                j++;
            }
            lasts[i] = j;
            i = j+1;
        }
        
        var memo = new Dictionary<int, int>();
        
        int f(char prevChar, int prevCount, int first, int remain)
        {
            int key =
                (((int)prevChar) << 24) |
                (prevCount << 16) |
                (first << 8) |
                (remain << 0);
            int res;
            if (memo.TryGetValue(key, out res))
            {
                return res;
            }
            
            // no more characters to consume
            if (first == s.Length)
            {
                return Len(prevChar, prevCount);
            }
            
            // lookup run length from pre-calculated table
            char c = s[first];
            int last = lasts[first];
            int count = last - first + 1;
            
            // delete none, same as last character
            if (prevChar == c)
            {
                res = f(prevChar, prevCount + count, last + 1, remain);
            }
            // delete none, different than last character
            else
            {
                res = f(c, count, last + 1, remain) + Len(prevChar, prevCount);
            }
            
            // delete all if possible
            if (count <= remain)
            {
                // delete all
                res = Math.Min(res, f(prevChar, prevCount, last + 1, remain - count));
            }
            // delete as many as we can
            else if (remain > 0)
            {
                // same as last character
                if (prevChar == c)
                {
                    res = Math.Min(res, f(prevChar, prevCount + count - remain, last + 1, 0));
                }
                // different than last character
                else
                {
                    res = Math.Min(res, f(c, count - remain, last + 1, 0) + Len(prevChar, prevCount));
                }
            }
            
            memo[key] = res;
            return res;
        }
        
        return f('\0', 0, 0, k);
    }
    
    // utility function to get the length a characters/count requires as a string
    int Len(char c, int count)
    {
        if (c == '\0')
        {
            return 0;
        }
        int len = 1; // letter
        if (count != 1)
        {
            for (int temp = count; temp > 0; temp /= 10)
            {
                len++;
            }
        }
        return len;
    }
}