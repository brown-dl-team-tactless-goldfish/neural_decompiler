/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */


void merge(int arr[], int l, int m, int r)
{
    int i, j, k;
    int n1 = m - l + 1;
    int n2 = r - m;
 
    /* create temp arrays */
    int L[n1], R[n2];
 
    /* Copy data to temp arrays L[] and R[] */
    for (i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];
 
    /* Merge the temp arrays back into arr[l..r]*/
    i = 0; // Initial index of first subarray
    j = 0; // Initial index of second subarray
    k = l; // Initial index of merged subarray
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        }
        else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
 
    /* Copy the remaining elements of L[], if there
    are any */
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
 
    /* Copy the remaining elements of R[], if there
    are any */
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}
 
/* l is for left index and r is right index of the
sub-array of arr to be sorted */
void mergeSort(int arr[], int l, int r)
{
    if (l < r) {
        // Same as (l+r)/2, but avoids overflow for
        // large l and h
        int m = l + (r - l) / 2;
 
        // Sort first and second halves
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
 
        merge(arr, l, m, r);
    }
}

int** diagonalSort(int** mat, int matSize, int* matColSize, int* returnSize, int** returnColumnSizes){
    
    *returnSize = matSize;
    (*returnColumnSizes) = (int*)malloc(sizeof(int)*matSize);
    
    for(int i=0;i<matSize;i++){
        (*returnColumnSizes)[i]=*matColSize;
    }       
    
    /*    
      A B C D
    a 3 3 1 1
    b 2 2 1 2
    --------------------------------------    
    ->(1,0)
    ->(0,0) (1,1)
    ->(0,1) (1,2)
    ->(0,2) (1,3)
    ->(0,3)
    --------------------------------------          
      A B C D
    a 2 1 1 1
    b 2 3 3 2
    */
    
    int i = 0;
    int j = 0;
    int BufferSize_i = 0;
    if(matSize > *matColSize)
        BufferSize_i = matSize;
    else
        BufferSize_i = *matColSize;
        
    int Buffer_ai[BufferSize_i];
    for(int k=0; k<BufferSize_i; k++)
        Buffer_ai[k] = 0;
    
    if(matSize < 2)
        return mat;
    
    /*    
    (2,0) (1,0) (0,0) (0,1) (0,2) (0,3) 
    */
    
    int RowIndex_i = 0;
    int ColIndex_i = 0;
    int Offset_i = 0;
    int NumDiagonalElement_i = 0;
    
    bool ReachEnd_b = false; 
    
    RowIndex_i = matSize-1;
    ColIndex_i = 0;
    
    // Iterate over all diagonal axis
    for(i=0; i<matSize+*matColSize-1; i++)
    {
        // Iterate until it reaches the end of a diagonal axis
        while(!ReachEnd_b)
        {
            // Save the elements in the diagonal axis into the Buffer array
            Buffer_ai[Offset_i] = mat[RowIndex_i+Offset_i][ColIndex_i+Offset_i];            
            Offset_i++;            
            
            // When it reaches the end, Sort the element in the Buffer array 
            if((RowIndex_i+Offset_i) >= matSize || (ColIndex_i+Offset_i) >= *matColSize)
            {
                mergeSort(Buffer_ai, 0, Offset_i-1); 
                NumDiagonalElement_i = Offset_i;
                Offset_i = 0;
                ReachEnd_b = true;
            }
        }          
        ReachEnd_b = false;
        
        // Save the sorted elements in the Buffer array back to the diagonal axis
        for(j=0; j<NumDiagonalElement_i; j++)
        {
            mat[RowIndex_i+Offset_i][ColIndex_i+Offset_i] = Buffer_ai[Offset_i]; 
            Offset_i++;
        }                        
        Offset_i = 0;
        
        // Find the starting point of a next diagonal axis  
        if(RowIndex_i != 0)
        {
            RowIndex_i--;
        }
        else
        {
            ColIndex_i++;
        }
    } 

    return mat;   
}