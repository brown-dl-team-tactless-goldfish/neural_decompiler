class Solution {
private:
    vector<int> dir{0,1,0,-1,0};
    int m{0};
    int n{0};
public:
    int cutOffTree(vector<vector<int>>& forest) {
        if(forest.empty() or forest[0].empty())
            return 0;
        vector<vector<int>>trees;
        m=forest.size();
        n=forest[0].size();
        for(int i=0;i<m;++i)
        {
            for(int j=0;j<n;++j)
            {
                if(forest[i][j]>1)
                {
                    trees.push_back({forest[i][j],i,j});
                }
            }
        }
        sort(trees.begin(),trees.end());
        int steps{0};
        int curRow=0;
        int curCol=0;
        for(size_t i=0;i<trees.size();++i)
        {
            int curSteps=getMinSteps(forest,curRow,curCol,trees[i][1],trees[i][2]);
            
            if(curSteps==-1)
            {
                return -1;
            }
            steps+=curSteps;
            curRow=trees[i][1];
            curCol=trees[i][2];
        }
        return steps;
    }
    
    int getMinSteps(vector<vector<int>>& forest,int sourceRow,int sourceCol, int targetRow,int targetCol)
    {
        if(sourceRow==targetRow and sourceCol==targetCol)
        {
            return 0;
        }
        queue<pair<int,int>>queue;
        queue.push(make_pair(sourceRow,sourceCol));
        vector<vector<int>>seen;
        seen.resize(m,vector<int>(n,0));
        seen[sourceRow][sourceCol]=1;
        int steps{0};
        while(!queue.empty())
        {
            int size=queue.size();
            steps++;
            for(size_t i=0;i<size;++i)
            {
                auto coord=queue.front();
                queue.pop();
                if(coord.first==targetRow and coord.second==targetCol)
                {
                    return steps-1;
                }
                for(int i=0;i<4;i++)
                {
                    int nextRow=coord.first+dir[i];
                    int nextCol=coord.second+dir[i+1];
                    if(nextRow>=0 and nextRow<m and nextCol>=0 and nextCol<n)
                    {
                        if(forest[nextRow][nextCol]>0 and !seen[nextRow][nextCol])
                        {
                            seen[nextRow][nextCol]=1;
                            queue.push(make_pair(nextRow,nextCol));
                        }
                    }
                }
            }
        }
        return -1;
    }
};


