/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
int countNode(struct ListNode* head){
    int d = 0 ;
    struct ListNode* tmp = head ;
    while(tmp){
        d++ ;
        tmp = tmp->next ;
    }
    return d ;
}
struct ListNode* swapNodes(struct ListNode* head, int k){
    int total = countNode(head) ;
    
    if(total == 1)
        return head ;
    
    if(total == 2){
        struct ListNode* tmp = head->next ;
        tmp->next = head ;
        head->next = NULL ;
        head = tmp ;
        return head ;
    }

    int p = total - k + 1 ;
    //find node1, ptr1, post1 
    int i = 1 ;
    struct ListNode* node1 = head ;
    struct ListNode* ptr1 = NULL ;
    struct ListNode* post1 = NULL ;
    while(i < k){
        ptr1 = node1 ;
        node1 = node1->next ;
        i++ ;
    }
    post1 = node1->next ;
    
    //find node2, ptr2, post2
    i = 1 ;
    struct ListNode* node2 = head ;
    struct ListNode* ptr2 = NULL ;
    struct ListNode* post2 = NULL ;
    while(i < p){
        ptr2 = node2 ;
        node2 = node2->next ;
        i++ ;
    }
    post2 = node2->next ;
    //if node1 == node2 , no need swap
    if(node1 == node2)
        return head ;
     
    //if node2 right after node1
    if( (p - k) == 1){
        ptr1->next = node2 ;
        node2->next = node1 ;
        node1->next = post2 ;
        return head ;
    }
    //if node1 right after node2
    if( (k - p) == 1){
        ptr2->next = node1 ;
        node1->next = node2 ;
        node2->next = post1 ;
        return head ;
    }
    //node1 is head
    if( k == 1){
        node2->next = post1 ;
        head = node2 ;
        ptr2->next = node1 ;
        node1->next = NULL ;
    }
    //node2 is head
    else if( k == total ){
        node1->next = post2 ;
        head = node1 ;
        ptr1->next = node2 ;
        node2->next = NULL ;
    }
    //other case, node1 and node2 int the middle of the list 
    else{
        ptr1->next = node2 ;
        node2->next = post1 ;
        ptr2->next = node1 ;
        node1->next = post2 ;
    }
    return head ;
}