class Solution {
public:
    // put index into sets
    void dfs(int index, int m, int csum, int & res, vector<int>& nums, vector<vector<int>> & sets) {
        if (csum > res) {
            return; // early terminate, if cost already over current best solution
        }
        if (index == nums.size()) { // all values from nums have been allocated, time to update final solution
            res = min(res, csum);
            return;
        }
        
        set<vector<int>> visited; 
		// we dont need to put nums[index] into the same set
		// For example, if current sets include [[0, 1], [0, 1]], we only need to update [[0, 1, 2] [0, 1]], 
		// no need to do [[0, 1][0,1, 2]]
        
        for (int i = 0; i < sets.size(); ++i) {
            if (visited.count(sets[i])) {
                continue;
            }
            visited.insert(sets[i]);

            if (sets[i].empty()) { // for empty set, we always put value inside, no change to total cost
                sets[i].push_back(nums[index]);
                dfs(index + 1, m, csum, res, nums, sets);
                sets[i].pop_back();
            } else {
                if (sets[i].back() >= nums[index] || sets[i].size() == m) { 
				    // every number must be larger than the previous one, this might be an optimization. Simplify difference
					// calculation and avoid duplicates.
                    continue;
                }
                int last = sets[i].back();
                int diff = (nums[index] - last); // increment to total incompatibility

                sets[i].push_back(nums[index]);
                dfs(index + 1, m, csum + diff, res, nums, sets);
                sets[i].pop_back();                
            }
        }
        
    }
    
    int minimumIncompatibility(vector<int>& nums, int k) {
        int n = nums.size(); // [1,n]
        vector<int> count(nums.size() + 1);
        int maxl = 0;
        for (int i: nums) {
            count[i]++;
            maxl = max(maxl, count[i]);
        }
        if (maxl > k) {
            return -1;
        }
        int m = n / k; // length for each
        vector<vector<int>> sets(k); // k empty sets
        sort(begin(nums), end(nums));
        int res = INT_MAX;
        
        dfs(0, m, 0, res, nums, sets);
        
        return res == INT_MAX ? -1 : res;
    }
};