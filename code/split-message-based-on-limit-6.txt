// First I thought of binary search , but realised soon , I can iterate over all the b's.
// Let's say answer is of size x , We know x-1 words will have length limit & last word should be <=limit
// Validate the last word , picking b greedily  :)
class Solution {
public:
    vector<string> splitMessage(string message, int limit) {
        int b = 0 , cnt = 0 , sm = 0;
        vector<string> ans;
        for(int i=1; i<=10000; i++) {
            sm+=Size(i);  // sum of length of ('1') + ('2')... ('i')  , we are calculating sum of length of all a's.
            int cnt = ((3 + Size(i)) * i) + message.size() + sm;   // sum of (3 is "</>"  + i's size ) * i times , message , sm 
            int len = (i-1) * limit; // till second last
            if(cnt - len <= limit) {  // if last is bigger than limit , its invalid!
                b = i;
                break;
            }
        }
        string s = "";
        cnt = 1;
        for(int i=0; i<message.size(); i++) {
              if(limit - (3 + Size(cnt) + Size(b) + (int)s.size())>0) {
                   s+=message[i];
              }else {
                   string word = s + "<" + to_string(cnt) + "/" + to_string(b) + ">";
                   ans.push_back(word);
                   s = message[i];
                   cnt++;
              }
        }
         string word = s + "<" + to_string(cnt) + "/" + to_string(b) + ">";
         ans.push_back(word);
         if(cnt>b || word.size()>limit) return {};   // cnt is last value of a , which should never be > than b , also last word size should be <= limit!
        return ans;
    }
    int Size(int n) {
         return to_string(n).size();
    }
};