/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> nodeIdx;
    vector<int> flips;
    int n = 0;
    vector<int> flipMatchVoyage(TreeNode* root, vector<int>& A) {
        n = A.size();
        nodeIdx.resize(n + 1, - 1);
        for (int i = 0; i < n; ++ i){
            nodeIdx[A[i]] = i;
        }
        int res = postOrder(root, A);
        if (res == -1 || n != res){
            return {-1};
        }
        return flips;
    }
    
    int postOrder(TreeNode* root, vector<int>& A){
        if (!root){
            return 0;
        }
        int l = postOrder(root->left, A);
        int r = postOrder(root->right, A);
        int idx = nodeIdx[root->val];
        if (root->left && !root->right){
            if (idx + 1 > n - 1 || A[idx + 1] != root->left->val){
                return -1;
            }
        }
        
        if (!root->left && root->right){
            if (idx + 1 > n - 1 || A[idx + 1] != root->right->val){
                return -1;
            }
        }
        
        if (root->left && root->right){
            if (idx + l + 1 > n - 1 || idx + r + 1 > n - 1){
                return -1;
            }
            if (A[idx + 1] == root->right->val && A[idx + r + 1] == root->left->val){
                flips.push_back(root->val);
            }
            else if (A[idx + 1] != root->left->val || A[idx + l + 1] != root->right->val){
                return -1;
            }
        }
        return l + r + 1;
    }
};