class Solution {
public:
    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {
        vector<vector<int>> minCost( grid.size(), vector<int>( grid[0].size(), INT_MAX ) );
        auto comparator = [&]( vector<int> &cell1, vector<int> &cell2 ){
            return minCost[cell1[0]][cell1[1]] > minCost[cell2[0]][cell2[1]];
        };
        priority_queue<vector<int>, vector<vector<int>>, decltype( comparator ) > pq( comparator );
        for( int i = 0; i < grid[0].size(); i++ ){
            minCost[0][i] = grid[0][i];
            pq.push( { 0, i } );
        }
        while( !pq.empty() ){
            auto cell = pq.top();
            pq.pop();
            int r = cell[0];
            int c = cell[1];
            if( r == grid.size()-1 ){
                return minCost[r][c];
            }
            int prevCellCost =  grid[r][c];   
            for( int i = 0; i < grid[0].size(); i++ ){
                int nextCost = minCost[r][c] + moveCost[prevCellCost][i] + grid[r+1][i];
                if( nextCost < minCost[r+1][i] ){
                    minCost[r+1][i] = nextCost;
                    pq.push( { r+1, i } );
                }
            }
        }
        return -1;
    }
};