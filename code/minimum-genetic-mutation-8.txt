struct GeneticRecord
{
    char cIndex;
    char cStep;

    struct GeneticRecord* pstNext;
};

int minMutation(char * start, char * end, char ** bank, int bankSize){
    if(bankSize == 0) return -1;
    if(bankSize == 1)
    {
        if(strcmp(*bank, end)) return -1;

        char cDiff = 0;
        while(*start)
        {
            if(*start != *end)
            {
                if(++cDiff > 1) return -1;
            }

            start++;
            end++;
        }

        return 1;
    }

    // check *start & *end first
    char cDiff = 0;
    for(char i=0; i<8; i++)
    {
        if(start[i] != end[i])
        {
            if(++cDiff > 1) break;
        }
    }

    char cBankSize = bankSize;
    if(cDiff <= 1)
    {
        for(char i=0; i<cBankSize; i++)
        {
            if(strcmp(end, bank[i]) == 0) return cDiff;
        }

        return -1;
    }

    // allocate aapDiffMem
    char** aapDiffMem = (char**) malloc(cBankSize*sizeof(char*));
    for(char i=1; i<cBankSize; i++)
    {
        aapDiffMem[i] = (char*) malloc(i*sizeof(char));
        memset(aapDiffMem[i], -1, i*sizeof(char));
    }

    // check end & all bank
    bool bHasEndInBank = false;
    char cIndex = cBankSize - 1;
    struct GeneticRecord* pstHead = NULL;
    struct GeneticRecord* pstTail = NULL;
    for(char i=0; i<cBankSize; i++)
    {
        // check cDiff
        char cDiff = 0;
        for(char j=0; j<8; j++)
        {
            if(end[j] != bank[i][j])
            {
                if(++cDiff > 1) break;
            }
        }

        if(cDiff == 0 && bHasEndInBank == false)
        {
            bHasEndInBank = true;
            if(cIndex != i)
            {
                for(char j=0; j<i; j++)
                {
                    aapDiffMem[i][j] = aapDiffMem[cIndex][j];
                    aapDiffMem[cIndex][j] = -1;
                }
                cIndex = i;
            }
        }
        else
        {
            if(i > cIndex)
            {
                aapDiffMem[i][cIndex] = cDiff;
            }
            else if(i < cIndex)
            {
                aapDiffMem[cIndex][i] = cDiff;
            }

            if(cDiff == 1)
            {
                if(pstTail)
                {
                    pstTail->pstNext = (struct GeneticRecord*) malloc(sizeof(struct GeneticRecord));
                    pstTail = pstTail->pstNext;
                }
                else
                {
                    pstTail = (struct GeneticRecord*) malloc(sizeof(struct GeneticRecord));
                    pstHead = pstTail;
                }

                pstTail->cIndex = i;
                pstTail->cStep = 1;
                pstTail->pstNext = NULL;
            }
        }
    }

    char cRet = -1;
    if(bHasEndInBank)
    {
        while(pstHead)
        {
            // check current bank and start
            cDiff = 0;
            for(char i=0; i<8; i++)
            {
                if(bank[pstHead->cIndex][i] != start[i])
                {
                    if(++cDiff > 1) break;
                }
            }

            // hit start
            if(cDiff == 1)
            {
                cRet = pstHead->cStep + 1;
                break;
            }

            // trace rest bank
            for(char i=0; i<cBankSize; i++)
            {
                // check already, skip
                if(i == pstHead->cIndex || i > pstHead->cIndex && aapDiffMem[i][pstHead->cIndex] >= 0 || i < pstHead->cIndex && aapDiffMem[pstHead->cIndex][i] >= 0) continue;

                // check cDiff
                cDiff = 0;
                for(char j=0; j<8; j++)
                {
                    if(bank[pstHead->cIndex][j] != bank[i][j])
                    {
                        if(++cDiff > 1) break;
                    }
                }

                if(i > cIndex)
                {
                    aapDiffMem[i][cIndex] = cDiff;
                }
                else
                {
                    aapDiffMem[cIndex][i] = cDiff;
                }

                if(cDiff == 1)
                {
                    if(pstTail->pstNext)
                    {
                        pstTail = pstTail->pstNext;
                    }
                    else
                    {
                        pstTail->pstNext = (struct GeneticRecord*) malloc(sizeof(struct GeneticRecord));
                        pstTail = pstTail->pstNext;
                        pstTail->pstNext = NULL;
                    }

                    pstTail->cIndex = i;
                    pstTail->cStep = pstHead->cStep + 1;
                }
            }        

            if(pstHead == pstTail) break;

            struct GeneticRecord* pstTmp = pstHead;
            pstHead = pstHead->pstNext;
            pstTmp->pstNext = pstTail->pstNext;
            pstTail->pstNext = pstTmp;
        }
    }

    // free memory
    for(char i=1; i<cBankSize; i++) free(aapDiffMem[i]);
    free(aapDiffMem);

    while(pstHead)
    {
        pstTail = pstHead;
        pstHead = pstHead->pstNext;
        free(pstTail);
    }

    return cRet;
}