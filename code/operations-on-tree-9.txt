class LockingTree {
public:
    map<int,int> map;
    vector<int> ans;
    vector<vector<int>> t;
    LockingTree(vector<int>& parent) {
        
        t.resize(parent.size());
        
        
        ans.resize(parent.size());
        ans[0] = -1;
        
        for(int i = 1; i < parent.size(); i++) {
            t[parent[i]].push_back(i);
            ans[i] = parent[i];
        }
        
        // for(int i = 0; i < ans.size(); i++) {
        //     cout<<ans[i]<<endl;
        // }
        
    }
    
    bool lock(int num, int user) {
        if(map.count(num)) return false;
        map[num] = user;
        return true;
    }
    
    bool unlock(int num, int user) {
        if(!map.count(num)) return false;
        if(map[num] != user) return false;
        map.erase(num);
        return 1;
    }
    
    bool upgrade(int num, int user) {
        if(map.count(num)) return false;
        if(!dfs(num)) {
            // cout<<"yes"<<endl;
            return false;
        }
        
        // cout<<"asd"<<endl;
        if(!check(num)) return false;
        
        
        dfs1(num);
        map[num] = user;
        return true;
        
    }
    
    bool dfs(int num) {
        if(t[num].size() == 0) return false;
        for(auto i : t[num]) {
            
            if(map.count(i)) {
                return true;
            }
            
            if(dfs(i)) return true;
            
        }
        
        return false;
        
    }
    
    void dfs1(int num) {
        for(auto i : t[num]) {
            map.erase(i);
            dfs1(i);
        }
    }
    
    bool check(int num) {
        while(num != -1) {
            num = ans[num];
            if(map.count(num)) return false;
        }
        
        return true;
        
    }
    
};

/**
 * Your LockingTree object will be instantiated and called as such:
 * LockingTree* obj = new LockingTree(parent);
 * bool param_1 = obj->lock(num,user);
 * bool param_2 = obj->unlock(num,user);
 * bool param_3 = obj->upgrade(num,user);
 */