/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


struct TreeNode* deleteNode(struct TreeNode* root, int key){
    //case1: if not find delete node return root.
    if(!root) return root;
    
    struct TreeNode* tmp=malloc(sizeof(struct TreeNode));
    
    if(root->val==key){
        //case2: if left child and right child both NULL delete node return NULL as root
        if(root->right == NULL && root->left == NULL){
            free(root);
            return NULL;
        //case3: if left child is NULL right child is not NULL, delete the root node,and the right child become root
        }else if(root->left == NULL){
            tmp=root->right;
            free(root);
            return tmp;
        //case4: if right child is NULL left child is not NULL, delete the root node,and the left child become root
        }else if(root->right == NULL){
            tmp=root->left;
            free(root);
            return tmp;
        //case5:if right child and left child neither NULL ,find the delete node's left subtree and put it in right subtree's leftest position, and return delete node's right child as new root
        }else{
            struct TreeNode* cur=root->right;
            while(cur->left != NULL){
                cur=cur->left;
            }
            cur->left=root->left;
            tmp=root;
            root=root->right;
            free(tmp);
            return root;
            
        }
    }
    if(root->val > key){
        root->left=deleteNode(root->left, key);
    } 
    if(root->val < key){
        root->right=deleteNode(root->right, key);
    } 
    return root;
}