class Solution {
public:
    const int dx[4] = {-1,0,1,0} ;
    const int dy[4] = {0,1,0,-1} ;
    
    int minimumObstacles(vector<vector<int>>& grid) {
        int r = grid.size() , c = grid[0].size() ;
        vector<vector<int>> dp(r,vector<int>(c,r*c)) ;
        
        queue<pair<int,int>>q ; q.push({0,0}) ; dp[0][0] = 0 ;
        while(q.size()){
            
            auto [i,j] = q.front() ; q.pop() ;
			//itr loop iterates for every direction up , right , down, left 
            for(int itr = 0 ; itr < 4 ; ++itr ){
                int ii = i + dx[itr] , jj = j + dy[itr] ;
                if(ii >= 0 and jj >= 0 and ii < r and jj < c){
                    if(dp[ii][jj] > dp[i][j] + (grid[ii][jj] == 1)){
					//if a better path is available only then explore it !
                        dp[ii][jj] = dp[i][j] + (grid[ii][jj] == 1) ;
                        q.push({ii,jj}) ;
                    }
                }
            }
            
        }
        
        return dp[r - 1][c - 1] ;
    }
};