typedef struct DSU{
    int* rank;
    int* root;
    int* setSize;//keep track of the size of each set
}DSU;
//create disjoint-set object
DSU* createDSU(int size){
    DSU* dsu = malloc(sizeof(DSU));
    dsu->rank = calloc(size, sizeof(int));
    dsu->root = malloc(size * sizeof(int));
    dsu->setSize = malloc(size * sizeof(int));
    for(int i = 0; i < size; i++){
        dsu->root[i] = i;
        dsu->setSize[i] = 1;
    }
    return dsu;
}
//find root of element
int find(int* root, int x){
    if(x == root[x])
        return x;
    return root[x] = find(root, root[x]);
}
//unite the roots of two sets
void setUnion(int* root, int* rank, int* setSize, int x, int y){
    int rootX = find(root, x);
    int rootY = find(root, y);
    if(rootX != rootY){
        if(rank[rootX] > rank[rootY]){
            root[rootY] = rootX;
            setSize[rootX] += setSize[rootY];
        }
        else if(rank[rootY] > rank[rootX]){
            root[rootX] = rootY;
            setSize[rootY] += setSize[rootX];
        }
        else{
            root[rootX] = rootY;
            rank[rootY]++;
            setSize[rootY] += setSize[rootX];
        }
    }
}
//free dsu object
void freeDSU(DSU* dsu, int size){
    free(dsu->root);
    free(dsu->rank);
    free(dsu);
}

long long countPairs(int n, int** edges, int edgesSize, int* edgesColSize){
    DSU* dsu = createDSU(n);
    int* root = dsu->root;
    int* rank = dsu->rank;
    int* setSize = dsu->setSize;
    //traverse all edges and unite sets.
    for(int i = 0; i < edgesSize; i++){
        int e1 = edges[i][0];
        int e2 = edges[i][1];
        setUnion(root, rank, setSize, e1, e2);
    }
    //for each node, add unreachable nodes to response variable
    long long res = 0;
    for(int i = 0; i < n; i++){
        res += n - setSize[find(root, i)];
    }
    freeDSU(dsu, n);
    return res / 2;
}