class Solution {
   public:
    bool placeWordInCrossword(vector<vector<char>>& board, string word) {
        for (auto _ : {1, 2}) {
            if (try_left2right(board, word.cbegin(), word.cend()) ||
                try_left2right(board, word.crbegin(), word.crend())) {
                return true;
            }
            transpose(board);
        }
        return false;
    }

    // O(mn)
    template <class It>
    bool try_left2right(const vector<vector<char>>& board,
                        const It sfirst,
                        const It slast) {
        return std::any_of(
            board.cbegin(),
            board.cend(),
            [this, sfirst, slast](const auto& line) {
                return placable(line.cbegin(), line.cend(), sfirst, slast);
            });
    }

    // O(last - first)
    template <class It>
    bool match(const vector<char>::const_iterator first,
               const vector<char>::const_iterator last,
               const It sfirst,
               const It slast) {
        return std::distance(first, last) == std::distance(sfirst, slast) &&
               std::equal(first, last, sfirst, [](char a, char b) {
                   return a == b || a == ' ';
               });
    }

    // O(last - first)
    template <class It>
    bool placable(const vector<char>::const_iterator first,
                  const vector<char>::const_iterator last,
                  const It sfirst,
                  const It slast) {
        if (std::distance(first, last) < std::distance(sfirst, slast)) {
            return false;
        }
        // core logic
        // [start, end) may be placable
        auto start = first;
        for (auto end = first; end != last; ++end) {
            if (*end == '#') {
                if (match(start, end, sfirst, slast)) {
                    return true;
                }
                start = end + 1;
            }
        }
        return match(start, last, sfirst, slast);
    }

    // O(mn)
    void transpose(vector<vector<char>>& board) {
        vector new_board(board[0].size(), vector(board.size(), ' '));
        for (int i = 0; i != board[0].size(); ++i) {
            for (int j = 0; j != board.size(); ++j) {
                new_board[i][j] = board[j][i];
            }
        }
        board = std::move(new_board);
    }
};