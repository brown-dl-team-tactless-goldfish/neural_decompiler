// use static memory so that it's a bit quicker
int gcd_value[14][14];
int cache[8][16384]; 

class Solution {
public:
    int n;
    int gcd(int a, int b) {
        while(a != b) {
            if(a > b) a = a - b;
            else b = b - a;
        }
        return a;
    }
    
	// c is the number of pairs we have yet to calculate
	// mask represents the numbers that had already been used
    int dfs(int c, int mask) {
        if (cache[c][mask]) return cache[c][mask];
        int r = -1;
        for(int i = 0; i < 2 * n; i++) {
            for(int j = i + 1; j < 2 * n; j++) {
                int mask_i = 1 << i;
                int mask_j = 1 << j;
				// If nums[i] and j are already used
                if((mask & mask_i) or (mask & mask_j)) continue;
                if(c == 1) {
                    r = c * gcd_value[i][j];
                    cache[c][mask] = r;
                    return r;
                } 
                r = max(r, dfs(c - 1, (mask | mask_i | mask_j)) + c * gcd_value[i][j]);
            }
        }
        cache[c][mask] = r;
        return r;
    }
    
    int maxScore(vector<int>& nums) {
        n = nums.size() / 2;
        memset(cache, 0, 8 * 16384 * sizeof(int));
        for(int i = 0; i < 2 * n; i++) {
            for(int j = i + 1; j < 2 * n; j++) {
                gcd_value[i][j] = gcd(nums[i], nums[j]);
            }
        }
        return dfs(n, 0);
    }
};