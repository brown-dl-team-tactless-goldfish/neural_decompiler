class Solution {
    vector<int> parents;
    int find_set(int v)
    {
        if(v == parents[v])
            return v;
        return parents[v] = find_set(parents[v]);
    }
    void union_set(int a, int b)
    {
        a = find_set(a);
        b = find_set(b);
        if(a == b)
            return;
        parents[a] = b;
        return;
    }
public:
    int minimumHammingDistance(vector<int>& source, vector<int>& target, vector<vector<int>>& allowedSwaps) 
    {
        int n = source.size();
        for(int i = 0; i < n; i++)
            parents.push_back(i);
        for(vector<int> &v : allowedSwaps)
        { 
            if(v[0] == v[1])
                continue;
            if(v[0] < v[1])
                union_set(v[0], v[1]);
            else
                union_set(v[1], v[0]);
        }
        vector<int> vp[n];
        vector<int> trg[n];
        for(int i = 0; i < n; i++)
        {
            int x = find_set(i);
            vp[x].push_back(source[i]);
            trg[x].push_back(target[i]);
        }
        int ans = 0;
        for(int i = 0; i < n; i++)
        {
            if(vp[i].size() == 0)
                continue;
            unordered_map<int, int> um;
            for(int j = 0; j < vp[i].size(); j++)
                um[vp[i][j]]++;
            for(int j = 0; j < trg[i].size(); j++)
            {
                if(um.count(trg[i][j]))
                {
                    if(um[trg[i][j]] == 1)
                        um.erase(trg[i][j]);
                    else
                        um[trg[i][j]]--;
                }
                else
                    ans++;
            }
        }
        return ans;
    }
};