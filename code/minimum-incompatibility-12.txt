int find(int i, int j, vector<int> &nums, int n, int k, vector<vector<int> >&dp) {
    
    int setBits = 0;
    int temp = i;
    while (temp > 0) {
        if (temp % 2 != 0)
            setBits ++;
        temp = temp/2;
    }
    
    if (setBits == n)
    {
        return 0;
    }

    
    if( j >= n)
        return INT_MAX;
    
    if(dp[i][j] != -1)
        return dp[i][j];
    
    int ans = INT_MAX;
    int x = j;
    
    int numberOfElementsInCurrentSubset = setBits % (n/k) ;
    while (x < nums.size()) {
        
        if ( (i & (1 << x)) != 0) {
            x++;
            continue;
        }
        
        int newX = x+1;
        while(newX < nums.size() && nums[x] == nums[newX]) {
            newX++;
        }
        
        
        ans = min(ans, find(i, newX, nums, n, k, dp));
        if(numberOfElementsInCurrentSubset == 0) {
            int val =  find ( i | (1 << x), newX, nums, n, k,  dp);
            
            if(val != INT_MAX)
                ans = min (ans, (-1*nums[x]) + val);
            
        } else if(numberOfElementsInCurrentSubset == ((n/k)-1)) {
            int val =  find(i | ( 1 << x), 0, nums, n, k, dp);
            
            if (val != INT_MAX)
                ans = min(ans, nums[x] + val);
            
        } else {
            int val =  find ( i | (1 << x), newX, nums, n, k,  dp);
            
            if(val != INT_MAX)
                ans = min (ans, val);

        }
        
        x = newX; 
    }
    
    dp[i][j] = ans;
    
    return dp[i][j];
    
}

int minimumIncompatibility(vector<int>& nums, int k) {
    if(nums.size() % k != 0 )
        return -1;
    if( (nums.size() / k) == 1)
        return 0;
    vector<vector<int> > dp(pow(2, 17), vector<int>(17, -1));
    sort(nums.begin(), nums.end());

    
    int ans = find(0, 0, nums, nums.size(), k, dp);
    if(ans == INT_MAX)
        return -1;
    return ans;
}