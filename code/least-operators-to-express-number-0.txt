int _loet(int* n, int c, int b, int max)
{
    if (max <= 0)
        return INT_MAX;

    if (c == 0)
    {
        int add = n[0] * 2; // n[0] * ('+' + '/') eg. base is 4, n[0] is 3 it's "+ 4 / 4 + 4 / 4 + 4 / 4"
        int minus = (b - n[0]) * 2 + 1; // base is 4, n[0] is 3  then it's "+ 4 - 4 / 4"
        return add < minus ? add : minus;
    }

    if (n[c] == 0)
        return _loet(n, c - 1, b, max);

    int t_add = _loet(n, c - 1, b, max - n[c] * c); // n[c] * (c - 1) '*' + n[c] * '+'

    if (t_add != INT_MAX)
    {
        t_add += n[c] * c;
        if (max > t_add)
            max = t_add;
    }

    int i = 0;
    int t[64] = {0};

    // calcuate the complemental code
    for (i = c; i >= 0; i --)
        t[i] = b - 1 - n[i];

    t[0] += 1;

    i = 0;
    while (t[i] == b)
    {
        t[i ++] = 0;
        t[i] += 1;
    }

    // how many operator needed for complement code
    // t_add represent e.g. 0x1222 (base 3)
    // t_minus represent 0x2000 - 1(base 3)

    int t_minus = _loet(t, c, b, max - c - 1);

    if (t_minus == INT_MAX)
        return t_add;

    t_minus += c + 1;

    return t_add > t_minus ? t_minus : t_add;
}

// use x base target
int leastOpsExpressTarget(int x, int target)
{
    int* all = malloc(sizeof(int) * 64);

    int ai = 0;
    int t = target;

    while (t)
    {
        all[ai ++] = t % x;
        t /= x;
    }

    // 1 means the '+' at the first
    return _loet(all, ai - 1, x, INT_MAX) - 1;
}