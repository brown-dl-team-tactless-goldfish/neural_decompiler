class Solution {
public:
    
    int check(vector<int> &tasks, int take, map<int,int> count, int pills, int power){
        //optimal to take first "take" tasks
        //satisfy the largest one first
        
        while(take>=1 && count.size()){
            auto it = count.end(); --it; 
            
            //last element can satisfy
            if(tasks[take-1] <= it->first) {}    
            //last worker cant satisfy, use pills
            else if(pills) {            
                //find worker with least strength which after eating pill, can do the current task
                it = count.lower_bound(tasks[take-1]-power); 
                if(it==count.end()) return 0;
                --pills;
            }
            else return 0;
            
            --take;
            (it->second)--;
            if(it->second == 0) 
                count.erase(it);
        }
        return take==0;
    }
    int maxTaskAssign(vector<int>& t, vector<int>& w, int p, int s) {
        int n = t.size();
        int m = w.size();
        sort(t.begin(), t.end());
        map<int,int> Count;
        for(auto &strength : w) Count[strength]++;
  
        int l = 0, r = n, ans = 0;
        
        while(l<=r){
            int mid  = l + (r-l)/2;
            int chk  = check(t,mid,Count,p,s); //check if we can take "mid" number of tasks. 
                                            //Return 1 if we can take, 0 otherwise         
            if(chk) {
                ans = mid;
                l   = mid+1;
            }
            else {
                r = mid-1;
            }
        }
        return ans;
        
    }
};