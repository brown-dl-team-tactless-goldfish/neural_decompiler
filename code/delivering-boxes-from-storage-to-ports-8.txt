
class SegmentTree {
public:
	vector<int> seg;
	const int INF = 1000000000;
	SegmentTree(int n) {
		seg.resize(4 * n + 1, INF);
	}
	int query(int ind, int l, int r, int low, int high) {
		if (l <= low && high <= r) {
			return seg[ind];
		}
		int mid = low + (high - low) / 2;
		int c1 = ind * 2, c2 = c1 + 1;
		int left = INF, right = INF;
		if (l <= mid) {
			left = min(left, query(c1, l, r, low, mid));
		}
		if (r > mid) {
			right = min(right, query(c2, l, r, mid + 1, high));
		}
		return min(left, right);
	}

	void update(int ind, int i, int val, int low, int high) {
		if (low == high) {
			seg[ind] = val;
			return;
		}
		int mid = low + (high - low) / 2;
		int c1 = ind * 2, c2 = c1 + 1;
		if (i <= mid) {
			update(c1, i, val, low, mid);
		}
		else {
			update(c2, i, val, mid + 1, high);
		}
		seg[ind] = min(seg[c1], seg[c2]);
	}
};
class Solution {
public:
	int boxDelivering(vector<vector<int>> &boxes, int portsCount,
                 int maxBoxes, int maxWeight) {
		int n = boxes.size();
		vector<int> min_l(n + 1);
		int cur_l = n, cur_num_boxs = 0, cur_weight = 0;
		for (int i = n - 1; i >= 0; i--) {
			cur_l = min(i + 1, cur_l);
			while (
				cur_l > 0 
				&& cur_num_boxs + 1 <= maxBoxes 
				&& cur_weight + boxes[cur_l - 1][1] <= maxWeight
				) {
				cur_l--;
				cur_num_boxs++;
				cur_weight += boxes[cur_l][1];
			}
			min_l[i] = cur_l;
			cur_num_boxs--;
			cur_weight -= boxes[i][1];
		}
		vector<int> diff_prefix(n + 1);
		diff_prefix[0] = 0;
		for (int i = 1; i < n; i++) {
			diff_prefix[i] = diff_prefix[i - 1];
			if (boxes[i][0] != boxes[i - 1][0]) {
				diff_prefix[i]++;
			}
		}

		SegmentTree seg(n);
		vector<int> dp(n + 1);
		dp[0] = 0;
		seg.update(1, 0, 0, 0, n);
		for (int i = 0; i < n; i++) {
			int min_dp_j = seg.query(1, min_l[i], i + 1, 0, n);
			dp[i] = min_dp_j + diff_prefix[i] + 2;
			if (i == n - 1) {
				break;
			}
			seg.update(1, i + 1, dp[i] - diff_prefix[i + 1], 0, n);
		}
		return dp[n - 1];
	}
};