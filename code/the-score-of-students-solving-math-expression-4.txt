class Solution {
   public:
    int scoreOfStudents(string s, vector<int>& answers) {
        const auto true_ans = calc_true_ans(s);
        const auto possible_ans = calc_possible_ans(s);
        int total = 0;
        for (auto ans : answers) {
            if (ans == true_ans) {
                total += 5;
            } else if (possible_ans.count(ans)) {
                total += 2;
            }
        }
        return total;
    }

    int calc_true_ans(string_view s) {
        int partial_ans = s[0] - '0';
        int ans = 0;
        for (int i = 2; i < s.size(); i += 2) {
            if (s[i - 1] == '+') {
                ans += partial_ans;
                partial_ans = s[i] - '0';
            } else {
                partial_ans *= s[i] - '0';
            }
        }
        return ans + partial_ans;
    }

    unordered_set<int> calc_possible_ans(string_view s) {
        const auto n = s.size();
        vector dp(n, vector<unordered_set<int>>(n));

        // dp[i][j] contains the possible result of s[i:j]
        for (int i = n - 1; i >= 0; i -= 2) {
            dp[i][i].insert(s[i] - '0');
            for (int j = i + 2; j < n; j += 2) {
                for (int k = i + 1; k < j; k += 2) {
                    for (auto lhs : dp[i][k - 1]) {
                        for (auto rhs : dp[k + 1][j]) {
                            const auto r = calc(s[k], lhs, rhs);
                            if (r <= 1000) {
                                dp[i][j].insert(r);
                            }
                        }
                    }
                }
            }
        }

        return dp[0][n - 1];
    }

    int calc(char c, int lhs, int rhs) {
        if (c == '+') {
            return lhs + rhs;
        }
        return lhs * rhs;
    }
};