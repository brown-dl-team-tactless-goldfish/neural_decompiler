
class Solution {
public:
    
    
    
    
    
// we are on ith index of the array. next() return the index we land on after making jump from ith index.
int next(vector<int> nums, int i){

    return (i+nums[i] + nums.size())%nums.size();
}




bool circularArrayLoop(vector<int>& nums){
    
    int n = nums.size();

    for(int i=0; i<n; i++){
        int slow = i;
        int fast = i;

        if(nums[i] == 0){
            continue;
        }

        while(nums[slow]*nums[next(nums,slow)]>0 && 
            nums[fast]*nums[next(nums,fast)]>0 && 
            nums[fast]*nums[next(nums,next(nums,fast))]>0){
            
            // we can make jumps. so make slow take 1 jump and make fast take 2 jumps
            slow = next(nums, slow);
            fast = next(nums, next(nums, fast));


                if(slow == fast){
                    // cycle is present. check if the length of the cycle is more than 1
                    if(slow == next(nums, slow)){
                        break;
                    }
                    // return true cuz valid cycle is present.
                    return true;
                }
        
        }


        // if cycle cannot be formed from the ith index, then we need to make some updations:
        // make the values before the point where cycle broke and whos sign is same as sarting value sign as 0.

        slow = i;  // again start slow from i
        int val = nums[slow];
        // slow is used to iterate over the numbers uptil the number where cycle was broken
        while(val*nums[slow]>0){   // while current ele has same magnitude as 1st element
            int x = slow;
            slow = next(nums, slow);
            nums[x] = 0;
        }
    }

    return false;


}

};


