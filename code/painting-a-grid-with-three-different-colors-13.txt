	vector<string> states;
	void generate(string state, char prev, int m){
    
		if(m==0){
			states.push_back(state);
			return;
		}

		string colors = "RGB";
		for(auto &color: colors){
			if(color!=prev)
				generate(state+color, color, m-1);
		}

	}

	// We use memoization to make use of the fact that the ans only depends upon
	// the current state and the number of columns left to fill.
	int dp[250][1001];
	long long waysToFill(int u, int cols_to_fill, vector<vector<int>> &G){

		if(cols_to_fill==0) return 1;
		else if(dp[u][cols_to_fill]!=-1) return dp[u][cols_to_fill];

		int ways = 0;
		for(auto v: G[u]){
			ways = (ways + waysToFill(v, cols_to_fill-1, G)) % M;
		}

		return dp[u][cols_to_fill] = ways;
	}

	public:
	int colorTheGrid(int m, int n) {
	
		// ** Note that m<=5 whereas n<=1000 **
		// First of all we Generate all the possible color combinations (states)
		// for a column with size m, store them into a vector 'states'
		// For Eg m=3 : RGB, BGR, RBR, GBG, ...
		// Also, we make sure that same colors are not adjacent (See generate function)
		generate("", '*', m);

		// Now, we can observe that the number of possible states (color combinations) for
		// current column only depend upon the previous column.
		// So we make a graph where there is an edge from i to j if we can transition from
		// state[i] to state[j] ( no same index can be of same color )
		int numStates = states.size();
		vector<vector<int>> G(numStates);

		for(int i=0;i<numStates;i++){
			for(int j=0;j<numStates;j++){

				bool is_compatible = true;
				for(int k=0;k<m;k++){
					if(states[i][k]==states[j][k]){
						is_compatible = false; break;
					}
				}
				if(is_compatible)
					G[i].push_back(j);

			}
		}

		// Sum up the number of ways to make a path of length n, starting from each state (node)
		memset(dp, -1, sizeof(dp));
		int totalWays = 0;
		for(int i=0;i<numStates;i++){
			totalWays = (totalWays + waysToFill(i, n-1, G)) % M;
		}

		return totalWays;

	}