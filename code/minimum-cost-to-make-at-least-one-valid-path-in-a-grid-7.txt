class Solution {
public:
    vector<vector<int>> dirs{{-1,-1}, {0,1}, {0, -1}, {1, 0}, {-1, 0}};
    void dfs(int r, int c, int cost, vector<vector<int>>& grid, queue<pair<int, int>>& q, vector<vector<int>>& costs) {
        if(r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || costs[r][c] != -1) {
            return;
        }
        costs[r][c] = cost;
        q.push({r,c});
        int nxt_r = r + dirs[grid[r][c]][0];
        int nxt_c = c + dirs[grid[r][c]][1];
        dfs(nxt_r, nxt_c, cost, grid, q, costs);
    }
    int minCost(vector<vector<int>>& grid) {
        vector<vector<int>> costs(grid.size(), vector<int>(grid[0].size(), -1));
        costs[0][0] = 0;
        queue<pair<int, int>> q;
        q.push({0,0});
        while(!q.empty()) {
            int cur_r = q.front().first;
            int cur_c = q.front().second;
            int curr_cost = costs[cur_r][cur_c];
            if(cur_r == grid.size() - 1 && cur_c == grid[0].size() - 1) {
                return curr_cost;
            }
            q.pop();
            int nxt_r = cur_r + dirs[grid[cur_r][cur_c]][0];
            int nxt_c = cur_c + dirs[grid[cur_r][cur_c]][1];
            dfs(nxt_r, nxt_c, curr_cost, grid, q, costs);
            for(int i = 1 ; i < dirs.size() ; i++) {
                if(i != grid[cur_r][cur_c]) {
                    int n_r = cur_r + dirs[i][0];
                    int n_c = cur_c + dirs[i][1];
                    dfs(n_r, n_c, curr_cost + 1, grid, q, costs);
                }
            }
        }
        return 0;
    }
};