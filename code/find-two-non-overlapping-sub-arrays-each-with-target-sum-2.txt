class Solution {
public:
    int minSumOfLengths(vector<int>& arr, int target) {
        unordered_map<int,int>m;
        
        // 'sum' will store the current sum of the elements
        int sum=0,n=arr.size();
        
        // 'ans' will be the ans
        long long ans=INT_MAX;
        
        // We'll build two arrays prefix and suffix
        // prefix[i] = minimum length of subarray ending on or before index i with sum = target
        // suffix[i] = minimum length of subarray starting from or after index i with sum = target
        vector<int>prefix(n,INT_MAX),suffix(n,INT_MAX);
        
        // Now populate the prefix array
		// Logic to populate the array is similar to finding the smallest subarray with a target sum
        for(int i=0;i<n;i++)
        {
            sum+=arr[i];
            if(sum==target)
            {
                prefix[i]=min(prefix[i],i+1);
            }
            if(m.find(sum-target)!=m.end())
            {
                prefix[i]=min(prefix[i],i-m[sum-target]);
            }
            prefix[i]=i>0?min(prefix[i],prefix[i-1]):prefix[i];
            m[sum]=i;
        }
        m.clear();
        sum=0;
        
        // Populate the suffix array
        for(int i=n-1;i>=0;i--)
        {
            sum+=arr[i];
            if(sum==target)
            {
                suffix[i]=min(suffix[i],n-i);
            }
            if(m.find(sum-target)!=m.end())
            {
                suffix[i]=min(suffix[i],m[sum-target]-i);
            }
            suffix[i]=i+1<n?min(suffix[i],suffix[i+1]):suffix[i];
            m[sum]=i;
        }
        
        // Now once we've got the prefix and suffix array we will traverse from 1 to n-1 and compute the answer
        for(int i=1;i<n-1;i++)
        {
            // first find left subarray ending on or before index 'i' and right subarray starting from or after index 'i+1'
            long long first=(long long)prefix[i]+(long long)suffix[i+1];
            
            // second find left subarray ending on or before index 'i-1' and right subarray starting from or after index 'i'
            long long second=(long long)prefix[i-1]+(long long)suffix[i];
            
            // take whichever gives the min aggregate length
            ans=min({ans,first,second});
        }
        
        // if at the end the ans is INT_MAX or greater that means there were no 2 subarrys with sum = target so return -1. otherwise return the actual ans
        return ans>=INT_MAX?-1:ans;
    }
};