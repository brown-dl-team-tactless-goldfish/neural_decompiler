const int N = 5e4 + 10;
bool f[N];
class Solution {
public:
    int minJumps(vector<int>& arr) {
        memset(f, 0, sizeof(f));
        const int n = arr.size();
        if (n==1) return 0;
        unordered_map<int, vector<int>> m;
        for (int i = 0; i < n; ++i) {
            m[arr[i]].push_back(i);
        }
        deque<int> dq;
        dq.emplace_back(n-1);
        int ret = 0;
        int depth = 1;
        f[n-1] = true;
        while (true) {
            int sz = dq.size();
            for (int i = 0; i < sz; ++i) {
                int k = dq.front(); dq.pop_front();
                if (k == 0) return depth;
                for (auto &x: m[arr[k]]) {
                    if (x != k &&  !f[x]) {
                        f[x] = true;
                        if (x == 0) return depth;
                        dq.push_back(x);
                    }
                }
                for (auto di : {-1, 1}) {
                    if (k + di < n && k + di >= 0 && !f[k + di]) {
                         f[k + di] = true;
                        if (k + di == 0) return depth;
                        dq.push_back(k + di);
                    }
                } 
            }
            depth++;
        }
        
        return ret;  
    }
};