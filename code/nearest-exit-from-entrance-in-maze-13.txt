//for shortest path applying bfs is better and clearer aproach
class Solution {
public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& ent) 
    {
     queue<pair<int,int>> q;
     q.push({ent[0]-1, ent[1]});
     q.push({ent[0]+1, ent[1]});
     q.push({ent[0], ent[1]-1});
     q.push({ent[0], ent[1]+1});
     maze[ent[0]][ent[1]]='+';  //blocking the visited block 
     int c = 0;
     while(!q.empty())
     {
         c++;
         int s = q.size();
         for(int i=0;i<s;i++)
         {
             auto p = q.front();
             int x = p.first, y = p.second;
             if(x<0 || y<0 || x>=maze.size() || y>=maze[0].size() || maze[x][y]=='+')
             {
                 q.pop(); //removing the unwanted traversal path
                 continue;
             }
             if(x==0 || y==0 || x==maze.size()-1 || y==maze[0].size()-1)
             {
                 return c;
             }
             q.push({x-1,y});
             q.push({x+1,y});
             q.push({x,y-1});
             q.push({x,y+1});
             q.pop();
             maze[x][y]='+'; //blocking the visited block 
         }
     }
     return -1;
    }
};