class Solution {
public:
    class Trie {
        public:
            int cnt;
            Trie* node[2];
    };
    
    Trie* root = new Trie();
    
    void insert(string bits) {
        Trie* head = root;
        int n = bits.size();
        for(int i = 0; i < n; i++) {
            int val = bits[i] - '0';
            if(head->node[val] == NULL) {
                Trie* newNode = new Trie();
                newNode->cnt++;
                head->node[val] = newNode;
                head = newNode;
            } else {
                head->node[val]->cnt++;
                head = head->node[val];
            }
        }
    }
    
    void deleteNode(string bits) {
        Trie* head = root;
        int n = bits.size();
        for(int i = 0; i < n; i++) {
            int val = bits[i] - '0';
            head->node[val]->cnt--;
            head = head->node[val];
        }
    }
    
    int query(string bits) {
        Trie* head = root;
        int n = bits.size();
        int ans = 0, cur = n-1;
        for(int i = 0; i < n; i++) {
            int val = bits[i] - '0';
            val = 1 - val;
            if(head->node[val] != NULL and head->node[val]->cnt > 0) {
                ans += (1<<cur);
                head = head->node[val];
            } else {
                head = head->node[1-val];
            }
            cur--;
        }
        return ans;
    }
    
    string intTobits(int temp) {
        string bits = "";
        while(temp) {
            if(temp % 2 == 0) {
                bits.push_back('0');
            } else {
                bits.push_back('1');
            }
            temp /= 2;
        }
        while(bits.size() < 18) bits.push_back('0');
        reverse(bits.begin(), bits.end());
        return bits;
    } 
    
    int n, rt;
    vector<vector<int>> adj;
    vector<bool> vis;
    unordered_map<int, vector<pair<int,int>>> mp;
    
    void dfs(int node, vector<int>& ans) {
        vis[node] = true;
        insert(intTobits(node));
        for(auto i : mp[node]) ans[i.first] = query(intTobits(i.second));
        for(auto i : adj[node]) if(!vis[i]) dfs(i, ans);
        deleteNode(intTobits(node));
    }
     
    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {
        
        vector<int> mpty;
        n = parents.size();
        
        for(int i = 0; i < n+1; i++) {
            adj.push_back(mpty);
            vis.push_back(false);
        }
        
        for(int i = 0; i < n; i++) {
            if(parents[i] == -1) {
                rt = i;
                continue;
            }
            adj[i].push_back(parents[i]);
            adj[parents[i]].push_back(i);
        }
        int len = queries.size();
        vector<int> ans(len);
        for(int i = 0; i < len; i++) {
            mp[queries[i][0]].push_back({i, queries[i][1]});
        }
        queries.clear();
        dfs(rt, ans);
        return ans;
    }
};