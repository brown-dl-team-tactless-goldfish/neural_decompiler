class Solution {
private:
    vector<long long> seg;
    vector<long long> lazy;
public:
    void update(int ind, int low, int high, int l, int r){
       if(lazy[ind]&1){
           seg[ind]=(high-low+1)-seg[ind];
            if(low!=high){
                lazy[2*ind+1]+=lazy[ind];
                lazy[2*ind+2]+=lazy[ind];
            }
            lazy[ind]=0;
       }

        if(low>r || high<l || low>high){
            return;
        }

        //fully overlapped
        if(low>=l && high<=r){
            seg[ind]=(high-low+1)-seg[ind];
            if(low!=high){
                lazy[2*ind+1]++;
                lazy[2*ind+2]++;
            }
            return;
        }

        //partially overlapped

        int mid=(low+high)>>1;
        update(2*ind+1,low,mid,l,r);
        update(2*ind+2,mid+1,high,l,r);
        seg[ind]=seg[2*ind+1]+seg[2*ind+2];
    }

    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {
        int n=nums1.size();
        seg.resize(4*n,0);
        lazy.resize(4*n,0);
        long long sum=0;
        vector<long long> ans;

        for(int i=0;i<n;i++){
            sum+=nums2[i];
            if(nums1[i]==1){
                update(0,0,n-1,i,i);    //index, low, high, l, r
            }
        }

        for(auto x:queries){
            int q=x[0];
            if(q==1){
                update(0,0,n-1,x[1],x[2]);
            }
            else if(q==2){
                sum=sum+seg[0]*x[1];
            }
            else{
                ans.push_back(sum);
            }
        }
        return ans;
    }
};