class Solution {
public:
    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {
        
        unordered_map<int, TreeNode*> node_map;
        unordered_map<int, bool> isChild_map;
        
        for (auto &desc : descriptions)
        {
            int p = desc[0];
            int c = desc[1];
            int isLeft = desc[2];
            
            auto pIt = node_map.find(p);
            if (pIt == node_map.end())
            {
                TreeNode *p_node = new TreeNode(p);
                node_map[p] = p_node;
            }
            
            auto cIt = node_map.find(c);
            if (cIt == node_map.end())
            {
                TreeNode *c_node = new TreeNode(c);
                node_map[c] = c_node;
            }
            
            if (isLeft)
            {
                node_map[p]->left = node_map[c];
            }
            else
            {
                node_map[p]->right = node_map[c];
            }
            
            if (isChild_map.find(p) == isChild_map.end())
            {
                isChild_map[p] = false;
            }
            isChild_map[c] = true;
        }
        
        int root = 0;
        for (auto &it : isChild_map)
        {
            if (!it.second) 
            {
                root = it.first;
                break;
            }
        }
        return node_map[root];
    }
};