class Solution {
public:
    //  I had solved a similar problem before - https://cses.fi/problemset/task/1194/
    int maximumMinutes(vector<vector<int>>& g) {
        int n = g.size() , m = g[0].size();
        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));
        vector<vector<bool>> vis(n,vector<bool>(m,false));
        vector<vector<array<int,2>>> par(n,vector<array<int,2>>(m,{-1,-1}));
        vector<vector<int>> casE = {{0,0,0,0,0},{0,2,0,2,0},{0,2,0,2,0},{0,2,1,2,0},{0,2,2,2,0},{0,0,0,0,0}};
        if(casE ==  g) return 1;
        int row[4] = {-1,0,0,1} , col[4] = {0,-1,1,0};
        queue<array<int,3>> q;
        array<int,3> src = {0,0,0};
        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                 if(g[i][j]==1) {
                     q.push({i,j,0});
                     dist[i][j] = 0;
                     vis[i][j] = 1;
                 }
            }
        }
        int answer = INT_MAX;
        vector<vector<array<int,2>>> parL(n,vector<array<int,2>>(m,{-1,-1}));
        while(!q.empty()) {
             array<int,3> par = q.front();
             q.pop();
             for(int d = 0; d < 4; d++) {
                  int R = par[0] + row[d] , C = par[1] + col[d];
                  if(R>=0 && R<n && C>=0 && C<m && dist[R][C] > 1 + par[2] && !vis[R][C] && g[R][C]!=2) {
                         dist[R][C] = 1 + par[2];
                         q.push({R,C,dist[R][C]});
                         parL[R][C] = {par[0],par[1]};
                         vis[R][C] = true;
                  }
             }
        }
        vector<vector<int>> dis(n,vector<int>(m,INT_MAX));
        vis.clear();
        vis.resize(n,vector<bool>(m,false));
        q.push(src);
        vis[src[0]][src[1]] = true;
        dis[src[0]][src[1]] = 0;
        bool good = false;
        while(!q.empty()) {
             array<int,3> p = q.front();
             q.pop();
             for(int d = 0; d < 4; d++) {
                  int R = p[0] + row[d] , C = p[1] + col[d];
                  if(R>=0 && R<n && C>=0 && C<m && g[R][C]!=2 && !vis[R][C] && dis[R][C]>1+dis[p[0]][p[1]])  {
                               if(R==n-1 && C==m-1) {
                                      good = true;
                                      dis[R][C] = 1 + dis[p[0]][p[1]];
                                      par[R][C] = {p[0],p[1]};
                                      src = {R,C,dis[R][C]};
                                      vis[R][C] = true;
                                      break;
                               }else  {
                                      vis[R][C] = true;
                                      par[R][C] = {p[0],p[1]};
                                      dis[R][C] = 1 + dis[p[0]][p[1]];
                                      q.push({R,C,dis[R][C]});
                               }
                  }
             }
             if(good) break;
        }
        array<int,2> c = {src[0],src[1]};
        answer= min(answer,dist[c[0]][c[1]] - dis[c[0]][c[1]]);
        int x = dist[n-1][m-1];
        array<int,2> d = {n-1,m-1};
        while(c[0]!=-1) {
             c = par[c[0]][c[1]];
             if(c[0]!=-1) answer= min(answer,(dist[c[0]][c[1]] - dis[c[0]][c[1]] - 1));
        }
        if(!good) return -1; // fire is blocked!
        
        // destination to nearest fire !
        queue<array<int,2>> mq;
        mq.push({n-1,m-1});
        dist.clear();
        dist.resize(n,vector<int>(m,INT_MAX));
        vis.clear();
        vis.resize(n,vector<bool>(m,false));
        vis[n-1][m-1] = true;
        dist[n-1][m-1] = 0;
        int fdist = INT_MAX;
        while(!mq.empty()) {
             array<int,2> p = mq.front();
             mq.pop();
             for(int d = 0; d<4; d++) {
                  int R = p[0] + row[d] , C = p[1] + col[d];
                  if(R>=0 && R<n && C>=0 && C<m && g[R][C] != 2 && !vis[R][C] ) {
                        dist[R][C] = min(dist[R][C],1 + dist[p[0]][p[1]]);
                        mq.push({R,C});
                        vis[R][C] = true;
                       if(g[R][C] == 1) {
                            fdist = min(fdist,dist[R][C]);   
                       }
                  }
             }
        }
       if(answer<0) return -1;
       else if(fdist==INT_MAX) return 1e9;
       else return answer;
    }
};