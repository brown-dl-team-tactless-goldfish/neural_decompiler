bool compareAffinity(pair<TreeNode*, int> &a, pair<TreeNode*, int> &b){
    return (a.second < b.second);
}

class Solution {
    unordered_map<int, TreeNode*> setOfTrees;
    
    void dfs(TreeNode* &curr, TreeNode* root){
        if(curr == NULL)
            return;
        
        if(curr->left == NULL && curr->right == NULL){
            if(setOfTrees.find(curr->val) != setOfTrees.end() && setOfTrees[curr->val] != curr 
               && setOfTrees[curr->val] != root){
                curr = setOfTrees[curr->val];
                setOfTrees.erase(curr->val);
            }
        }
        
        dfs(curr->left, root);
        dfs(curr->right, root);
    }
    
    int leafAffinity(TreeNode* curr){
        if(curr == NULL)
            return 0;
        
        if(curr->left == NULL && curr->right == NULL && 
                setOfTrees.find(curr->val) != setOfTrees.end()){
            return 1;
        }
        
        return leafAffinity(curr->left) + leafAffinity(curr->right);
    }

    bool isBST(TreeNode* node, int min, int max)
    {
        if (node==NULL)
            return true;

        if (node->val < min || node->val > max)
            return false;

        return isBST(node->left, min, node->val-1) && 
                isBST(node->right, node->val+1, max); 
    }
public:
    TreeNode* canMerge(vector<TreeNode*>& trees) {
        for(auto t: trees)
            setOfTrees[t->val] = t;
        
        vector<pair<TreeNode*, int>> treesT;
        
        for(auto t: trees)
            treesT.push_back(make_pair(t, leafAffinity(t)));
        
        sort(treesT.begin(), treesT.end(), compareAffinity);
        
        for(int i=0; i<treesT.size(); i++){
            if(setOfTrees.find(treesT[i].first->val) != setOfTrees.end())
                dfs(treesT[i].first, treesT[i].first);
        }
        
        if(setOfTrees.size() > 1)
            return NULL;
        
        if(isBST(setOfTrees.begin()->second, INT_MIN, INT_MAX))
            return setOfTrees.begin()->second;
        else return NULL;
    }
};