class Solution {
public:
    bool isRationalEqual(string S, string T) {
        vector<string> s = parse(S), t = parse(T);
        
        process_99(s);
        process_99(t);
        
        return judge(s, t);
    }
    
private:
    // the canonical compare function
    bool judge(vector<string>& s, vector<string> &t) {
        if (s[0] != t[0]) {
            return false;
        }
        return to50s(s) == to50s(t);
    }
    
    // extend the string to size()==50
    string to50s(vector<string>& s) {
        string r = s[1];
        if (s[2].empty()) {
            s[2] = "0";
        }
        while (r.size() < 50) {
            r += s[2];
        }
        return r.substr(0, 50);
    }
    
    // process repeating 9's
    void process_99(vector<string>& s) {
        if (s[2] != "9" && s[2] != "99" && s[2] != "999" && s[2] != "9999") {
            return;
        }
        s[2] = "";
        while (!s[1].empty() && s[1].back() == '9') {
            s[1].pop_back();
        }
        if (s[1].empty()) {
            s[0] = to_string(stoi(s[0])+1);
        } else {
            s[1].back()++;
        }
    }
    
    // parse the three parts
    vector<string> parse(const string& s) {
        vector<string> result(3, "");
        size_t dot, lp, rp = s.size()-1;
        dot = s.find('.');
        if (dot == string::npos) {
            result[0] = s;
            return result;
        }
        
        result[0] = s.substr(0, dot);

        lp = s.find('(');
        if (lp == string::npos) {
            result[1] = s.substr(dot+1);
            return result;
        }
        
        result[1] = s.substr(dot+1, lp-dot-1);
        result[2] = s.substr(lp+1, rp-lp-1);
            
        return result;
    }
};