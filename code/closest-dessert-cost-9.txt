class Solution {
    int val = INT_MAX;
    void dfs(int currCost, int totCost, int idx, vector<int>& toppingCosts, int toppingCount)
    {
        if(abs(currCost-totCost) < abs(val-totCost)) 
            val = currCost;
        else if(abs(currCost-totCost) == abs(val-totCost))
        {
            if(val > currCost)
                val = currCost;
        }
        if(idx == toppingCosts.size() || currCost >= totCost)
            return;
        dfs(currCost, totCost, idx+1, toppingCosts, 0);
        if(toppingCount == 0)
        {
            //took the toppings and take it can take once more;
            dfs(currCost+toppingCosts[idx], totCost, idx, toppingCosts, toppingCount+1);
        }
        else if(toppingCount == 1)
        {
            //took the topping for second time and can't take again;
            dfs(currCost+toppingCosts[idx], totCost, idx+1, toppingCosts, toppingCount-1);
        }
        return;
    }
public:
    int closestCost(vector<int>& baseCosts, vector<int>& toppingCosts, int target) {
        for(int &base : baseCosts)
            dfs(base, target, 0, toppingCosts, 0);
        return val;
    }
};