class Solution {
public:
    const int mod = 1e9 + 7;
    int f(vector<vector<pair<int,int>>>& es, int i, int cur, vector<int>& dp, vector<int>& dis) {
        if(dp[i] != -1) {
            return dp[i];
        }
        int ret = 0; 
        for(auto& [u,w] : es[i]) {
            if(dis[u] < cur) {
                ret += f(es,u,dis[u],dp,dis);
                ret %= mod;
            }
        }
        return dp[i] = ret; 
    }
    const int INF = INT_MAX;
    int countRestrictedPaths(int n, vector<vector<int>>& edges) {
        vector<int> dp(n,INF);
        vector<vector<pair<int,int>>> es(n);
        for(auto& e : edges) {
            es[e[0]-1].push_back({e[1]-1,e[2]});
            es[e[1]-1].push_back({e[0]-1,e[2]});
        }
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;
        q.push({0,n-1});
        while(q.size()) {
            auto [w,v] = q.top();
            q.pop();
            if(dp[v]>w) {
                dp[v] = w;
            } else {
                continue;
            }
            for(auto [u,w1] : es[v]) {
                int w_2 = w1 + w; 
                if(dp[u] > w_2) {
                    q.push({w_2,u});
                }
            }
        }
        vector<int> t(n,-1);
        t[n-1] = 1;
        return f(es,0,dp[0],t,dp);
    }
};