class Solution {
public:
    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int mB, int mW) {
        int non_reducible = 1; // the base cost associated with the given boxes
        for (int i=1;i<boxes.size();i++) {
            non_reducible += boxes[i][0] != boxes[i-1][0];
        }
        
        int start = 0, sum =0;// we'll be taking boxes[start...i] in the latest trip
        vector<int> dp(boxes.size(),0); // it will be non-decreasing
        for (int i =0;i<boxes.size();i++) {
            sum += boxes[i][1]; // admit boxes[i] in the sliding window
            while ((i - start +1 > mB) || (sum > mW)) {// keep increasing the sliding window tail till constraints are satisfied
                sum -= boxes[start++][1];
            }
            // newStart is the value of start at this point
            
            if (start > 0) {
                // the optimal start will be found before dp[start -1] == dp[start] becomes false
                while((start < i) && (boxes[start-1][0] == boxes[start][0]) && (dp[start -1] == dp[start])) {
                    sum -= boxes[start++][1];
                }
            }
            // we try and make  (boxes[start][0] == boxes[start-1][0]) == 0 while keeping dp[start-1] constant 
            dp[i] = (start > 0 ? (dp[start -1] + (boxes[start][0] == boxes[start-1][0])) : 0) + 1;
        }
        
        return dp[boxes.size()-1] + non_reducible;
    }
};