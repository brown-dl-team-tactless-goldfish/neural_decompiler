/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
bool verify(char *word, char *pattern){
    char mapped1[strlen(pattern)];
    char mapped2[strlen(pattern)];
    mapped1[0] = word[0];
    mapped2[0] = pattern[0];
    for (int i=1; i<strlen(pattern); i++){
        mapped1[i] = word[i];
        mapped2[i] = pattern[i];
        for (int j=0; j<i; j++){
            if (word[i] == mapped1[j]){
                if (pattern[i] != mapped2[j])
                    return false;
            }
        }
        for (int j=0; j<i; j++){
            if (pattern[i] == mapped2[j]){
                if (word[i] != mapped1[j])
                    return false;
            }
        }
        if (word[i] != word[i-1]){
            if (pattern[i] == pattern[i-1]){
                return false;
            } 
        }
        else if (word[i] == word[i-1]){
            if (pattern[i] != pattern[i-1]){
                return false;
            }
        }
    }
    return true;
}

char ** findAndReplacePattern(char ** words, int s, char * pattern, int* returnSize){
    int i = 0, k = 0, ansCounter = 0;
    char **ans = (char **)malloc(s*sizeof(char *));
    for (int j=0; j<s; j++){
        ans[j] = (char *)malloc((1+strlen(pattern))*sizeof(char));
        ans[j][strlen(pattern)] = '\0';
    }
    
    for (; i<s; i++){
        if (verify(words[i], pattern) == true){
            strcpy(ans[ansCounter], words[i]);
            k++;
            ansCounter++;
        }
    }
    char **res = (char **)malloc(k*sizeof(char *));
    for (int j=0; j<k; j++){
        res[j] = (char *)malloc((1+strlen(pattern))*sizeof(char));
        res[j][strlen(pattern)] = '\0';
        strcpy(res[j], ans[j]);
    }
    *returnSize = k;
    return res;
}