#define RES_LEN         250
#define DELIM_SPACE     7

typedef struct {
    char *rKey;     // key format: 'root->val,root->left,root->right'
    int cnt;        // value count of same keys
    UT_hash_handle hh;
} hElem;

char *dfs(struct TreeNode *root, hElem **map, struct TreeNode **res, int *idx) {
    hElem *temp;
    if(!root){ 
        char *r = calloc(sizeof(char), 2);
        strcpy(r, "N");
        return r;
    }
    
    char *lStr = dfs(root->left, map, res, idx);
    char *rStr = dfs(root->right, map, res, idx);
    int cLen = strlen(lStr) + strlen(rStr) + DELIM_SPACE;
    
    char *resStr = calloc(sizeof(char), cLen);
    sprintf(resStr, "%d,%s,%s", root->val, lStr, rStr);
    HASH_FIND_STR(*map, resStr, temp);
    if(temp) {      // duplicate found
        temp->cnt++;
        if(temp->cnt == 2) {
            res[(*idx)++] = root;
        }
    } else {
        hElem *temp = malloc(sizeof(hElem));
        temp->rKey = resStr;
        temp->cnt = 1;
        HASH_ADD_KEYPTR(hh, *map, temp->rKey, strlen(temp->rKey), temp);
    }
    return resStr;
}

struct TreeNode** findDuplicateSubtrees(struct TreeNode* root, int* returnSize){
    struct TreeNode **res = malloc(sizeof(struct TreeNode *) * RES_LEN);
    *returnSize = 0;
    hElem *map = NULL;
    // traverse the the tree and add the subtrees formed as strings 'root->val$root->left$root->right' to the hash
    dfs(root, &map, res, returnSize);
    return res;
}