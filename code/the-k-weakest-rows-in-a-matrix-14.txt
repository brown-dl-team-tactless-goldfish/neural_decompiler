/**
 * Note: The returned array must be malloced, assume caller calls free().
 Input: mat = 
[[1,1,0,0,0],
 [1,1,1,1,0],
 [1,0,0,0,0],
 [1,1,0,0,0],
 [1,1,1,1,1]], 
k = 3
Output: [2,0,3]
Explanation: 
The number of soldiers in each row is: 
- Row 0: 2 
- Row 1: 4 
- Row 2: 1 
- Row 3: 2 
- Row 4: 5
The rows ordered from weakest to strongest are [2,0,3,1,4].

*/


typedef struct {
    int row_idx;
    int nos;
}node;

int cmp(const void *a, const void *b){
    return (*(node**)a)->nos - (*(node**)b)->nos;
}
int* kWeakestRows(int** mat, int matSize, int* matColSize, int k, int* returnSize){
    node **array = (node**)calloc(matSize, sizeof(node*));
    int *ans = (int*)calloc(k, sizeof(int));
    *returnSize = k;

    for (int i = 0; i< matSize; i++){
        int s_sum = 0;
        for(int j = 0; j < *matColSize; j++){
            if (mat[i][j]==1){
                s_sum++;
            }else{
                break;
            }
        }
        array[i] = (node*)calloc(1, sizeof(node));
        array[i]->row_idx = i;
        array[i]->nos = s_sum;
    }

    qsort(array, matSize, sizeof(node*), cmp);

    for (int i = 0; i < k; i++){
        ans[i] = array[i]->row_idx;
    }

    for (int i = 0; i< matSize; i++){
        free(array[i]);
    }
    free(array);
    return ans;
}