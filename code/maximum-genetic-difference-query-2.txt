
class Node{
    public:
        Node* children[2];
        int cnt;
        Node(){
            children[0] = NULL;
            children[1] = NULL;
            cnt = 0;
        }
};

class Trie{
    public:
        Node *root;
        Trie(){
            root = new Node();
        }
        void insert(int number){
            Node* node = root;
            for (int i=31;i>=0;i--){
                int direction = ((1<<i)&number);
                if (direction) direction=1;
                if (!node->children[direction]){
                    node->children[direction] = new Node();
                }
                node = node->children[direction];
                node->cnt++;
            }
        }
        void remove(int number){
            Node* node = root;
            for (int i=31;i>=0;i--){
                int direction = ((1<<i)&number);
                if (direction) direction=1;
                if (!node->children[direction]){
                    node->children[direction] = new Node();
                }
                node = node->children[direction];
                node->cnt--;
            }
        }
    
    int query(int number){
        int res = 0;
        Node* node = root;
        for (int i=31;i>=0;i--){
            int direction = ((1<<i)&number);
            if (direction) direction=1;
            direction = 1-direction;
            if ((node->children[direction]) && ((node->children[direction])->cnt>0)){
                node = node->children[direction];
                res |= (1<<i);
            }
            else{
                node = node->children[1-direction];
            }
        }
        return res;
    }
};
class Solution {
public:
    vector<int> res;
    vector<vector<int>> adj;
    unordered_map<int,vector<pair<int,int>>> q;
    
    void dfs(int node, int par, Trie trie){
        trie.insert(node);
        for (auto v:q[node]){
            int ans = trie.query(v.first);
            res[v.second] = ans;
            }
        
        for (auto c:adj[node]){
            dfs(c,node,trie);
            }
        trie.remove(node);
    }
    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {
        Trie trie;
        for (int i=0;i<queries.size();i++){
            int node = queries[i][0] , val = queries[i][1];
            q[node].push_back({val,i});
        }
        int root = -1, n = parents.size();
        adj.resize(n);
        res.resize(queries.size());
        for (int i=0;i<n;i++){
            int node = i, par=parents[i];
            if (par==-1) root = i;
            else adj[par].push_back(i);
        }
        dfs(root,-1,trie);
        return res;
    }
};