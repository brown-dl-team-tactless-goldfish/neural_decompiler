using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _636_exclusive_time_of_function
{
    class Program
    {
        static void Main(string[] args)
        {
            var n = 2;
            var logs = new List<string>(new string[] { "0:start:0", "1:start:2", "1:end:5", "0:end:6" });
            var test = new Program();
            var result = test.ExclusiveTime(n, logs);   
       
            // skip test case 2 and 3
        }

        /// <summary>
        /// Jan. 28, 2022
        /// Input: n = 2, logs = ["0:start:0","1:start:2","1:end:5","0:end:6"] Output: [3,4]
        /// Understand how to calculate total time 
		/// https://leetcode.com/problems/exclusive-time-of-functions/discuss/467666/Easy-C-Solution
        /// </summary>
        /// <param name="n"></param>
        /// <param name="logs"></param>
        /// <returns></returns>
        public int[] ExclusiveTime(int n, IList<string> logs)
        {
            var totalTime = new int[n];

            var stack = new Stack<Tuple<int, Tuple<int, int>>>();

            foreach (var log in logs)
            {
                var data = log.Split(':');

                // "0:start:0"
                int id = int.Parse(data[0]);
                int time = int.Parse(data[2]);
                var isStart = data[1][0] == 's';

                if (isStart)
                {
                    stack.Push(new Tuple<int, Tuple<int,int>>(id, new Tuple<int, int>(time, 0)));
                }
                else
                {
                    if (stack.Peek().Item1 != id)
                    {
                        throw new Exception("something is wrong");
                    }

                    var top = stack.Pop();

                    var topStartTime = top.Item2.Item1;
                    var innerTopTime = top.Item2.Item2;
                    var allTime = time - topStartTime + 1;

                    if (stack.Count > 0)
                    {
                        var peek = stack.Pop();

                        var item1 = peek.Item1;
                        var item2 = peek.Item2;  // Tuple<int, Tuple<int, int>>
                        var nested = new Tuple<int, int>(item2.Item1, item2.Item2 + allTime);
                        var update = new Tuple<int, Tuple<int, int>>(item1, nested);

                        stack.Push(update);
                    }

                    totalTime[top.Item1] += (allTime - innerTopTime);
                }
            }

            return totalTime;
        }
    }
}