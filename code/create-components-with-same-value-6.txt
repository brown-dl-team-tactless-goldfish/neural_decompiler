class Solution {
public:
//     start from leaf nodes and add its value to its neighbour checking if this can be added to it or not
//     check only for those values whose total sum% (size we want to divide is zero)
    
    bool bfs(int sum, vector<vector<int>> &adj, vector<int> nums, queue<int> q, vector<int> cnt){
        while(!q.empty()){
            int val = q.front();
            q.pop();
            if(nums[val] > sum) return false;  // self value jayada hojaye
            for(auto it: adj[val]){
                if(nums[val] < sum)
                 nums[it] += nums[val];
                 cnt[it] -= 1;
                 if(cnt[it] == 1) q.push(it);
                
            }
        }
        return true;
    }
    
    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {
        vector<vector<int>> adj(nums.size());
        queue<int> q;
        vector<int> cnt(nums.size());
        int sum = accumulate(nums.begin(), nums.end(), 0);
        for(int i = 0; i < edges.size(); i++){
            adj[edges[i][0]].push_back(edges[i][1]);
            adj[edges[i][1]].push_back(edges[i][0]);
        }
        for(int i = 0; i < adj.size(); i++){
            cnt[i] = adj[i].size();
            if(adj[i].size() == 1) q.push(i);
        }
        for(int i = nums.size(); i >= 1; i--){
            if(sum%i == 0 && bfs(sum/i, adj, nums, q, cnt))
                 return i - 1;
        }
        return 0;
    }
};