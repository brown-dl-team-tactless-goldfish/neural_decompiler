class Solution {
public:
    void treeTraverse(TreeNode* root,unordered_map<TreeNode*, TreeNode*>&parentList,vector<TreeNode*>&leafNodeList)
    {
        if(root->left==NULL && root->right==NULL)
        {
            leafNodeList.push_back(root);
            return;            
        }
        
        if(root->left)
        {
            parentList[root->left]=root;
            treeTraverse(root->left,parentList,leafNodeList);
        }
        
        if(root->right)
        {
            parentList[root->right]=root;
            treeTraverse(root->right,parentList,leafNodeList);
        }
    }
    
    void findGoodPair(TreeNode* node, TreeNode * prevnode, int l, int &dis, int &count, unordered_map<TreeNode*, TreeNode*>&parentList)
    {
        if(l>dis)return;
        
        if(prevnode!=NULL && node->left==NULL && node->right==NULL)
        {
            count++;
            return;
        }
        
        if(parentList[node]!=NULL && parentList[node]!=prevnode)
        {
            findGoodPair(parentList[node],node,l+1,dis,count,parentList);
        }
        if(node->left!=NULL && node->left!=prevnode)
        {
            findGoodPair(node->left,node,l+1,dis,count,parentList);
        }
        if(node->right!=NULL && node->right!=prevnode)
        {
            findGoodPair(node->right,node,l+1,dis,count,parentList);
        }
    }
    
    int countPairs(TreeNode* root, int distance) {
        
        unordered_map<TreeNode*, TreeNode*>parentList;
        vector<TreeNode*>leafNodeList;
        treeTraverse(root,parentList,leafNodeList);
        parentList[root]=NULL;
        int count = 0;
        int c;
        for(int i=0;i<leafNodeList.size();i++)
        {
            c = 0;
            findGoodPair(leafNodeList[i],NULL,0,distance,c,parentList);
            count+= c;
        }
        
        return count/2;
    }
};