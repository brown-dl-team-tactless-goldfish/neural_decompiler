void dfs_search(struct TreeNode *root, int *hashmap, int *count, int odd)
{
    if(root==NULL)
      return;
     
    hashmap[root->val]++; //hashmap is used to store the root->val frequency appeared in that path
    
    /* we check if the current root->val has appeared even or odd number of times
      and update the value of odd variable.*/
   
    if(hashmap[root->val]%2==1) odd++;
    else odd--;
   
    //whenever we encounter a leaf node we update the value of the count if the odd value in the path is less than equal to 1. 
	//As for a path values to be plaindrome max 1 digit can be of odd frequency.
    if(root->left==NULL && root->right ==NULL) 
    {
          if(odd<=1)       
            (*count)++;
    }
    
    dfs_search(root->left,hashmap,count,odd);
    dfs_search(root->right,hashmap,count,odd);
    
    // reupdating the odd value after the dfs traversal of that node... as now that node will not be in the path
    // tree = [2,3,1,3,1,null,1]
    // dfs(2)->dfs(3)->dfs(3) this will be the call stack of the dfs traversal. Now after checking the plaindrome 
    // conditions call will return to dfs(3) leaf value whose hashmap and odd data has to be deleted as next 
    // call will be dfs(2)->dfs(3)->dfs(1) 
    // plz visualize the tree for more clarity
    
    if(hashmap[root->val]%2==1) odd--; 
    else odd++;
    hashmap[root->val]--;
    
}

int pseudoPalindromicPaths (struct TreeNode* root){

    int i,hashmap[10];
    int count=0;
    for(i=0;i<10;i++)
        hashmap[i]=0;
    
    dfs_search(root,hashmap,&count,0);
    return count;
}