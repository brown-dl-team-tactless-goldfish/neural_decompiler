class Solution {
public:
    //same depth means node at same level
    //for this we will use queue
    //As we need parent information of each node so queue will have curr_node and its parent as pair 
    // The main point here is ans of node at particular level is =(Total_Sum at that level) - (sum of node having same parent)
    // now for calculating sum of node having same parent i am using map
    //The key point here is i am not using int as my key in map because two different node can have same value so i am using TreeNode* as key
    // I am modifying same tree so i have used temp arr to store node in a way they are coming in queue at each level
    TreeNode* replaceValueInTree(TreeNode* root) {
        queue<pair<TreeNode*,TreeNode*>>q;       
        q.push({NULL,root});
        
        while(q.size())
        {
            int size=q.size();
            unordered_map<TreeNode*,int>mp;
            vector<pair<TreeNode*,TreeNode*>>temp;
            int total_sum=0;
            while(size--)
            {
                auto node=q.front(); //node.first=parent , node.second=curr_node
                q.pop();
                 
                total_sum+=node.second->val;  //calculating total sum at particular level
                mp[node.first]+=node.second->val;  //storing sum of node having same parent
                temp.push_back({node.first,node.second}); //this is used so that we can modify current tree
                
                if(node.second->left)
                    q.push({node.second,node.second->left});
                
                if(node.second->right)
                    q.push({node.second,node.second->right});
            }
            
            for(auto it:temp)
            {
                int val=total_sum-mp[it.first]; //formula
                it.second->val=val;
            }
        }
        return root;
    }
};