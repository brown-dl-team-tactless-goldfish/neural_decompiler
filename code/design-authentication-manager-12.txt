class AuthenticationManager {
    int K; // time-to-live
    using Set = unordered_set<string>;
    using TimeMap = map<int, Set>;
    using NameMap = unordered_map<string, int>;
    TimeMap timeMap;
    NameMap nameMap;
    void processExpiry(int t) {
        auto last = timeMap.upper_bound(t); // < t
        for (auto it = timeMap.begin(); it != last; ++it) {
            auto [_, ids] = tie(it->first, it->second);
            for (auto& id: ids)
                nameMap.erase(id);
        }
        timeMap.erase(timeMap.begin(), last);
    }
public:
    AuthenticationManager(int K) : K{ K } {
    }
    void generate(string id, int t) {
        timeMap[t + K].insert(id);
        nameMap[id] = t + K;
    }
    void renew(string id, int t) {
        processExpiry(t);
        if (nameMap.find(id) == nameMap.end()) // has it expired?
            return;
        auto last = nameMap[id];
        auto it = timeMap.lower_bound(last);
        auto [_, ids] = tie(it->first, it->second);
        ids.erase(id);
        generate(id, t);
    }
    int countUnexpiredTokens(int t) {
        processExpiry(t);
        return nameMap.size();
    }
};