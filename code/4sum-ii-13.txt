int cmpfun(const void *a,const void *b){
    return *(int*)a-*(int*)b;
}
int fourSumCount(int* A1, int n1, int* A2, int n2, int* A3, int n3, int* A4, int n4){
    // section 1: compute sum of every possible pair between A1 and A2
    int N1 = n1*n1,N2=n1*n1;
    int H1[N1],H2[N2];
    int idx=0;
    for(int i=0;i<n1;i++){
        for(int j=0;j<n1;j++){
            H1[idx++]=A1[i]+A2[j];
        }
    }
    idx=0;
    // section 2: compute sum of every possible pair between A3 and A4
    for(int i=0;i<n1;i++){
        for(int j=0;j<n1;j++){
            H2[idx++]=A3[i]+A4[j];
        }
    }

    // section 3: Sort the two arrays
    qsort(H1,N1,sizeof(int),cmpfun);
    qsort(H2,N2,sizeof(int),cmpfun);
    
    // section 4: Binary search for the negative of every element(sum) of H1 in H2
    int ans=0,prev_ans=0;
    for(int i=0;i<N1;i++){
        if(i!=0&&H1[i]==H1[i-1]){
            ans+=prev_ans;continue;
        }
        int key =(-1)*H1[i];
        int l = 0,h=N2-1,mid;
        while(l<=h){
            mid = l+((h-l)/2);
            if(H2[mid]==key) break;
            else if(H2[mid]>key) h = mid-1;
            else l = mid+1;
        }
        prev_ans=0;
        int j = mid-1;
        while(mid<N2&&H2[mid]==key){prev_ans++;mid++;}
        while(j>=0&&H2[j]==key){prev_ans++;j--;}
        ans+=prev_ans;
    }
    return ans;
}