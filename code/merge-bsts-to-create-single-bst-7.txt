int n=0;
unordered_map<int,TreeNode*> parent;
TreeNode* find(int val)
{
	if(parent.find(val)!=parent.end())
		return parent[val];
	else return NULL;
}
void dfs(TreeNode* root,TreeNode* p) // add all leaf nodes which are not roots to the DS.
{
	if(root==NULL)
		return;
	++n;
	if(root->left==NULL&&root->right==NULL&&p!=NULL)
		parent[root->val]=p;
	else
	{
		dfs(root->left,root);
		dfs(root->right,root);
	}
}
void dfsInOrder(TreeNode* root,vector<int>& arr)
{
	if(!root)
		return;
	dfsInOrder(root->left,arr);
	arr.push_back(root->val);
	dfsInOrder(root->right,arr);
}
TreeNode* canMerge(vector<TreeNode*>& trees)
{
	for(TreeNode* x:trees)
		dfs(x,NULL);
	TreeNode* ret=NULL;
	for(TreeNode* root:trees)
	{
		TreeNode* p=find(root->val);
		if(p==NULL)
			if(ret==NULL)
				ret=root;
			else return NULL;
		else
		{
			if(p->val<root->val)
				p->right=root;
			else p->left=root;
			parent.erase(root->val);
			n--; // with each union, the number of nodes the tree should have reduces by one.
		}
	}
	vector<int> arr;
	dfsInOrder(ret,arr);
	for(int i=1;i<arr.size();++i)
		if(arr[i]<=arr[i-1])
			return NULL;
	if(n!=arr.size())
		ret=NULL;
	return ret;
}