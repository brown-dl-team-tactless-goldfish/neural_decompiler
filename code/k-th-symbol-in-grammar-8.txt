int kthGrammarMethod1(int N, int K){

    /*
    The whole structure can be viewed a binary tree, when a node is 0, their two children nodes are 0 and 1, similarly, 
    when a node is 1, two children nodes are 1 and 0. 
    
    If we look at the value of K, we can tell, all odd values of K are the LHS children of their parents,
    and all even values of K are the RHS children of their parents.
    We can now know whether the position of K is a left node or a right node by finding if K's value is odd or even. 
    
    If K is even, current node is right child, and its parent is the (K/2)th node in previous row; 

    If K is odd, current node is left child and its parent is the ((K+1)/2)th node in previous row.
    
    The value of current node depends on its parent node, without knowing its parent node value, we still cannot determine current node value. 
    That's why we need recursion, we keep going previous row to find the parent node until reach the first row. 
    Then all the parent node value will be determined after the recursion function returns.
    */

   // for odd value of N, return 0
   if( N == 1 || K == 1){   return 0;   }

   if(K%2 == 0){
       return ((kthGrammarMethod1(N-1, K/2) == 0) ? 1  : 0);            // K is even, its on RHS of tree, so its child is flipped, so if parent = 0, return 1
   }
   else{
       return ((kthGrammarMethod1(N-1, (K+1)/2) == 0) ? 0 : 1);         // K is odd, parent and child both has same value, so return same value as that of parent
   }
}