int cmp(const void* a, const void* b){
    return *(int*)a - *(int*)b ;
}

//Keep increasing the minimum value until K is used up
int maximumProduct(int* nums, int numsSize, int k){
    int mod = 1e9 +  7 ;
    qsort( nums, numsSize, sizeof(int), cmp ) ;
    int  p = 0 ; //p is the first position that val is bigger than before
    for(int i = 1; i < numsSize; i++){
        if(nums[i] != nums[i-1]){
            p = i ;
            break ;
        }
    }
    //p == 0, menas all equal
    if(p == 0){
        for(int i = 0; i < numsSize; i++){
                nums[i] += k / numsSize ;
        }
        for(int i = 0; i < k % numsSize; i++)
            nums[i] += 1 ;
        k = 0 ;
    }
    while(k){
        //Keep increasing the minimum value until K is used up
        while(nums[p-1] < nums[p]){
            for(int i = 0; i < p; i++){
                nums[i]++ ;
                k-- ;
                if(k == 0)
                    break ;
            }
            if(k == 0)
                break ;
        }
        
        //find next p
        int org = p ;
        if(nums[p] == nums[p-1]){
            for(int i = p + 1; i < numsSize; i++){
                if(nums[i] != nums[p]){
                    p = i ;
                    break ;
                }
            }
        }
        //org == p, means all equal 
        if(org == p){
            for(int i = 0; i < numsSize; i++){
                nums[i] += k / numsSize ;
            }
            for(int i = 0; i < k % numsSize; i++)
                nums[i] += 1 ;
            k = 0 ;
        }
    }
    long long ans = 1 ;
    for(int i = 0; i < numsSize; i++){
        ans = (ans * nums[i]) % mod ;
    }
    return ans ;
}