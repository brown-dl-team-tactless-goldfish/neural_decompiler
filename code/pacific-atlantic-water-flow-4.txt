#define VALUE_MASK      0x1FFFF

#define PACIFIC_BIT     0x40000000
#define ATLANTIC_BIT    0x20000000
#define BOTH_BIT        0x60000000

unsigned short PacificAtlanticInner(int** ppnHeights, unsigned char ucHeightsSize, unsigned char ucHeightsColSize, int nBitType, unsigned char ucRow, unsigned char ucCol)
{
    ppnHeights[ucRow][ucCol] |= nBitType;
    unsigned short usRet = (ppnHeights[ucRow][ucCol] & BOTH_BIT) == BOTH_BIT;
    int nValue = ppnHeights[ucRow][ucCol] & VALUE_MASK;

    // check top
    if(ucRow && (ppnHeights[ucRow-1][ucCol]&nBitType) == 0 && (ppnHeights[ucRow-1][ucCol]&VALUE_MASK) >= nValue)
    {
        usRet += PacificAtlanticInner(ppnHeights, ucHeightsSize, ucHeightsColSize, nBitType, ucRow-1, ucCol);
    }

    // check left
    if(ucCol && (ppnHeights[ucRow][ucCol-1]&nBitType) == 0 && (ppnHeights[ucRow][ucCol-1]&VALUE_MASK) >= nValue)
    {
        usRet += PacificAtlanticInner(ppnHeights, ucHeightsSize, ucHeightsColSize, nBitType, ucRow, ucCol-1);
    }

    // check right
    if(ucCol < ucHeightsColSize && (ppnHeights[ucRow][ucCol+1]&nBitType) == 0 && (ppnHeights[ucRow][ucCol+1]&VALUE_MASK) >= nValue)
    {
        usRet += PacificAtlanticInner(ppnHeights, ucHeightsSize, ucHeightsColSize, nBitType, ucRow, ucCol+1);
    }

    // check bottom
    if(ucRow < ucHeightsSize && (ppnHeights[ucRow+1][ucCol]&nBitType) == 0 && (ppnHeights[ucRow+1][ucCol]&VALUE_MASK) >= nValue)
    {
        usRet += PacificAtlanticInner(ppnHeights, ucHeightsSize, ucHeightsColSize, nBitType, ucRow+1, ucCol);
    }

    return usRet;
}

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** pacificAtlantic(int** heights, int heightsSize, int* heightsColSize, int* returnSize, int** returnColumnSizes){
    unsigned char ucHeightsSize = heightsSize - 1, ucHeightsColSize = *heightsColSize - 1;

    // check first row (pacific ocean)
    for(unsigned char i=0; i<=ucHeightsColSize; i++)
    {
        if((heights[0][i]&PACIFIC_BIT) == 0) PacificAtlanticInner(heights, ucHeightsSize, ucHeightsColSize, PACIFIC_BIT, 0, i);
    }

    // check first col (pacific ocean)
    for(unsigned char i=1; i<=ucHeightsSize; i++)
    {
        if((heights[i][0]&PACIFIC_BIT) == 0) PacificAtlanticInner(heights, ucHeightsSize, ucHeightsColSize, PACIFIC_BIT, i, 0);
    }

    // check last row (atlantic ocean)
    unsigned short usRet = 0;
    for(unsigned char i=0; i<=ucHeightsColSize; i++)
    {
        if((heights[ucHeightsSize][i]&ATLANTIC_BIT) == 0) usRet += PacificAtlanticInner(heights, ucHeightsSize, ucHeightsColSize, ATLANTIC_BIT, ucHeightsSize, i);
    }

    // check last col (atlantic ocean)
    for(unsigned char i=0; i<ucHeightsSize; i++)
    {
        if((heights[i][ucHeightsColSize]&ATLANTIC_BIT) == 0) usRet += PacificAtlanticInner(heights, ucHeightsSize, ucHeightsColSize, ATLANTIC_BIT, i, ucHeightsColSize);
    }

    // allocate *returnSize, **returnColumnSizes & **ppnRet
    *returnSize = usRet;
    *returnColumnSizes = (int*) malloc(usRet*sizeof(int));
    int** ppnRet = (int**) malloc(usRet*sizeof(int*));

    // write date
    usRet = 0;
    for(unsigned char i=0; i<=ucHeightsSize; i++)
    {
        for(unsigned char j=0; j<=ucHeightsColSize; j++)
        {
            if((heights[i][j] & BOTH_BIT) == BOTH_BIT)
            {
                (*returnColumnSizes)[usRet] = 2;
                ppnRet[usRet] = (int*) malloc(2*sizeof(int));
                ppnRet[usRet][0] = i;
                ppnRet[usRet++][1] = j;
            }
        }
    }

    return ppnRet;
}