    double mincostToHireWorkers(vector<int>& quality, vector<int>& wage, int K) {
        int N = quality.size();
        double res = DBL_MAX;
       
        //[1] Sort
        // w[a]/q[a] * q[b] >= w[b] ==> w[a]/q[a] >= w[b]/q[b]
        // If w[i]/q[i] >= w[j]/q[j], then worker-i can take worker-j.
        vector<int> index(N);
        for (int i = 0; i < N; i++) index[i] = i;
        auto cmp = [&] (const int& a, const int& b) {
            return wage[a]*1.0/quality[a]*1.0 > wage[b]*1.0/quality[b]*1.0;
        };
        sort(index.begin(), index.end(), cmp);
        
        // [2] MaxHeap by quality
        // At worker-i+1, Paid = (w[i+1]/q[i+1])x(q[i+1]+q[a]+q[b]+..+q[c]+q[d]) 
        // At worker-(i), Paid = (w[i]/q[i])x(q[i]+q[a]+q[b]+..+q[c]) if q[d] is largest than others. 
        auto cmp2 = [&] (const int& a, const int& b) {
            return quality[a] < quality[b];
        };
        priority_queue<int, vector<int>, decltype(cmp2)> PQ(cmp2);
        double total = 0;
        
        for (int i = N-1; i > N-K; i--) {
            total += (quality[index[i]]*1.0);
            PQ.push(index[i]);
        }
        
        for (int i = N-K; i >= 0; i--) {
            total += (quality[index[i]]*1.0);
            PQ.push(index[i]);    
            res = min(res, (wage[index[i]]*1.0/quality[index[i]]*1.0)*total);
            total -= (quality[PQ.top()]*1.0);
            PQ.pop();
        }
        
        return res;
    }