#define MAPLEN 10

//stack's node
struct node{
    int val;
    struct node *next;
};

/*
Map's key : insert value
Map's value : Element{
    int val;
    int freq;
    struct node *head; // stack's head
};
*/
typedef struct{
    int val;
    int freq;
    struct node *head;
}Element;

/*
MAPLEN is the child len of the trie tree
racingElement point to the winner element (winner tree)
*/
typedef struct map{
    Element* element;
    Element* racingElement;
    struct map *child[MAPLEN];
}Map;

void element_free(Element* element){
    while (element->head){
        struct node *del = element->head;
        element->head = element->head->next;
        free(del);
    }
    free(element);
}

void map_free(Map* map){
    if (map->element) element_free(map->element);
    for (int i=0; i<MAPLEN; i++){
        if (map->child[i]) map_free(map->child[i]);
    }
    free(map);
}

Element* Element_cmp(Element* a, Element* b){
    if (a == b) return a;
    if (!a && !b) return 0;
    if (!a) return b;
    if (!b) return a;
	
    if (a->freq > b->freq) return a;
    if (b->freq > a->freq) return b;
    if (a->freq == 0) return 0;
	
    if (a->head->val > b->head->val) return a;
    if (a->head->val < b->head->val) return b;
    return 0;
}

void element_pop(Element* element){
    if (element->freq == 0){
        return;
    }
    struct node* del = element->head;
    element->head = element->head->next;
    element->freq--;
    free(del);
}

void element_push(int index, Element* element){
    element->freq++;
    struct node *newNode = malloc(sizeof(struct node));
    newNode->val = index;
    newNode->next = element->head;
    element->head = newNode;
}

Element* element_init(int val, int index){
    Element *r = malloc(sizeof(Element));
    r->val = val;
    r->freq = 0;
    r->head = 0;
    element_push(index, r);
    return r;
}

Map* map_init(){
    Map *r = malloc(sizeof(Map));
    r->element = 0;
    r->racingElement = 0;
    for (int i=0; i<MAPLEN; i++){
        r->child[i] = 0;
    }
    return r;
}

void map_insert(int originVal, int val, int index, Map* map){
    if (val == 0){
        if(!map->element){
            map->element = element_init(originVal, index);
        }
        else{
            element_push(index, map->element);
        }
    }
    else{
	    // transverse through trie tree (winner tree)
        int map_index = val%MAPLEN;
        if (!map->child[map_index]){
            map->child[map_index] = map_init();
        }
        int remain_val = val/MAPLEN;
        map_insert(originVal, remain_val, index, map->child[map_index]);
    }
	// after insert. count the new winner Element (winner tree)
    for (int i=0; i<MAPLEN; i++){
        if (!map->child[i]) continue;
        map->racingElement = Element_cmp(map->racingElement, map->child[i]->racingElement);
    }
    map->racingElement = Element_cmp(map->racingElement, map->element);
}

void map_pop(int originVal, int val, Map* map){
    if (val == 0){
        element_pop(map->element);
    }
    else{
	    // transverse through trie tree (winner tree)
        int map_index = val%MAPLEN;
        int remain_val = val/MAPLEN;
        map_pop(originVal, remain_val, map->child[map_index]);
    }
	// after pop. count the new winner Element (winner tree)
    for (int i=0; i<MAPLEN; i++){
        if (!map->child[i]) continue;
        map->racingElement = Element_cmp(map->racingElement, map->child[i]->racingElement);
    }
    map->racingElement = Element_cmp(map->racingElement, map->element);
}

typedef struct {
    Map *map;
    int index;
    int size;
} FreqStack;


FreqStack* freqStackCreate() {
    FreqStack *r = malloc(sizeof(FreqStack));
    r->map = map_init();
    r->index = 0;
    r->size = 0;
    return r;
}

void freqStackPush(FreqStack* obj, int val) {
    map_insert(val, val, obj->index, obj->map);
    obj->index++;
    obj->size++;
}

int freqStackPop(FreqStack* obj) {
    if (obj->size == 0) return -1;
    obj->size--;
    int r = obj->map->racingElement->val;
    map_pop(r, r, obj->map);
    return r;
}

void freqStackFree(FreqStack* obj) {
    if (obj->map){
        map_free(obj->map);
    }
    free(obj);
}