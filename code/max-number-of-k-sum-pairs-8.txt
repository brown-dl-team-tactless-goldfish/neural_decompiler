/* Handle collision */
typedef struct _linklist_t {
    struct _linklist_t *next;
    int val;
} linklist_t;

linklist_t *generate_node(void) {
    linklist_t *node = (linklist_t *)malloc(sizeof(linklist_t));
    memset(node, 0, sizeof(linklist_t));

    return node;
}

void insert_chaining_hash(linklist_t **map, int index, int val, int numsSize) {
    // printf("insert hash[%d], val: %d\n", index, val);
    int hash_index = index % numsSize;
    linklist_t *temp = map[hash_index];
    if(temp == NULL) {
        // first time
        temp = generate_node();
        temp->val = val;
        map[hash_index] = temp;
        return;
    }
    // printf("alrealy %d\n", index);
    linklist_t *last = temp;
    for(;temp!=NULL;temp=temp->next) {
        last = temp;
    }

    temp = generate_node();
    temp->val = val;
    last->next = temp;
}

bool search_and_remove(linklist_t **map, int index, int val, int numsSize) {
    int hash_index = index%numsSize;
    for(linklist_t *a=map[index%numsSize];a!=NULL;a=a->next) {
        if(a->val == val) {
            map[hash_index] = map[hash_index]->next;
            // printf("Remove %d, %d\n", index, val);
            return true;
        }
    }

    return false;
}


/* Using hash mapping */
int maxOperations(int *nums, int numsSize, int k) {
    linklist_t **map = malloc(numsSize*sizeof(linklist_t *));
    memset(map, 0, numsSize*sizeof(linklist_t *));

    int count = 0;
    /* X + Y = K => X = K-Y, search X or K-Y -> Get the same value */
    for(int i=0;i<numsSize;i++) {
        int k_y = k - nums[i];
        if(k_y < 0 || k_y >= k || nums[i] >= k) continue;
        if(search_and_remove(map, k_y, nums[i], numsSize)) {
            count++;
        }
        else {
            insert_chaining_hash(map, nums[i], k_y, numsSize);
        }
    }

    return count;
}
