class Solution {
public:
    class SegmentTree {
        public:
        vector<int> seg;
        int maxN;
		
        SegmentTree(int n) : maxN(n) {
            seg = vector<int>(maxN * 4 + 10, 0);
        }
        int query(int l, int r) {
            return query_util(0, 0, maxN - 1, l, r);
        }
        int query_util(int i, int low, int high, int l, int r) {
            if(low >= l && high <= r)
                return seg[i];
            if(high < l || low > r)
                return INT_MIN;
            int mid = (high + low) / 2;
            int left = query_util(2 * i + 1, low, mid, l, r);
            int right = query_util(2 * i + 2, mid + 1, high, l, r);
            return max(left, right);
        }
        void update(int len, int ele) {
            update_util(0, 0, maxN - 1, ele, len);
        }
        void update_util(int i, int low, int high, int ele, int len) {
            if(low == high) {
                seg[i] = len;
                return;
            }
            int mid = low + (high - low) / 2;
            if(low <= ele && ele <= mid) {
                update_util(2 * i + 1, low, mid, ele, len);
            } else {
                update_util(2 * i + 2, mid + 1, high, ele, len);
            }
            seg[i] = max(seg[2 * i + 1], seg[2 * i + 2]);
        }
    };
	
    int lengthOfLIS(vector<int>& nums, int k) {
        int max_ele = nums[0];
        for(auto it : nums)
            max_ele = max(max_ele, it);
			
        SegmentTree seg(max_ele + 1);
        
        for(auto it : nums) {
            int lower = max(0, it - k);
            int longestIncreasingBefore = 1 + seg.query(lower, it - 1);
            seg.update(longestIncreasingBefore, it);
        }
        
        return seg.query(1, max_ele);
    }
};