class Solution {
public:
    int rotatedDigits(int N) {
        int count = 0, size = 1;
        if(N > 9) count += 4;
        if(N > 99) count += 36; // 4 * 7 + 2 * 4
        if(N > 999) count += 276; // 7 * 7 * 7 - 1 * 7 * 7 - 2 * 3 * 3;
        count += dfs(to_string(N));
        return count;
    }
    int dfs(string N, int i = 0, int hf = false, char last = '.') {
        int count = 0, size = N.size();
        if(i == size) return hf;
        if(i > 0 && N[i-1] > last) return hf ? combs1[size-i-1] : combs2[size-i-1];
        for(const char n: nums) {
            if(n == '0' && i == 0) continue;
            if(n <= N[i]) count += dfs(N, i+1, hf || isFree(n), n);
            else break;
        }
        return count;
    }
    static inline bool isFree(char c) {
        return c == '2' || c == '5' || c == '6' || c == '9';
    }
    
    vector<char> nums = {'0', '1', '2', '5', '6', '8', '9'}; // valid nums
    vector<int> combs1 = {7, 49, 343}; // 7, 7*7, 7*7*7 // No restriction
    vector<int> combs2 = {4, 40, 316}; // 7 - 3, 7*7 - 3*3, 6*7*7 - 2*3*3// At least 1 unique
};