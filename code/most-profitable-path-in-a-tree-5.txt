class Solution
{
public:
    int mostProfitablePath(vector<vector<int>> &edges, int bob, vector<int> &amount)
    {
        int n = edges.size() + 1;
        vector<int> adj[n];

        for (auto &x : edges)
        {
            adj[x[0]].push_back(x[1]);
            adj[x[1]].push_back(x[0]);
        }
        vector<int> p(n, -1); // parent array
        vector<int> t(n);     // time array
        vector<int> vis(n);   // visited array

        queue<int> bq;
        bq.push(bob);
        t[bob] = 0;
        vis[bob] = 1;

        while (!bq.empty())
        {
            int x = bq.front();
            bq.pop();
            for (int y : adj[x])
            {
                if (vis[y] == true)
                    continue;
                p[y] = x;
                vis[y] = 1;
                t[y] = t[x] + 1;
                bq.push(y);
            }
        }
        set<int> st; // nodes in path of Bob->0
        int node = 0;
        while (node != -1)
        {
            st.insert(node);
            node = p[node];
        }
        // set time for all the non-visited nodes as -1
        for (int i = 0; i < n; i++)
            if (st.find(i) == st.end())
                t[i] = -1;

        vis.assign(n, 0);
        queue<pair<int, pair<int, int>>> q;
        int ans = INT_MIN;
        q.push({0, {0, 0}});

        while (!q.empty())
        {
            auto node = q.front();
            q.pop();
            int x = node.first;           // curr node
            int ct = node.second.first;   // curr time
            int val = node.second.second; // curr val for alice

            if (vis[x] == true)
                continue;
            vis[x] = true;

            if (t[x] == -1)               //case 1
                val += amount[x];
            else if (ct == t[x])          //case 2
                val += amount[x] / 2;
            else if (ct < t[x])           //case 3
                val += amount[x];

            if (adj[x].size() == 1 && x != 0) // if it is a leaf node
                ans = max(ans, val);

            for (int y : adj[x])
                q.push({y, {ct + 1, val}});
        }
        return ans;
    }
};