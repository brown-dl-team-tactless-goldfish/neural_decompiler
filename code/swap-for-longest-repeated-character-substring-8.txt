class Solution {
public:
    int maxRepOpt1(string text) {
        int res = 0; // result
        unordered_map<char, vector<pair<int, int>>> blocks; // store blocks for each character, a block means consecutive same characters, pair<int, int> is a block's starting and ending points
        for (int i = 0, j = 0; j < text.size(); i = j)
        {
            char c = text[i];
            while (j < text.size() && text[j] == c)
            {
                ++j; // find a block
            }
            
            blocks[c].push_back({i, j - 1}); // add block 
        }
        
        for (const auto& pair : blocks)
        {
            const auto& v = pair.second;
            for (int i = 0; i < v.size(); ++i)
            {
                int len = v[i].second - v[i].first + 1; // length of current block
                if (i + 1 < v.size() && v[i + 1].first - v[i].second == 2) // if there exists 1 block separated by 1 character
                {
                    len += v[i + 1].second - v[i + 1].first + (v.size() > 2 ? 2 : 1); // combine 2 blocks
                }
                else if (v.size() > 1) // if there exists other blocks but none of them separated by 1 letter 
                {
                    ++len; // swap a letter
                }
                
                res = max(res, len);
            }
        }
        
        return res;
    }
};