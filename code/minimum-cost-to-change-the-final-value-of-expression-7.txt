struct Result {
    bool v;
    int cost;
};

Result Parse(const char** p) {
    char op = '\0';
    bool first = true;
    Result res;
    while (**p != ')' && **p != '\0') {
        bool has_child = false;
        Result child;
        switch (**p) {
            case '0':
            case '1':
                child = {(**p - '0') == 1, 1};
                has_child = true;
                break;
            case '&':
            case '|':
                op = **p;
                break;
            case '(':
                (*p)++;
                child = Parse(p);
                has_child = true;
                break;
        }
        (*p)++;
        if (!has_child) continue;
        if (first) {
            res = child;
            first = false;
            continue;
        }
        if (op == '&' && child.v == 0) {
            if (res.v == 0) {  // 0&0 change to 1
                res.cost = min(res.cost + 1, child.cost + 1);
            } else {
                // 1&0 change to 1
                res.cost = 1;
            }
            res.v = 0;
        } else if (op == '&' && child.v == 1) {
            if (res.v == 0) {
                res.cost = 1;
            } else {
                res.cost = min(res.cost, child.cost);
            }
        } else if (op == '|' && child.v == 0) {
            if (res.v == 0) {  // 0|0 => 1
                res.cost = min(res.cost, child.cost);
            } else {
                res.cost = 1;
            }
        } else {  // op == |, cv == 1
            if (res.v == 0) {
                res.cost = 1;
            } else {
                res.cost = min(res.cost + 1, child.cost + 1);
            }
            res.v = 1;
        }
    }
    return res;
}

class Solution {
public:
    int minOperationsToFlip(string e) {
        const char* s = e.c_str();
        return Parse(&s).cost;
    }
};

