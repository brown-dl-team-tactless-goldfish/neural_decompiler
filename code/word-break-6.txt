struct word {
        char *s;
        int len;
        struct word *next;
};

bool is_word(char *s, int len, struct word *hd)
{
        char c = *s;
        struct word *w = hd[c - 'a'].next;
        
        while (w) {
                if (w->len == len && !strncmp(s, w->s, len))
                        return true;
                w = w->next;
        }

        return false;
}

bool __word_break(char *s, int len, int *memo, struct word *hd)
{
        if (!len)
                return true;
        
        if (memo[len - 1] != -1)
                return memo[len - 1];

        int i;
        for (i = 1; i <= 20 && i <= len; i++) {
                if (is_word(s, i, hd) && __word_break(s + i, len - i, memo, hd)) {
                        memo[len - 1] = 1;
                        return true;
                }
        }
        
        memo[len - 1] = 0;
        return false;
}

struct word *new_word(char *s)
{
        struct word *new = malloc(sizeof(struct word));
        new->next = NULL;
        new->s = s;
        new->len = strlen(s);
        return new;
}

void init_hash_dict(struct word *hd, char **wordDict, int wordDictSize)
{
        int i;
        char *s;
        char c;
        
        for (i = 0; i < wordDictSize; i++) {
                s = wordDict[i];
                c = *s;
                struct word *tmp = &hd[c - 'a'];
                while (tmp->next)
                        tmp = tmp->next;
                tmp->next = new_word(s);
        }
}

bool wordBreak(char * s, char ** wordDict, int wordDictSize)
{
        int i;
        int memo[300] = {0};
        for (i = 0; i < 300; i++)
                memo[i] = -1;
        
        struct word hd[26] = {{0}}; //hash dictionary
        init_hash_dict(hd, wordDict, wordDictSize);
        
        int len = strlen(s);
        return __word_break(s, len, memo, hd);
}