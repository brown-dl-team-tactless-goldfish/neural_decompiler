class Solution:
    def isPrintable(self, targetGrid: List[List[int]]) -> bool:
        N, M, colors = len(targetGrid), len(targetGrid[0]) if len(targetGrid) else 0, max( max(r) for r in targetGrid )
        boundry = [(N, 0, M, 0)]*(colors+1) # boundry[i] = (a, b, c, d) if the color shows in rows [a:b+1] and colums [c:d+1]
        resolved = set()
        for x in range(N):
            for y in range(M):
                c = targetGrid[x][y]
                boundry[c] = min(x, boundry[c][0]), max(x, boundry[c][1]), min(y, boundry[c][2]), max(y, boundry[c][3])
        
        def cleanRectangle(color: int) -> bool: # if we can form a rectangle, remove this color (label 0)
            frX, toX, frY, toY = boundry[color]
            if color in resolved:
                return True
            for i in range(frX, toX+1):
                for j in range(frY, toY+1):
                    if targetGrid[i][j] == color:
                        targetGrid[i][j] = -1
                    elif targetGrid[i][j] == -1: # circle back to a unsolved color, detect a deadlock (circular dependency)
                        return False
                    elif targetGrid[i][j] > 0 and not cleanRectangle(targetGrid[i][j]):
                        return False
            for i in range(frX, toX+1):
                for j in range(frY, toY+1):
                    targetGrid[i][j] = 0
            resolved.add(color)
            return True
        
        for i in range(N):
            for j in range(M):
                if targetGrid[i][j] and not cleanRectangle(targetGrid[i][j]):
                    return False
        return True