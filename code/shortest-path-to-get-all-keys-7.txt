int stepsMp[30][30][1 << 6];

int dx[] = {0, 0, -1, 1};
int dy[] = {-1, 1, 0, 0};

class Solution {
public:
    int shortestPathAllKeys(vector<string>& grid) {
        memset(stepsMp, -1, sizeof(stepsMp));
        int n = grid.size(), m = grid[0].size();
        int keys = 0;
        int all = 0;
        int si, sj;
        for (int i=0; i < n; i++) for (int j=0; j < m; j++) {
            char c = grid[i][j];
            if (c == '@') {si = i; sj = j;}
            
            if (c >= 'a' && c <= 'f') keys++;
        }
        
        all = (1 << keys) - 1;
        
        queue<vector<int>> q; // x, y, steps, state
        stepsMp[si][sj][0] = 0;
        q.push({si, sj, 0, 0});
        
        while (!q.empty()) {
            auto t = q.front(); q.pop();
            
            for (int i = 0; i < 4; i++) {
                int x = t[0] + dx[i], y = t[1] + dy[i], steps = t[2] + 1, state = t[3];
                
                if (x < 0 || y < 0 || x >= n || y >= m) continue;
                
                char c = grid[x][y];
                if (c == '#') continue;
                if (c >= 'A' && c <= 'F') {
                    int d = c - 'A';
                    if ( ((1<<d) & state) == 0) continue;
                } 
                
                if (c >= 'a' && c <= 'f') {
                    int d = c - 'A';
                    state |= (1<<d);
                }
                if (state == all) return steps;
                
                if (stepsMp[x][y][state] == -1) {
                    q.push({x, y, steps, state});
                    stepsMp[x][y][state] = steps;
                }
                
            }
        }
        return -1;
    }
};