pair<int, int> minOperationsToFlip_(const string& s, vector<int>& m, int sIdx, int eIdx) {

	while (m[sIdx] >= 0 && m[sIdx] == m[eIdx]) ++sIdx, --eIdx;

	if (sIdx == eIdx) return {s[sIdx] - '0', 1};

	int idx = eIdx;

	int balance = 0;

	while (1) {
		if (s[idx] == ')') ++balance;
		else if (s[idx] == '(') --balance;
		if (balance == 0) break;
		--idx;
	}

	pair<int, int> a = minOperationsToFlip_(s, m, sIdx, idx - 2);
	pair<int, int> b = minOperationsToFlip_(s, m, idx, eIdx);

	int curr, minOper;

	if (s[idx - 1] == '|') {
		if (a.first == 0 && b.first == 0) curr = 0;
		else curr = 1;

		if (a.first == 0 && b.first == 0) {
			minOper = min(a.second, b.second);
		} else if (a.first == 1 && b.first == 1) {
			minOper = min(a.second, b.second) + 1;
		} else {
			minOper = 1;
		}

	} else {
		if (a.first == 1 && b.first == 1) curr = 1;
		else curr = 0;

		if (a.first == 0 && b.first == 0) {
			minOper = min(a.second, b.second) + 1;
		} else if (a.first == 1 && b.first == 1) {
			minOper = min(a.second, b.second);
		} else {
			minOper = 1;
		}

	}

	return {curr, minOper};
}

int minOperationsToFlip(string expression) {

	vector<int> m(expression.size(), -1);
	stack<int> myStack;
	int cnt = 0;

	for (int i = 0; i < expression.size(); ++i) {
		if (expression[i] == '(') myStack.push(i);
		else if (expression[i] == ')') {
			m[i] = cnt;
			m[myStack.top()] = cnt;
			myStack.pop();
			++cnt;
		}
	}

	return minOperationsToFlip_(expression, m, 0, (int)expression.length() - 1).second;
}