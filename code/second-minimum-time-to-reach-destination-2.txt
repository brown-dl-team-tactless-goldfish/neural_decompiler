class Solution {
public:
public:
    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {
        unordered_map<int, unordered_set<int>> g;
        for(auto& e : edges) {
            g[e[0]].insert(e[1]);
            g[e[1]].insert(e[0]);
        }

        queue<int> q;
        q.push(1);
        int dist[10001]{}, one_more_step[10001]{};
        dist[1] = 1;
        int step = 2;
        while(!q.empty()) {
            for(int i = q.size(); i > 0; i--) {
                int t = q.front(); q.pop();
                for(int nxt : g[t]) if(dist[nxt] == step-1 || one_more_step[nxt]) one_more_step[t] = 1;
                for(int nxt : g[t]) {
                    if(!dist[nxt]) {
                        q.push(nxt);
                        dist[nxt] = step;
                    }
                }
            }
            step++;
        }

        step = one_more_step[n] ? dist[n] : dist[n]+1;
        int ans = 0;
        for(int i = 0; i < step; i++) {
            ans += time;
            if(i < step -1) {
                int mul = ans/change;
                if(mul%2) ans = (mul+1)*change;
            }
        }
        return ans;
    }
};