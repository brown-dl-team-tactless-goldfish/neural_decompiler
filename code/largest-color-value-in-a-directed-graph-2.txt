class Solution {
public:
    vector<int>ADJ[100010], memo[100010];
    vector<int>visited;
    string C;
    bool isCycle(int node) {
        if (visited[node]) return true;
        visited[node] = 1;
        for (int next_node : ADJ[node]) if (visited[next_node] == 0 && isCycle(next_node)) return true;
        else if (visited[next_node] == 1) return true;
        visited[node] = 2;
        return false;
    }
    vector<int> dfs(int node) {
        if (memo[node].size() > 0) return memo[node];
        visited[node] = true;
        int color = C[node] - 'a';
        vector<int>ret(26, 0);
        ret[color] = 1;
        for (int next_node : ADJ[node]) {
            vector<int>f = dfs(next_node);
            f[color]++;
            for (int i = 0; i < 26; i++) ret[i] = max(ret[i], f[i]);
        }
        return memo[node] = ret;
    }
    int largestPathValue(string colors, vector<vector<int>>& edges) {
        C = colors;
        int n = colors.size();
        visited = vector<int>(n, 0);
        for (vector<int> edge : edges) {
            int u = edge[0], v = edge[1];
            ADJ[u].push_back(v);
        }
        for (int i = 0 ; i < n; i++) if (!visited[i]) if (isCycle(i)) return -1;
        int ans = 0;
        for (int i = 0; i < n; i++) if (memo[i].size() ==0) {
            dfs(i);
            for (int j = 0; j < 26; j++) ans = max(memo[i][j], ans);
        }
        return ans;
    }
};