#define MOD 1000000007

class Solution {
public:
    int numberOfSets(const int n, const int k) {
        /* Assume i-1 blocks occupied by segments out of n-1 total "blocks"
		   (each block is defined as range [x, x+1] for 0 <= x < n, and in range [0, i] there are i-1 blocks.)
		   
           Ways of assigning i-1 blocks to k segments: choose(i+k-1, k-1) 
		   (see "stars and bars" problem for how to derive this formula)
		   
           Each segment must have at least 1 block, 
		   so we actually only have (i+k-1)-k = i-1 blocks that are free to be assigned
		   Thus, actual formula becomes: choose(i-1, k-1)
        
           Ways of assigning n-1-(i-1) empty blocks to k+1 possible spots (in between each of the k segments): 
		   choose(n-1-i+k, k)
		
		   Ways of assigning i blocks to k segments out of n-1 total blocks thus becomes: 
		   choose(i-1,k-1) * choose(n-1-i+k, k)
		   
		   Since we can assign anywhere between k and n blocks to be occupied by the k segments,
		   the total combination count becomes:
		   
		   count = sum{choose(i-1,k-1) * choose(n-1-i+k,k), k <= i <= n}
		  
		   We can use DP to get all the choose(a, b) values needed for calculating count. 
		   for aCb matrix:
		   max_a: i+k-1 -> [2k-1, n+k-1], n-i+k -> [n-2k, n], max_a = n+k-1
		   max_b: k
		*/
		
        std::vector<std::vector<int>> dp(n+k, std::vector<int>(k+1, 0));
        for(int i{0}; i < n+k; ++i) dp[i][0] = 1;
        for(int i{1}; i < n+k; ++i)
            for(int j{1}, stop{std::min(i,k)}; j <= stop; ++j)
                dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % MOD;
        
		int64_t count{0};
        for(int i{k}; i <= n; ++i) count = (count + ((int64_t)dp[i-1][k-1] * (int64_t)dp[n-i+k-1][k]) % MOD) % MOD;
        
        return count;
    }
};