public class Solution 
{
    public int MinimumMoves(int[][] grid) 
    {
        int r = grid.Length, c = grid[0].Length;
        var queue = new Queue<int[]>();
        queue.Enqueue(new int[] {0, 0, 0});
        var visited = new bool[r,c,2];
        visited[0, 0, 0] = true;
        int depth = 0;
        while(queue.Count != 0)
        {
            var count = queue.Count();
            while(count-- != 0)
            {
                var curr = queue.Dequeue();
                int x = curr[0], y = curr[1], dir = curr[2];
                if((x == r - 1 && y == c - 2 && dir == 0))
                    return depth;
                List<int[]> next = new List<int[]>();
                if(dir == 0)
                {
                    if(y + 2 < c && grid[x][y + 2] == 0)
                        next.Add(new[] {x, y + 1, 0});
                    if(x + 1 < r && grid[x + 1][y] == 0 && grid[x + 1][y + 1] == 0)
                    {
                        next.Add(new[] {x, y, 1});
                        next.Add(new[] {x + 1, y, 0});
                    }
                }
                else
                {
                    if(x + 2 < r && grid[x + 2][y] == 0)
                        next.Add(new[] {x + 1, y, 1});
                    if(y + 1 < c && grid[x][y + 1] == 0 && grid[x + 1][y + 1] == 0)
                    {
                        next.Add(new[] {x, y, 0});
                        next.Add(new[] {x, y + 1, 1});
                    }
                }
                    
                foreach(var n in next)
                {
                    if(!visited[n[0], n[1], n[2]])
                    {
                        visited[n[0], n[1], n[2]] = true;
                        queue.Enqueue(n);
                    }
                }
            }
            
            depth++;
        }
        
        return -1;
    }
}