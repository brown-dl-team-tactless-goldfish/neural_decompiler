#define TABLE_BITS 12
#define ITEM_MASK (0xfff)
#define TABLE_SIZE ((INT_MAX >> TABLE_BITS) + 1)
#define ITEM_SIZE ((ITEM_MASK >> 5) + 1)

struct HH_ITEM {
    int count;
    unsigned int val[ITEM_SIZE];
};

/* you don't need keep all possible value, just need 1 bit to check */
void add_hh_item(struct HH_ITEM **table, int value) {
    if (table[value >> TABLE_BITS] == NULL) {
        table[value >> TABLE_BITS] = (struct HH_ITEM *)malloc(sizeof(struct HH_ITEM));
        table[value >> TABLE_BITS]->count = 0;
        for (int i = 0; i < ITEM_SIZE; i++) table[value >> TABLE_BITS]->val[i] = 0;
    }

    if ((table[value >> TABLE_BITS]->val[(value & ITEM_MASK) >> 5] & 1U << (value & 0x1f)) == 0) {
        table[value >> TABLE_BITS]->val[(value & ITEM_MASK) >> 5] |= 1U << (value & 0x1f);
        table[value >> TABLE_BITS]->count++;
    }
}

int subarrayBitwiseORs(int *arr, int arrSize) {
    struct HH_ITEM *table[TABLE_SIZE] = {0};
    int subarr[32] = {0};
    int pos = 0;

    subarr[0] = arr[0];
    pos = 1;
    add_hh_item(table, subarr[0]);

    for (int i = 1; i < arrSize; i++) {
        // skip same value
        if (arr[i] == arr[i - 1]) continue;

        for (int j = 0; j < 32; j++) {
            subarr[j] |= arr[i];
            add_hh_item(table, subarr[j]);
        }

        subarr[pos] = arr[i];
        add_hh_item(table, subarr[pos]);
        pos++;
        pos &= 0x1f;
    }

    // count possible results
    int sum = 0;
    for (int i = 0; i < TABLE_SIZE; i++) {
        if (table[i] != NULL) {
            sum += table[i]->count;
            free(table[i]);
        }
    }

    return sum;
}