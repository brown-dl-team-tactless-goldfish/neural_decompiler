class Solution {
public:
    int minimumMoves(vector<vector<int>>& nums) {
        map<tuple<int,int,int>,int> mp;  // tuple stores 3 parameter
                                         // {row of head of snake, col of head of snake, alignment of snake}
										 // alignment = 0 mean horizontal, alignment = 1 means vertical
        queue<vector<int>> q;  //stores {row of head of snake, col of head of snake, alignment of snake}
        q.push({0,1,0}); mp[{0,1,0}]++;
        int l = 0,n=nums.size();
        while(!q.empty()){
            int s = q.size();
            while(s--){
                vector<int> t = q.front(); q.pop();
                int i = t[0], j =t[1];
                if(i==n-1 && j==n-1 && t[2]==0) return l; // check the destination, and return currenet level if found
                if(t[2]==0){  // if direction is horizontal
                    if(j+1<n && nums[i][j+1]==0 && mp.find({i,j+1,0})==mp.end()){ // check if it can move to right 
                        mp[{i,j+1,0}]++; q.push({i,j+1,0});
                    }
                    if(i+1<n && nums[i+1][j]==0 && nums[i+1][j-1]==0){
                        if(mp.find({i+1,j,0})==mp.end()){  // check if it can move to down 
                           mp[{i+1,j,0}]++; q.push({i+1,j,0}); 
                        }
                        if(mp.find({i+1,j-1,1})==mp.end()){   // check if it can rotate clockwise 
                            mp[{i+1,j-1,1}]++; q.push({i+1,j-1,1}); 
                        }
                    }
                }
                else{    // if direction is vertical 
                    if(i+1<n && nums[i+1][j]==0 && mp.find({i+1,j,1})==mp.end()) {  // check if it can move to down 
                        mp[{i+1,j,1}]++; q.push({i+1,j,1});
                    }
                    if(j+1<n && nums[i][j+1]==0 && nums[i-1][j+1]==0){
                        if(mp.find({i,j+1,1})==mp.end()){   // check if it can move to right 
                            mp[{i,j+1,1}]++; q.push({i,j+1,1});
                        }
                        if(mp.find({i-1,j+1,0})==mp.end()){   // check if it can rotate anticlockwise
                            mp[{i-1,j+1,0}]++; q.push({i-1,j+1,0});
                        }
                    } 
                }
            }
            l++;
        }
        return -1;
    }
};