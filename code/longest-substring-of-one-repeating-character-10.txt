class Solution {
public:
  // Find parent using binary search
  int getParent(int idx, map<int, int>& parentToLen) {
    auto parentIt = parentToLen.lower_bound(idx);
    if (parentIt != parentToLen.end() && parentIt->first == idx) {
      return idx;
    } else {
      return (--parentIt)->first;
    }
  }
  
  vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {
    int n = s.size();
    int numQueries = queryCharacters.size();
    
    // The previous character
    char prev = '\0';
    int parentIdx = -1;
    
    // Stores the mapping of parent to the patch of repeating characters
    map<int, int> parentToLen;
    // Stores the mapping of lengths to the number of parents with that length
    map<int, int> lenToNumParents;
    
    // Populate parentToLen
    for (int i = 0; i < n; ++i) {
      char c = s[i];
      if (prev) {
        if (c == prev) {
          parentToLen[parentIdx]++;
        } else {
          parentIdx = i;
          parentToLen[i] = 1;
        }
      } else {
        parentIdx = i;
        parentToLen[i] = 1;
      }
      prev = c;
    }
    // Populate lenToNumParents
    for (auto it = parentToLen.begin(); it != parentToLen.end(); ++it) {
      lenToNumParents[it->second]++;
    }
    
    vector<int> result;
    for (int q = 0; q < numQueries; ++q) {
      char qC = queryCharacters[q];
      int qI = queryIndices[q];
      char original = s[qI];
      
      // Just re-use the old result if qC is the same as the original char
      if (qC == original) {
        if (!result.empty()) {
          result.push_back(result.back());
        } else {
          result.push_back(lenToNumParents.rbegin()->first);
        }
        continue;
      }
      
      // Information about the char on the left (if any)
      char left = '\0';
      int leftParent = -1;
      int leftParentLen = -1;
      if (qI > 0) {
        left = s[qI - 1];
        leftParent = getParent(qI - 1, parentToLen);
        leftParentLen = parentToLen[leftParent];
      }
      
      // Information about the char on the right (if any)
      char right = '\0';
      int rightParent = -1;
      int rightParentLen = -1;
      if (qI < (n - 1)) {
        right = s[qI + 1];
        rightParent = getParent(qI + 1, parentToLen);
        rightParentLen = parentToLen[rightParent];
      }
      
      if (left && right && left == qC && qC == right) {
        // Bridging two patches
        lenToNumParents[parentToLen[leftParent]]--;
        parentToLen[leftParent] += (1 + rightParentLen);
        lenToNumParents[parentToLen[leftParent]]++;
        
        lenToNumParents[parentToLen[rightParent]]--;
        lenToNumParents[parentToLen[qI]]--;
        parentToLen.erase(rightParent);
        parentToLen.erase(qI);
      } else if (left && right && left == original && original == right) {
        // Breaking up a patch
        lenToNumParents[parentToLen[leftParent]]--;
        lenToNumParents[parentToLen[qI + 1]]--;
        lenToNumParents[parentToLen[qI]]--;
        parentToLen[qI + 1] = leftParent + leftParentLen - qI - 1;
        parentToLen[leftParent] = qI - leftParent;
        parentToLen[qI] = 1;
        lenToNumParents[parentToLen[leftParent]]++;
        lenToNumParents[parentToLen[qI + 1]]++;
        lenToNumParents[parentToLen[qI]]++;
      } else {
        if (left && left == qC) {
          // Forming left edge of patch
          lenToNumParents[parentToLen[leftParent]]--;
          parentToLen[leftParent]++;
          lenToNumParents[parentToLen[leftParent]]++;
          lenToNumParents[parentToLen[qI]]--;
          parentToLen.erase(qI);
        } else if (left && left == original) {
          // Breaking left edge of patch
          lenToNumParents[parentToLen[leftParent]]--;
          parentToLen[leftParent]--;
          lenToNumParents[parentToLen[leftParent]]++;
        }
        if (right && qC == right) {
          // Forming right edge of patch
          lenToNumParents[parentToLen[qI]]--;
          parentToLen[qI] = 1 + rightParentLen;
          lenToNumParents[parentToLen[qI]]++;
          lenToNumParents[parentToLen[rightParent]]--;
          parentToLen.erase(rightParent);
        } else if (right && original == right) {
          // Breaking right edge of patch
          lenToNumParents[parentToLen[qI + 1]]--;
          parentToLen[qI + 1] = rightParentLen - 1;
          lenToNumParents[parentToLen[qI + 1]]++;
          lenToNumParents[parentToLen[rightParent]]--;
          parentToLen.erase(rightParent);
        }
        if (left != qC && qC != right) {
          // Just a single character change
          lenToNumParents[parentToLen[qI]]--;
          parentToLen[qI] = 1;
          lenToNumParents[parentToLen[qI]]++;
        }
      }
      
      vector<int> lensToErase;
      for (auto it = lenToNumParents.rbegin(); it != lenToNumParents.rend(); ++it) {
        if (it->second == 0) {
          lensToErase.push_back(it->first);
        }
        if (it->second > 0) {
          result.push_back(it->first);
          break;
        }
      }
      
      // Remove lens otherwise they clutter the map
      for (int len: lensToErase) {
        lenToNumParents.erase(len);
      }
      
      // Update the string
      s[qI] = qC;
    }

    return result;
  }

};