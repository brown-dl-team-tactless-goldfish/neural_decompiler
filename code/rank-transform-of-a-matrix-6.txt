using PII = pair<int, int> ;
class Solution {
    vector<int>Father ;
    int findFather(int x){
        if(x != Father[x])
            Father[x] = findFather(Father[x]) ;
        return Father[x] ;
    }
    
    void unionSet(int a, int b){
        a = Father[a] ;
        b = Father[b] ;
        if(a < b)
            Father[b] = a ;
        else
            Father[a] = b ;
    }
public:
    vector<vector<int>> matrixRankTransform(vector<vector<int>>& matrix) {
        int m = matrix.size() ;
        int n = matrix[0].size() ;
        Father.resize(m * n) ;
        for(int i = 0; i < m*n; i++)
            Father[i] = i ;
        vector<vector<int>>next(m*n) ;
        vector<int>inDegree(m*n) ;
        for(int i = 0; i < m; i++){
            vector<PII>tmp ;  //{value, index}
            for(int j = 0; j < n; j++)
                tmp.push_back({matrix[i][j], i*n+j}) ;
            
            sort(tmp.begin(), tmp.end()) ;
            for(int j = 1; j < n; j++){
                int preIidx = tmp[j-1].second ;
                int curIdx = tmp[j].second ;
                if(tmp[j-1].first < tmp[j].first){
                    next[preIidx].push_back(curIdx) ;
                    inDegree[curIdx]++ ;
                }
                else{
                    if(findFather(preIidx) !=  findFather(curIdx))
                        unionSet(preIidx, curIdx) ;
                }
            }
        }

        for(int j = 0; j < n; j++){
            vector<PII>tmp ;
            for(int i = 0; i < m; i++)
                tmp.push_back({matrix[i][j], i*n+j}) ;
            sort(tmp.begin(), tmp.end()) ;
            for(int i = 1; i < m; i++){
                int preIidx = tmp[i-1].second ;
                int curIdx = tmp[i].second ;
                if(tmp[i-1].first < tmp[i].first){
                    next[preIidx].push_back(curIdx) ;
                    inDegree[curIdx]++ ;
                }
                else{
                    if(findFather(preIidx) !=  findFather(curIdx))
                        unionSet(preIidx, curIdx) ;
                }                
            }
        }

        unordered_map<int, vector<int>>group ; // {index, index of the same value}
        //build group
        for(int i =0; i < m; i++){
            for(int j = 0; j < n; j++){
                int root = findFather(i*n+j) ;
                group[root].push_back(i*n + j) ;
                if(root != i*n + j)
                    inDegree[root] += inDegree[i*n+j] ;
            }
        }
        queue<int>q ; //{idx} ;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(Father[i*n+j] == i*n+j && inDegree[i*n+j] == 0)
                    q.push(i*n+j) ;
            }
        }
        int rank = 1 ;
        auto rets = vector<vector<int>>(m, vector<int>(n)) ;
        while(!q.empty()){
            int sz = q.size() ;
            for(int i = 0; i < sz; i++){
                int cur = q.front() ;
                q.pop() ;
                
                for(auto& g : group[cur]){
                    rets[g/n][g%n] = rank ;
                    for(auto& nxt : next[g]){
                        inDegree[Father[nxt]]-- ;
                        if(inDegree[Father[nxt]] == 0)
                            q.push(Father[nxt]) ;
                    }
                }
            }
            rank++ ;
        }
        return rets;
    }
};