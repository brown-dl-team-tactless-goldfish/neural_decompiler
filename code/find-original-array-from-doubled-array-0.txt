int cmpfunc( const void* p1,  const void* p2){
   int* arr1 = *(int**)p1;
   int* arr2 = *(int**)p2; 
  return arr1[0] - arr2[0];
}

int checkItemInArray(int** set, int setSize, int val, int cn){
    int left = 0, right = setSize-1, mid;
    while(left < right){
        mid = left + (right - left)/2;
        if(set[mid][0] == val){
            if(set[mid][1] >= cn){
                set[mid][1] -= cn;
                return mid;
            }
            else
                return -1;
        }
        else if(set[mid][0] > val)
            right = mid -1;
        else 
            left = mid + 1;
    }
    
    if(set[left][0] == val && set[left][1] >= cn){
        set[left][1] -= cn;
        return left;
    }
    else 
        return -1;    
}

int* findOriginalArray(int* changed, int changedSize, int* returnSize){
    //changedSize is odd number, then return NULL
    if(changedSize%2 == 1){
        * returnSize = 0;
        return NULL;
    }
    
    * returnSize = 0;
    
    //O(n), iterate each item, get the set<val, count>
    //>>>>> 
    int* hash = calloc(1e5 + 1, sizeof(int));
    int** set = malloc(changedSize * sizeof(int*));
    int setSize = 0;
    for(int i = 0; i < changedSize; i++){
        hash[changed[i]]++;
        if(hash[ changed[i] ] == 1){
            set[setSize] = malloc(2 * sizeof(int));
            set[setSize][0] = changed[i];
            setSize++;
        }
    }
    for(int i = 0; i < setSize; i++){
        set[i][1] = hash[ set[i][0] ] ;
    }
    free(hash);
    //<<<< end set<val, count>
    //sort set's 1st item    
    qsort(set, setSize, sizeof(int*), cmpfunc);

    int ptr = 0, post = setSize-1;
    int idx = 0;
    
    int* final = malloc(setSize * sizeof(int));
    int* finalcn = malloc(setSize * sizeof(int));
    int p = 0;  //for final[] and finalcn[]
    while(idx < changedSize/2 ){
        if(set[ptr][1] == 0){
            for(int i = ptr+1; i < setSize; i++){
                if(set[i][1] > 0){
                    ptr = i;
                    break;
                }                        
            }
        }
        //special case: data is 0, the numbers should be even.
        if(set[ptr][0] == 0){
            if(set[ptr][1] % 2 == 1){
                return NULL;
            }
            idx += (set[ptr][1]/2);
            final[p] = set[ptr][0];
            finalcn[p] = set[ptr][1]/2;
            p++;
            set[ptr][1] = 0;  //already checked
            ptr++;
            //next cycle
            continue;
        }
        
        //other smallest val
        if( checkItemInArray(set, setSize, set[ptr][0] * 2, set[ptr][1]) == -1){
            return NULL;    
        }
        idx += set[ptr][1];
        final[p] = set[ptr][0];
        finalcn[p] = set[ptr][1];
        p++;        
        set[ptr][1] = 0; //already checked
        ptr++;
    }
    
    int id= 0;
    int* ans = malloc((changedSize/2) * sizeof(int));
    for(int i = 0; i < p; i++){
        for(int j = 0; j < finalcn[i]; j++){
            ans[id] = final[i];
            id++;
        }

    }
    * returnSize = id;
    return ans;
}