 #include<stdlib.h>
struct Data1
{
	int num[20];
	int size;
	int tried;
};
struct Data2
{
	int num[81];
	int size;
	int righte;
};
struct Data1** creatdata1()
{
	int i;
	struct Data1** data1 = (struct Data1**)malloc(sizeof(struct Data1*) * 81);
	for (i = 0; i < 81; i++)
		data1[i] = (struct Data1*)malloc(sizeof(struct Data1));
	for (i = 0; i < 81; i++)
		data1[i]->size = data1[i]->tried = 0;
	return data1;
}
struct Data2* creatdata2()
{
	struct Data2* data2 = (struct Data2*)malloc(sizeof(struct Data2));
	data2->size = data2->righte = 0;
	return data2;
}
void data1Add(struct Data1** data1,int i, int j, int val)
{
	if (val == '.' - '0')return;
	int k = i * 9 + j;
	int flag = 1;
	for (int a = 0; a < data1[k]->size; a++)
		if (data1[k]->num[a] == val) flag = 0;
	if (flag)
	{
		data1[k]->size += 1;
		data1[k]->num[data1[k]->size-1] = val;
		return;
	}
	return;
	
}
void addRefreshData1(struct Data1** data1, int i,int j, int num)
{
	for (int k = 0; k < 9; k++) {
		data1Add(data1, i, k, num);
		data1Add(data1, k, j, num);
		data1Add(data1, i - i % 3 + k / 3, j - j % 3 + k % 3, num);
	}
}
void rblank(char** board, struct Data1** data1, int i, int j)
{
	int k;
	int index = i * 9 + j;
	data1[index]->size = 0;
	for (k = 0; k < 9; k++)
	{
		data1Add(data1, i, j, board[i][k] - '0');
		data1Add(data1, i, j, board[k][j] - '0');
		data1Add(data1, i, j, board[i - i % 3 + k / 3][j - j % 3 + k % 3] - '0');
	}
}
void delRefreshData1(char** board, struct Data1** data1, int index)
{
	int i, j, k;
	i = index / 9;
	j = index % 9;
	for (k = 0; k < 9; k++)
	{
		rblank(board, data1, i, k);
		rblank(board, data1, k, j);
		rblank(board, data1, i - i % 3 + k / 3, j - j % 3 + k % 3);
	}


}
void solveSudoku(char** board, int boardRowSize, int boardColSize)
{
	int i, j, blank = 0, index, last;
	for (i = 0; i < 81; i++) if (board[i / 9][i % 9] == '.') blank++;
	char *ch = (char*)malloc(81);
	for (i = 0; i < 81; i++)
		ch[i] = board[i / 9][i % 9];
	struct Data1** data1 = creatdata1();
	struct Data2* data2 = creatdata2();
	for (i = 0; i < 9; i++)
		for (j = 0; j < 9; j++)
			addRefreshData1(data1, i, j, board[i][j] - '0');
	int k = 0;
	int fl = 1;
	int isFilled = 0;
	while (blank)
	{
		
		fl = 1;
		while (fl)
		{
			fl = 0;
			for (i = 0; i < 81; i++)
			{
				if (ch[i] == '.'&&data1[i]->size + data1[i]->tried >= 9) //这个空格不能填了需要回退删除数据
				{
					index = data2->num[data2->size - 1];
					ch[index] = '.';
					board[index / 9][index % 9] = '.';
					if (data2->righte)
					{
						last = data2->num[data2->size];
						data1[last]->tried = 0;
					}
					delRefreshData1(board, data1, index);
					data2->size--;
					data2->righte = 1;
					blank++;
					fl = 1;
					break;
				}
			}
		}
		isFilled = 0;
		while (!isFilled)
		{	
			k=(k+1)%9;
			for (i = 0; i < 81; i++)
			{
				if (ch[i] == '.'&& data1[i]->size + data1[i]->tried + k == 9)
				{
					for (int c = 1; c <= 9; c++)
					{
						int flag = 1;
						for (j = 0; j < data1[i]->size; j++) if (data1[i]->num[j] == c) flag = 0;
						for (j = 1; j <= data1[i]->tried; j++) if (data1[i]->num[data1[i]->tried + 10] == c) flag = 0;
						if (flag) {
							ch[i] = c + '0';
							board[i / 9][i % 9] = c + '0';
							data2->size++;
							data2->righte = 0;
							data2->num[data2->size - 1] = i;
							blank--;
							addRefreshData1(data1, i / 9, i % 9, c);
							data1[i]->tried++;
							data1[i]->num[data1[i]->tried + 10] = c;
							break;
						}
					}
					isFilled = 1;
					k = 0;
					break;
				}
			}
			
		}
	}
	free(ch); free(data1); free(data2);
}