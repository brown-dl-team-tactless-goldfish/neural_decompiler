class TrieNode {
    TrieNode* child[2] = {}; 
    int mult = 0; 
    int val = -1; 
friend class Trie; 
};


class Trie {
    TrieNode* root; 
public: 
    Trie() { root = new TrieNode(); }
    void insert(int val) {
        TrieNode* node = root; 
        for (int i = 18; i >= 0; --i) {
            int bit = (val >> i) & 1; 
            if (!node->child[bit]) node->child[bit] = new TrieNode(); 
            node = node->child[bit]; 
            node->mult += 1; 
        }
        node->val = val; 
    }
    
    int search(int val) {
        TrieNode* node = root; 
        for (int i = 18; i >= 0; --i) {
            int bit = (val >> i) & 1; 
            if (node->child[1^bit]) node = node->child[1^bit]; 
            else node = node->child[bit]; 
        }
        return val ^ node->val; 
    }
    
    void remove(int val) {
        TrieNode* node = root; 
        for (int i = 18; i >= 0; --i) {
            int bit = (val >> i) & 1; 
            --node->child[bit]->mult; 
            if (node->child[bit]->mult == 0) {
                delete node->child[bit]; 
                node->child[bit] = nullptr; 
                break; 
            }
            node = node->child[bit]; 
        }
    }
};


class Solution {
public:
    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {
        int root = -1; 
        unordered_map<int, vector<int>> tree; 
        
        for (int i = 0; i < parents.size(); ++i) {
            if (parents[i] == -1) root = i; 
            else tree[parents[i]].push_back(i); 
        }
        
        unordered_map<int, vector<pair<int, int>>> mp; 
        for (int i = 0; i < queries.size(); ++i) {
            int node = queries[i][0], val = queries[i][1]; 
            mp[node].emplace_back(val, i); 
        }
        
        vector<int> ans(queries.size(), 0); 
        Trie* trie = new Trie(); 
        
        function<void(int)> fn = [&](int x) {
            trie->insert(x); 
            for (auto& [v, i] : mp[x]) ans[i] = trie->search(v); 
            for (auto& xx : tree[x]) fn(xx); 
            trie->remove(x); 
        }; 
    
        fn(root); 
        return ans; 
    }
};