// Bitwise AND of two numbers is always less than or equal to the max. of no.s.
// To maximise the AND operation of a subarray, try to take the maximum no.s only.
// Just find out the maximum no., the longest occurence of it and thats your answer :)
int longestSubarray(vector<int>& nums) {
        
        int x = *max_element(nums.begin(),nums.end());
        int c = 0, ans = 0;
        // ans to store longest occurence and c to count adjacent occurence
        for(int i=0;i<nums.size()-1;i++) {
            if(nums[i]==x && nums[i+1]==x) {
                c++; 
            }else {
                c = 0;
            }
            ans = max(ans,c);
        }
        // (ans+1) bcoz for 5 consecutive elements, ans has stored 4.
        return ans+1;
    }