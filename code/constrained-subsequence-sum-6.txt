    public class Solution
    {
        private class Fenwick
        {
            private const int CHUNK_SIZE = 256;

            private class Node
            {
                public readonly int Min;
                public readonly int Max;

                public Node(int min, int max)
                {
                    Min = min;
                    Max = max;
                }

                public Node Left;
                public Node Right;
                public bool IsLeaf => Left == null && Right == null;
                public long Val;
            }

            private readonly Node _root;
            private readonly long[] _data;

            public Fenwick(int min, int max, long[] input)
            {
                _root = new Node(min, max);
                _data = input;
                Build(_root);
            }

            private void Build(Node node)
            {
                int chunk = node.Max - node.Min + 1;
                int chunksCount = Convert.ToInt32(Math.Ceiling((double)chunk / CHUNK_SIZE));

                if (chunksCount <= 1)
                {
                    checked
                    {
                        node.Val = _data[node.Min];

                        for (int i = node.Min; i <= node.Max; i++)
                        {
                            node.Val = Math.Max(node.Val, _data[i]);
                        }
                    }

                    return;
                }

                int leftChunksCount = chunksCount / 2;

                node.Left = new Node(node.Min, node.Min + leftChunksCount * CHUNK_SIZE - 1);
                node.Right = new Node(node.Min + leftChunksCount * CHUNK_SIZE, node.Max);

                Build(node.Left);
                Build(node.Right);

                node.Val = Math.Max(node.Left.Val, node.Right.Val);
            }

            private void Update(Node node, int i, long val)
            {
                if (node == null || i < node.Min || i > node.Max)
                {
                    return;
                }


                if (!node.IsLeaf)
                {
                    Update(node.Left, i, val);
                    Update(node.Right, i, val);

                    node.Val = Math.Max(node.Left.Val, node.Right.Val);
                }
                else
                {
                    _data[i] = val;
                    node.Val = _data[node.Min];

                    for (int idx = node.Min; idx <= node.Max; idx++)
                    {
                        node.Val = Math.Max(node.Val, _data[idx]);
                    }
                }
            }

            public void Update(int i, long val)
            {
                Update(_root, i, val);
            }

            private long Max(Node node, int from, int to)
            {
                if (node == null || from > node.Max || to < node.Min)
                {
                    return int.MinValue;
                }

                if (node.Min == from && node.Max == to)
                {
                    return node.Val;
                }

                if (node.IsLeaf)
                {
                    int start = Math.Max(node.Min, from);
                    int end = Math.Min(node.Max, to);
                    long res = _data[start];
                    for (int i = start; i <= end; i++)
                    {
                        res = Math.Max(res, _data[i]);
                    }

                    return res;
                }


                return Math.Max(
                    Max(node.Left, Math.Max(node.Left.Min, from), Math.Min(node.Left.Max, to)),
                    Max(node.Right, Math.Max(node.Right.Min, from), Math.Min(node.Right.Max, to))
                    );
            }

            public long Max(int from, int to)
            {
                return Max(_root, from, to);
            }
        }

        public int ConstrainedSubsetSum(int[] nums, int k)
        {
            checked
            {
                long[] dp = new long[nums.Length];
                for (int i = 0; i < nums.Length; i++)
                {
                    dp[i] = int.MinValue;
                }
                dp[0] = nums[0];

                Fenwick f = new Fenwick(0, nums.Length - 1, dp);

                for (int i = 1; i < nums.Length; i++)
                {
                    long cur = nums[i];
                    cur = Math.Max(cur, nums[i] +  f.Max(Math.Max(0, i - k), i - 1));
                    f.Update(i, cur);
                }

                return (int)dp.Max();
            }
        }
    }