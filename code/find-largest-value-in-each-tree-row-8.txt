typedef struct QNode{
    struct TreeNode* dataTreenode;
    struct QNode* next;
}QNode;

typedef struct LinkQueue{
    QNode* front;
    QNode* rear;
}LinkQueue;

int maximumtreedepth(struct TreeNode* root){
    int result=0,lmaximuntreedepth=0,rmaximuntreedepth=0;
    if(!root) return result;
    else{
        if(root->left)  lmaximuntreedepth=maximumtreedepth(root->left);
        if(root->right) rmaximuntreedepth=maximumtreedepth(root->right);
        if(lmaximuntreedepth>rmaximuntreedepth) result=lmaximuntreedepth+1;
        else result=rmaximuntreedepth+1;
        return result;
    }
}

int* largestValues(struct TreeNode* root, int* returnSize) {
    int* result=NULL;
    *returnSize=0;
    if(!root) return result;
    else{
        int treedepth=maximumtreedepth(root);
        result=(int*)malloc(sizeof(int)*treedepth);
        LinkQueue treeQueue;
        treeQueue.front=treeQueue.rear=(QNode*)malloc(sizeof(QNode));
        int curtreelevelnodenum=0,nextreelevelnodenum=0;
        QNode* q=(QNode*)malloc(sizeof(QNode));
        q->dataTreenode=root;
        q->next=NULL;
        treeQueue.rear->next=q;
        treeQueue.rear=q;
        curtreelevelnodenum++;
        for(int i=0;i<treedepth;i++){
            nextreelevelnodenum=0;
            result[i]=treeQueue.rear->dataTreenode->val;
            for(int j=0;j<curtreelevelnodenum;j++){
                if((q->dataTreenode->val)>result[i]) result[i]=q->dataTreenode->val;
                if(q->dataTreenode->left){
                    QNode* ql=(QNode*)malloc(sizeof(QNode));
                    ql->dataTreenode=q->dataTreenode->left;
                    ql->next=NULL;
                    treeQueue.rear->next=ql;
                    treeQueue.rear=ql;
                    nextreelevelnodenum++;
                }
                if(q->dataTreenode->right){
                    QNode* qr=(QNode*)malloc(sizeof(QNode));
                    qr->dataTreenode=q->dataTreenode->right;
                    qr->next=NULL;
                    treeQueue.rear->next=qr;
                    treeQueue.rear=qr;
                    nextreelevelnodenum++;
                }
                 q=q->next;
            }
            curtreelevelnodenum=nextreelevelnodenum;
        }
        free(treeQueue.front);
        free(treeQueue.rear);
        free(q);
        *returnSize=treedepth;
        return result;
    }
}