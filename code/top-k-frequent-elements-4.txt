// frequency, value
#define FREQ 0
#define VAL  1

void swap(int ** arr, int i, int j){
    int tempFreq = arr[i][FREQ];
    int tempVal  = arr[i][VAL];
    
    arr[i][FREQ] = arr[j][FREQ];
    arr[i][VAL]  = arr[j][VAL];
    
    arr[j][FREQ] = tempFreq;
    arr[j][VAL] = tempVal;
}

void rank(int ** top, int tSize, int newVal, int newValFreq){
    if(newValFreq > top[tSize-1][FREQ]){
        top[tSize-1][FREQ] = newValFreq;
        top[tSize-1][VAL] = newVal;
        for(int row = tSize; row> 1;row--){
            if(top[row-1][FREQ] > top[row-2][FREQ])
                swap(top, row-1, row-2);
        }
    }
}

int cmpr(void*a, void*b){
    return (*(int*)a - *(int*)b);
}
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){
    int prevCount = 1;
    
    //sort array by student ID
    qsort(nums, numsSize, sizeof(int), cmpr);//nlogn
    
    //allocate memory for intermediate calculation
    int** out = (int**)malloc(k*sizeof(int*));
    for(int i=0; i<k ;i++){
        *(out + i) = (int*)malloc(2*sizeof(int));
        *(*(out + i)+0) = -1;
        *(*(out + i)+1) = -1;
    }
    
    //traverse the array counting frequencies and keeping the k max frequencies
    for(int i=1; i<numsSize ;i++){
        if(nums[i-1] == nums[i]){
            prevCount++;
        }
        else{
            rank(out, k, nums[i-1], prevCount);
            prevCount = 1;
        } 
    }
    rank(out, k, nums[numsSize-1],prevCount);
    
    //copy the k max frequencies value
    int* output = (int*)malloc(k*sizeof(int));
    for(int i = 0; i<k ;i++){
        output[i] = out[i][VAL];
    }
    free(out);
    *returnSize = k;
    return output;
}

