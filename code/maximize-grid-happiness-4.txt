constexpr int MAX_M = 243; // 3**5;
constexpr int MAX_COL = 5;

// Parses the 3-based bitmask.
vector<int> parse(int b) {
    vector<int> parsed(MAX_COL);
    for (int bi = 0; bi < MAX_COL; ++bi) {
        parsed[bi] = b % 3;
        b /= 3;
    }
    return parsed;
}

// Delta happiness between two columns.
vector<vector<int>> getDelta() {
    vector<vector<int>> delta(MAX_M, vector<int>(MAX_M, 0));
    vector<int> prev(MAX_COL), curr(MAX_COL);
    for (int b = 0; b < MAX_M; ++b) {
        prev = parse(b);
        for (int tb = 0; tb < MAX_M; ++tb) {
            curr = parse(tb);
            for (int i = 0; i < MAX_COL; ++i) {
                if (prev[i] == 2 && curr[i] != 0) delta[b][tb] += 20;
                else if (prev[i] == 1 && curr[i] != 0) delta[b][tb] -= 30;
            }
            for (int i = 0; i < MAX_COL; ++i) {
                if (curr[i] == 2) {
                    delta[b][tb] += 40;
                    if (i-1 >= 0 && curr[i-1] != 0) delta[b][tb] += 20;
                    if (i+1 < MAX_COL && curr[i+1] != 0) delta[b][tb] += 20;
                    if (prev[i] != 0) delta[b][tb] += 20;
                } else if (curr[i] == 1) {
                    delta[b][tb] += 120;
                    if (i-1 >= 0 && curr[i-1] != 0) delta[b][tb] -= 30;
                    if (i+1 < MAX_COL && curr[i+1] != 0) delta[b][tb] -= 30;
                    if (prev[i] != 0) delta[b][tb] -= 30;
                }
            }
        }
    }
    return delta;
}

// Computes the #extro, #intro represented by every bitmask.
vector<vector<int>> getCnt() {
    vector<vector<int>> cnt(MAX_M, vector<int>(2, 0));
    for (int b = 0; b < MAX_M; ++b) {
        vector<int> parsed = parse(b);
        for (int i = 0; i < MAX_COL; ++i) {
            if (parsed[i] == 2) ++cnt[b][0];
            else if (parsed[i] == 1) ++cnt[b][1];
        }
    }
    return cnt;
}

class Solution {
public:
    int getMaxGridHappiness(int m, int n, int IC, int EC) {
        static vector<vector<int>> delta = getDelta(); // (bitmask,bitmaks)->delta happiness.
        static vector<vector<int>> cnt = getCnt(); // bitmask->(ec, ic);

        int M = 1;
        for (int i = 0; i < m; ++i) M *= 3;

        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(M, vector<int>((IC+1)*(EC+1), -1)));
        dp[0][0][0] = 0;
        for (int i = 1; i <= n; ++i) {
            for (int b = 0; b < M; ++b) {
                for (int cnt_comb = 0; cnt_comb < (IC+1)*(EC+1); ++cnt_comb) {
                    const int ec = cnt_comb%(EC+1), ic = cnt_comb/(EC+1);
                    const int prev_ec = ec-cnt[b][0], prev_ic = ic-cnt[b][1];
                    if (prev_ec < 0 || prev_ic < 0) continue;
                    const int prev_cnt_comb = prev_ic*(EC+1)+prev_ec;
                    for (int tb = 0; tb < M; ++tb) {
                        if (dp[i-1][tb][prev_cnt_comb] == -1) continue;
						// Transition.
                        dp[i][b][cnt_comb] = max(dp[i][b][cnt_comb], dp[i-1][tb][prev_cnt_comb]+delta[tb][b]);
                    }
                }
            }
        }
        
        int ans = -1;
        for (int i = 0; i < M; ++i) {
            for (int j = 0; j < (IC+1)*(EC+1); ++j) {
                ans = max(ans, dp.back()[i][j]);
            }
        }
        return ans;
    }
};