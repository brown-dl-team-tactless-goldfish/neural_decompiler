template<typename T1, typename T2, typename T3>
struct triad {
    T1 first; T2 second; T3 third;
    triad(const T1& _f, const T2& _s, const T3& _t) : first(_f), second(_s), third(_t) {}
    triad(T1&& _f, T2&& _s, T3&& _t) : first(move(_f)), second(move(_s)), third(move(_t)) {}
};

class Solution {
public:
    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {
        int n = servers.size();
        int m = tasks.size();
        
        // we need to get the free server with the smallest weight, smallest index
        typedef triad<int,int,int> Triad;
        auto comp = [](auto& v2, auto& v1) {
            if(v1.first < v2.first) { return true; }
            else if(v1.first > v2.first) { return false; }
            else if(v1.first == v2.first) { return v1.second<v2.second; }
            else { return false; }
        };
        
        // create a priority queue of free servers
        priority_queue<Triad, vector<Triad>, decltype(comp) > pqFreeServers(comp);
        
        // Mark all servers as intially free
        for(int i=0; i<n; ++i) {
            pqFreeServers.emplace(servers[i], i, 0);
        }
        
        // reuse the allocated vector for output array
        servers.clear();
        auto& ret = servers;
        
        // create a priority queue of busy servers
        // sort by the server that gets freed first
        auto comp2 = [](auto& v2, auto& v1) { return v1.third<v2.third; };
        priority_queue<Triad, vector<Triad>, decltype(comp2) > pqBusyServers(comp2);
        
        int j = 0;
        int currTime = 0;
        while(j<m) {
        
            // jth task is added at jth second
            currTime = max(currTime, j);
            
            // get the next task
            auto& t = tasks[j];
            
            // add servers that are free
            while(!pqBusyServers.empty() && pqBusyServers.top().third<=currTime) {
                auto s = pqBusyServers.top(); pqBusyServers.pop();
                s.third = 0;
                pqFreeServers.emplace(s);
            }
            
            // if none of the servers are free, then find one that becomes free the earliest
            // time travel: move the clock forward in time
            if(pqFreeServers.empty()) {
                currTime = max(currTime, pqBusyServers.top().third);
                continue;
            }
            
            // get the next free server
            auto s = pqFreeServers.top(); pqFreeServers.pop();
            
            // push the index of server
            ret.push_back(s.second);
            
            // mark the server as "not free"
            s.third = t + currTime;
            pqBusyServers.emplace(s);
            
            // move to the next task
            ++j;
        }
        
        return ret;
    }
};