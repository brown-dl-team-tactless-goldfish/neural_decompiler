struct Positions {
    int br;
    int bc;
    int pr;
    int pc;
    
    Positions(int a, int b, int c, int d) {
        br = a;
        bc = b;
        pr = c;
        pc = d;
    }
};


class Solution {
public:
    int minPushBox(vector<vector<char>>& grid) {
        m = grid.size();
        n = m == 0 ? 0 : grid[0].size();
        
        Positions pos(0, 0, 0, 0);
        
        deque<Positions> dq;
        
        for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++) {
                if (grid[r][c] == 'B') {
                    pos.br = r;
                    pos.bc = c;
                } 
                
                if (grid[r][c] == 'S') {
                    pos.pr = r;
                    pos.pc = c;
                }
            }
        }
        
        dq.push_back(pos);
       
        unordered_set<string> visited;
        int push_times = 0;
        
        while (!dq.empty()) {
            int sz = dq.size();
            for (int i = 0; i < sz; i++) {
                auto cur = dq.front();
                dq.pop_front();
                int box_r = cur.br, box_c = cur.bc;
                int ppl_r = cur.pr, ppl_c = cur.pc;
                
                for (const auto dir : dirs) {
					// new box/person row/column
                    int nbr = box_r + dir.first;
                    int nbc = box_c + dir.second;
                    int npr = box_r - dir.first;
                    int npc = box_c - dir.second;
					// avoid out of boundary
                    if (nbr < 0 || nbr >= m || nbc < 0 || nbc >= n) continue;
                    if (npr < 0 || npr >= m || npc < 0 || npc >= n) continue;
					// avoid visit previous position, note that both person and box posiitons needs to be encoded
					// (r, c) is encoded as r * 29 + c
                    if (visited.count(to_string(nbr * 29 + nbc) + "." + to_string(npr * 29 + npc))) continue;
					// avoid wall
                    if (grid[nbr][nbc] == '#' || grid[npr][npc] == '#') continue;
                    unordered_set<int> tmp;
					// avoid non-reachable position
                    if (!canPersonReach(ppl_r, ppl_c, npr, npc, grid, box_r, box_c, tmp)) continue;
                    if (grid[nbr][nbc] == 'T') return push_times + 1;
                   
                    dq.push_back({nbr, nbc, npr, npc});
                    visited.insert(to_string(nbr * 29 + nbc) + "." + to_string(npr * 29 + npc));
                } 
            }
            push_times++;
        }
        
        return -1;
    }
    
    
private:
    vector<pair<int, int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    int m, n;
    
    bool canPersonReach(int pr, int pc, const int tar_r, const int tar_c, vector<vector<char>>& grid, const int box_r, const int box_c, unordered_set<int>& visited) {
        if (pr == tar_r && pc == tar_c) return true;
        visited.insert(pr * 29 + pc);
        for (const auto dir : dirs) {
            int nr = pr + dir.first;
            int nc = pc + dir.second;
            if (nr < 0 || nr >= m || nc < 0 || nc >= n) continue;
            if (grid[nr][nc] == '#') continue;
            if (nr == box_r && nc == box_c) continue;
            if (visited.count(nr * 29 + nc)) continue;
            if (canPersonReach(nr, nc, tar_r, tar_c, grid, box_r, box_c, visited)) return true;
        }
        return false;
        
    }
};