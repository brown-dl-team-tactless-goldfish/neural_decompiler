int cmpfunc(const void* a, const void* b){
    return *(int*)a - *(int*)b;
}

int** diagonalSort(int** mat, int matSize, int* matColSize, int* returnSize, int** returnColumnSizes){
    int i, j;
    int row = matSize;
    int col = * matColSize;
    int set = (row < col)?row:col;
    int* data = (int*)malloc(set * sizeof(int));
    int index;
    
    int** ans = (int*)malloc(row * sizeof(int*));
    * returnSize = row;
    * returnColumnSizes = (int*)malloc(row * sizeof(int));    
    for(i = 0; i < row; i++){
        ans[i] = (int*)malloc(col * sizeof(int));
        returnColumnSizes[0][i] = col;
    }    
    //row 對角線
    for(i = row-1; i >=0; i--){
        index = 0;
        for(j = 0; j < set; j++){
            if((i+j) < row){
                data[index] = mat[i+j][j]; 
                index++;
            }
            else
                break;
        }
        qsort(data, index, sizeof(int), cmpfunc);
        index = 0;
        for(j = 0; j < set; j++){
            if((i+j) < row){
                ans[i+j][j] = data[index];   
                index++;
            }
            else
                break;
        }        
    }
    //col 對角線
    for(i = 1; i <col; i++){
        index = 0;
        for(j = 0; j < set; j++){
            if((i+j) < col){
                data[index] = mat[j][i+j]; 
                index++;
            }
            else
                break;
        }
        qsort(data, index, sizeof(int), cmpfunc);
        index = 0;
        for(j = 0; j < set; j++){
            if((i+j) < col){
                ans[j][i+j]  = data[index];   
                index++;
            }
            else
                break;
        }        
    }    
    free(data);
    return ans;   
}