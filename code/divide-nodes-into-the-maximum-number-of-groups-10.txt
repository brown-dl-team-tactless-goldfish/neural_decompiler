class Solution {
public:
    vector<int> findComponent(int root, vector<vector<int>>& graph, vector<bool>& visited) {
        queue<int> que;
        unordered_set<int> component;
        que.push(root);
        component.insert(root);
        visited[root] = true;
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; ++i) {
                auto top = que.front();
                que.pop();
                for (auto nei : graph[top]) {
                    if (!component.count(nei)) {
                        que.push(nei);
                        component.insert(nei);
                        visited[nei] = true;
                    }
                }
            }
        }
        return vector<int>(component.begin(), component.end());
    }

    int countGroup(vector<int>& component, vector<vector<int>>& graph, int n) {
        int ma = 0;
        for (auto root : component) {
            // bfs to count groups
            int group = 0;
            queue<int> que;
            que.push(root);
            vector<bool> visited(n + 1);
            unordered_set<int> curGroup;
            unordered_set<int> nextGroup;
            curGroup.insert(root);
            visited[root] = true;
            while (!que.empty()) {
                int size = que.size();
                curGroup = nextGroup;
                nextGroup.clear();
                for (int i = 0; i < size; ++i) {
                    auto front = que.front();
                    que.pop();
                    for (auto nei : graph[front]) {
                        if (curGroup.count(nei)) {
                            return -1;
                        }
                        if (!visited[nei]) {
                            visited[nei] = true;
                            nextGroup.insert(nei);
                            que.push(nei);
                        }
                    }
                }
                ++group;
            }
            // cout << root << " " << group << endl;
            ma = max(ma, group);
        }
        return ma;
    }

    int magnificentSets(int n, vector<vector<int>>& edges) {
        vector<bool> visited(n + 1);
        vector<vector<int>> graph(n + 1);
        for (auto& edge : edges) {
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
        }
        int result = 0;
        for (int i = 1; i <= n; ++i) {
            if (!visited[i]) {
                vector<int> component = findComponent(i, graph, visited);
                int group = countGroup(component, graph, n);
                if (group == -1) {
                    return -1;
                }
                result += group;
            }
        }
        return result;
    }
};