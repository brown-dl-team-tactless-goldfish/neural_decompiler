class Solution {
public:
    vector<string> getNeighbors(string word, unordered_set<string>& dict) {
        vector<string> res;
        for (int i = 0; i < word.length(); i++) {
            char old_char = word[i];
            for (char c = 'a'; c <= 'z'; c++) {
                word[i] = c;
                if (dict.count(word)) {
                    res.push_back(word);
                }
            }
            word[i] = old_char;
        }
        return res;
    }
    
    void bfs(string beginWord, string endWord,
             unordered_map<string, int>& distance, unordered_set<string>& dict,
             unordered_map<string, vector<string>>& adjacency_list) {
        dict.insert(beginWord);
        for (auto w : dict) {
            adjacency_list[w] = {};
        }
        queue<string> q;
        q.push(beginWord);
        distance[beginWord] = 0;
        while (!q.empty()) {
            bool foundEnd = false;
            for (int size = q.size(); size > 0; size--) {
                const string cur = q.front(); q.pop();
                int cur_dist = distance[cur];
                vector<string> nbors = getNeighbors(cur, dict);
                for (auto nbor : nbors) {
                    adjacency_list[cur].push_back(nbor);
                    if (distance.find(nbor) == distance.end()) {
                        distance[nbor] = cur_dist + 1;
                        if (nbor == endWord) {
                            foundEnd = true;
                        } else {
                            q.push(nbor);
                        }
                    }
                }
            }
            if (foundEnd) break;
        }
    }
    
    void backTrack(string srcWord, string dstWord,
                   unordered_map<string, vector<string>>& adjacency_list,
                   unordered_map<string, int>& distance,
                   vector<string>& tmp, vector<vector<string>>& res) {
        if (srcWord == dstWord) {
            res.push_back(tmp);
            return;
        }
        for (auto nbor : adjacency_list[srcWord]) {
            if (distance[nbor] == distance[srcWord] + 1) {
                tmp.push_back(nbor);
                backTrack(nbor, dstWord, adjacency_list, distance, tmp, res);
                tmp.pop_back();
            }
        }
    }
    
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
        vector<vector<string>> res;
        unordered_set<string> dict(wordList.begin(), wordList.end());
        unordered_map<string, int> distance;
        unordered_map<string, vector<string>> adjacency_list;
        bfs(beginWord, endWord, distance, dict, adjacency_list);
        vector<string> tmp{beginWord};
        backTrack(beginWord, endWord, adjacency_list, distance, tmp, res);
        return res;
    }
};