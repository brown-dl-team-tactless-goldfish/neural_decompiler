class TreeAncestor {
    vector<vector<int>> parent;
    vector<vector<int>> gr;
    vector<int> dep;
public:
    void dfs(int curr , int par) {
        if(par!=-1)  dep[curr] = dep[par]+1;
        parent[curr][0] = par;

        // calculating 2^j parent
        for (int j = 1 ; j < 30 ; j++) {
            if(parent[curr][j-1] >= 0)
                parent[curr][j] = parent[parent[curr][j - 1]][j - 1];
        }

        for (auto x : gr[curr]) {
            if (x != par) {
                dfs(x, curr);
            }
        }
    }   
    TreeAncestor(int n, vector<int>& parents) {
        
        // graph list resizing
        gr.resize(n);
        dep.resize(n,0);
        parent.resize(n,vector<int>(30,-3));
        
        // making adj list
        dep[0] = 0;
        int sz = parents.size();
        for(int i = 0 ; i < sz ; i++){
            if(parents[i]!=-1)
            gr[parents[i]].push_back(i);
        }
        
        // dfs
        dfs(0,-1);
    }
    
    int getKthAncestor(int node, int k) {
        
        if(k>dep[node]) return -1;
        
	    for (int j = 29 ; j >= 0 ; j--) {
            if (((k >> j) & 1) == 1) {
                node = parent[node][j];
            }
	    }
        return node;
    }
};

/**
 * Your TreeAncestor object will be instantiated and called as such:
 * TreeAncestor* obj = new TreeAncestor(n, parent);
 * int param_1 = obj->getKthAncestor(node,k);
 */