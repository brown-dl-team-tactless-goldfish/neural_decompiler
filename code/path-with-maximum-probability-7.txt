double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {
  // map of the weights
  map<pair<int, int>, double> weights;
  // build the neighbor list for each node
  map<int, vector<int>> adjList;

  for (int i = 0; i < edges.size(); i++) {
    adjList[edges[i][0]].push_back(edges[i][1]);
    adjList[edges[i][1]].push_back(edges[i][0]);
    weights[make_pair(edges[i][0], edges[i][1])] = -log10(succProb[i]);
    weights[make_pair(edges[i][1], edges[i][0])] = -log10(succProb[i]);
  }
  
  // store from small -> large based on the cost
  priority_queue<pair<double, int>, vector<pair<double, int>>, std::greater<pair<double, int>>> q;
  double dist[n];
  
  for (int i = 0; i < n; i++) {
    dist[i] = DBL_MAX;
  }
  
  q.push(make_pair(0.0, start));
  dist[start] = 0.0;
  
  // dijkstra's algorithm for min cost
  while (!q.empty()) {
    auto u = q.top(); q.pop();
    
    // adjacent list of current node
    vector<int>& tmp = adjList[u.second];
    
    // update the cost for all the neighboring nodes
    for (int i = 0; i < tmp.size(); i++) {
      if (dist[tmp[i]] > (dist[u.second] + weights[make_pair(u.second, tmp[i])])) {
        dist[tmp[i]] = dist[u.second] + weights[make_pair(u.second, tmp[i])];
        q.push(make_pair(dist[tmp[i]], tmp[i]));
      }
    }
  }
  
  return pow(10, -dist[end]);
}