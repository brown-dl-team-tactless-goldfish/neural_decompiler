    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {
        using ll = long long;
        
        vector<int> bestOn1Tire;

        for (auto &t: tires) {
            const int f = t[0], r=t[1];
            
            int curLap = 0;
            ll curLapTime = f;
            int totalTime = 0;
            
            do {
                totalTime += curLapTime;
                if (curLap < bestOn1Tire.size()) bestOn1Tire[curLap] = min(bestOn1Tire[curLap], totalTime);
                 else bestOn1Tire.push_back(totalTime);
                curLapTime *= r;
                curLap++;
            } while (curLapTime < changeTime+f);            
        }
        
        int maxLapsOn1Tire = bestOn1Tire.size();
        
        vector<int> bestTime(numLaps, INT_MAX); // it will accumulate best time to complete ith lap
        bestTime[0] = bestOn1Tire[0]; // we start from the best time on one tire for 1st lap
        
        for (int laps=2; laps <= numLaps; laps++) {
		// core knapsack alg is here: what would be the best time if we use single tire 1 last lap.. 2 last laps ... X last laps.
            for (int lapsOn1Tire=1, K=min(laps,maxLapsOn1Tire); lapsOn1Tire<=K; ++lapsOn1Tire ) {  
                int curLapTime = lapsOn1Tire < laps ? bestTime[laps-lapsOn1Tire-1] + changeTime : 0;
                curLapTime += bestOn1Tire[lapsOn1Tire-1];
                bestTime[laps-1] = min(bestTime[laps-1], curLapTime);
            }
        }
        
        return bestTime[numLaps-1];
    }