class DSU {
public:
    DSU(int len) {
        parent.resize(len+1);
        rank.resize(len+1);
        for(int i = 0; i <= len; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }
    int find(int x) {
        if(x == parent[x]) return x;
        return parent[x] = find(parent[x]);
    }
    void Union(int u, int v) {
        int p1 = find(u);
        int p2 = find(v);
        if(rank[p1] > rank[p2]) parent[p2] = p1;
        else if(rank[p1] < rank[p2]) parent[p1] = p2;
        else parent[p2] = p1, rank[p1]++; 
    }
    bool CompP(int u, int v) {
        return find(u) == find(v);
    }
private:
    vector<int> parent;
    vector<int> rank;
};
class Solution {
public:
    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {
        int sz = queries.size();
        int m = edgeList.size();
        for(int i = 0; i < sz; i++) {
            queries[i].push_back(i);
        }
        sort(queries.begin(), queries.end(), [](vector<int> &a, vector<int> &b){return a[2] < b[2];});
        sort(edgeList.begin(), edgeList.end(), [](vector<int> &a, vector<int> &b){return a[2] < b[2];});
        int i = 0;
        DSU ds(n);
        vector<bool> ans(sz);
        for(auto q : queries) {
            while(i < m && edgeList[i][2] < q[2]) {
                int u = edgeList[i][0];
                int v = edgeList[i][1];
                ds.Union(u, v);
                i++;
            }
            ans[q[3]] = ds.CompP(q[0], q[1]);
        }
        return ans;
    }
};