class ThroneInheritance {
public:
  ThroneInheritance(const string& kingName)
    :root{make_shared<FamTreeNode>(kingName)}
  {
    reg(root);
  }

  void birth(const string& parentName, const string& childName) {
    if(nameToNode.count(parentName) == 0) throw invalid_argument(parentName + " not born");
    
    nameToNode[parentName]->children.push_back(make_shared<FamTreeNode>(childName));
    
    reg(nameToNode[parentName]->children.back());
  }

  void death(const string& name) {
    if(nameToNode.count(name) == 0) throw invalid_argument(name + " not born");
    
    nameToNode[name]->isAlive = false;
  }

  vector<string> getInheritanceOrder() {
    vector<string> o;
    o.reserve(nameToNode.size());
    
    function<void(shared_ptr<FamTreeNode>)> preOrder{[&](shared_ptr<FamTreeNode> n){
      if(n == nullptr) return;
      
      if(n->isAlive) o.push_back(n->name);
      
      for(auto c : n->children) preOrder(c);
    }};
    
    preOrder(root);
    
    return o;
  }
  
private:
  struct FamTreeNode {
    FamTreeNode(const string& name)
      :name{name}
    {}
    
    string name;
    
    bool isAlive{true};
    
    vector<shared_ptr<FamTreeNode>> children;
  };
  
  shared_ptr<FamTreeNode> root;
  
  unordered_map<string_view, shared_ptr<FamTreeNode>> nameToNode;
  
  void reg(shared_ptr<FamTreeNode> n) {
    nameToNode[n->name] = n;
  }
};