/**
 * Method: Binary search approach
 * Out of given elements in the array what can be the possible scope of
 * search for us to start? Since we need largest sum of subarray let us 
 * begin with largest element as left and sum of all elements (worst) as 
 * right boundary of the scope. Then at each iteration we check if the mid
 * value of this scope can be used to split as m groups. If we can, then, 
 * we can reduce our scope to left side else right side of mid value.
 */
bool validSplit(int *nums, int size, int largest, int m) {
    int splits = 0, total = 0;
    
    for(int i = 0; i < size; i++) {
        total += nums[i];
        if(total > largest) {
            splits ++;
            // including nums[i] made bigger total
            // start off with new group with nums[i] as first element
            total = nums[i];
        }
    }
    // include the last subarray
    splits++;
    return splits <= m;
}

int splitArray(int* nums, int numsSize, int m){
    int left = INT_MIN, right = 0;
    
    for(int i = 0; i < numsSize; i++) {
        left = fmax(left, nums[i]);
        right += nums[i];
    }
    
	int res = 0;
    
    while(left <= right) {
        int mid = left + (right - left) / 2;
        // check if using this mid can we split nums into m groups
        if(validSplit(nums, numsSize, mid, m)) {
            res = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return res;   
}