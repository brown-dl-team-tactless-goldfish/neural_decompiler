class Solution {
public:
    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {
        vector<vector<int>>g(n+1);
        for(auto e:edges){
            g[e[0]].push_back(e[1]);
            g[e[1]].push_back(e[0]);
        }
        queue<pair<double,pair<int,int>>>q;
        vector<bool>visited(n+1,false);
        q.push({1,{0,1}});
        visited[1]=true;
        
        while(!q.empty()){
            auto p=q.front();
            q.pop();
            int v=p.second.second;
            int time=p.second.first;
            double prob=p.first;
            //cout<<prob<<" ";
            if(v==target && v==1 && g[v].size()!=0 && time<t)
                return 0;
            if(v==target && v==1 && g[v].size()==0 && time<t)
                return prob;
            if(v==target && time==t)
                return prob;
            if(v==target && time<t && g[v].size()==1)
                return prob;
            if(v==target)
                return 0;
            int ne=0;
            for(auto i: g[v]){
                if(visited[i]==false){
                    ne++;
                }
            }
            double pr=(1.0)/(ne);
            for(auto i: g[v]){
                if(visited[i]==false){
                    visited[i]=true;
                    q.push({prob*pr,{time+1,i}});
                }
            }
            
        }
        return 0;
    }
};