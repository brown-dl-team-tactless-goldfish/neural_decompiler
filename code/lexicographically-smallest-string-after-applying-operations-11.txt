class Solution {
public:
    
    // return string after add operation
    string AddOperation(string s, int a)
    {
        for(int i=1;i<s.length();i+=2)
            s[i] = (s[i]-'0'+a)%10 + '0';
        
        return s;
    }
    
    // return string after rotate operation
    string RotateOperation(string s, int b)
    {
        int left = s.length()-b;
        
        string str = s.substr(left,b) + s.substr(0,left);
        
        return str;
    }
    
    string findLexSmallestString(string s, int a, int b) {
        
        // track processed strings
        unordered_map<string,bool>visited;
        
        queue<string>Q;
        
        string result = "";
        
        Q.push(s);
        visited[s] = true;
        
        string curr;
        
        while(!Q.empty())
        {
            curr = Q.front();
            Q.pop();
            
            // get lexical small string
            if(result.empty() || lexicographical_compare(curr.begin(),curr.end(),result.begin(),result.end()))
                result = curr;
            
            // get strings after add and rotate operations
            string addString = AddOperation(curr,a);
            string rotateString = RotateOperation(curr,b);
            
            // push addString if not already processed
            if(visited.count(addString)==0)
            {
                visited[addString] = true;
                Q.push(addString);
            }
            
            // push rotateString if not already processed
            if(visited.count(rotateString)==0)
            {
                visited[rotateString] = true;
                Q.push(rotateString);
            }
        }
        
        return result;
    }
};