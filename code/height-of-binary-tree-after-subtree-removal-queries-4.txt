/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
struct SegmentTree {
#define lc (C << 1)
#define rc (C << 1 | 1)
#define M ((L+R)>>1)
  struct data {
    int sum;
    data() :sum(0) {};
  };
  vector<data>st;
  int N;
  SegmentTree(int _N) :N(_N) {
    st.resize(4 * N);
  }
  void combine(data& cur, data& l, data& r) {
    cur.sum = max(l.sum,r.sum);
  }
  data Query(int i, int j, int C, int L, int R) {
    if (j < L || i > R || L > R) return data();
    if (i <= L && R <= j) return st[C];
    data ret;
    data d1 = Query(i, j, lc, L, M);
    data d2 = Query(i, j, rc, M + 1, R);
    combine(ret, d1, d2);
    return ret;
  }
  void Update(int i, int j, int val, int C, int L, int R) {
    if (j < L || i > R || L > R) return;
    if (i <= L && R <= j) {
      st[C].sum = val;
      return;
    }
    Update(i, j, val, lc, L, M);
    Update(i, j, val, rc, M + 1, R);
    combine(st[C], st[lc], st[rc]);
  }
  void Update(int i, int j, int val) {
    Update(i, j, val, 1, 1, N);
  }
  int Query(int i, int j) {
    return Query(i, j, 1, 1, N).sum;
  }
};
class Solution {
public: 
    int startTime[100001],endTime[100001];
    int arr[100001];
    int T;
    void dfs(TreeNode* root,int d){
        ++T;
        startTime[root->val] = T;
        arr[T] = d;
        if(root->left!=nullptr)dfs(root->left,d+1);
        if(root->right!=nullptr) dfs(root->right,d+1);
        endTime[root->val] = T;
    }
    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {
        T = 0;
        dfs(root,0);
        SegmentTree st(T);
        for(int i=1;i<=T;i++){
            st.Update(i,i,arr[i]);
        }
        vector<int>ret;
        for(int&x:queries){
            int from = startTime[x];
            int till = endTime[x];
            int a = st.Query(1,from-1);
            int b = st.Query(till+1,T);
            ret.push_back(max(a,b));
        }
        return ret;
    }
};