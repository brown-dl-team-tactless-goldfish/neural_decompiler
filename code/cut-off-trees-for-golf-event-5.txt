class Solution {
public:
    struct Node{
        int x,y,height;
        bool operator<(Node& node){
            return height<node.height;
        }
    };
    int cutOffTree(vector<vector<int>>& forest) {
        if(forest.size() == 0 or forest[0].size() == 0) return -1;
        int n = forest.size(), m = forest[0].size();
        int res = 0;
        //step1: build nodes and sort them in a deque
        for(int i = 0;i<n;i++){
            for(int j = 0;j<m;j++){
                if(forest[i][j] > 1)
                    trees.push_back({i,j,forest[i][j]});
            }
        }
        sort(trees.begin(),trees.end());
        //step2: move node by node in the deque
        int x = 0,y = 0;
        while(!trees.empty()){
            Node node = trees.front();
            trees.pop_front();
            int step = move(node,x,y,forest);
            if(step != -1) res += step;
            else return -1;
            // cout<<node.x<<"  "<<node.y<<"  "<<step<<endl;
            x = node.x;
            y = node.y;
            forest[x][y] = 1;
        }
        return res;
    }
private:
    deque<Node> trees;
    int res = 0;
    int dx[4] = {0,0,1,-1};
    int dy[4] = {1,-1,0,0};
    int move(Node node,int r,int c,vector<vector<int>>& forest){
        if(r == node.x and c == node.y) return 0;
        int row = forest.size(),col = forest[0].size();
        vector<vector<int>> visited(row,vector<int>(col,0));
        queue<pair<int,int>> q,next;
        q.push(make_pair(r,c));
        visited[r][c] = 1;
        int step = 0;
        while(!q.empty()){
            int c_x = q.front().first;
            int c_y = q.front().second;
            q.pop();
            for(int i = 0;i<4;i++){
                int nx = c_x+dx[i];
                int ny = c_y+dy[i];
                if(nx>=0 and ny>=0 and nx<row and ny<col and visited[nx][ny] == 0 and forest[nx][ny]>0){
                    visited[nx][ny] = 1;
                    if(nx == node.x and ny == node.y) return ++step;
                    next.push(make_pair(nx,ny));
                }
            }
            if(q.empty()){
                swap(q,next);
                step++;
            }
        }
        return -1;
    }
};