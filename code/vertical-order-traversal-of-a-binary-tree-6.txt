	public class DictComparer : IComparer<KeyValuePair<int, int>>
	{
		public int Compare(KeyValuePair<int, int> x, KeyValuePair<int, int> y)
		{
			if (x.Key == y.Key) return x.Value - y.Value;
			else return x.Key - y.Key;
		}
	}

public class Solution {
    int maxColumn = 0;
    int minColumn = 0;
	// Define other methods and classes here
    public IList<IList<int>> VerticalTraversal(TreeNode root)
    {
        if (root == null) return new List<IList<int>>();
        var result = new List<IList<int>>();
        var dict = new Dictionary<int, List<KeyValuePair<int, int>>>();
        var queue = new Queue<Tuple<TreeNode, int, int>>();
        queue.Enqueue(new Tuple<TreeNode, int, int>(root, 0, 0));
        //Build the BFS
        while (queue.Count != 0)
        {

            var node = queue.Dequeue();
            if(node.Item1 == null) continue;

            var row = node.Item2;
            var col = node.Item3;
            var val = node.Item1.val;
            if (dict.ContainsKey(col))
            {
                dict[col].Add(new KeyValuePair<int, int>(row, val));
            }
            else
            {
                dict.Add(col, new List<KeyValuePair<int, int>>() { new KeyValuePair<int, int>(row, val) });
            }

            maxColumn = Math.Max(maxColumn, col);
            minColumn = Math.Min(minColumn, col);
            queue.Enqueue(new Tuple<TreeNode, int, int>(node.Item1.left, row + 1, col - 1));
            queue.Enqueue(new Tuple<TreeNode, int, int>(node.Item1.right, row + 1, col + 1));
        }

        for (int i = minColumn; i <= maxColumn; i++)
        {
            var value = dict[i];
            value.Sort(new DictComparer());
            var vt = new List<int>();
            foreach (var item in value)
            {
                vt.Add(item.Value);
            }
            result.Add(vt);
        }

        return result;

    }
}