class Solution {
public:
    vector<int> gardenNoAdj(int n, vector<vector<int>>& paths) {
        // Use bfs
          // create an adjacency list
          vector<vector<int>>adjList(n+1,vector<int>());

          for(auto path:paths)
          {
              adjList[path[0]].push_back(path[1]);
              adjList[path[1]].push_back(path[0]);
          }

        // to store answer
        vector<int>ans(n,0);
        vector<int>visited(n+1,0);

        for(int i=1;i<=n;i++)
          {   
              // yet not visited
              if(!visited[i])
              {
                  bfs(adjList,ans,visited,i);
              }
          }

          // return ans
          return ans;
    }

    void bfs(vector<vector<int>>&adjList,vector<int>&ans,vector<int>&visited,int node)
    {
        queue<pair<int,int>>q;
        q.push({node,1});
        visited[node]=1;
        int flower=1;
        ans[node-1]=flower;

        while(!q.empty())
        {
            flower=q.front().second;
                node=q.front().first;
              
            // traverse over neighbors
            for(auto n:adjList[node])
            {  
                // not visited
                if(!visited[n])
                {
                    visited[n]=1;
                    flower++;
                    if(flower>4)
                      flower=1;
                      ans[n-1]=flower;
                     q.push({n,flower});
                    //  cout<<n<<"   "<<flower<<endl;
                    
                }

                if(ans[node-1]==ans[n-1])
                  {  int x=ans[n-1];
                    x++;
                    if(x>4)
                           x=1;
                    q.push({n,x});
                       
                      ans[n-1]=x;
                        
                  }
            }

            // pop front element
            q.pop();
        }
    }
};