/* Approach copied from
 *   https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/discuss/831519/C%2B%2B-O(MN)-with-explanation
 *
 */

#include <search.h>

/* We need a NUL-terminated key to use with the hash table.  This integer
 * representation is faster to calculate than calling sprintf().
 */
static void
int2key (int v, char key[8])
{
    /* Assumption key is non-negative */
    key[0] = 0x80 | (v >> 28);
    key[1] = 0x80 | (v >> 21);
    key[2] = 0x80 | (v >> 14);
    key[3] = 0x80 | (v >> 7);
    key[4] = 0x80 | (v >> 0);
    key[5] = 0; /* NUL byte needed for termination */
}

struct elem
{
    int         num;        /* Original number */
    unsigned    count;      /* Number of occurrences */
    char        key[8];     /* NUL-terminated representation of `num' */
};

/* Constraints: */
#define MAX_ELEMS 1000
#define MAX_NUM 100000

#define DEBUG 0


static int
lookup_freq (int v)
{
    char key[8];
    ENTRY *entry;
    
    int2key(v, key);
    entry = hsearch((ENTRY) { .key = key, }, FIND);
    if (entry)
        return ((struct elem *) entry->data)->count;
    else
        return 0;
}


static int
count (const int *a, int a_count, const int *b, int b_count)
{
    /* XXX assume all allocations are successul */
    struct elem *elems, *el;
    ENTRY *entry;
    unsigned n_elems, j;
    long target, square;
    char key[8];
    int i, count;
    
    if (DEBUG)
        printf("called %s\n", __func__);
    
    /* Calculate frequency table */
    elems = malloc(sizeof(elems[0]) * MAX_ELEMS);
    n_elems = 0;
    hcreate(MAX_ELEMS);
    for (i = 0; i < b_count; ++i)
    {
        el = &elems[n_elems];
        int2key(b[i], el->key);
        entry = hsearch((ENTRY) { .key = el->key, .data = el}, ENTER);
        /* again, assume success */
        if (entry->data == el)
        {
            if (DEBUG)
                printf("new element for %d\n", b[i]);
            el->count = 1;
            el->num = b[i];
            ++n_elems;
        }
        else
            ++((struct elem *) entry->data)->count;
    }
    
    count = 0;
    for (i = 0; i < a_count; ++i)
    {
        square = (long) a[i] * (long) a[i];
        if (DEBUG)
            printf("square: %ld\n", square);
        for (j = 0; j < n_elems; ++j)
        {
            if (DEBUG)
                printf("elems[%u] = { num: %d, count: %u }\n", j, elems[j].num, elems[j].count);
            if (square % elems[j].num)
                continue;
            target = square / elems[j].num;
            if (target > MAX_NUM)
                continue;
            int2key((int) target, key);
            entry = hsearch((ENTRY) { .key = key, }, FIND);
            if (entry)
            {
                el = entry->data;
                if (target == elems[j].num)
                    count += el->count * (el->count - 1);
                else
                    count += el->count * lookup_freq(square / target);
                if (DEBUG)
                    printf("found target %ld, new count: %d\n", target, count);
            }
            else if (DEBUG)
                printf("did not find target %ld\n", target);
        }
    }
    
    hdestroy();
    free(elems);
    
    return count / 2;
}

int numTriplets(int* nums1, int nums1Size, int* nums2, int nums2Size){
    return count(nums1, nums1Size, nums2, nums2Size)
         + count(nums2, nums2Size, nums1, nums1Size);
}