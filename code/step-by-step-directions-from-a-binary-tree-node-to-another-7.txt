class Solution {
public:
    string getDirections(TreeNode* root, int s, int d) {
        //The shortest path will go through lowest common ancestor, so find LCA first.
        TreeNode* lca = findLca(root, s, d);
        
        if(s == lca -> val){
            string path ="";
            bool found = false;
            findPath(lca, d, path, found);
            return path;
        }
        else if(d == lca -> val){
            string path ="";
            bool found = false;
            findPath(lca, s, path, found);
            
            //Going from s to d (lca in this case) will need travelling to parent node, given by 'U'.
            for(auto& c: path) c= 'U';
            return path;
        }
        else{
            string pathLcaToS = "";
            bool found = false;
            findPath(lca, s, pathLcaToS, found);
            
            //We need path from s to lca, the path we have currently is from lca to s, so reverse the path. - This step is unnecessary because all characters in this path will be replaced by 'U', but technically it is right step and also improves understanding.
            reverse(pathLcaToS.begin(), pathLcaToS.end());
            
            //Going from s to lca will need travelling to parent node, given by 'U'.
            for(auto& c: pathLcaToS) c = 'U';
            string pathSToLca = pathLcaToS;
            
            //Find path from lca to d
            string pathLcaToD = "";
            found = false;
            findPath(lca, d, pathLcaToD, found);
            
            string pathSToD = pathSToLca + pathLcaToD;
            return pathSToD;
        }
    }
    
    TreeNode* findLca(TreeNode* root, int s, int d){
        if(!root || root->val == s || root->val == d) return root;
        
        auto left = findLca(root->left, s, d);
        auto right = findLca(root->right, s, d);
        
        if(!left) return right;
        else if(!right) return left;
        else if(left && right) return root;
        
        return NULL;
    }
    
    void findPath(TreeNode* root, int destination, string& res, bool& found){
        if(root->val == destination){
            found = true;
            return;
        }
        
        if(!found && root->left){
            res += "L";
            findPath(root -> left, destination, res, found);
            if(!found) res.pop_back();
        }
        
        if(!found && root->right){
            res += "R";
            findPath(root->right, destination, res, found);
            if(!found) res.pop_back();
        }
    }
};