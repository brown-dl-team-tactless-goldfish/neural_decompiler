using LL = long long ;
class Solution {
    vector<vector<LL>> helper(vector<int>&nums){
        int n = nums.size() ;
        vector<vector<LL>>ret(n+1) ;
        for(int state = 0; state < (1 << n); state++ ){
            int i = __builtin_popcount(state) ;
            LL sum = 0 ;
            for(int k = 0; k < n; k++){
                if((state >> k)&1)
                    sum += (LL)nums[k] ;
            }
            ret[i].push_back(sum) ;
        }
        for(int i = 0; i < n; i++){
            sort(ret[i].begin(), ret[i].end()) ;
        }
        return ret ;
    }
public:
    int minimumDifference(vector<int>& nums) {
        int n = nums.size()/2 ;
        vector<int>nums1(n) ;
        vector<int>nums2(n) ;
        int ret = INT_MAX ;
        LL sum = accumulate(nums.begin(), nums.end(), 0LL) ;
        
        for(int i = 0; i < n; i++)
            nums1[i] = nums[i] ;
        for(int i = n; i < 2*n ;i++)
            nums2[i-n] = nums[i] ;

        vector<vector<LL>>Map2 = helper(nums2) ;
 
        for(int state = 0; state < (1 << n); state++){
            int i =  __builtin_popcount(state) ;
            LL x = 0 ;
            for(int k = 0; k < n; k++){
                if((state >> k)&1)
                    x += (LL)nums1[k] ;
            }
            int j = n - i ;
 
            auto iter = lower_bound( Map2[j].begin(), Map2[j].end(), sum/2-x ) ;
            if(iter != Map2[j].end())
                ret = fmin(ret, abs(*iter*2+2*x-sum));
            if(iter != Map2[j].begin()){
                iter = prev(iter);
                ret = fmin(ret, abs(*iter*2+2*x-sum));
            }
        }
        return ret ;
    }
};