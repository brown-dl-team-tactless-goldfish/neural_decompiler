/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


struct Stack
{
    struct TreeNode * data[30];
    int top;
};

struct Stack stack;


int isStackFull()
{
    if(stack.top >= 30)
        return 1;
    return 0;
}

int isStackEmpty()
{
    if(stack.top == -1)
        return 1;
    return 0;
}

void Enqueue(struct TreeNode * ptrav)
{
    if(isStackFull())
    {
        return;
    }
    stack.data[++stack.top] = ptrav;
}

struct TreeNode * Dequeue()
{
    if(isStackEmpty())
    {
        return NULL;
    }
    
    struct TreeNode * ret = stack.data[stack.top];
    stack.top--;
    return ret;
}

struct TreeNode* bstFromPreorder(int* preorder, int preorderSize)
{
    stack.top = -1;
    int i=0;
    struct TreeNode * tmp, *dequeue_element;
    struct TreeNode * root = (struct TreeNode *)malloc(sizeof(struct TreeNode));
    root->val = *(preorder+i);
    root->left = root->right = NULL;
    struct TreeNode * ptrav = root;
    
    while( i < preorderSize)
    {
        if( *(preorder+i) < ptrav->val)
        {
            tmp = (struct TreeNode *)malloc(sizeof(struct TreeNode));
            tmp->val = *(preorder+i);
            tmp->left = tmp->right = NULL;
            
            ptrav->left = tmp;
            
            Enqueue(ptrav);
            
            ptrav = tmp;
        }
        
        else if( *(preorder+i) > ptrav->val )
        {
            if(!isStackEmpty())
            {
                //Check with the value in the stack. If this value is in range, insert on right node.
                if(*(preorder+i) < (stack.data[stack.top])->val)
                {
                    //Insert in the right node of ptrav
                    tmp = (struct TreeNode *)malloc(sizeof(struct TreeNode));
                    tmp->val = *(preorder+i);
                    tmp->left = tmp->right = NULL;
                
                    ptrav->right = tmp;
                    ptrav = tmp;
                }
            
                else
                {
                    dequeue_element = Dequeue();
                    ptrav = dequeue_element;
                    continue;
                }
            }
            
            //If the stack is empty
            else if(isStackEmpty())
            {
                //Insert in the right node of ptrav
                tmp = (struct TreeNode *)malloc(sizeof(struct TreeNode));
                tmp->val = *(preorder+i);
                tmp->left = tmp->right = NULL;
                
                ptrav->right = tmp;
                ptrav = tmp;
            }
        }
        i++;
    }
    
    return root;
}




