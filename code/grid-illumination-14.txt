class Solution {
public:
    //diag_down is for those lines that have slope equal to 1.
    //diag_up is for those lines that have slope equal to -1.
	//diag_down[intercept] = 2 means that the diagonal line with slope 1 and y-intercept (i.e. vertical-intercept) "intercept" is being lit by 2 lamps.
    unordered_map<int, int> hor, vert, diag_down, diag_up;
    vector<vector<int>> *lamps_saved;
    bool IsHorizontalLit(int y) { return hor.count(y) > 0; }
    bool IsVerticalLit(int x) { return vert.count(x) > 0; }
    bool IsDiagonalDownLit(int x, int y) {
        int intercept = y - x;
        return diag_down.count(intercept) > 0;
    }
    bool IsDiagonalUpLit(int x, int y) {
        int intercept = y + x;
        return diag_up.count(intercept) > 0;
    }
    bool IsLit(int x, int y) {
        return IsHorizontalLit(y) || IsVerticalLit(x) || IsDiagonalDownLit(x, y) || IsDiagonalUpLit(x, y);
    }
    bool IsLampAtOrAdjacentToLocation(int x, int y, const vector<int> &lamp) {
        return !(x < lamp[0] - 1 || x > lamp[0] + 1 || y > lamp[1] + 1 || y < lamp[1] - 1);
    }
    bool IsLampAtOrAdjacentToLocation(int x, int y, int &result_x, int &result_y, int &index) {
        for (int i = 0; i < lamps_saved->size(); ++i) {
            auto &lamp = lamps_saved->operator[](i);
            if (IsLampAtOrAdjacentToLocation(x, y, lamp)) {
                result_x = lamp[0];
                result_y = lamp[1];
                index = i;
                return true;
            }
        }
        return false;
    }
    void TurnOnLamp(int x, int y) {
        hor[y]++;
        vert[x]++;
        int up_intercept = y + x, down_intercept = y - x;
        diag_up[up_intercept]++;
        diag_down[down_intercept]++;
        return ;
    }
    void TurnOffLamp(int x, int y, int index = -1) {
        vector<vector<int>> &lamps = *lamps_saved;
        //Erase the lamp from the list of lamps.
        if (index < 0) {
            for (int i = 0; i < lamps.size(); ++i) {
                auto &lamp = lamps[i];
                if (x == lamp[0] && y == lamp[1]) {
                    lamps.erase(lamps.begin() + i);
                    break;
                }
            }
        } else {
            lamps.erase(lamps.begin() + index);
        }
        hor[y]--; //Turn off the horizontal row
        assert(hor[y] >= 0);
        if (hor[y] == 0) 
            hor.erase(hor.find(y));
        vert[x]--; //Turn off the vertical row
        assert(vert[x] >= 0);
        if (vert[x] == 0) 
            vert.erase(vert.find(x));
        
        int up_intercept = y + x, down_intercept = y - x;
        diag_down[down_intercept]--; //Turn off the diagonal line going down.
        assert(diag_down[down_intercept] >= 0);
        if (diag_down[down_intercept] == 0) 
            diag_down.erase(diag_down.find(down_intercept));
        diag_up[up_intercept]--; //Turn off the diagonal line going up.
        assert(diag_up[up_intercept] >= 0);
        if (diag_up[up_intercept] == 0) 
            diag_up.erase(diag_up.find(up_intercept));
        return ;
    }
    vector<int> gridIllumination(int N, vector<vector<int>>& lamps, vector<vector<int>>& queries) {
        lamps_saved = &lamps;
        for (auto &lamp : lamps) {
            TurnOnLamp(lamp[0], lamp[1]);
        }
        vector<int> result;
        for (const auto &query : queries) {
            int x = query[0], y = query[1];
            int is_lit = IsLit(x, y);
            result.push_back(is_lit);
            int result_x, result_y, index;
            if (!is_lit)
                continue;
            while (IsLampAtOrAdjacentToLocation(x, y, result_x, result_y, index)) {
                TurnOffLamp(result_x, result_y, index);
            }
        }
        return result;
    }
};