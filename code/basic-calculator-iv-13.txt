class Solution {
    struct Term {
        std::vector<std::string> vars;
        
        Term()
        {}
        
        explicit Term(const std::string& var)
          : vars({var})
        {}
        
        size_t size() const {
            return vars.size();
        }
        
        bool empty() const {
            return size() == 0;
        }
        
        bool operator==(const Term& rhs) const {
            if (size() != rhs.size()) {
                return false;
            }
            for (int i = 0; i < vars.size(); i++) {
                if (vars[i] != rhs.vars[i]) {
                    return false;
                }
            }
            return true;
        }
        
        std::string toString() const {
            std::ostringstream oss;
            for (int i = 0; i < vars.size(); i++) {
                if (i) {
                    oss << "*";
                }
                oss << vars[i];
            }
            return oss.str();
        }
    };
    
    struct TermLess {
        bool operator()(const Term& lhs, const Term& rhs) const {
            if (lhs.size() != rhs.size()) {
                return lhs.size() > rhs.size(); 
            }
            return lhs.vars < rhs.vars;
        }
    };
    
    using TermCoeff = std::map<Term, int, TermLess>; 
    
    struct Expression {
        TermCoeff term_coeff;
        
        Expression()
        {}
        
        explicit Expression(int coeff)
          : term_coeff({{Term(), coeff}})
        {}
        
        Expression(const std::string& var, int coeff)
          : term_coeff({{Term(var), coeff}})
        {}
        
        void add(const Term& term, int coeff) {
            term_coeff[term] += coeff;
        }
        
        std::vector<std::string> toVector() const {
            std::vector<std::string> result;
            for (const auto& [term, coeff] : term_coeff) {
                if (coeff == 0) {
                    continue;
                }
                std::ostringstream oss;
                oss << std::to_string(coeff);
                if (!term.empty()) {
                    oss << "*" << term.toString();
                }
                result.push_back(oss.str());
            }
            return result;
        }
    };
    
    using VariableValue = std::unordered_map<std::string, int>;

private:
    Term merge(const Term& lhs, const Term& rhs) {
        Term term;
        term.vars.reserve(lhs.vars.size() + rhs.vars.size());
        term.vars.insert(term.vars.end(), lhs.vars.begin(), lhs.vars.end());
        term.vars.insert(term.vars.end(), rhs.vars.begin(), rhs.vars.end());
        std::sort(term.vars.begin(), term.vars.end());
        return term;
    }
    
    Expression add(const Expression& lhs, const Expression& rhs, int sign) {
        Expression expr = lhs;
        for (const auto& [term, coeff] : rhs.term_coeff) {
            expr.add(term, sign * coeff);
        }
        return expr;
    }
    
    Expression mult(const Expression& lhs, const Expression& rhs) {
        Expression expr;
        for (const auto& [lhs_term, lhs_coeff] : lhs.term_coeff) {
            for (const auto& [rhs_term, rhs_coeff] : rhs.term_coeff) {
                Term res_term = merge(lhs_term, rhs_term);
                int res_coeff = lhs_coeff * rhs_coeff;
                expr.add(res_term, res_coeff);
            }
        }
        return expr;
    }
    
public:
    std::vector<std::string> basicCalculatorIV(const std::string& expression,
                                               const std::vector<std::string>& evalvars,
                                               const std::vector<int>& evalints) {
        std::istringstream iss(expression);
        VariableValue var_value;
        for (int i = 0; i < evalvars.size(); i++) {
            var_value[evalvars[i]] = evalints[i];
        }
        return evaluate(iss, var_value).toVector();
    }
    
private:
    void skipSpaces(std::istringstream& iss) {
        while (iss.good() && std::isblank(iss.peek())) {
            iss.get();
        }
    }
    
    Expression getExpr(std::istringstream& iss, const VariableValue& var_value) {
        Expression result;
        skipSpaces(iss);

        int coeff = 1;
        if (std::isdigit(iss.peek())) {
            iss >> coeff;
            return Expression(coeff);
        }

        std::string var;
        while (iss.good() && std::isalpha(iss.peek())) {
            var += iss.get();
        }
        auto it = var_value.find(var);
        if (it != var_value.end()) {
            coeff = it->second;
            return Expression(coeff);
        }

        return Expression(var, coeff);
    }
    
    Expression evaluate(std::istringstream& iss, const VariableValue& var_value) {
        Expression result;
        Expression term(1);
        skipSpaces(iss);
        char op = '*';
        int sign = +1;
        while (iss.good() && op != ')') {
            skipSpaces(iss);
            char ch = iss.peek();
            Expression expr = ch == '(' ? (iss.get(), evaluate(iss, var_value)) : getExpr(iss, var_value);
            switch (op) {
                case '*':
                    term = mult(term, expr);
                    break;
                case '+':
                case '-':
                    result = add(result, term, sign);
                    sign = op == '+' ? +1 : -1;
                    term = expr;
                    break;
            }
            skipSpaces(iss);
            op = iss.get();
        }
        return add(result, term, sign);
    }
};