class Solution {
public:
    int minimumHammingDistance(vector<int>& source, vector<int>& target, vector<vector<int>>& allowedSwaps) {
        int size{(int)target.size()};
        std::vector<int> root(size, 0);
        for(int i{0}; i < size; ++i) root[i] = i;
        for(const auto &s: allowedSwaps) root[parent(root, s[0])] = parent(root, s[1]);
        std::vector<std::unordered_map<int,int>> avail(size);
        for(int i{0}; i < size; ++i) ++avail[parent(root, root[i])][source[i]];
        int count{0};
        for(int i{0}; i < size; ++i) {
            auto it{avail[parent(root, root[i])].find(target[i])};
            if(it != avail[root[i]].end() && it->second) --it->second, ++count;
        }
        return size-count;
    }
    
    static int parent(std::vector<int>& root, int i) {
        return root[i] = root[i] == i ? i : parent(root, root[i]);
    }
};