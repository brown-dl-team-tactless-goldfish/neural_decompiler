#define IS_DIGIT(c) ('0' <= (c) && (c) <= '9')
#define IS_LOWCHAR(c) ('a' <= (c) && (c) <= 'z')

int dp[41][41][2000];
int nums1[40][3];
int nums2[40][3];
class Solution {
public:
    bool possiblyEquals(string s1, string s2) {
        m = s1.size();
        n = s2.size();
        memset(dp, -1, sizeof(dp));
        memset(nums1, -1, sizeof(nums1));
        memset(nums2, -1, sizeof(nums2));
        for (int i = 0; i < m; ++i) {
            int num = 0;
            for (int j = i; j < m && j - i < 3 && IS_DIGIT(s1[j]); ++j) {
                num = num * 10 + int(s1[j] - '0');
                nums1[i][j - i] = num;
            }
        }
        for (int i = 0; i < n; ++i) {
            int num = 0;
            for (int j = i; j < n && j - i < 3 && IS_DIGIT(s2[j]); ++j) {
                num = num * 10 + int(s2[j] - '0');
                nums2[i][j - i] = num;
            }
        }
        this->s1 = move(s1);
        this->s2 = move(s2);
        return getdp(0, 0, 1000);
    }
private:
    int getdp(int p1, int p2, int state) {
        bool pay1 = false, pay2 = false;
        if (dp[p1][p2][state] != -1) {
            return dp[p1][p2][state];
        } else if (p1 == m && p2 == n) {
            return dp[p1][p2][state] = (state == 1000 ? 1 : 0);
        } else if (p1 == m && p2 < n && state >= 1000) {
            return dp[p1][p2][state] = 0;
        } else if (p1 == m && p2 < n && state < 1000) {
            pay2 = true;
        } else if (p1 < m && p2 == n && state > 1000) {
            pay1 = true;
        } else if (p1 < m && p2 == n && state <= 1000) {
            return dp[p1][p2][state] = 0;
        } else if (p1 < m && p2 < n && state > 1000) {
            pay1 = true;
        } else if (p1 < m && p2 < n && state == 1000) {
            ;
        } else {
            pay2 = true;
        }
        
        if (pay1) {
            int debt1 = max(0, state - 1000);
            if (IS_LOWCHAR(s1[p1])) {
                return dp[p1][p2][state] = getdp(p1 + 1, p2, debt1 - 1 + 1000);
            } else {
                for (int i = 0; i < 3 && nums1[p1][i] != -1 && dp[p1][p2][state] != 1; ++i) {
                    dp[p1][p2][state] = getdp(p1 + i + 1, p2, debt1 - nums1[p1][i] + 1000);
                }
                return dp[p1][p2][state];
            }
        }
        
        if (pay2) {
            int debt2 = -min(0, state - 1000);
            if (IS_LOWCHAR(s2[p2])) {
                return dp[p1][p2][state] = getdp(p1, p2 + 1, -(debt2 - 1) + 1000);
            } else {
                for (int i = 0; i < 3 && nums2[p2][i] != -1 && dp[p1][p2][state] != 1; ++i) {
                    dp[p1][p2][state] = getdp(p1, p2 + i + 1, -(debt2 - nums2[p2][i]) + 1000);
                }
                return dp[p1][p2][state];
            }
        }
        
        if (IS_LOWCHAR(s1[p1]) && IS_LOWCHAR(s2[p2])) {
            return dp[p1][p2][state] = (s1[p1] == s2[p2]) && getdp(p1 + 1, p2 + 1, 1000);
        } else if (IS_LOWCHAR(s1[p1]) && IS_DIGIT(s2[p2])) {
            for (int i = 0; i < 3 && nums2[p2][i] != -1 && dp[p1][p2][state] != 1; ++i) {
                dp[p1][p2][state] = getdp(p1 + 1, p2 + i + 1, nums2[p2][i] - 1 + 1000);
            }
            return dp[p1][p2][state];
        } else if (IS_DIGIT(s1[p1]) && IS_LOWCHAR(s2[p2])) {
            for (int i = 0; i < 3 && nums1[p1][i] != -1 && dp[p1][p2][state] != 1; ++i) {
                dp[p1][p2][state] = getdp(p1 + i + 1, p2 + 1, -(nums1[p1][i] - 1) + 1000);
            }
            return dp[p1][p2][state];
        } else {
            for (int i = 0; i < 3 && nums1[p1][i] != -1 && dp[p1][p2][state] != 1; ++i) {
                for (int j = 0; j < 3 && nums2[p2][j] != -1 && dp[p1][p2][state] != 1; ++j) {
                    dp[p1][p2][state] = getdp(p1 + i + 1, p2 + j + 1, nums2[p2][j] - nums1[p1][i] + 1000);
                }
            }
            return dp[p1][p2][state];
        }
    }
    int m;
    int n;
    string s1;
    string s2;
};
