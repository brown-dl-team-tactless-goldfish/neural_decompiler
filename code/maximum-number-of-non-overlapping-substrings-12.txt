#define to_digit(c)(c - 'a')
class Solution {
public: 
    
vector<string> maxNumOfSubstrings(string s)
{
	vector<int> first(26);
	vector<int> last(26);
	vector<int> cnt(26);

	for (int i = 0; i < s.size(); i++)
	{
		first[to_digit(s[s.size() - 1 - i])] = s.size() - 1 - i;
		last[to_digit(s[i])] = i;
		cnt[to_digit(s[i])]++;
	}

	vector<string> res;

	int left = 0, right = last[to_digit(s[left])] + 1;
	while (left < right)
	{
		int offset = 0;
		while (s[left] == s[left + offset])++offset;
		
		//try to find substrings that only have one kind of characters and these characters appears only in this substring, 
		//since we are asked to give the shortest substring, so, this strategy always works;
		if (left == first[to_digit(s[left])] && last[to_digit(s[left])] + 1 == left + offset)
			res.push_back(s.substr(left, offset));

		right = max(right, last[to_digit(s[left])] + 1);
		left += offset;
	}
	
	//if we didn't find an answer, then the substring (0-right) should be the answer, but it might can be shorter;
	if (res.empty())
	{
		//handle strings like "cbababc"
		int start = 0, end = right - 1;
		while (start < end && s[start] == s[end] && cnt[to_digit(s[start])] == 2)
			start++, end--;
		if (start == end)
			res.push_back(s.substr(0, right));
		else
			res.push_back(s.substr(start, end - start + 1));
	}
	
	//if right is not at the end of this string, try to find other substrings in the remaining substring and put the answer into the result.
	if (right < s.size())
	{
		vector<string> tmp = maxNumOfSubstrings(s.substr(right, s.size() - right));
		for (string& str : tmp)
			res.push_back(str);
	}
	return res;
}
    
};