typedef long long   ll;
const int           M   = 10 + 5e1;
const int           N   = 10 + 5e2;
const ll            mod =  7 + 1e9;

int     n, m;
ll      f[N][M];
int     g[N][M];

int     Next[N];
int     dp[N];
string  str;


class Solution {
public:
    int findGoodStrings(int nn, string s1, string s2, string evil) {
        memset(Next, 0, sizeof(Next));
        memset(dp, 0, sizeof(dp));
        memset(f, 0, sizeof(f));
        memset(g, 0, sizeof(g));
        n = s1.size();
        m = evil.size();
        s1 = "#"+s1, s2 = "#"+s2, evil = "#"+evil;
        
        
        // dp1ï¼š kmp
        prefix(evil);
        
        // dp2
        for (int i = 0; i < m; i++) {
            for (int ch = 'a'; ch <= 'z'; ch++) g[i][ch-'a'] = kmp(evil, i, ch);
        }
        
        // dp3
        for (int t = 0; t <  m; t++) f[0][t] = 1;
        for (int i = 1; i <= n; i++) {
            for (int t = 0; t < m; t++) {                                f[i][t] = f[i-1][t+1];
                for (int ch = 'a'; ch <= 'z'; ch++) if (ch != evil[t+1]) f[i][t] = (f[i][t] + f[i-1][ g[t][ch-'a'] ]) % mod;
            }
        }
        
        
        // Digit dp
        str = s1;       ll l = dfs(1, 0, true);
        str = s2;       ll r = dfs(1, 0, true);
        return (r-l+(1-isEvil(s1,evil))+mod)%mod;    
    }
    
    
    ll  dfs(int k, int len, bool limit) {
        if (k >  n) return 1;
        if (!limit) return f[n-k+1][len];
        
        ll  ans = 0, beg = 'a', upp = limit?str[k]:'z';
        for (int ch = beg; ch <= upp; ch++) {                                            
            if (g[len][ch-'a'] != m) ans = (ans + dfs(k+1, g[len][ch-'a'], limit&&ch==str[k])) % mod;
        }
        return ans;
    }
    
    
    void prefix(string& s) {
        for (int i = 2, k = 0; i <= m; i++) {
            while (k > 0 && s[k+1] != s[i]) k = Next[k];
            if (s[k+1] == s[i]) k++;
            Next[i] = k;
        }
    }
    
    int kmp(string& s, int k, char ch) {
        while (k > 0 && s[k+1] != ch) k = Next[k];
        if (s[k+1] == ch) k++;
        return k;
    }
    
    bool isEvil(string& s, string& p) {
        for (int i = 1, k = 0; i <= n; i++) {
            while (k > 0 && (k == m || p[k+1] != s[i])) k = Next[k];
            if (p[k+1] == s[i]) k++;
            if (m == (dp[i]=k)) return true;
        }
        return false;
    }
};