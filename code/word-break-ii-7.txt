class Solution {
public:
    struct Trie {
        char val;
        Trie* children[26];
        bool complete = false;
    };
    Trie* buildTrie(const vector<string>& words) {
        Trie* root = new Trie{'_'};
        for (auto& w : words) {
            auto curr = root;
            for (auto& c : w) {
                if (!curr->children[c-'a'])
                    curr->children[c-'a'] = new Trie{c};
                curr = curr->children[c-'a'];
            }
            curr->complete = true;
        }
        return root;
    }
    vector<string> wordBreak(string s, vector<string>& wordDict) {
        Trie* trie = buildTrie(wordDict);
        function<vector<string>(int)> dfs = [&](int i) -> vector<string> {
            if (i==s.size())
                return {""};
            auto curr = trie;
            if (!curr->children[s[i]-'a'])
                return {};
            curr = curr->children[s[i]-'a'];
            int j = i+1;
            vector<string> retVec;
            while (curr) {
                if (curr->complete) {
                    auto val = s.substr(i, j-i);
                    auto newVec = dfs(j);
                    for (auto& v : newVec)
                        retVec.push_back(val + (v.size()==0 ? "" : " ") + v);
                }
                curr = j<s.size() ? curr->children[s[j]-'a'] : nullptr;
                j++;
            }
            return retVec;
        };
        return dfs(0);
    }
};