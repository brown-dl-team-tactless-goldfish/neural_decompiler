class Solution {
    void dfs(TreeNode* root, vector<int> &v) {
        if(!root) return;
        dfs(root -> left, v);
        v.push_back(root -> val);
        dfs(root -> right, v);
    }
    int bs(vector<int> &v, int pos, vector<int> &a, int x) {
        int s = 0, e = v.size() - 1, m;
        while(s <= e) {
            m = (s + e) / 2;
            if(v[m] == x) {a[pos] = x; return m;}
                
            if(v[m] < x) s = m + 1;
            else e = m - 1;
        }
        return m;
    }
public:
    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& q) {
        vector<int> v;
        dfs(root, v);
        vector<vector<int>> ans;

        for(int x : q) {
            vector<int> a(2);
            
            int m = bs(v, 0, a, x);
            if(a[0] != x) {
                if(m == 0) {
                    a[0] = v[m] < x ? v[m] : -1;
                }
                else a[0] = v[m] < x ? v[m] : v[m - 1];
            }
            m = bs(v, 1, a, x);
            if(a[1] != x) {
                if(m == v.size() - 1) {
                    a[1] = v[m] > x ? v[m] : -1;
                }
                else a[1] = v[m] > x ? v[m] : v[m + 1];
            }
            ans.push_back(a);
        }
        return ans;
    }
};