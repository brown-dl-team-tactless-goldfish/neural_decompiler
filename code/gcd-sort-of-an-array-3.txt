class Solution {
    vector<int>Father ;
    int findFather(int x){
        if(x != Father[x])
            Father[x] = findFather(Father[x]) ;
        return Father[x] ;
    }
    
    void unionSet(int a, int b){
        a = findFather(a) ;
        b = findFather(b) ;
        if(a < b)
            Father[b] = a ;
        else
            Father[a] = b ;
    }
    
    vector<int>findPrimeSet(int n){
        vector<int>tmp(n+1) ;
        for(int i = 2; i <= n; i++){
            if(tmp[i] == 1)
                continue ;
            int j = i*2 ;
            while(j <= n){
                tmp[j] = 1 ;
                j += i ;
            }
        }
        vector<int>primes ;
        for(int i = 2; i <= n; i++){
            if( tmp[i] == 0 ){
                primes.push_back(i) ;
            }
        }
        return primes ;
    }
public:
    bool gcdSort(vector<int>& nums) {
        int maxNum = *max_element(nums.begin(), nums.end()) ;
        vector<int>Primes = findPrimeSet(maxNum) ;
        Father.resize(maxNum+1) ;
        for(int i = 0; i <= maxNum; i++)
            Father[i] = i ;
        for(int i = 0; i < nums.size(); i++){
            int x = nums[i] ;
            for(const auto p : Primes){
                if(p > x)
                    break ;
                if(x%p == 0){
                    if(findFather(nums[i]) != findFather(p) )
                        unionSet(nums[i] , p) ;
                    while(x%p == 0)
                        x /= p ;
                }
            }
        }
        auto nums1 = nums ;
        sort(nums1.begin(), nums1.end()) ;
        for(int i = 0; i < nums.size(); i++){
            if(findFather(nums1[i]) != findFather(nums[i]) ){                
               return false ;
            }
        }
        return true ;
    }
};