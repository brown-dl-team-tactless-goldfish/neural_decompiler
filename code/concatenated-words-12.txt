class Trie {
 public:
    bool isLeaf;
    Trie* children[26];
    Trie() {
        this->isLeaf = 0;
        for(int i = 0; i < 26; i++) {
            this->children[i] = nullptr;
        }
    }
    void insert(string word) {
        Trie *curr = this;
        for(auto c : word) {
            if(curr->children[c-'a'] == nullptr) {
                curr->children[c-'a'] = new Trie();
            }
            curr = curr->children[c-'a'];
        }
        curr->isLeaf = true;
    }
    
    bool isConcatenated(string word, int index, int concatenatedCount) {
        if(index == word.length()) {
            return concatenatedCount >= 2;
        }
        
        Trie* curr = this;
        for(int i = index ; i < word.length(); i++) {
            if(curr->children[word[i] - 'a'] == nullptr) {
                return false;
            }
            
            curr = curr->children[word[i] - 'a'];
            if(curr->isLeaf) {
                if(isConcatenated(word, i+1, concatenatedCount+1)) {
                    return true;
                }
            }
        }
        return false;
    }
};
class Solution {
public:
    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        if(words.empty()) {
            return {};
        }
        Trie *root = new Trie();
        for(auto word : words) {
            root->insert(word);
        }
        
        vector<string> concatenated;
        for(auto word : words) {
            if(root->isConcatenated(word, 0, 0)) {
                concatenated.push_back(word);
            }
        }
        return concatenated;
    }
};