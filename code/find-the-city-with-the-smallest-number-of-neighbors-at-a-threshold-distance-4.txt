class Solution {
public:
    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
        vector<unordered_map<int, int>> neighbors(n); // adjacent cities for all a city
        vector<int> reachable(n, 0); // reachable cities <= distanceThreshold for a city
        int res = 0; // result
        
        for (const auto& e : edges)
        {
            neighbors[e[0]][e[1]] = e[2];
            neighbors[e[1]][e[0]] = e[2]; // edges of all cities
        }
        
        for (int i = 0; i < n; ++i)
        {
            reachable[i] = shortestPath(i, distanceThreshold, neighbors); // find the reachable cities for city i
            if (reachable[i] < reachable[res] || (reachable[i] == reachable[res] && i > res))
            {
                res = i; // update result if needed
            }
        }
        
        return res;
    }
    
private:
    inline int shortestPath(int city, int distanceThreshold, const vector<unordered_map<int, int>>& neighbors)
    {
        int res = 0; // Dijkstra's algorithm
        vector<int> dists(neighbors.size(), INT_MAX); // distance from src city to all others
        auto comp = [&](int c1, int c2){ return dists[c1] > dists[c2]; };
        priority_queue<int, vector<int>, decltype(comp)> heap(comp); // min heap
        
        dists[city] = 0;
        heap.push(city); // initialize distance array and min heap
        
        while (!heap.empty())
        {
            int c = heap.top(); // get the city with minimum distance to the src city
            for (const auto& pair : neighbors[c])
            {
                if (dists[c] + pair.second < dists[pair.first]) // if the distance from src to city c needs to be updated
                {
                    dists[pair.first] = dists[c] + pair.second;
                    heap.push(pair.first); // update the distance and push the city into min heap
                }
            }
            
            heap.pop();
        }
        
        for (int d : dists)
        {
            res += d <= distanceThreshold ? 1 : 0; // count the # of reachable cities <= distanceThreshold
        }
        
        return res;
    }
};