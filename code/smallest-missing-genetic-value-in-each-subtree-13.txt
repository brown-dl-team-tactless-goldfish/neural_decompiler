class Solution {
public:
    //to find all which all is included
    void dfs(vector<vector<int>>&graph,vector<bool>&visited,int curr,set<int>&s1,vector<int>&num){
        if(visited[curr]) return;
        visited[curr]=true;
        for(auto child:graph[curr]){
            if(!visited[child]) dfs(graph,visited,child,s1,num);
        }
        //erasing value from set so tha min value is always at the top
        s1.erase(num[curr]);
    }
    vector<int> smallestMissingValueSubtree(vector<int>& parents, vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n,1);
        int temp=-1;
        //to check if 1 is present in nums or not if not present then return ans with all 1;
        for(int i=0;i<nums.size();i++){
            if(nums[i]==1){
                temp=i;
                break;
            }
        }
        if(temp==-1) return ans;
        //now start maiking directed graph
        vector<vector<int>>vect(n);
        for(int i=1;i<parents.size();i++){
            vect[parents[i]].push_back(i);
        }
        //visited array because we donot want to visit a subtree when we go till root from node whose nums[i] is 1
        vector<bool>visited(n+10,false);
        //to store min till now
        set<int>s1;
        for(int i=0;i<=n;i++) s1.insert(i+1);
        //storing all the parents of node[i] whose nums[i] value is 1;
        vector<int>tobevisited;
        while(temp!=-1){
            tobevisited.push_back(temp);
            temp=parents[temp];
        }
        //now only for parents of nums[i]=1 to be visited and all node must have value =1 in ans 
        for(int i=0;i<tobevisited.size();i++){
            dfs(vect,visited,tobevisited[i],s1,nums);
            ans[tobevisited[i]]=*s1.begin();
        }
        return ans;
        
    }
};