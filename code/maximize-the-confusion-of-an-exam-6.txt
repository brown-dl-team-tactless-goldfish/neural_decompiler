class Solution {
public:
    // This function gives maximum consecutive 'c's if k replacements are allowed
    int helper(string &s,int k,char c)
    {
        // This function uses a sliding window technique
        // Here 'i' is the left and 'j' is the right pointer
        // 'count' gives the opposite of character 'c'. i.e if 'c' is 'T' then 'count' will give count of 'F' and vice versa
        int count=0,i=0,j=0,ans=0;
        
        // 'rev' is the opposite character
        char rev=c=='T'?'F':'T';
        while(j<s.length())
        {
            if(s[j]==rev)
            {
                count++;
            }
            // If there are more than 'k' opposite characters in our window then we've to shrink our window since at max we can flip 'k' characters. not more than that.
            while(count>k)
            {
                if(s[i]==rev)
                {
                    count--;
                }
                // Shrink the window by incrementing the left pointer
                i++;
            }
            
            // When we have less than or equal to 'k' opposite characters , the window length can be a potential solution
            ans=max(ans,j-i+1);
            // Expand the window
            j++;
        }
        return ans;
    }
    int maxConsecutiveAnswers(string answerKey, int k) 
    {
        // The answer will be the maximum between maximum consecutive 'T's and maximum consecutive 'F's if 'k' replacements are allowed
        return max(helper(answerKey,k,'T'),helper(answerKey,k,'F'));
    }
};