#include<stdlib.h>
#include<stdio.h>
#include<string.h>
#include<stdbool.h>
#include<stdint.h>
#include<math.h>
#define CALLOC2D(array, type, rowSize, colSize)\
do {\
array = (type **)calloc(rowSize, sizeof(type *));\
int _i;\
for (_i = 0; _i < rowSize; _i++) {\
array[_i] = (type *)calloc(colSize, sizeof(type));\
}\
} while (0)
#define CLEAR2D(array, rowSize, colSize)\
do {\
int _i;\
for (_i = 0; _i < rowSize; _i++) {\
memset(array[_i], 0, colSize);\
}\
} while (0)
#define FREE2D(array, rowSize)\
do {\
int _i;\
for (_i = 0; _i < rowSize; _i++) {\
free(array[_i]);\
}\
} while (0)
struct TrieNode {
bool end;
struct TrieNode *next[26]; 
};
struct TrieNode* trieCreate() {
struct TrieNode* dummy = (struct TrieNode *)malloc(sizeof(struct TrieNode));
dummy->end = false;
memset(dummy->next, 0, sizeof(dummy->next));
return dummy;
}
void insert(struct TrieNode* root, char* word) {
if (root == NULL || word == NULL) return;
struct TrieNode* p = root;
while (*word != '\0') {
if (p->next[*word - 'a'] == NULL) {
p->next[*word - 'a'] = trieCreate();
}
p = p->next[*word - 'a'];
word++;
}
p->end = true;
}
void trieFree(struct TrieNode* root) {
if (root == NULL) return;
int i;
for (i = 0; i < 26; i++) {
trieFree(root->next[i]);
}
free(root);
}
void dfs(char** board, int boardRowSize, int boardColSize,
bool** visited, int i, int j,
char* word, int depth,
struct TrieNode* node,
char **ans, int* returnSize) {
if (i >= 0 && i < boardRowSize && j >= 0 && j < boardColSize && !visited[i][j]) {
word[depth] = board[i][j];
visited[i][j] = true;
struct TrieNode* next_node = node->next[board[i][j] - 'a'];
if (next_node) {
if (next_node->end) {
strcpy(ans[(*returnSize)++], word);
next_node->end = false;
}
depth++;
dfs(board, boardRowSize, boardColSize, visited, i, j - 1, word, depth, next_node, ans, returnSize); 
dfs(board, boardRowSize, boardColSize, visited, i, j + 1, word, depth, next_node, ans, returnSize); 
dfs(board, boardRowSize, boardColSize, visited, i - 1, j, word, depth, next_node, ans, returnSize); 
dfs(board, boardRowSize, boardColSize, visited, i + 1, j, word, depth, next_node, ans, returnSize); 
}
word[depth] = 0;
visited[i][j] = false; 
}
}
char** findWords(char** board, int boardRowSize, int boardColSize, char** words, int wordsSize, int* returnSize) {
int bufSize = 128;
char *buf = (char *)calloc(bufSize, sizeof(char));
char **ans;
CALLOC2D(ans, char, wordsSize, bufSize);
bool **visited;
CALLOC2D(visited, bool, boardRowSize, boardColSize);
int i, j;
struct TrieNode* trie = trieCreate();
for (i = 0; i < wordsSize; i++) {
insert(trie, words[i]);
}
for (i = 0; i < boardRowSize; i++) {
for (j = 0; j < boardColSize; j++) {
dfs(board, boardRowSize, boardColSize, visited, i, j, buf, 0, trie, ans, returnSize);
}
}
trieFree(trie);
free(buf);
FREE2D(visited, boardRowSize);
return ans;
}
int main() {
char *board[7] = { "baabab", "abaaaa", "abaaab", "ababba", "aabbab", "aabbba", "aabaab" }; 
char *words[30] = {
"bbaabaabaaaaabaababaaaaababb", 
"aabbaaabaaabaabaaaaaabbaaaba", 
"babaababbbbbbbaabaababaabaaa", 
"bbbaaabaabbaaababababbbbbaaa", 
"babbabbbbaabbabaaaaaabbbaaab",
"bbbababbbbbbbababbabbbbbabaa", 
"babababbababaabbbbabbbbabbba", 
"abbbbbbaabaaabaaababaabbabba", 
"aabaabababbbbbbababbbababbaa", 
"aabbbbabbaababaaaabababbaaba", 
"ababaababaaabbabbaabbaabbaba", 
"abaabbbaaaaababbbaaaaabbbaab", 
"aabbabaabaabbabababaaabbbaab", 
"baaabaaaabbabaaabaabababaaaa", 
"aaabbabaaaababbabbaabbaabbaa",
"aaabaaaaabaabbabaabbbbaabaaa", 
"abbaabbaaaabbaababababbaabbb", 
"baabaababbbbaaaabaaabbababbb", 
"aabaababbaababbaaabaabababab", 
"abbaaabbaabaabaabbbbaabbbbbb", 
"aaababaabbaaabbbaaabbabbabab", 
"bbababbbabbbbabbbbabbbbbabaa", 
"abbbaabbbaaababbbababbababba",
"bbbbbbbabbbababbabaabababaab", 
"aaaababaabbbbabaaaaabaaaaabb", 
"bbaaabbbbabbaaabbaabbabbaaba", 
"aabaabbbbaabaabbabaabababaaa", 
"abbababbbaababaabbababababbb", 
"aabbbabbaaaababbbbabbababbbb", 
"babbbaabababbbbbbbbbaabbabaa" }; 
int size = 0;
char **ans = findWords(board, 7, 6, words, 30, &size);
int i;
for (i = 0; i < size; i++) {
}
return 0;
}