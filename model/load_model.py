import sys
sys.path.insert(0, '')
import tensorflow as tf
import os
import re
from model.transformer.dataprocess import read_vocab_from_csv
from model.neural_decompiler import CGenerator
from model.neural_decompiler import NeuralDecompiler

def setup():
    global cgen

    current_dir = os.path.dirname(os.path.realpath(__file__))
    saved_model_path = f"{current_dir}/../model_checkpoints/model-checkpoint"
    asm_vocab_dir = "vocab/new_asm_vocab.csv"
    c_vocab_dir = "vocab/new_c_vocab.csv"

    asm_vocab_path = f"{current_dir}/{asm_vocab_dir}"
    c_vocab_path = f"{current_dir}/{c_vocab_dir}"
    ASM_VOCAB = read_vocab_from_csv(asm_vocab_path)
    C_VOCAB = read_vocab_from_csv(c_vocab_path)

    emb_sz = 128
    c_vocab_size = len(C_VOCAB)
    asm_vocab_size = len(ASM_VOCAB)

    model = NeuralDecompiler(emb_sz=emb_sz, 
                                input_vocab_size=asm_vocab_size,
                                output_vocab_size=c_vocab_size,
                                ff_hidden_dim=128,
                                num_layers=3,
                                num_heads=8,
                                dropout=0)
    
    model.load_weights(f'{saved_model_path}_weights')
    cgen = CGenerator(model, ASM_VOCAB, C_VOCAB, max_length=500)

def translate_asm(asm_code):
    asm_code = tf.constant(asm_code, dtype=tf.string)

    return cgen(asm_code)

def beautify_c_code(c_code, indent_size):
    """
    Given raw C code generated by the model, returns a beautified, indented version of it.

    ### Params
    c_code: str - a string containing the raw C code.
    indent_size: int - the number of spaces to use for indenting.

    ### Returns
    str - the beautified code.
    """
    # adding newlines after ; { }
    c_code = re.sub(r'(;|{|})', r'\1\n', c_code)

    # removing spaces before * ) ; ,
    c_code = re.sub(r' (\*|\)|;|,)', r'\1', c_code)
    # removing spaces after (
    c_code = re.sub(r'\( ', r'(', c_code)

    # removing spaces between operators (+=, -=, *=, /=, ==, ++, --)
    c_code = re.sub(r'(\+|\-|\*|/|=) =', r'\1=', c_code)
    c_code = re.sub(r' (\+|\-) \1', r'\1\1', c_code)
    
    # removing spaces around array indexing.
    # ex. var_0 [ var_1 ] --> var_0[var_1]
    c_code = re.sub(r'(var_\d+) \[ (var_\d+) \]', r'\1[\2]', c_code)

    # adding spaces between multiplication that were removed above
    # ex. var_0* var_1 --> var_0 * var_1
    c_code = re.sub(r'(var_\d+)\* (var_\d+)', r'\1 * \2', c_code)

    # get rid of space between function name and open bracket (
    # ex. func_0 (int var_0) --> func_0(int var_0)
    c_code = re.sub(r'(func_\d+) \(', r'\1(', c_code)

    # removing newlines after ; inside for loop
    # ex. 
    # for (int var_0 = <CNUM>;
    # var_0 < var_1;
    # var_0++) {
    # becomes
    # for (int var_0 = <CNUM>; var_0 < var_1; var_0++) {
    c_code = re.sub(r'for \(([^\)]*);\s+([^\)]*);\s+([^\)]*)\)', r'for (\1; \2; \3)', c_code)

    # indenting code
    indent_level = 0 # the running number of indents
    output_lines = []
    for line in c_code.split('\n'):
        if '{' in line: # if we have open bracket, increment indent level
            output_lines.append(' ' * indent_size * indent_level + line.strip())
            indent_level += 1
        elif '}' in line: # if we have close bracket, decrement indent level
            indent_level -= 1
            output_lines.append(' ' * indent_size * indent_level + line.strip())
        else:
            output_lines.append(' ' * indent_size * indent_level + line.strip())

    return '\n'.join(output_lines)

if __name__ == "__main__":
    with open('model/tests/load_model_asm_test.txt', 'r') as f:
        asm_code = f.read()

    setup()
    print(translate_asm(asm_code))
